/*!
 * jQuery JavaScript Library v2.1.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowclip^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	// Support: Windows Web Apps (WWA)
	// `name` and `type` need .setAttribute for WWA
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));
;// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highstock JS v2.1.3 (2015-02-27)
 *
 * (c) 2009-2014 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

// JSLint options:
/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
(function () {
// encapsulated variables
var UNDEFINED,
	doc = document,
	win = window,
	math = Math,
	mathRound = math.round,
	mathFloor = math.floor,
	mathCeil = math.ceil,
	mathMax = math.max,
	mathMin = math.min,
	mathAbs = math.abs,
	mathCos = math.cos,
	mathSin = math.sin,
	mathPI = math.PI,
	deg2rad = mathPI * 2 / 360,


	// some variables
	userAgent = navigator.userAgent,
	isOpera = win.opera,
	isIE = /(msie|trident)/i.test(userAgent) && !isOpera,
	docMode8 = doc.documentMode === 8,
	isWebKit = /AppleWebKit/.test(userAgent),
	isFirefox = /Firefox/.test(userAgent),
	isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
	SVG_NS = 'http://www.w3.org/2000/svg',
	hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
	useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
	Renderer,
	hasTouch,
	symbolSizes = {},
	idCounter = 0,
	garbageBin,
	defaultOptions,
	dateFormat, // function
	globalAnimation,
	pathAnim,
	timeUnits,
	noop = function () { return UNDEFINED; },
	charts = [],
	chartCount = 0,
	PRODUCT = 'Highstock',
	VERSION = '2.1.3',

	// some constants for frequently used strings
	DIV = 'div',
	ABSOLUTE = 'absolute',
	RELATIVE = 'relative',
	HIDDEN = 'hidden',
	PREFIX = 'highcharts-',
	VISIBLE = 'visible',
	PX = 'px',
	NONE = 'none',
	M = 'M',
	L = 'L',
	numRegex = /^[0-9]+$/,
	NORMAL_STATE = '',
	HOVER_STATE = 'hover',
	SELECT_STATE = 'select',
	marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
	
	// Object for extending Axis
	AxisPlotLineOrBandExtension,

	// constants for attributes
	STROKE_WIDTH = 'stroke-width',

	// time methods, changed based on whether or not UTC is used
	Date,  // Allow using a different Date class
	makeTime,
	timezoneOffset,
	getTimezoneOffset,
	getMinutes,
	getHours,
	getDay,
	getDate,
	getMonth,
	getFullYear,
	setMinutes,
	setHours,
	setDate,
	setMonth,
	setFullYear,


	// lookup over the types and the associated classes
	seriesTypes = {},
	Highcharts;

// The Highcharts namespace
Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};

Highcharts.seriesTypes = seriesTypes;

/**
 * Extend an object with the members of another
 * @param {Object} a The object to be extended
 * @param {Object} b The object to add to the first one
 */
var extend = Highcharts.extend = function (a, b) {
	var n;
	if (!a) {
		a = {};
	}
	for (n in b) {
		a[n] = b[n];
	}
	return a;
};
	
/**
 * Deep merge two or more objects and return a third object. If the first argument is
 * true, the contents of the second object is copied into the first object.
 * Previously this function redirected to jQuery.extend(true), but this had two limitations.
 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
 * it copied properties from extended prototypes. 
 */
function merge() {
	var i,
		args = arguments,
		len,
		ret = {},
		doCopy = function (copy, original) {
			var value, key;

			// An object is replacing a primitive
			if (typeof copy !== 'object') {
				copy = {};
			}

			for (key in original) {
				if (original.hasOwnProperty(key)) {
					value = original[key];

					// Copy the contents of objects, but not arrays or DOM nodes
					if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]'
							&& key !== 'renderTo' && typeof value.nodeType !== 'number') {
						copy[key] = doCopy(copy[key] || {}, value);
				
					// Primitives and arrays are copied over directly
					} else {
						copy[key] = original[key];
					}
				}
			}
			return copy;
		};

	// If first argument is true, copy into the existing object. Used in setOptions.
	if (args[0] === true) {
		ret = args[1];
		args = Array.prototype.slice.call(args, 2);
	}

	// For each argument, extend the return
	len = args.length;
	for (i = 0; i < len; i++) {
		ret = doCopy(ret, args[i]);
	}

	return ret;
}

/**
 * Shortcut for parseInt
 * @param {Object} s
 * @param {Number} mag Magnitude
 */
function pInt(s, mag) {
	return parseInt(s, mag || 10);
}

/**
 * Check for string
 * @param {Object} s
 */
function isString(s) {
	return typeof s === 'string';
}

/**
 * Check for object
 * @param {Object} obj
 */
function isObject(obj) {
	return obj && typeof obj === 'object';
}

/**
 * Check for array
 * @param {Object} obj
 */
function isArray(obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
}

/**
 * Check for number
 * @param {Object} n
 */
function isNumber(n) {
	return typeof n === 'number';
}

function log2lin(num) {
	return math.log(num) / math.LN10;
}
function lin2log(num) {
	return math.pow(10, num);
}

/**
 * Remove last occurence of an item from an array
 * @param {Array} arr
 * @param {Mixed} item
 */
function erase(arr, item) {
	var i = arr.length;
	while (i--) {
		if (arr[i] === item) {
			arr.splice(i, 1);
			break;
		}
	}
	//return arr;
}

/**
 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
 * @param {Object} obj
 */
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}

/**
 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
 * it attempts to set expando properties on the SVG element, which is not allowed.
 *
 * @param {Object} elem The DOM element to receive the attribute(s)
 * @param {String|Object} prop The property or an abject of key-value pairs
 * @param {String} value The value if a single property is set
 */
function attr(elem, prop, value) {
	var key,
		ret;

	// if the prop is a string
	if (isString(prop)) {
		// set the value
		if (defined(value)) {
			elem.setAttribute(prop, value);

		// get the value
		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
			ret = elem.getAttribute(prop);
		}

	// else if prop is defined, it is a hash of key/value pairs
	} else if (defined(prop) && isObject(prop)) {
		for (key in prop) {
			elem.setAttribute(key, prop[key]);
		}
	}
	return ret;
}
/**
 * Check if an element is an array, and if not, make it into an array. Like
 * MooTools' $.splat.
 */
function splat(obj) {
	return isArray(obj) ? obj : [obj];
}


/**
 * Return the first value that is defined. Like MooTools' $.pick.
 */
var pick = Highcharts.pick = function () {
	var args = arguments,
		i,
		arg,
		length = args.length;
	for (i = 0; i < length; i++) {
		arg = args[i];
		if (arg !== UNDEFINED && arg !== null) {
			return arg;
		}
	}
};

/**
 * Set CSS on a given element
 * @param {Object} el
 * @param {Object} styles Style object with camel case property names
 */
function css(el, styles) {
	if (isIE && !hasSVG) { // #2686
		if (styles && styles.opacity !== UNDEFINED) {
			styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
		}
	}
	extend(el.style, styles);
}

/**
 * Utility function to create element with attributes and styles
 * @param {Object} tag
 * @param {Object} attribs
 * @param {Object} styles
 * @param {Object} parent
 * @param {Object} nopad
 */
function createElement(tag, attribs, styles, parent, nopad) {
	var el = doc.createElement(tag);
	if (attribs) {
		extend(el, attribs);
	}
	if (nopad) {
		css(el, {padding: 0, border: NONE, margin: 0});
	}
	if (styles) {
		css(el, styles);
	}
	if (parent) {
		parent.appendChild(el);
	}
	return el;
}

/**
 * Extend a prototyped class by new members
 * @param {Object} parent
 * @param {Object} members
 */
function extendClass(parent, members) {
	var object = function () { return UNDEFINED; };
	object.prototype = new parent();
	extend(object.prototype, members);
	return object;
}

/**
 * Pad a string to a given length by adding 0 to the beginning
 * @param {Number} number
 * @param {Number} length
 */
function pad(number, length) {
	// Create an array of the remaining length +1 and join it with 0's
	return new Array((length || 2) + 1 - String(number).length).join(0) + number;
}

/**
 * Wrap a method with extended functionality, preserving the original function
 * @param {Object} obj The context object that the method belongs to 
 * @param {String} method The name of the method to extend
 * @param {Function} func A wrapper function callback. This function is called with the same arguments
 * as the original function, except that the original function is unshifted and passed as the first 
 * argument. 
 */
var wrap = Highcharts.wrap = function (obj, method, func) {
	var proceed = obj[method];
	obj[method] = function () {
		var args = Array.prototype.slice.call(arguments);
		args.unshift(proceed);
		return func.apply(this, args);
	};
};


function getTZOffset(timestamp) {
	return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
}

/**
 * Based on http://www.php.net/manual/en/function.strftime.php
 * @param {String} format
 * @param {Number} timestamp
 * @param {Boolean} capitalize
 */
dateFormat = function (format, timestamp, capitalize) {
	if (!defined(timestamp) || isNaN(timestamp)) {
		return 'Invalid date';
	}
	format = pick(format, '%Y-%m-%d %H:%M:%S');

	var date = new Date(timestamp - getTZOffset(timestamp)),
		key, // used in for constuct below
		// get the basic time values
		hours = date[getHours](),
		day = date[getDay](),
		dayOfMonth = date[getDate](),
		month = date[getMonth](),
		fullYear = date[getFullYear](),
		lang = defaultOptions.lang,
		langWeekdays = lang.weekdays,

		// List all format keys. Custom formats can be added from the outside. 
		replacements = extend({

			// Day
			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
			'A': langWeekdays[day], // Long weekday, like 'Monday'
			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
			'e': dayOfMonth, // Day of the month, 1 through 31
			'w': day,

			// Week (none implemented)
			//'W': weekNumber(),

			// Month
			'b': lang.shortMonths[month], // Short month, like 'Jan'
			'B': lang.months[month], // Long month, like 'January'
			'm': pad(month + 1), // Two digit month number, 01 through 12

			// Year
			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
			'Y': fullYear, // Four digits year, like 2009

			// Time
			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
			'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
			'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
		}, Highcharts.dateFormats);


	// do the replaces
	for (key in replacements) {
		while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
			format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
		}
	}

	// Optionally capitalize the string and return
	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
};

/** 
 * Format a single variable. Similar to sprintf, without the % prefix.
 */
function formatSingle(format, val) {
	var floatRegex = /f$/,
		decRegex = /\.([0-9])/,
		lang = defaultOptions.lang,
		decimals;

	if (floatRegex.test(format)) { // float
		decimals = format.match(decRegex);
		decimals = decimals ? decimals[1] : -1;
		if (val !== null) {
			val = Highcharts.numberFormat(
				val,
				decimals,
				lang.decimalPoint,
				format.indexOf(',') > -1 ? lang.thousandsSep : ''
			);
		}
	} else {
		val = dateFormat(format, val);
	}
	return val;
}

/**
 * Format a string according to a subset of the rules of Python's String.format method.
 */
function format(str, ctx) {
	var splitter = '{',
		isInside = false,
		segment,
		valueAndFormat,
		path,
		i,
		len,
		ret = [],
		val,
		index;
	
	while ((index = str.indexOf(splitter)) !== -1) {
		
		segment = str.slice(0, index);
		if (isInside) { // we're on the closing bracket looking back
			
			valueAndFormat = segment.split(':');
			path = valueAndFormat.shift().split('.'); // get first and leave format
			len = path.length;
			val = ctx;

			// Assign deeper paths
			for (i = 0; i < len; i++) {
				val = val[path[i]];
			}

			// Format the replacement
			if (valueAndFormat.length) {
				val = formatSingle(valueAndFormat.join(':'), val);
			}

			// Push the result and advance the cursor
			ret.push(val);
			
		} else {
			ret.push(segment);
			
		}
		str = str.slice(index + 1); // the rest
		isInside = !isInside; // toggle
		splitter = isInside ? '}' : '{'; // now look for next matching bracket
	}
	ret.push(str);
	return ret.join('');
}

/**
 * Get the magnitude of a number
 */
function getMagnitude(num) {
	return math.pow(10, mathFloor(math.log(num) / math.LN10));
}

/**
 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
 * @param {Number} interval
 * @param {Array} multiples
 * @param {Number} magnitude
 * @param {Object} options
 */
function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
	var normalized, 
		i,
		retInterval = interval;

	// round to a tenfold of 1, 2, 2.5 or 5
	magnitude = pick(magnitude, 1);
	normalized = interval / magnitude;

	// multiples for a linear scale
	if (!multiples) {
		multiples = [1, 2, 2.5, 5, 10];

		// the allowDecimals option
		if (allowDecimals === false) {
			if (magnitude === 1) {
				multiples = [1, 2, 5, 10];
			} else if (magnitude <= 0.1) {
				multiples = [1 / magnitude];
			}
		}
	}

	// normalize the interval to the nearest multiple
	for (i = 0; i < multiples.length; i++) {
		retInterval = multiples[i];
		if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
			(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
			break;
		}
	}

	// multiply back to the correct magnitude
	retInterval *= magnitude;
	
	return retInterval;
}


/**
 * Utility method that sorts an object array and keeping the order of equal items.
 * ECMA script standard does not specify the behaviour when items are equal.
 */
function stableSort(arr, sortFunction) {
	var length = arr.length,
		sortValue,
		i;

	// Add index to each item
	for (i = 0; i < length; i++) {
		arr[i].ss_i = i; // stable sort index
	}

	arr.sort(function (a, b) {
		sortValue = sortFunction(a, b);
		return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
	});

	// Remove index from items
	for (i = 0; i < length; i++) {
		delete arr[i].ss_i; // stable sort index
	}
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMin(data) {
	var i = data.length,
		min = data[0];

	while (i--) {
		if (data[i] < min) {
			min = data[i];
		}
	}
	return min;
}

/**
 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
 * method is slightly slower, but safe.
 */
function arrayMax(data) {
	var i = data.length,
		max = data[0];

	while (i--) {
		if (data[i] > max) {
			max = data[i];
		}
	}
	return max;
}

/**
 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
 * It loops all properties and invokes destroy if there is a destroy method. The property is
 * then delete'ed.
 * @param {Object} The object to destroy properties on
 * @param {Object} Exception, do not destroy this property, only delete it.
 */
function destroyObjectProperties(obj, except) {
	var n;
	for (n in obj) {
		// If the object is non-null and destroy is defined
		if (obj[n] && obj[n] !== except && obj[n].destroy) {
			// Invoke the destroy
			obj[n].destroy();
		}

		// Delete the property from the object.
		delete obj[n];
	}
}


/**
 * Discard an element by moving it to the bin and delete
 * @param {Object} The HTML node to discard
 */
function discardElement(element) {
	// create a garbage bin element, not part of the DOM
	if (!garbageBin) {
		garbageBin = createElement(DIV);
	}

	// move the node and empty bin
	if (element) {
		garbageBin.appendChild(element);
	}
	garbageBin.innerHTML = '';
}

/**
 * Provide error messages for debugging, with links to online explanation 
 */
function error (code, stop) {
	var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
	if (stop) {
		throw msg;
	}
	// else ...
	if (win.console) {
		console.log(msg);
	}
}

/**
 * Fix JS round off float errors
 * @param {Number} num
 */
function correctFloat(num) {
	return parseFloat(
		num.toPrecision(14)
	);
}

/**
 * Set the global animation to either a given value, or fall back to the
 * given chart's animation option
 * @param {Object} animation
 * @param {Object} chart
 */
function setAnimation(animation, chart) {
	globalAnimation = pick(animation, chart.animation);
}

/**
 * The time unit lookup
 */
timeUnits = {
	millisecond: 1,
	second: 1000,
	minute: 60000,
	hour: 3600000,
	day: 24 * 3600000,
	week: 7 * 24 * 3600000,
	month: 28 * 24 * 3600000,
	year: 364 * 24 * 3600000
};


/**
 * Format a number and return a string based on input settings
 * @param {Number} number The input number to format
 * @param {Number} decimals The amount of decimals
 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
 */
Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
	var lang = defaultOptions.lang,
		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
		n = +number || 0,
		c = decimals === -1 ?
			mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
			(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
		d = decPoint === undefined ? lang.decimalPoint : decPoint,
		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
		s = n < 0 ? "-" : "",
		i = String(pInt(n = mathAbs(n).toFixed(c))),
		j = i.length > 3 ? i.length % 3 : 0;

	return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
			(c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
};
/**
 * Path interpolation algorithm used across adapters
 */
pathAnim = {
	/**
	 * Prepare start and end values so that the path can be animated one to one
	 */
	init: function (elem, fromD, toD) {
		fromD = fromD || '';
		var shift = elem.shift,
			bezier = fromD.indexOf('C') > -1,
			numParams = bezier ? 7 : 3,
			endLength,
			slice,
			i,
			start = fromD.split(' '),
			end = [].concat(toD), // copy
			startBaseLine,
			endBaseLine,
			sixify = function (arr) { // in splines make move points have six parameters like bezier curves
				i = arr.length;
				while (i--) {
					if (arr[i] === M) {
						arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
					}
				}
			};

		if (bezier) {
			sixify(start);
			sixify(end);
		}

		// pull out the base lines before padding
		if (elem.isArea) {
			startBaseLine = start.splice(start.length - 6, 6);
			endBaseLine = end.splice(end.length - 6, 6);
		}

		// if shifting points, prepend a dummy point to the end path
		if (shift <= end.length / numParams && start.length === end.length) {
			while (shift--) {
				end = [].concat(end).splice(0, numParams).concat(end);
			}
		}
		elem.shift = 0; // reset for following animations

		// copy and append last point until the length matches the end length
		if (start.length) {
			endLength = end.length;
			while (start.length < endLength) {

				//bezier && sixify(start);
				slice = [].concat(start).splice(start.length - numParams, numParams);
				if (bezier) { // disable first control point
					slice[numParams - 6] = slice[numParams - 2];
					slice[numParams - 5] = slice[numParams - 1];
				}
				start = start.concat(slice);
			}
		}

		if (startBaseLine) { // append the base lines for areas
			start = start.concat(startBaseLine);
			end = end.concat(endBaseLine);
		}
		return [start, end];
	},

	/**
	 * Interpolate each value of the path and return the array
	 */
	step: function (start, end, pos, complete) {
		var ret = [],
			i = start.length,
			startVal;

		if (pos === 1) { // land on the final path without adjustment points appended in the ends
			ret = complete;

		} else if (i === end.length && pos < 1) {
			while (i--) {
				startVal = parseFloat(start[i]);
				ret[i] =
					isNaN(startVal) ? // a letter instruction like M or L
						start[i] :
						pos * (parseFloat(end[i] - startVal)) + startVal;

			}
		} else { // if animation is finished or length not matching, land on right value
			ret = end;
		}
		return ret;
	}
};

(function ($) {
	/**
	 * The default HighchartsAdapter for jQuery
	 */
	win.HighchartsAdapter = win.HighchartsAdapter || ($ && {
		
		/**
		 * Initialize the adapter by applying some extensions to jQuery
		 */
		init: function (pathAnim) {
			
			// extend the animate function to allow SVG animations
			var Fx = $.fx;
			
			/*jslint unparam: true*//* allow unused param x in this function */
			$.extend($.easing, {
				easeOutQuad: function (x, t, b, c, d) {
					return -c * (t /= d) * (t - 2) + b;
				}
			});
			/*jslint unparam: false*/
		
			// extend some methods to check for elem.attr, which means it is a Highcharts SVG object
			$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
				var obj = Fx.step,
					base;
					
				// Handle different parent objects
				if (fn === 'cur') {
					obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype
				
				} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
					obj = $.Tween.propHooks[fn];
					fn = 'set';
				}
		
				// Overwrite the method
				base = obj[fn];
				if (base) { // step.width and step.height don't exist in jQuery < 1.7
		
					// create the extended function replacement
					obj[fn] = function (fx) {

						var elem;
						
						// Fx.prototype.cur does not use fx argument
						fx = i ? fx : this;

						// Don't run animations on textual properties like align (#1821)
						if (fx.prop === 'align') {
							return;
						}
		
						// shortcut
						elem = fx.elem;
		
						// Fx.prototype.cur returns the current value. The other ones are setters
						// and returning a value has no effect.
						return elem.attr ? // is SVG element wrapper
							elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
							base.apply(this, arguments); // use jQuery's built-in method
					};
				}
			});

			// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
			wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
				return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
			});
			
			// Define the setter function for d (path definitions)
			this.addAnimSetter('d', function (fx) {
				var elem = fx.elem,
					ends;
		
				// Normally start and end should be set in state == 0, but sometimes,
				// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
				// in these cases
				if (!fx.started) {
					ends = pathAnim.init(elem, elem.d, elem.toD);
					fx.start = ends[0];
					fx.end = ends[1];
					fx.started = true;
				}
		
				// Interpolate each value of the path
				elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
			});
			
			/**
			 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
			 * @param {Array} arr
			 * @param {Function} fn
			 */
			this.each = Array.prototype.forEach ?
				function (arr, fn) { // modern browsers
					return Array.prototype.forEach.call(arr, fn);
					
				} : 
				function (arr, fn) { // legacy
					var i, 
						len = arr.length;
					for (i = 0; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};
			
			/**
			 * Register Highcharts as a plugin in the respective framework
			 */
			$.fn.highcharts = function () {
				var constr = 'Chart', // default constructor
					args = arguments,
					options,
					ret,
					chart;

				if (this[0]) {

					if (isString(args[0])) {
						constr = args[0];
						args = Array.prototype.slice.call(args, 1); 
					}
					options = args[0];

					// Create the chart
					if (options !== UNDEFINED) {
						/*jslint unused:false*/
						options.chart = options.chart || {};
						options.chart.renderTo = this[0];
						chart = new Highcharts[constr](options, args[1]);
						ret = this;
						/*jslint unused:true*/
					}

					// When called without parameters or with the return argument, get a predefined chart
					if (options === UNDEFINED) {
						ret = charts[attr(this[0], 'data-highcharts-chart')];
					}
				}
				
				return ret;
			};

		},

		/**
		 * Add an animation setter for a specific property
		 */
		addAnimSetter: function (prop, setter) {
			// jQuery 1.8 style
			if ($.Tween) {
				$.Tween.propHooks[prop] = {
					set: setter
				};
			// pre 1.8
			} else {
				$.fx.step[prop] = setter;
			}
		},
		
		/**
		 * Downloads a script and executes a callback when done.
		 * @param {String} scriptLocation
		 * @param {Function} callback
		 */
		getScript: $.getScript,
		
		/**
		 * Return the index of an item in an array, or -1 if not found
		 */
		inArray: $.inArray,
		
		/**
		 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
		 * @param {Object} elem The HTML element
		 * @param {String} method Which method to run on the wrapped element
		 */
		adapterRun: function (elem, method) {
			return $(elem)[method]();
		},
	
		/**
		 * Filter an array
		 */
		grep: $.grep,
	
		/**
		 * Map an array
		 * @param {Array} arr
		 * @param {Function} fn
		 */
		map: function (arr, fn) {
			//return jQuery.map(arr, fn);
			var results = [],
				i = 0,
				len = arr.length;
			for (; i < len; i++) {
				results[i] = fn.call(arr[i], arr[i], i, arr);
			}
			return results;
	
		},
	
		/**
		 * Get the position of an element relative to the top left of the page
		 */
		offset: function (el) {
			return $(el).offset();
		},
	
		/**
		 * Add an event listener
		 * @param {Object} el A HTML element or custom object
		 * @param {String} event The event type
		 * @param {Function} fn The event handler
		 */
		addEvent: function (el, event, fn) {
			$(el).bind(event, fn);
		},
	
		/**
		 * Remove event added with addEvent
		 * @param {Object} el The object
		 * @param {String} eventType The event type. Leave blank to remove all events.
		 * @param {Function} handler The function to remove
		 */
		removeEvent: function (el, eventType, handler) {
			// workaround for jQuery issue with unbinding custom events:
			// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
			var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
			if (doc[func] && el && !el[func]) {
				el[func] = function () {};
			}
	
			$(el).unbind(eventType, handler);
		},
	
		/**
		 * Fire an event on a custom object
		 * @param {Object} el
		 * @param {String} type
		 * @param {Object} eventArguments
		 * @param {Function} defaultFunction
		 */
		fireEvent: function (el, type, eventArguments, defaultFunction) {
			var event = $.Event(type),
				detachedType = 'detached' + type,
				defaultPrevented;
	
			// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
			// never uses these properties, Chrome includes them in the default click event and
			// raises the warning when they are copied over in the extend statement below.
			//
			// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
			// testing if they are there (warning in chrome) the only option is to test if running IE.
			if (!isIE && eventArguments) {
				delete eventArguments.layerX;
				delete eventArguments.layerY;
				delete eventArguments.returnValue;
			}
	
			extend(event, eventArguments);
	
			// Prevent jQuery from triggering the object method that is named the
			// same as the event. For example, if the event is 'select', jQuery
			// attempts calling el.select and it goes into a loop.
			if (el[type]) {
				el[detachedType] = el[type];
				el[type] = null;
			}
	
			// Wrap preventDefault and stopPropagation in try/catch blocks in
			// order to prevent JS errors when cancelling events on non-DOM
			// objects. #615.
			/*jslint unparam: true*/
			$.each(['preventDefault', 'stopPropagation'], function (i, fn) {
				var base = event[fn];
				event[fn] = function () {
					try {
						base.call(event);
					} catch (e) {
						if (fn === 'preventDefault') {
							defaultPrevented = true;
						}
					}
				};
			});
			/*jslint unparam: false*/
	
			// trigger it
			$(el).trigger(event);
	
			// attach the method
			if (el[detachedType]) {
				el[type] = el[detachedType];
				el[detachedType] = null;
			}
	
			if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
				defaultFunction(event);
			}
		},
		
		/**
		 * Extension method needed for MooTools
		 */
		washMouseEvent: function (e) {
			var ret = e.originalEvent || e;
			
			// computed by jQuery, needed by IE8
			if (ret.pageX === UNDEFINED) { // #1236
				ret.pageX = e.pageX;
				ret.pageY = e.pageY;
			}
			
			return ret;
		},
	
		/**
		 * Animate a HTML element or SVG element wrapper
		 * @param {Object} el
		 * @param {Object} params
		 * @param {Object} options jQuery-like animation options: duration, easing, callback
		 */
		animate: function (el, params, options) {
			var $el = $(el);
			if (!el.style) {
				el.style = {}; // #1881
			}
			if (params.d) {
				el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
				params.d = 1; // because in jQuery, animating to an array has a different meaning
			}
	
			$el.stop();
			if (params.opacity !== UNDEFINED && el.attr) {
				params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
			}
			el.hasAnim = 1; // #3342
			$el.animate(params, options);
	
		},
		/**
		 * Stop running animation
		 */
		stop: function (el) {
			if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
				$(el).stop();
			}
		}
	});
}(win.jQuery));


// check for a custom HighchartsAdapter defined prior to this file
var globalAdapter = win.HighchartsAdapter,
	adapter = globalAdapter || {};
	
// Initialize the adapter
if (globalAdapter) {
	globalAdapter.init.call(globalAdapter, pathAnim);
}


// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
// and all the utility functions will be null. In that case they are populated by the
// default adapters below.
var adapterRun = adapter.adapterRun,
	getScript = adapter.getScript,
	inArray = adapter.inArray,
	each = Highcharts.each = adapter.each,
	grep = adapter.grep,
	offset = adapter.offset,
	map = adapter.map,
	addEvent = adapter.addEvent,
	removeEvent = adapter.removeEvent,
	fireEvent = adapter.fireEvent,
	washMouseEvent = adapter.washMouseEvent,
	animate = adapter.animate,
	stop = adapter.stop;



/* ****************************************************************************
 * Handle the options                                                         *
 *****************************************************************************/
defaultOptions = {
	colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', 
		    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	lang: {
		loading: 'Loading...',
		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
				'August', 'September', 'October', 'November', 'December'],
		shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		decimalPoint: '.',
		numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
		resetZoom: 'Reset zoom',
		resetZoomTitle: 'Reset zoom level 1:1',
		thousandsSep: ' '
	},
	global: {
		useUTC: true,
		//timezoneOffset: 0,
		canvasToolsURL: 'http://code.highcharts.com/stock/2.1.3/modules/canvas-tools.js',
		VMLRadialGradientURL: 'http://code.highcharts.com/stock/2.1.3/gfx/vml-radial-gradient.png'
	},
	chart: {
		//animation: true,
		//alignTicks: false,
		//reflow: true,
		//className: null,
		//events: { load, selection },
		//margin: [null],
		//marginTop: null,
		//marginRight: null,
		//marginBottom: null,
		//marginLeft: null,
		borderColor: '#4572A7',
		//borderWidth: 0,
		borderRadius: 0,
		defaultSeriesType: 'line',
		ignoreHiddenSeries: true,
		//inverted: false,
		//shadow: false,
		spacing: [10, 10, 15, 10],
		//spacingTop: 10,
		//spacingRight: 10,
		//spacingBottom: 15,
		//spacingLeft: 10,
		//style: {
		//	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
		//	fontSize: '12px'
		//},
		backgroundColor: '#FFFFFF',
		//plotBackgroundColor: null,
		plotBorderColor: '#C0C0C0',
		//plotBorderWidth: 0,
		//plotShadow: false,
		//zoomType: ''
		resetZoomButton: {
			theme: {
				zIndex: 20
			},
			position: {
				align: 'right',
				x: -10,
				//verticalAlign: 'top',
				y: 10
			}
			// relativeTo: 'plot'
		}
	},
	title: {
		text: 'Chart title',
		align: 'center',
		// floating: false,
		margin: 15,
		// x: 0,
		// verticalAlign: 'top',
		// y: null,
		style: {
			color: '#333333',
			fontSize: '18px'
		}

	},
	subtitle: {
		text: '',
		align: 'center',
		// floating: false
		// x: 0,
		// verticalAlign: 'top',
		// y: null,
		style: {
			color: '#555555'
		}
	},

	plotOptions: {
		line: { // base series options
			allowPointSelect: false,
			showCheckbox: false,
			animation: {
				duration: 1000
			},
			//connectNulls: false,
			//cursor: 'default',
			//clip: true,
			//dashStyle: null,
			//enableMouseTracking: true,
			events: {},
			//legendIndex: 0,
			//linecap: 'round',
			lineWidth: 2,
			//shadow: false,
			// stacking: null,
			marker: {
				//enabled: true,
				//symbol: null,
				lineWidth: 0,
				radius: 4,
				lineColor: '#FFFFFF',
				//fillColor: null,
				states: { // states for a single point
					hover: {
						enabled: true,
						lineWidthPlus: 1,
						radiusPlus: 2
					},
					select: {
						fillColor: '#FFFFFF',
						lineColor: '#000000',
						lineWidth: 2
					}
				}
			},
			point: {
				events: {}
			},
			dataLabels: {
				align: 'center',
				// defer: true,
				// enabled: false,
				formatter: function () {
					return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
				},
				style: {
					color: 'contrast',
					fontSize: '11px',
					fontWeight: 'bold',
					textShadow: '0 0 6px contrast, 0 0 3px contrast'
				},
				verticalAlign: 'bottom', // above singular point
				x: 0,
				y: 0,
				// backgroundColor: undefined,
				// borderColor: undefined,
				// borderRadius: undefined,
				// borderWidth: undefined,
				padding: 5
				// shadow: false
			},
			cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
			pointRange: 0,
			//pointStart: 0,
			//pointInterval: 1,
			//showInLegend: null, // auto: true for standalone series, false for linked series
			states: { // states for the entire series
				hover: {
					//enabled: false,
					lineWidthPlus: 1,
					marker: {
						// lineWidth: base + 1,
						// radius: base + 1
					},
					halo: {
						size: 10,
						opacity: 0.25
					}
				},
				select: {
					marker: {}
				}
			},
			stickyTracking: true,
			//tooltip: {
				//pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
				//valueDecimals: null,
				//xDateFormat: '%A, %b %e, %Y',
				//valuePrefix: '',
				//ySuffix: ''				
			//}
			turboThreshold: 1000
			// zIndex: null
		}
	},
	labels: {
		//items: [],
		style: {
			//font: defaultFont,
			position: ABSOLUTE,
			color: '#3E576F'
		}
	},
	legend: {
		enabled: true,
		align: 'center',
		//floating: false,
		layout: 'horizontal',
		labelFormatter: function () {
			return this.name;
		},
		//borderWidth: 0,
		borderColor: '#909090',
		borderRadius: 0,
		navigation: {
			// animation: true,
			activeColor: '#274b6d',
			// arrowSize: 12
			inactiveColor: '#CCC'
			// style: {} // text styles
		},
		// margin: 20,
		// reversed: false,
		shadow: false,
		// backgroundColor: null,
		/*style: {
			padding: '5px'
		},*/
		itemStyle: {			
			color: '#333333',
			fontSize: '12px',
			fontWeight: 'bold'
		},
		itemHoverStyle: {
			//cursor: 'pointer', removed as of #601
			color: '#000'
		},
		itemHiddenStyle: {
			color: '#CCC'
		},
		itemCheckboxStyle: {
			position: ABSOLUTE,
			width: '13px', // for IE precision
			height: '13px'
		},
		// itemWidth: undefined,
		// symbolRadius: 0,
		// symbolWidth: 16,
		symbolPadding: 5,
		verticalAlign: 'bottom',
		// width: undefined,
		x: 0,
		y: 0,
		title: {
			//text: null,
			style: {
				fontWeight: 'bold'
			}
		}			
	},

	loading: {
		// hideDuration: 100,
		labelStyle: {
			fontWeight: 'bold',
			position: RELATIVE,
			top: '45%'
		},
		// showDuration: 0,
		style: {
			position: ABSOLUTE,
			backgroundColor: 'white',
			opacity: 0.5,
			textAlign: 'center'
		}
	},

	tooltip: {
		enabled: true,
		animation: hasSVG,
		//crosshairs: null,
		backgroundColor: 'rgba(249, 249, 249, .85)',
		borderWidth: 1,
		borderRadius: 3,
		dateTimeLabelFormats: { 
			millisecond: '%A, %b %e, %H:%M:%S.%L',
			second: '%A, %b %e, %H:%M:%S',
			minute: '%A, %b %e, %H:%M',
			hour: '%A, %b %e, %H:%M',
			day: '%A, %b %e, %Y',
			week: 'Week from %A, %b %e, %Y',
			month: '%B %Y',
			year: '%Y'
		},
		footerFormat: '',
		//formatter: defaultFormatter,
		headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
		pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
		shadow: true,
		//shape: 'callout',
		//shared: false,
		snap: isTouchDevice ? 25 : 10,
		style: {
			color: '#333333',
			cursor: 'default',
			fontSize: '12px',
			padding: '8px',
			whiteSpace: 'nowrap'
		}
		//xDateFormat: '%A, %b %e, %Y',
		//valueDecimals: null,
		//valuePrefix: '',
		//valueSuffix: ''
	},

	credits: {
		enabled: true,
		text: 'Highcharts.com',
		href: 'http://www.highcharts.com',
		position: {
			align: 'right',
			x: -10,
			verticalAlign: 'bottom',
			y: -5
		},
		style: {
			cursor: 'pointer',
			color: '#909090',
			fontSize: '9px'
		}
	}
};




// Series defaults
var defaultPlotOptions = defaultOptions.plotOptions,
	defaultSeriesOptions = defaultPlotOptions.line;

// set the default time methods
setTimeMethods();



/**
 * Set the time methods globally based on the useUTC option. Time method can be either
 * local time or UTC (default).
 */
function setTimeMethods() {
	var globalOptions = defaultOptions.global,
		useUTC = globalOptions.useUTC,
		GET = useUTC ? 'getUTC' : 'get',
		SET = useUTC ? 'setUTC' : 'set';


	Date = globalOptions.Date || window.Date;
	timezoneOffset = useUTC && globalOptions.timezoneOffset;
	getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
	makeTime = function (year, month, date, hours, minutes, seconds) {
		var d;
		if (useUTC) {
			d = Date.UTC.apply(0, arguments);
			d += getTZOffset(d);
		} else {
			d = new Date(
				year,
				month,
				pick(date, 1),
				pick(hours, 0),
				pick(minutes, 0),
				pick(seconds, 0)
			).getTime();
		}
		return d;
	};
	getMinutes =  GET + 'Minutes';
	getHours =    GET + 'Hours';
	getDay =      GET + 'Day';
	getDate =     GET + 'Date';
	getMonth =    GET + 'Month';
	getFullYear = GET + 'FullYear';
	setMinutes =  SET + 'Minutes';
	setHours =    SET + 'Hours';
	setDate =     SET + 'Date';
	setMonth =    SET + 'Month';
	setFullYear = SET + 'FullYear';

}

/**
 * Merge the default options with custom options and return the new options structure
 * @param {Object} options The new custom options
 */
function setOptions(options) {
	
	// Copy in the default options
	defaultOptions = merge(true, defaultOptions, options);
	
	// Apply UTC
	setTimeMethods();

	return defaultOptions;
}

/**
 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
 * wasn't enough because the setOptions method created a new object.
 */
function getOptions() {
	return defaultOptions;
}


/**
 * Handle color operations. The object methods are chainable.
 * @param {String} input The input color in either rbga or hex format
 */
var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
	rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

var Color = function (input) {
	// declare variables
	var rgba = [], result, stops;

	/**
	 * Parse the input color to rgba array
	 * @param {String} input
	 */
	function init(input) {

		// Gradients
		if (input && input.stops) {
			stops = map(input.stops, function (stop) {
				return Color(stop[1]);
			});

		// Solid colors
		} else {
			// rgba
			result = rgbaRegEx.exec(input);
			if (result) {
				rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
			} else { 
				// hex
				result = hexRegEx.exec(input);
				if (result) {
					rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
				} else {
					// rgb
					result = rgbRegEx.exec(input);
					if (result) {
						rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
					}
				}
			}
		}		

	}
	/**
	 * Return the color a specified format
	 * @param {String} format
	 */
	function get(format) {
		var ret;

		if (stops) {
			ret = merge(input);
			ret.stops = [].concat(ret.stops);
			each(stops, function (stop, i) {
				ret.stops[i] = [ret.stops[i][0], stop.get(format)];
			});

		// it's NaN if gradient colors on a column chart
		} else if (rgba && !isNaN(rgba[0])) {
			if (format === 'rgb') {
				ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
			} else if (format === 'a') {
				ret = rgba[3];
			} else {
				ret = 'rgba(' + rgba.join(',') + ')';
			}
		} else {
			ret = input;
		}
		return ret;
	}

	/**
	 * Brighten the color
	 * @param {Number} alpha
	 */
	function brighten(alpha) {
		if (stops) {
			each(stops, function (stop) {
				stop.brighten(alpha);
			});
		
		} else if (isNumber(alpha) && alpha !== 0) {
			var i;
			for (i = 0; i < 3; i++) {
				rgba[i] += pInt(alpha * 255);

				if (rgba[i] < 0) {
					rgba[i] = 0;
				}
				if (rgba[i] > 255) {
					rgba[i] = 255;
				}
			}
		}
		return this;
	}
	/**
	 * Set the color's opacity to a given alpha value
	 * @param {Number} alpha
	 */
	function setOpacity(alpha) {
		rgba[3] = alpha;
		return this;
	}

	// initialize: parse the input
	init(input);

	// public methods
	return {
		get: get,
		brighten: brighten,
		rgba: rgba,
		setOpacity: setOpacity
	};
};


/**
 * A wrapper object for SVG elements
 */
function SVGElement() {}

SVGElement.prototype = {
	
	// Default base for animation
	opacity: 1,
	// For labels, these CSS properties are applied to the <text> node directly
	textProps: ['fontSize', 'fontWeight', 'fontFamily', 'color', 
		'lineHeight', 'width', 'textDecoration', 'textShadow'],
	
	/**
	 * Initialize the SVG renderer
	 * @param {Object} renderer
	 * @param {String} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this;
		wrapper.element = nodeName === 'span' ?
			createElement(nodeName) :
			doc.createElementNS(SVG_NS, nodeName);
		wrapper.renderer = renderer;
	},
	
	/**
	 * Animate a given attribute
	 * @param {Object} params
	 * @param {Number} options The same options as in jQuery animation
	 * @param {Function} complete Function to perform at the end of animation
	 */
	animate: function (params, options, complete) {
		var animOptions = pick(options, globalAnimation, true);
		stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
		if (animOptions) {
			animOptions = merge(animOptions, {}); //#2625
			if (complete) { // allows using a callback with the global animation without overwriting it
				animOptions.complete = complete;
			}
			animate(this, params, animOptions);
		} else {
			this.attr(params);
			if (complete) {
				complete();
			}
		}
		return this;
	},

	/**
	 * Build an SVG gradient out of a common JavaScript configuration object
	 */
	colorGradient: function (color, prop, elem) {
		var renderer = this.renderer,
			colorObject,
			gradName,
			gradAttr,
			gradients,
			gradientObject,
			stops,
			stopColor,
			stopOpacity,
			radialReference,
			n,
			id,
			key = [];

		// Apply linear or radial gradients
		if (color.linearGradient) {
			gradName = 'linearGradient';
		} else if (color.radialGradient) {
			gradName = 'radialGradient';
		}

		if (gradName) {
			gradAttr = color[gradName];
			gradients = renderer.gradients;
			stops = color.stops;
			radialReference = elem.radialReference;

			// Keep < 2.2 kompatibility
			if (isArray(gradAttr)) {
				color[gradName] = gradAttr = {
					x1: gradAttr[0],
					y1: gradAttr[1],
					x2: gradAttr[2],
					y2: gradAttr[3],
					gradientUnits: 'userSpaceOnUse'
				};
			}

			// Correct the radial gradient for the radial reference system
			if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
				gradAttr = merge(gradAttr, {
					cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
					cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
					r: gradAttr.r * radialReference[2],
					gradientUnits: 'userSpaceOnUse'
				});
			}

			// Build the unique key to detect whether we need to create a new element (#1282)
			for (n in gradAttr) {
				if (n !== 'id') {
					key.push(n, gradAttr[n]);
				}
			}
			for (n in stops) {
				key.push(stops[n]);
			}
			key = key.join(',');

			// Check if a gradient object with the same config object is created within this renderer
			if (gradients[key]) {
				id = gradients[key].attr('id');

			} else {

				// Set the id and create the element
				gradAttr.id = id = PREFIX + idCounter++;
				gradients[key] = gradientObject = renderer.createElement(gradName)
					.attr(gradAttr)
					.add(renderer.defs);


				// The gradient needs to keep a list of stops to be able to destroy them
				gradientObject.stops = [];
				each(stops, function (stop) {
					var stopObject;
					if (stop[1].indexOf('rgba') === 0) {
						colorObject = Color(stop[1]);
						stopColor = colorObject.get('rgb');
						stopOpacity = colorObject.get('a');
					} else {
						stopColor = stop[1];
						stopOpacity = 1;
					}
					stopObject = renderer.createElement('stop').attr({
						offset: stop[0],
						'stop-color': stopColor,
						'stop-opacity': stopOpacity
					}).add(gradientObject);

					// Add the stop element to the gradient
					gradientObject.stops.push(stopObject);
				});
			}

			// Set the reference to the gradient object
			elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
		} 
	},

	/**
	 * Apply a polyfill to the text-stroke CSS property, by copying the text element
	 * and apply strokes to the copy.
	 *
	 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
	 * TODO: 
	 * - update defaults
	 */
	applyTextShadow: function (textShadow) {
		var elem = this.element,
			tspans,
			hasContrast = textShadow.indexOf('contrast') !== -1,
			// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
			// this again with new IE release. In exports, the rendering is passed to PhantomJS. 
			supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);

		// When the text shadow is set to contrast, use dark stroke for light text and vice versa
		if (hasContrast) {
			textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
		}

		/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
		if (elem.textContent.indexOf('2.') === 0) {
			elem.style['text-shadow'] = 'none';
			supports = false;
		}
		// */

		// No reason to polyfill, we've got native support
		if (supports) {
			if (hasContrast) { // Apply the altered style
				css(elem, {
					textShadow: textShadow
				});
			}
		} else {

			this.fakeTS = true; // Fake text shadow

			// In order to get the right y position of the clones, 
			// copy over the y setter
			this.ySetter = this.xSetter;

			tspans = [].slice.call(elem.getElementsByTagName('tspan'));
			each(textShadow.split(/\s?,\s?/g), function (textShadow) {
				var firstChild = elem.firstChild,
					color,
					strokeWidth;
				
				textShadow = textShadow.split(' ');
				color = textShadow[textShadow.length - 1];

				// Approximately tune the settings to the text-shadow behaviour
				strokeWidth = textShadow[textShadow.length - 2];

				if (strokeWidth) {
					each(tspans, function (tspan, y) {
						var clone;

						// Let the first line start at the correct X position
						if (y === 0) {
							tspan.setAttribute('x', elem.getAttribute('x'));
							y = elem.getAttribute('y');
							tspan.setAttribute('y', y || 0);
							if (y === null) {
								elem.setAttribute('y', 0);
							}
						}

						// Create the clone and apply shadow properties
						clone = tspan.cloneNode(1);
						attr(clone, {
							'class': PREFIX + 'text-shadow',
							'fill': color,
							'stroke': color,
							'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
							'stroke-width': strokeWidth,
							'stroke-linejoin': 'round'
						});
						elem.insertBefore(clone, firstChild);
					});
				}
			});
		}
	},

	/**
	 * Set or get a given attribute
	 * @param {Object|String} hash
	 * @param {Mixed|Undefined} val
	 */
	attr: function (hash, val) {
		var key,
			value,
			element = this.element,
			hasSetSymbolSize,
			ret = this,
			skipAttr;

		// single key-value pair
		if (typeof hash === 'string' && val !== UNDEFINED) {
			key = hash;
			hash = {};
			hash[key] = val;
		}

		// used as a getter: first argument is a string, second is undefined
		if (typeof hash === 'string') {
			ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);
		
		// setter
		} else {

			for (key in hash) {
				value = hash[key];
				skipAttr = false;



				if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
					if (!hasSetSymbolSize) {
						this.symbolAttr(hash);
						hasSetSymbolSize = true;
					}
					skipAttr = true;
				}

				if (this.rotation && (key === 'x' || key === 'y')) {
					this.doTransform = true;
				}
				
				if (!skipAttr) {
					(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
				}

				// Let the shadow follow the main element
				if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
					this.updateShadows(key, value);
				}
			}

			// Update transform. Do this outside the loop to prevent redundant updating for batch setting
			// of attributes.
			if (this.doTransform) {
				this.updateTransform();
				this.doTransform = false;
			}

		}

		return ret;
	},

	updateShadows: function (key, value) {
		var shadows = this.shadows,
			i = shadows.length;
		while (i--) {
			shadows[i].setAttribute(
				key,
				key === 'height' ?
					mathMax(value - (shadows[i].cutHeight || 0), 0) :
					key === 'd' ? this.d : value
			);
		}
	},

	/**
	 * Add a class name to an element
	 */
	addClass: function (className) {
		var element = this.element,
			currentClassName = attr(element, 'class') || '';

		if (currentClassName.indexOf(className) === -1) {
			attr(element, 'class', currentClassName + ' ' + className);
		}
		return this;
	},
	/* hasClass and removeClass are not (yet) needed
	hasClass: function (className) {
		return attr(this.element, 'class').indexOf(className) !== -1;
	},
	removeClass: function (className) {
		attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
		return this;
	},
	*/

	/**
	 * If one of the symbol size affecting parameters are changed,
	 * check all the others only once for each call to an element's
	 * .attr() method
	 * @param {Object} hash
	 */
	symbolAttr: function (hash) {
		var wrapper = this;

		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
			wrapper[key] = pick(hash[key], wrapper[key]);
		});

		wrapper.attr({
			d: wrapper.renderer.symbols[wrapper.symbolName](
				wrapper.x,
				wrapper.y,
				wrapper.width,
				wrapper.height,
				wrapper
			)
		});
	},

	/**
	 * Apply a clipping path to this object
	 * @param {String} id
	 */
	clip: function (clipRect) {
		return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
	},

	/**
	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
	 * calculated attributes
	 * @param {Number} strokeWidth
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	crisp: function (rect) {

		var wrapper = this,
			key,
			attribs = {},
			normalizer,
			strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

		normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

		// normalize for crisp edges
		rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
		rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
		rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
		rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
		rect.strokeWidth = strokeWidth;

		for (key in rect) {
			if (wrapper[key] !== rect[key]) { // only set attribute if changed
				wrapper[key] = attribs[key] = rect[key];
			}
		}

		return attribs;
	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: function (styles) {
		var elemWrapper = this,
			oldStyles = elemWrapper.styles,
			newStyles = {},
			elem = elemWrapper.element,
			textWidth,
			n,
			serializedCss = '',
			hyphenate,
			hasNew = !oldStyles;

		// convert legacy
		if (styles && styles.color) {
			styles.fill = styles.color;
		}

		// Filter out existing styles to increase performance (#2640)
		if (oldStyles) {
			for (n in styles) {
				if (styles[n] !== oldStyles[n]) {
					newStyles[n] = styles[n];
					hasNew = true;
				}
			}
		}
		if (hasNew) {
			textWidth = elemWrapper.textWidth = 
				(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || 
				elemWrapper.textWidth; // #3501

			// Merge the new styles with the old ones
			if (oldStyles) {
				styles = extend(
					oldStyles,
					newStyles
				);
			}		

			// store object
			elemWrapper.styles = styles;

			if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
				delete styles.width;
			}

			// serialize and set style attribute
			if (isIE && !hasSVG) {
				css(elemWrapper.element, styles);
			} else {
				/*jslint unparam: true*/
				hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
				/*jslint unparam: false*/
				for (n in styles) {
					serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
				}
				attr(elem, 'style', serializedCss); // #1881
			}


			// re-build text
			if (textWidth && elemWrapper.added) {
				elemWrapper.renderer.buildText(elemWrapper);
			}
		}

		return elemWrapper;
	},

	/**
	 * Add an event listener
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		var svgElement = this,
			element = svgElement.element;
		
		// touch
		if (hasTouch && eventType === 'click') {
			element.ontouchstart = function (e) {			
				svgElement.touchEventFired = Date.now();				
				e.preventDefault();
				handler.call(element, e);
			};
			element.onclick = function (e) {												
				if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
					handler.call(element, e);
				}
			};			
		} else {
			// simplest possible event model for internal use
			element['on' + eventType] = handler;
		}
		return this;
	},

	/**
	 * Set the coordinates needed to draw a consistent radial gradient across
	 * pie slices regardless of positioning inside the chart. The format is
	 * [centerX, centerY, diameter] in pixels.
	 */
	setRadialReference: function (coordinates) {
		this.element.radialReference = coordinates;
		return this;
	},

	/**
	 * Move an object and its children by x and y values
	 * @param {Number} x
	 * @param {Number} y
	 */
	translate: function (x, y) {
		return this.attr({
			translateX: x,
			translateY: y
		});
	},

	/**
	 * Invert a group, rotate and flip
	 */
	invert: function () {
		var wrapper = this;
		wrapper.inverted = true;
		wrapper.updateTransform();
		return wrapper;
	},

	/**
	 * Private method to update the transform attribute based on internal
	 * properties
	 */
	updateTransform: function () {
		var wrapper = this,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			scaleX = wrapper.scaleX,
			scaleY = wrapper.scaleY,
			inverted = wrapper.inverted,
			rotation = wrapper.rotation,
			element = wrapper.element,
			transform;

		// flipping affects translate as adjustment for flipping around the group's axis
		if (inverted) {
			translateX += wrapper.attr('width');
			translateY += wrapper.attr('height');
		}

		// Apply translate. Nearly all transformed elements have translation, so instead
		// of checking for translate = 0, do it always (#1767, #1846).
		transform = ['translate(' + translateX + ',' + translateY + ')'];

		// apply rotation
		if (inverted) {
			transform.push('rotate(90) scale(-1,1)');
		} else if (rotation) { // text rotation
			transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');
			
			// Delete bBox memo when the rotation changes
			//delete wrapper.bBox;
		}

		// apply scale
		if (defined(scaleX) || defined(scaleY)) {
			transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
		}

		if (transform.length) {
			element.setAttribute('transform', transform.join(' '));
		}
	},
	/**
	 * Bring the element to the front
	 */
	toFront: function () {
		var element = this.element;
		element.parentNode.appendChild(element);
		return this;
	},


	/**
	 * Break down alignment options like align, verticalAlign, x and y
	 * to x and y relative to the chart.
	 *
	 * @param {Object} alignOptions
	 * @param {Boolean} alignByTranslate
	 * @param {String[Object} box The box to align to, needs a width and height. When the
	 *		box is a string, it refers to an object in the Renderer. For example, when
	 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
	 *		x and y properties.
	 *
	 */
	align: function (alignOptions, alignByTranslate, box) {
		var align,
			vAlign,
			x,
			y,
			attribs = {},
			alignTo,
			renderer = this.renderer,
			alignedObjects = renderer.alignedObjects;

		// First call on instanciate
		if (alignOptions) {
			this.alignOptions = alignOptions;
			this.alignByTranslate = alignByTranslate;
			if (!box || isString(box)) { // boxes other than renderer handle this internally
				this.alignTo = alignTo = box || 'renderer';
				erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
				alignedObjects.push(this);
				box = null; // reassign it below
			}

		// When called on resize, no arguments are supplied
		} else {
			alignOptions = this.alignOptions;
			alignByTranslate = this.alignByTranslate;
			alignTo = this.alignTo;
		}

		box = pick(box, renderer[alignTo], renderer);

		// Assign variables
		align = alignOptions.align;
		vAlign = alignOptions.verticalAlign;
		x = (box.x || 0) + (alignOptions.x || 0); // default: left align
		y = (box.y || 0) + (alignOptions.y || 0); // default: top align

		// Align
		if (align === 'right' || align === 'center') {
			x += (box.width - (alignOptions.width || 0)) /
					{ right: 1, center: 2 }[align];
		}
		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


		// Vertical align
		if (vAlign === 'bottom' || vAlign === 'middle') {
			y += (box.height - (alignOptions.height || 0)) /
					({ bottom: 1, middle: 2 }[vAlign] || 1);

		}
		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

		// Animate only if already placed
		this[this.placed ? 'animate' : 'attr'](attribs);
		this.placed = true;
		this.alignAttr = attribs;

		return this;
	},

	/**
	 * Get the bounding box (width, height, x and y) for the element
	 */
	getBBox: function (reload) {
		var wrapper = this,
			bBox,// = wrapper.bBox,
			renderer = wrapper.renderer,
			width,
			height,
			rotation = wrapper.rotation,
			element = wrapper.element,
			styles = wrapper.styles,
			rad = rotation * deg2rad,
			textStr = wrapper.textStr,
			textShadow,
			elemStyle = element.style,
			toggleTextShadowShim,
			cacheKey;

		if (textStr !== UNDEFINED) {

			// Properties that affect bounding box
			cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

			// Since numbers are monospaced, and numerical labels appear a lot in a chart,
			// we assume that a label of n characters has the same bounding box as others 
			// of the same length.
			if (textStr === '' || numRegex.test(textStr)) {
				cacheKey = 'num:' + textStr.toString().length + cacheKey;

			// Caching all strings reduces rendering time by 4-5%.
			} else {
				cacheKey = textStr + cacheKey;
			}
		}

		if (cacheKey && !reload) {
			bBox = renderer.cache[cacheKey];
		}

		// No cache found
		if (!bBox) {

			// SVG elements
			if (element.namespaceURI === SVG_NS || renderer.forExport) {
				try { // Fails in Firefox if the container has display: none.

					// When the text shadow shim is used, we need to hide the fake shadows
					// to get the correct bounding box (#3872)
					toggleTextShadowShim = this.fakeTS && function (display) {
						each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
							tspan.style.display = display;
						});
					};

					// Workaround for #3842, Firefox reporting wrong bounding box for shadows
					if (isFirefox && elemStyle.textShadow) {
						textShadow = elemStyle.textShadow;
						elemStyle.textShadow = '';
					} else if (toggleTextShadowShim) {
						toggleTextShadowShim(NONE);
					}

					bBox = element.getBBox ?
						// SVG: use extend because IE9 is not allowed to change width and height in case
						// of rotation (below)
						extend({}, element.getBBox()) :
						// Canvas renderer and legacy IE in export mode
						{
							width: element.offsetWidth,
							height: element.offsetHeight
						};

					// #3842
					if (textShadow) {
						elemStyle.textShadow = textShadow;
					} else if (toggleTextShadowShim) {
						toggleTextShadowShim('');
					}
				} catch (e) {}

				// If the bBox is not set, the try-catch block above failed. The other condition
				// is for Opera that returns a width of -Infinity on hidden elements.
				if (!bBox || bBox.width < 0) {
					bBox = { width: 0, height: 0 };
				}


			// VML Renderer or useHTML within SVG
			} else {

				bBox = wrapper.htmlGetBBox();

			}

			// True SVG elements as well as HTML elements in modern browsers using the .useHTML option
			// need to compensated for rotation
			if (renderer.isSVG) {
				width = bBox.width;
				height = bBox.height;

				// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
				if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
					bBox.height = height = 14;
				}

				// Adjust for rotated text
				if (rotation) {
					bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
					bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
				}
			}

			// Cache it
			renderer.cache[cacheKey] = bBox;
		}
		return bBox;
	},

	/**
	 * Show the element
	 */
	show: function (inherit) {
		// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)
		if (inherit && this.element.namespaceURI === SVG_NS) {
			this.element.removeAttribute('visibility');
		} else {
			this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
		}
		return this;
	},

	/**
	 * Hide the element
	 */
	hide: function () {
		return this.attr({ visibility: HIDDEN });
	},

	fadeOut: function (duration) {
		var elemWrapper = this;
		elemWrapper.animate({
			opacity: 0
		}, {
			duration: duration || 150,
			complete: function () {
				elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
			}
		});
	},

	/**
	 * Add the element
	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
	 *	to append the element to the renderer.box.
	 */
	add: function (parent) {

		var renderer = this.renderer,
			element = this.element,
			inserted;

		if (parent) {
			this.parentGroup = parent;
		}

		// mark as inverted
		this.parentInverted = parent && parent.inverted;

		// build formatted text
		if (this.textStr !== undefined) {
			renderer.buildText(this);
		}

		// Mark as added
		this.added = true;

		// If we're adding to renderer root, or other elements in the group 
		// have a z index, we need to handle it
		if (!parent || parent.handleZ || this.zIndex) {
			inserted = this.zIndexSetter();
		}

		// If zIndex is not handled, append at the end
		if (!inserted) {
			(parent ? parent.element : renderer.box).appendChild(element);
		}

		// fire an event for internal hooks
		if (this.onAdd) {
			this.onAdd();
		}

		return this;
	},

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		var parentNode = element.parentNode;
		if (parentNode) {
			parentNode.removeChild(element);
		}
	},

	/**
	 * Destroy the element and element wrapper
	 */
	destroy: function () {
		var wrapper = this,
			element = wrapper.element || {},
			shadows = wrapper.shadows,
			parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
			grandParent,
			key,
			i;

		// remove events
		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
		stop(wrapper); // stop running animations

		if (wrapper.clipPath) {
			wrapper.clipPath = wrapper.clipPath.destroy();
		}

		// Destroy stops in case this is a gradient object
		if (wrapper.stops) {
			for (i = 0; i < wrapper.stops.length; i++) {
				wrapper.stops[i] = wrapper.stops[i].destroy();
			}
			wrapper.stops = null;
		}

		// remove element
		wrapper.safeRemoveChild(element);

		// destroy shadows
		if (shadows) {
			each(shadows, function (shadow) {
				wrapper.safeRemoveChild(shadow);
			});
		}

		// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
		while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
			grandParent = parentToClean.parentGroup;
			wrapper.safeRemoveChild(parentToClean.div);
			delete parentToClean.div;
			parentToClean = grandParent;
		}

		// remove from alignObjects
		if (wrapper.alignTo) {
			erase(wrapper.renderer.alignedObjects, wrapper);
		}

		for (key in wrapper) {
			delete wrapper[key];
		}

		return null;
	},

	/**
	 * Add a shadow to the element. Must be done after the element is added to the DOM
	 * @param {Boolean|Object} shadowOptions
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			shadow,
			element = this.element,
			strokeWidth,
			shadowWidth,
			shadowElementOpacity,

			// compensate for inverted plot area
			transform;


		if (shadowOptions) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
			transform = this.parentInverted ?
				'(-1,-1)' :
				'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
			for (i = 1; i <= shadowWidth; i++) {
				shadow = element.cloneNode(0);
				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
				attr(shadow, {
					'isShadow': 'true',
					'stroke': shadowOptions.color || 'black',
					'stroke-opacity': shadowElementOpacity * i,
					'stroke-width': strokeWidth,
					'transform': 'translate' + transform,
					'fill': NONE
				});
				if (cutOff) {
					attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
					shadow.cutHeight = strokeWidth;
				}

				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				shadows.push(shadow);
			}

			this.shadows = shadows;
		}
		return this;

	},

	xGetter: function (key) {
		if (this.element.nodeName === 'circle') {
			key = { x: 'cx', y: 'cy' }[key] || key;
		}
		return this._defaultGetter(key);
	},

	/** 
	 * Get the current value of an attribute or pseudo attribute, used mainly
	 * for animation.
	 */
	_defaultGetter: function (key) {
		var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

		if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
			ret = parseFloat(ret);
		}
		return ret;
	},


	dSetter: function (value, key, element) {
		if (value && value.join) { // join path
			value = value.join(' ');
		}
		if (/(NaN| {2}|^$)/.test(value)) {
			value = 'M 0 0';
		}
		element.setAttribute(key, value);

		this[key] = value;
	},
	dashstyleSetter: function (value) {
		var i;
		value = value && value.toLowerCase();
		if (value) {
			value = value
				.replace('shortdashdotdot', '3,1,1,1,1,1,')
				.replace('shortdashdot', '3,1,1,1')
				.replace('shortdot', '1,1,')
				.replace('shortdash', '3,1,')
				.replace('longdash', '8,3,')
				.replace(/dot/g, '1,3,')
				.replace('dash', '4,3,')
				.replace(/,$/, '')
				.split(','); // ending comma

			i = value.length;
			while (i--) {
				value[i] = pInt(value[i]) * this['stroke-width'];
			}
			value = value.join(',')
				.replace('NaN', 'none'); // #3226
			this.element.setAttribute('stroke-dasharray', value);
		}
	},
	alignSetter: function (value) {
		this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
	},
	opacitySetter: function (value, key, element) {
		this[key] = value;
		element.setAttribute(key, value);
	},
	titleSetter: function (value) {
		var titleNode = this.element.getElementsByTagName('title')[0];
		if (!titleNode) {
			titleNode = doc.createElementNS(SVG_NS, 'title');
			this.element.appendChild(titleNode);
		}
		titleNode.textContent = (String(pick(value), '')).replace(/<[^>]*>/g, ''); // #3276 #3895
	},
	textSetter: function (value) {
		if (value !== this.textStr) {
			// Delete bBox memo when the text changes
			delete this.bBox;
		
			this.textStr = value;
			if (this.added) {
				this.renderer.buildText(this);
			}
		}
	},
	fillSetter: function (value, key, element) {
		if (typeof value === 'string') {
			element.setAttribute(key, value);
		} else if (value) {
			this.colorGradient(value, key, element);
		}
	},
	zIndexSetter: function (value, key) {
		var renderer = this.renderer,
			parentGroup = this.parentGroup,
			parentWrapper = parentGroup || renderer,
			parentNode = parentWrapper.element || renderer.box,
			childNodes,
			otherElement,
			otherZIndex,
			element = this.element,
			inserted,
			i;
		
		if (defined(value)) {
			element.setAttribute(key, value); // So we can read it for other elements in the group
			this[key] = +value;
		}

		// Insert according to this and other elements' zIndex. Before .add() is called,
		// nothing is done. Then on add, or by later calls to zIndexSetter, the node
		// is placed on the right place in the DOM.
		if (this.added) {
			value = this.zIndex;

			if (value && parentGroup) {
				parentGroup.handleZ = true;
			}
		
			childNodes = parentNode.childNodes;
			for (i = 0; i < childNodes.length && !inserted; i++) {
				otherElement = childNodes[i];
				otherZIndex = attr(otherElement, 'zIndex');
				if (otherElement !== element && (
						// Insert before the first element with a higher zIndex
						pInt(otherZIndex) > value ||
						// If no zIndex given, insert before the first element with a zIndex
						(!defined(value) && defined(otherZIndex))

						)) {
					parentNode.insertBefore(element, otherElement);
					inserted = true;
				}
			}
			if (!inserted) {
				parentNode.appendChild(element);
			}
		}
		return inserted;
	},
	_defaultSetter: function (value, key, element) {
		element.setAttribute(key, value);
	}
};

// Some shared setters and getters
SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = 
		SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = 
		SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
	this[key] = value;
	this.doTransform = true;
};

// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
// stroke attribute altogether. #1270, #1369, #3065, #3072.
SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
	this[key] = value;
	// Only apply the stroke attribute if the stroke width is defined and larger than 0
	if (this.stroke && this['stroke-width']) {
		this.strokeWidth = this['stroke-width'];
		SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
		element.setAttribute('stroke-width', this['stroke-width']);
		this.hasStroke = true;
	} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
		element.removeAttribute('stroke');
		this.hasStroke = false;
	}
};


/**
 * The default SVG renderer
 */
var SVGRenderer = function () {
	this.init.apply(this, arguments);
};
SVGRenderer.prototype = {
	Element: SVGElement,

	/**
	 * Initialize the SVGRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Boolean} forExport
	 */
	init: function (container, width, height, style, forExport) {
		var renderer = this,
			loc = location,
			boxWrapper,
			element,
			desc;

		boxWrapper = renderer.createElement('svg')
			.attr({
				version: '1.1'
			})
			.css(this.getStyle(style));
		element = boxWrapper.element;
		container.appendChild(element);

		// For browsers other than IE, add the namespace attribute (#1978)
		if (container.innerHTML.indexOf('xmlns') === -1) {
			attr(element, 'xmlns', SVG_NS);
		}

		// object properties
		renderer.isSVG = true;
		renderer.box = element;
		renderer.boxWrapper = boxWrapper;
		renderer.alignedObjects = [];

		// Page url used for internal references. #24, #672, #1070
		renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
			loc.href
				.replace(/#.*?$/, '') // remove the hash
				.replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
				.replace(/ /g, '%20') : // replace spaces (needed for Safari only)
			'';

		// Add description
		desc = this.createElement('desc').add();
		desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


		renderer.defs = this.createElement('defs').add();
		renderer.forExport = forExport;
		renderer.gradients = {}; // Object where gradient SvgElements are stored
		renderer.cache = {}; // Cache for numerical bounding boxes

		renderer.setSize(width, height, false);



		// Issue 110 workaround:
		// In Firefox, if a div is positioned by percentage, its pixel position may land
		// between pixels. The container itself doesn't display this, but an SVG element
		// inside this container will be drawn at subpixel precision. In order to draw
		// sharp lines, this must be compensated for. This doesn't seem to work inside
		// iframes though (like in jsFiddle).
		var subPixelFix, rect;
		if (isFirefox && container.getBoundingClientRect) {
			renderer.subPixelFix = subPixelFix = function () {
				css(container, { left: 0, top: 0 });
				rect = container.getBoundingClientRect();
				css(container, {
					left: (mathCeil(rect.left) - rect.left) + PX,
					top: (mathCeil(rect.top) - rect.top) + PX
				});
			};

			// run the fix now
			subPixelFix();

			// run it on resize
			addEvent(win, 'resize', subPixelFix);
		}
	},

	getStyle: function (style) {
		return (this.style = extend({
			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
			fontSize: '12px'
		}, style));
	},

	/**
	 * Detect whether the renderer is hidden. This happens when one of the parent elements
	 * has display: none. #608.
	 */
	isHidden: function () {
		return !this.boxWrapper.getBBox().width;
	},

	/**
	 * Destroys the renderer and its allocated members.
	 */
	destroy: function () {
		var renderer = this,
			rendererDefs = renderer.defs;
		renderer.box = null;
		renderer.boxWrapper = renderer.boxWrapper.destroy();

		// Call destroy on all gradient elements
		destroyObjectProperties(renderer.gradients || {});
		renderer.gradients = null;

		// Defs are null in VMLRenderer
		// Otherwise, destroy them here.
		if (rendererDefs) {
			renderer.defs = rendererDefs.destroy();
		}

		// Remove sub pixel fix handler
		// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
		// See issue #982
		if (renderer.subPixelFix) {
			removeEvent(win, 'resize', renderer.subPixelFix);
		}

		renderer.alignedObjects = null;

		return null;
	},

	/**
	 * Create a wrapper for an SVG element
	 * @param {Object} nodeName
	 */
	createElement: function (nodeName) {
		var wrapper = new this.Element();
		wrapper.init(this, nodeName);
		return wrapper;
	},

	/**
	 * Dummy function for use in canvas renderer
	 */
	draw: function () {},

	/**
	 * Parse a simple HTML string into SVG tspans
	 *
	 * @param {Object} textNode The parent text SVG node
	 */
	buildText: function (wrapper) {
		var textNode = wrapper.element,
			renderer = this,
			forExport = renderer.forExport,
			textStr = pick(wrapper.textStr, '').toString(),
			hasMarkup = textStr.indexOf('<') !== -1,
			lines,
			childNodes = textNode.childNodes,
			styleRegex,
			hrefRegex,
			parentX = attr(textNode, 'x'),
			textStyles = wrapper.styles,
			width = wrapper.textWidth,
			textLineHeight = textStyles && textStyles.lineHeight,
			textShadow = textStyles && textStyles.textShadow,
			ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
			i = childNodes.length,
			tempParent = width && !wrapper.added && this.box,
			getLineHeight = function (tspan) {
				return textLineHeight ? 
					pInt(textLineHeight) :
					renderer.fontMetrics(
						/(px|em)$/.test(tspan && tspan.style.fontSize) ?
							tspan.style.fontSize :
							((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
						tspan
					).h;
			},
			unescapeAngleBrackets = function (inputStr) {
				return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
			};

		/// remove old text
		while (i--) {
			textNode.removeChild(childNodes[i]);
		}

		// Skip tspans, add text directly to text node. The forceTSpan is a hook 
		// used in text outline hack.
		if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
			textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
			return;

		// Complex strings, add more logic
		} else {

			styleRegex = /<.*style="([^"]+)".*>/;
			hrefRegex = /<.*href="(http[^"]+)".*>/;

			if (tempParent) {
				tempParent.appendChild(textNode); // attach it to the DOM to read offset width
			}

			if (hasMarkup) {
				lines = textStr
					.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
					.replace(/<(i|em)>/g, '<span style="font-style:italic">')
					.replace(/<a/g, '<span')
					.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
					.split(/<br.*?>/g);

			} else {
				lines = [textStr];
			}


			// remove empty line at end
			if (lines[lines.length - 1] === '') {
				lines.pop();
			}

			
			// build the lines
			each(lines, function (line, lineNo) {
				var spans, spanNo = 0;

				line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
				spans = line.split('|||');

				each(spans, function (span) {
					if (span !== '' || spans.length === 1) {
						var attributes = {},
							tspan = doc.createElementNS(SVG_NS, 'tspan'),
							spanStyle; // #390
						if (styleRegex.test(span)) {
							spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
							attr(tspan, 'style', spanStyle);
						}
						if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
							attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
							css(tspan, { cursor: 'pointer' });
						}

						span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

						// Nested tags aren't supported, and cause crash in Safari (#1596)
						if (span !== ' ') {

							// add the text node
							tspan.appendChild(doc.createTextNode(span));

							if (!spanNo) { // first span in a line, align it to the left
								if (lineNo && parentX !== null) {
									attributes.x = parentX;
								}
							} else {
								attributes.dx = 0; // #16
							}

							// add attributes
							attr(tspan, attributes);

							// Append it
							textNode.appendChild(tspan);

							// first span on subsequent line, add the line height
							if (!spanNo && lineNo) {

								// allow getting the right offset height in exporting in IE
								if (!hasSVG && forExport) {
									css(tspan, { display: 'block' });
								}

								// Set the line height based on the font size of either
								// the text element or the tspan element
								attr(
									tspan,
									'dy',
									getLineHeight(tspan)
								);
							}

							/*if (width) {
								renderer.breakText(wrapper, width);
							}*/

							// Check width and apply soft breaks or ellipsis
							if (width) {
								var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
									hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
									tooLong,
									wasTooLong,
									actualWidth,
									rest = [],
									dy = getLineHeight(tspan),
									softLineNo = 1,
									rotation = wrapper.rotation,
									wordStr = span, // for ellipsis
									cursor = wordStr.length, // binary search cursor
									bBox;

								while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
									wrapper.rotation = 0; // discard rotation when computing box
									bBox = wrapper.getBBox(true);
									actualWidth = bBox.width;

									// Old IE cannot measure the actualWidth for SVG elements (#2314)
									if (!hasSVG && renderer.forExport) {
										actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
									}

									tooLong = actualWidth > width;

									// For ellipsis, do a binary search for the correct string length
									if (wasTooLong === undefined) {
										wasTooLong = tooLong; // First time
									}
									if (ellipsis && wasTooLong) {
										cursor /= 2;

										if (wordStr === '' || (!tooLong && cursor < 0.5)) {
											words = []; // All ok, break out
										} else {
											if (tooLong) {
												wasTooLong = true;
											}
											wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
											words = [wordStr + '\u2026'];
											tspan.removeChild(tspan.firstChild);
										}

									// Looping down, this is the first word sequence that is not too long,
									// so we can move on to build the next line.
									} else if (!tooLong || words.length === 1) {
										words = rest;
										rest = [];
												
										if (words.length) {
											softLineNo++;
											
											tspan = doc.createElementNS(SVG_NS, 'tspan');
											attr(tspan, {
												dy: dy,
												x: parentX
											});
											if (spanStyle) { // #390
												attr(tspan, 'style', spanStyle);
											}
											textNode.appendChild(tspan);
										}
										if (actualWidth > width) { // a single word is pressing it out
											width = actualWidth;
										}
									} else { // append to existing line tspan
										tspan.removeChild(tspan.firstChild);
										rest.unshift(words.pop());
									}
									if (words.length) {
										tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
									}
								}
								if (wasTooLong) {
									wrapper.attr('title', wrapper.textStr);
								}
								wrapper.rotation = rotation;
							}

							spanNo++;
						}
					}
				});
			});
			if (tempParent) {
				tempParent.removeChild(textNode); // attach it to the DOM to read offset width
			}

			// Apply the text shadow
			if (textShadow && wrapper.applyTextShadow) {
				wrapper.applyTextShadow(textShadow);
			}
		}
	},

	

	/*
	breakText: function (wrapper, width) {
		var bBox = wrapper.getBBox(),
			node = wrapper.element,
			textLength = node.textContent.length,
			pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
			increment = 0,
			finalPos;

		if (bBox.width > width) {
			while (finalPos === undefined) {
				textLength = node.getSubStringLength(0, pos);

				if (textLength <= width) {
					if (increment === -1) {
						finalPos = pos;
					} else {
						increment = 1;
					}
				} else {
					if (increment === 1) {
						finalPos = pos - 1;
					} else {
						increment = -1;
					}
				}
				pos += increment;
			}
		}
		console.log(finalPos, node.getSubStringLength(0, finalPos))
	},
	*/

	/** 
	 * Returns white for dark colors and black for bright colors
	 */
	getContrast: function (color) {
		color = Color(color).rgba;
		return color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';
	},

	/**
	 * Create a button with preset states
	 * @param {String} text
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Function} callback
	 * @param {Object} normalState
	 * @param {Object} hoverState
	 * @param {Object} pressedState
	 */
	button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
		var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
			curState = 0,
			stateOptions,
			stateStyle,
			normalStyle,
			hoverStyle,
			pressedStyle,
			disabledStyle,
			verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

		// Normal state - prepare the attributes
		normalState = merge({
			'stroke-width': 1,
			stroke: '#CCCCCC',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#FEFEFE'],
					[1, '#F6F6F6']
				]
			},
			r: 2,
			padding: 5,
			style: {
				color: 'black'
			}
		}, normalState);
		normalStyle = normalState.style;
		delete normalState.style;

		// Hover state
		hoverState = merge(normalState, {
			stroke: '#68A',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#FFF'],
					[1, '#ACF']
				]
			}
		}, hoverState);
		hoverStyle = hoverState.style;
		delete hoverState.style;

		// Pressed state
		pressedState = merge(normalState, {
			stroke: '#68A',
			fill: {
				linearGradient: verticalGradient,
				stops: [
					[0, '#9BD'],
					[1, '#CDF']
				]
			}
		}, pressedState);
		pressedStyle = pressedState.style;
		delete pressedState.style;

		// Disabled state
		disabledState = merge(normalState, {
			style: {
				color: '#CCC'
			}
		}, disabledState);
		disabledStyle = disabledState.style;
		delete disabledState.style;

		// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
		addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
			if (curState !== 3) {
				label.attr(hoverState)
					.css(hoverStyle);
			}
		});
		addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
			if (curState !== 3) {
				stateOptions = [normalState, hoverState, pressedState][curState];
				stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
				label.attr(stateOptions)
					.css(stateStyle);
			}
		});

		label.setState = function (state) {
			label.state = curState = state;
			if (!state) {
				label.attr(normalState)
					.css(normalStyle);
			} else if (state === 2) {
				label.attr(pressedState)
					.css(pressedStyle);
			} else if (state === 3) {
				label.attr(disabledState)
					.css(disabledStyle);
			}
		};

		return label
			.on('click', function () {
				if (curState !== 3) {
					callback.call(label);
				}
			})
			.attr(normalState)
			.css(extend({ cursor: 'default' }, normalStyle));
	},

	/**
	 * Make a straight line crisper by not spilling out to neighbour pixels
	 * @param {Array} points
	 * @param {Number} width
	 */
	crispLine: function (points, width) {
		// points format: [M, 0, 0, L, 100, 0]
		// normalize to a crisp line
		if (points[1] === points[4]) {
			// Substract due to #1129. Now bottom and left axis gridlines behave the same.
			points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
		}
		if (points[2] === points[5]) {
			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
		}
		return points;
	},


	/**
	 * Draw a path
	 * @param {Array} path An SVG path in array form
	 */
	path: function (path) {
		var attr = {
			fill: NONE
		};
		if (isArray(path)) {
			attr.d = path;
		} else if (isObject(path)) { // attributes
			extend(attr, path);
		}
		return this.createElement('path').attr(attr);
	},

	/**
	 * Draw and return an SVG circle
	 * @param {Number} x The x position
	 * @param {Number} y The y position
	 * @param {Number} r The radius
	 */
	circle: function (x, y, r) {
		var attr = isObject(x) ?
			x :
			{
				x: x,
				y: y,
				r: r
			},
			wrapper = this.createElement('circle');

		wrapper.xSetter = function (value) {
			this.element.setAttribute('cx', value);
		};
		wrapper.ySetter = function (value) {
			this.element.setAttribute('cy', value);
		};
		return wrapper.attr(attr);
	},

	/**
	 * Draw and return an arc
	 * @param {Number} x X position
	 * @param {Number} y Y position
	 * @param {Number} r Radius
	 * @param {Number} innerR Inner radius like used in donut charts
	 * @param {Number} start Starting angle
	 * @param {Number} end Ending angle
	 */
	arc: function (x, y, r, innerR, start, end) {
		var arc;

		if (isObject(x)) {
			y = x.y;
			r = x.r;
			innerR = x.innerR;
			start = x.start;
			end = x.end;
			x = x.x;
		}

		// Arcs are defined as symbols for the ability to set
		// attributes in attr and animate
		arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
			innerR: innerR || 0,
			start: start || 0,
			end: end || 0
		});
		arc.r = r; // #959
		return arc;
	},

	/**
	 * Draw and return a rectangle
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Number} r Border corner radius
	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
	 */
	rect: function (x, y, width, height, r, strokeWidth) {

		r = isObject(x) ? x.r : r;

		var wrapper = this.createElement('rect'),
			attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
				x: x,
				y: y,
				width: mathMax(width, 0),
				height: mathMax(height, 0)
			};

		if (strokeWidth !== UNDEFINED) {
			attribs.strokeWidth = strokeWidth;
			attribs = wrapper.crisp(attribs);
		}

		if (r) {
			attribs.r = r;
		}

		wrapper.rSetter = function (value) {
			attr(this.element, {
				rx: value,
				ry: value
			});
		};
		
		return wrapper.attr(attribs);
	},

	/**
	 * Resize the box and re-align all aligned elements
	 * @param {Object} width
	 * @param {Object} height
	 * @param {Boolean} animate
	 *
	 */
	setSize: function (width, height, animate) {
		var renderer = this,
			alignedObjects = renderer.alignedObjects,
			i = alignedObjects.length;

		renderer.width = width;
		renderer.height = height;

		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
			width: width,
			height: height
		});

		while (i--) {
			alignedObjects[i].align();
		}
	},

	/**
	 * Create a group
	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
	 *	 This can be used for styling and scripting.
	 */
	g: function (name) {
		var elem = this.createElement('g');
		return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
	},

	/**
	 * Display an image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var attribs = {
				preserveAspectRatio: NONE
			},
			elemWrapper;

		// optional properties
		if (arguments.length > 1) {
			extend(attribs, {
				x: x,
				y: y,
				width: width,
				height: height
			});
		}

		elemWrapper = this.createElement('image').attr(attribs);

		// set the href in the xlink namespace
		if (elemWrapper.element.setAttributeNS) {
			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
				'href', src);
		} else {
			// could be exporting in IE
			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
			elemWrapper.element.setAttribute('hc-svg-href', src);
		}
		return elemWrapper;
	},

	/**
	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
	 *
	 * @param {Object} symbol
	 * @param {Object} x
	 * @param {Object} y
	 * @param {Object} radius
	 * @param {Object} options
	 */
	symbol: function (symbol, x, y, width, height, options) {

		var obj,

			// get the symbol definition function
			symbolFn = this.symbols[symbol],

			// check if there's a path defined for this symbol
			path = symbolFn && symbolFn(
				mathRound(x),
				mathRound(y),
				width,
				height,
				options
			),

			imageElement,
			imageRegex = /^url\((.*?)\)$/,
			imageSrc,
			imageSize,
			centerImage;

		if (path) {

			obj = this.path(path);
			// expando properties for use in animate and attr
			extend(obj, {
				symbolName: symbol,
				x: x,
				y: y,
				width: width,
				height: height
			});
			if (options) {
				extend(obj, options);
			}


		// image symbols
		} else if (imageRegex.test(symbol)) {

			// On image load, set the size and position
			centerImage = function (img, size) {
				if (img.element) { // it may be destroyed in the meantime (#1390)
					img.attr({
						width: size[0],
						height: size[1]
					});

					if (!img.alignByTranslate) { // #185
						img.translate(
							mathRound((width - size[0]) / 2), // #1378
							mathRound((height - size[1]) / 2)
						);
					}
				}
			};

			imageSrc = symbol.match(imageRegex)[1];
			imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

			// Ireate the image synchronously, add attribs async
			obj = this.image(imageSrc)
				.attr({
					x: x,
					y: y
				});
			obj.isImg = true;

			if (imageSize) {
				centerImage(obj, imageSize);
			} else {
				// Initialize image to be 0 size so export will still function if there's no cached sizes.
				obj.attr({ width: 0, height: 0 });

				// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
				// the created element must be assigned to a variable in order to load (#292).
				imageElement = createElement('img', {
					onload: function () {
						centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
					},
					src: imageSrc
				});
			}
		}

		return obj;
	},

	/**
	 * An extendable collection of functions for defining symbol paths.
	 */
	symbols: {
		'circle': function (x, y, w, h) {
			var cpw = 0.166 * w;
			return [
				M, x + w / 2, y,
				'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
				'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
				'Z'
			];
		},

		'square': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h,
				x, y + h,
				'Z'
			];
		},

		'triangle-down': function (x, y, w, h) {
			return [
				M, x, y,
				L, x + w, y,
				x + w / 2, y + h,
				'Z'
			];
		},
		'diamond': function (x, y, w, h) {
			return [
				M, x + w / 2, y,
				L, x + w, y + h / 2,
				x + w / 2, y + h,
				x, y + h / 2,
				'Z'
			];
		},
		'arc': function (x, y, w, h, options) {
			var start = options.start,
				radius = options.r || w || h,
				end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
				innerRadius = options.innerR,
				open = options.open,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				longArc = options.end - start < mathPI ? 0 : 1;

			return [
				M,
				x + radius * cosStart,
				y + radius * sinStart,
				'A', // arcTo
				radius, // x radius
				radius, // y radius
				0, // slanting
				longArc, // long or short arc
				1, // clockwise
				x + radius * cosEnd,
				y + radius * sinEnd,
				open ? M : L,
				x + innerRadius * cosEnd,
				y + innerRadius * sinEnd,
				'A', // arcTo
				innerRadius, // x radius
				innerRadius, // y radius
				0, // slanting
				longArc, // long or short arc
				0, // clockwise
				x + innerRadius * cosStart,
				y + innerRadius * sinStart,

				open ? '' : 'Z' // close
			];
		},

		/**
		 * Callout shape used for default tooltips, also used for rounded rectangles in VML
		 */
		callout: function (x, y, w, h, options) {
			var arrowLength = 6,
				halfDistance = 6,
				r = mathMin((options && options.r) || 0, w, h),
				safeDistance = r + halfDistance,
				anchorX = options && options.anchorX,
				anchorY = options && options.anchorY,
				path,
				normalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;

			x += normalizer;
			y += normalizer;
			path = [
				'M', x + r, y, 
				'L', x + w - r, y, // top side
				'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
				'L', x + w, y + h - r, // right side
				'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
				'L', x + r, y + h, // bottom side
				'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
				'L', x, y + r, // left side
				'C', x, y, x, y, x + r, y // top-right corner
			];
			
			if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
				path.splice(13, 3,
					'L', x + w, anchorY - halfDistance, 
					x + w + arrowLength, anchorY,
					x + w, anchorY + halfDistance,
					x + w, y + h - r
				);
			} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
				path.splice(33, 3, 
					'L', x, anchorY + halfDistance, 
					x - arrowLength, anchorY,
					x, anchorY - halfDistance,
					x, y + r
				);
			} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
				path.splice(23, 3,
					'L', anchorX + halfDistance, y + h,
					anchorX, y + h + arrowLength,
					anchorX - halfDistance, y + h,
					x + r, y + h
				);
			} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
				path.splice(3, 3,
					'L', anchorX - halfDistance, y,
					anchorX, y - arrowLength,
					anchorX + halfDistance, y,
					w - r, y
				);
			}
			return path;
		}
	},

	/**
	 * Define a clipping rectangle
	 * @param {String} id
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {
		var wrapper,
			id = PREFIX + idCounter++,

			clipPath = this.createElement('clipPath').attr({
				id: id
			}).add(this.defs);

		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
		wrapper.id = id;
		wrapper.clipPath = clipPath;
		wrapper.count = 0;

		return wrapper;
	},


	


	/**
	 * Add text to the SVG object
	 * @param {String} str
	 * @param {Number} x Left position
	 * @param {Number} y Top position
	 * @param {Boolean} useHTML Use HTML to render the text
	 */
	text: function (str, x, y, useHTML) {

		// declare variables
		var renderer = this,
			fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
			wrapper,
			attr = {};

		if (useHTML && !renderer.forExport) {
			return renderer.html(str, x, y);
		}

		attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
		if (y) {
			attr.y = Math.round(y);
		}
		if (str || str === 0) {
			attr.text = str;
		}

		wrapper = renderer.createElement('text')
			.attr(attr);

		// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
		if (fakeSVG) {
			wrapper.css({
				position: ABSOLUTE
			});
		}

		if (!useHTML) {
			wrapper.xSetter = function (value, key, element) {
				var tspans = element.getElementsByTagName('tspan'),
					tspan,
					parentVal = element.getAttribute(key),
					i;
				for (i = 0; i < tspans.length; i++) {
					tspan = tspans[i];
					// If the x values are equal, the tspan represents a linebreak
					if (tspan.getAttribute(key) === parentVal) {
						tspan.setAttribute(key, value);
					}
				}
				element.setAttribute(key, value);
			};
		}
		
		return wrapper;
	},

	/**
	 * Utility to return the baseline offset and total line height from the font size
	 */
	fontMetrics: function (fontSize, elem) {
		fontSize = fontSize || this.style.fontSize;
		if (elem && win.getComputedStyle) {
			elem = elem.element || elem; // SVGElement
			fontSize = win.getComputedStyle(elem, "").fontSize;
		}
		fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

		// Empirical values found by comparing font size and bounding box height.
		// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
		var lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2),
			baseline = mathRound(lineHeight * 0.8);

		return {
			h: lineHeight,
			b: baseline,
			f: fontSize
		};
	},

	/**
	 * Correct X and Y positioning of a label for rotation (#1764)
	 */
	rotCorr: function (baseline, rotation, alterY) {
		var y = baseline;
		if (rotation && alterY) {
			y = mathMax(y * mathCos(rotation * deg2rad), 4);
		}
		return {
			x: (-baseline / 3) * mathSin(rotation * deg2rad),
			y: y
		};
	},

	/**
	 * Add a label, a text item that can hold a colored or gradient background
	 * as well as a border and shadow.
	 * @param {string} str
	 * @param {Number} x
	 * @param {Number} y
	 * @param {String} shape
	 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
	 *	coordinates it should be pinned to
	 * @param {Number} anchorY
	 * @param {Boolean} baseline Whether to position the label relative to the text baseline,
	 *	like renderer.text, or to the upper border of the rectangle.
	 * @param {String} className Class name for the group
	 */
	label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

		var renderer = this,
			wrapper = renderer.g(className),
			text = renderer.text('', 0, 0, useHTML)
				.attr({
					zIndex: 1
				}),
				//.add(wrapper),
			box,
			bBox,
			alignFactor = 0,
			padding = 3,
			paddingLeft = 0,
			width,
			height,
			wrapperX,
			wrapperY,
			crispAdjust = 0,
			deferredAttr = {},
			baselineOffset,
			needsBox;

		/**
		 * This function runs after the label is added to the DOM (when the bounding box is
		 * available), and after the text of the label is updated to detect the new bounding
		 * box and reflect it in the border box.
		 */
		function updateBoxSize() {
			var boxX,
				boxY,
				style = text.element.style;

			bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && 
				text.getBBox(); //#3295 && 3514 box failure when string equals 0
			wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
			wrapper.height = (height || bBox.height || 0) + 2 * padding;

			// update the label-scoped y offset
			baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;

			
			if (needsBox) {

				// create the border box if it is not already present
				if (!box) {
					boxX = mathRound(-alignFactor * padding);
					boxY = baseline ? -baselineOffset : 0;

					wrapper.box = box = shape ?
						renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
						renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
					box.attr('fill', NONE).add(wrapper);
				}

				// apply the box attributes
				if (!box.isImg) { // #1630
					box.attr(extend({
						width: mathRound(wrapper.width),
						height: mathRound(wrapper.height)
					}, deferredAttr));
				}
				deferredAttr = null;
			}
		}

		/**
		 * This function runs after setting text or padding, but only if padding is changed
		 */
		function updateTextPadding() {
			var styles = wrapper.styles,
				textAlign = styles && styles.textAlign,
				x = paddingLeft + padding * (1 - alignFactor),
				y;

			// determin y based on the baseline
			y = baseline ? 0 : baselineOffset;

			// compensate for alignment
			if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
				x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
			}

			// update if anything changed
			if (x !== text.x || y !== text.y) {
				text.attr('x', x);
				if (y !== UNDEFINED) {
					text.attr('y', y);
				}
			}

			// record current values
			text.x = x;
			text.y = y;
		}

		/**
		 * Set a box attribute, or defer it if the box is not yet created
		 * @param {Object} key
		 * @param {Object} value
		 */
		function boxAttr(key, value) {
			if (box) {
				box.attr(key, value);
			} else {
				deferredAttr[key] = value;
			}
		}

		/**
		 * After the text element is added, get the desired size of the border box
		 * and add it before the text in the DOM.
		 */
		wrapper.onAdd = function () {
			text.add(wrapper);
			wrapper.attr({
				text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
				x: x,
				y: y
			});

			if (box && defined(anchorX)) {
				wrapper.attr({
					anchorX: anchorX,
					anchorY: anchorY
				});
			}
		};

		/*
		 * Add specific attribute setters.
		 */

		// only change local variables
		wrapper.widthSetter = function (value) {
			width = value;
		};
		wrapper.heightSetter = function (value) {
			height = value;
		};
		wrapper.paddingSetter =  function (value) {
			if (defined(value) && value !== padding) {
				padding = wrapper.padding = value;
				updateTextPadding();
			}
		};
		wrapper.paddingLeftSetter =  function (value) {
			if (defined(value) && value !== paddingLeft) {
				paddingLeft = value;
				updateTextPadding();
			}
		};


		// change local variable and prevent setting attribute on the group
		wrapper.alignSetter = function (value) {
			alignFactor = { left: 0, center: 0.5, right: 1 }[value];
		};

		// apply these to the box and the text alike
		wrapper.textSetter = function (value) {
			if (value !== UNDEFINED) {
				text.textSetter(value);
			}
			updateBoxSize();
			updateTextPadding();
		};

		// apply these to the box but not to the text
		wrapper['stroke-widthSetter'] = function (value, key) {
			if (value) {
				needsBox = true;
			}
			crispAdjust = value % 2 / 2;
			boxAttr(key, value);
		};
		wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
			if (key === 'fill' && value) {
				needsBox = true;
			}
			boxAttr(key, value);
		};
		wrapper.anchorXSetter = function (value, key) {
			anchorX = value;
			boxAttr(key, value + crispAdjust - wrapperX);
		};
		wrapper.anchorYSetter = function (value, key) {
			anchorY = value;
			boxAttr(key, value - wrapperY);
		};

		// rename attributes
		wrapper.xSetter = function (value) {
			wrapper.x = value; // for animation getter
			if (alignFactor) {
				value -= alignFactor * ((width || bBox.width) + padding);
			}
			wrapperX = mathRound(value);
			wrapper.attr('translateX', wrapperX);
		};
		wrapper.ySetter = function (value) {
			wrapperY = wrapper.y = mathRound(value);
			wrapper.attr('translateY', wrapperY);
		};

		// Redirect certain methods to either the box or the text
		var baseCss = wrapper.css;
		return extend(wrapper, {
			/**
			 * Pick up some properties and apply them to the text instead of the wrapper
			 */
			css: function (styles) {
				if (styles) {
					var textStyles = {};
					styles = merge(styles); // create a copy to avoid altering the original object (#537)
					each(wrapper.textProps, function (prop) {
						if (styles[prop] !== UNDEFINED) {
							textStyles[prop] = styles[prop];
							delete styles[prop];
						}
					});
					text.css(textStyles);
				}
				return baseCss.call(wrapper, styles);
			},
			/**
			 * Return the bounding box of the box, not the group
			 */
			getBBox: function () {
				return {
					width: bBox.width + 2 * padding,
					height: bBox.height + 2 * padding,
					x: bBox.x - padding,
					y: bBox.y - padding
				};
			},
			/**
			 * Apply the shadow to the box
			 */
			shadow: function (b) {
				if (box) {
					box.shadow(b);
				}
				return wrapper;
			},
			/**
			 * Destroy and release memory.
			 */
			destroy: function () {

				// Added by button implementation
				removeEvent(wrapper.element, 'mouseenter');
				removeEvent(wrapper.element, 'mouseleave');

				if (text) {
					text = text.destroy();
				}
				if (box) {
					box = box.destroy();
				}
				// Call base implementation to destroy the rest
				SVGElement.prototype.destroy.call(wrapper);

				// Release local pointers (#1298)
				wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
			}
		});
	}
}; // end SVGRenderer


// general renderer
Renderer = SVGRenderer;
// extend SvgElement for useHTML option
extend(SVGElement.prototype, {
	/**
	 * Apply CSS to HTML elements. This is used in text within SVG rendering and
	 * by the VML renderer
	 */
	htmlCss: function (styles) {
		var wrapper = this,
			element = wrapper.element,
			textWidth = styles && element.tagName === 'SPAN' && styles.width;

		if (textWidth) {
			delete styles.width;
			wrapper.textWidth = textWidth;
			wrapper.updateTransform();
		}
		if (styles && styles.textOverflow === 'ellipsis') {
			styles.whiteSpace = 'nowrap';
			styles.overflow = 'hidden';
		}
		wrapper.styles = extend(wrapper.styles, styles);
		css(wrapper.element, styles);

		return wrapper;
	},

	/**
	 * VML and useHTML method for calculating the bounding box based on offsets
	 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
	 * use the cached value
	 *
	 * @return {Object} A hash containing values for x, y, width and height
	 */

	htmlGetBBox: function () {
		var wrapper = this,
			element = wrapper.element;

		// faking getBBox in exported SVG in legacy IE
		// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
		if (element.nodeName === 'text') {
			element.style.position = ABSOLUTE;
		}

		return {
			x: element.offsetLeft,
			y: element.offsetTop,
			width: element.offsetWidth,
			height: element.offsetHeight
		};
	},

	/**
	 * VML override private method to update elements based on internal
	 * properties based on SVG transform
	 */
	htmlUpdateTransform: function () {
		// aligning non added elements is expensive
		if (!this.added) {
			this.alignOnAdd = true;
			return;
		}

		var wrapper = this,
			renderer = wrapper.renderer,
			elem = wrapper.element,
			translateX = wrapper.translateX || 0,
			translateY = wrapper.translateY || 0,
			x = wrapper.x || 0,
			y = wrapper.y || 0,
			align = wrapper.textAlign || 'left',
			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
			shadows = wrapper.shadows,
			styles = wrapper.styles;

		// apply translate
		css(elem, {
			marginLeft: translateX,
			marginTop: translateY
		});
		if (shadows) { // used in labels/tooltip
			each(shadows, function (shadow) {
				css(shadow, {
					marginLeft: translateX + 1,
					marginTop: translateY + 1
				});
			});
		}

		// apply inversion
		if (wrapper.inverted) { // wrapper is a group
			each(elem.childNodes, function (child) {
				renderer.invertChild(child, elem);
			});
		}

		if (elem.tagName === 'SPAN') {

			var width,
				rotation = wrapper.rotation,
				baseline,
				textWidth = pInt(wrapper.textWidth),
				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


				baseline = renderer.fontMetrics(elem.style.fontSize).b;

				// Renderer specific handling of span rotation
				if (defined(rotation)) {
					wrapper.setSpanRotation(rotation, alignCorrection, baseline);
				}

				width = pick(wrapper.elemWidth, elem.offsetWidth);

				// Update textWidth
				if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
					css(elem, {
						width: textWidth + PX,
						display: 'block',
						whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
					});
					width = textWidth;
				}

				wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
			}

			// apply position with correction
			css(elem, {
				left: (x + (wrapper.xCorr || 0)) + PX,
				top: (y + (wrapper.yCorr || 0)) + PX
			});

			// force reflow in webkit to apply the left and top on useHTML element (#1249)
			if (isWebKit) {
				baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
			}

			// record current text transform
			wrapper.cTT = currentTextTransform;
		}
	},

	/**
	 * Set the rotation of an individual HTML span
	 */
	setSpanRotation: function (rotation, alignCorrection, baseline) {
		var rotationStyle = {},
			cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

		rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
		rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
		css(this.element, rotationStyle);
	},

	/**
	 * Get the correction in X and Y positioning as the element is rotated.
	 */
	getSpanCorrection: function (width, baseline, alignCorrection) {
		this.xCorr = -width * alignCorrection;
		this.yCorr = -baseline;
	}
});

// Extend SvgRenderer for useHTML option.
extend(SVGRenderer.prototype, {
	/**
	 * Create HTML text node. This is used by the VML renderer as well as the SVG
	 * renderer through the useHTML option.
	 *
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	html: function (str, x, y) {
		var wrapper = this.createElement('span'),
			element = wrapper.element,
			renderer = wrapper.renderer;

		// Text setter
		wrapper.textSetter = function (value) {
			if (value !== element.innerHTML) {
				delete this.bBox;
			}
			element.innerHTML = this.textStr = value;
		};

		// Various setters which rely on update transform
		wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
			if (key === 'align') {
				key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
			}
			wrapper[key] = value;
			wrapper.htmlUpdateTransform();
		};

		// Set the default attributes
		wrapper.attr({
				text: str,
				x: mathRound(x),
				y: mathRound(y)
			})
			.css({
				position: ABSOLUTE,
				fontFamily: this.style.fontFamily,
				fontSize: this.style.fontSize
			});

		// Keep the whiteSpace style outside the wrapper.styles collection
		element.style.whiteSpace = 'nowrap';

		// Use the HTML specific .css method
		wrapper.css = wrapper.htmlCss;

		// This is specific for HTML within SVG
		if (renderer.isSVG) {
			wrapper.add = function (svgGroupWrapper) {

				var htmlGroup,
					container = renderer.box.parentNode,
					parentGroup,
					parents = [];

				this.parentGroup = svgGroupWrapper;

				// Create a mock group to hold the HTML elements
				if (svgGroupWrapper) {
					htmlGroup = svgGroupWrapper.div;
					if (!htmlGroup) {

						// Read the parent chain into an array and read from top down
						parentGroup = svgGroupWrapper;
						while (parentGroup) {

							parents.push(parentGroup);

							// Move up to the next parent group
							parentGroup = parentGroup.parentGroup;
						}

						// Ensure dynamically updating position when any parent is translated
						each(parents.reverse(), function (parentGroup) {
							var htmlGroupStyle;

							// Create a HTML div and append it to the parent div to emulate
							// the SVG group structure
							htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {
								className: attr(parentGroup.element, 'class')
							}, {
								position: ABSOLUTE,
								left: (parentGroup.translateX || 0) + PX,
								top: (parentGroup.translateY || 0) + PX
							}, htmlGroup || container); // the top group is appended to container

							// Shortcut
							htmlGroupStyle = htmlGroup.style;

							// Set listeners to update the HTML div's position whenever the SVG group
							// position is changed
							extend(parentGroup, {
								translateXSetter: function (value, key) {
									htmlGroupStyle.left = value + PX;
									parentGroup[key] = value;
									parentGroup.doTransform = true;
								},
								translateYSetter: function (value, key) {
									htmlGroupStyle.top = value + PX;
									parentGroup[key] = value;
									parentGroup.doTransform = true;
								},
								visibilitySetter: function (value, key) {
									htmlGroupStyle[key] = value;
								}
							});
						});

					}
				} else {
					htmlGroup = container;
				}

				htmlGroup.appendChild(element);

				// Shared with VML:
				wrapper.added = true;
				if (wrapper.alignOnAdd) {
					wrapper.htmlUpdateTransform();
				}

				return wrapper;
			};
		}
		return wrapper;
	}
});

/* ****************************************************************************
 *                                                                            *
 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
 *                                                                            *
 * For applications and websites that don't need IE support, like platform    *
 * targeted mobile apps and web apps, this code can be removed.               *
 *                                                                            *
 *****************************************************************************/

/**
 * @constructor
 */
var VMLRenderer, VMLElement;
if (!hasSVG && !useCanVG) {

/**
 * The VML element wrapper.
 */
VMLElement = {

	/**
	 * Initialize a new VML element wrapper. It builds the markup as a string
	 * to minimize DOM traffic.
	 * @param {Object} renderer
	 * @param {Object} nodeName
	 */
	init: function (renderer, nodeName) {
		var wrapper = this,
			markup =  ['<', nodeName, ' filled="f" stroked="f"'],
			style = ['position: ', ABSOLUTE, ';'],
			isDiv = nodeName === DIV;

		// divs and shapes need size
		if (nodeName === 'shape' || isDiv) {
			style.push('left:0;top:0;width:1px;height:1px;');
		}
		style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

		markup.push(' style="', style.join(''), '"/>');

		// create element with default attributes and style
		if (nodeName) {
			markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
				markup.join('')
				: renderer.prepVML(markup);
			wrapper.element = createElement(markup);
		}

		wrapper.renderer = renderer;
	},

	/**
	 * Add the node to the given parent
	 * @param {Object} parent
	 */
	add: function (parent) {
		var wrapper = this,
			renderer = wrapper.renderer,
			element = wrapper.element,
			box = renderer.box,
			inverted = parent && parent.inverted,

			// get the parent node
			parentNode = parent ?
				parent.element || parent :
				box;


		// if the parent group is inverted, apply inversion on all children
		if (inverted) { // only on groups
			renderer.invertChild(element, parentNode);
		}

		// append it
		parentNode.appendChild(element);

		// align text after adding to be able to read offset
		wrapper.added = true;
		if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
			wrapper.updateTransform();
		}

		// fire an event for internal hooks
		if (wrapper.onAdd) {
			wrapper.onAdd();
		}

		return wrapper;
	},

	/**
	 * VML always uses htmlUpdateTransform
	 */
	updateTransform: SVGElement.prototype.htmlUpdateTransform,

	/**
	 * Set the rotation of a span with oldIE's filter
	 */
	setSpanRotation: function () {
		// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
		// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
		// has support for CSS3 transform. The getBBox method also needs to be updated
		// to compensate for the rotation, like it currently does for SVG.
		// Test case: http://jsfiddle.net/highcharts/Ybt44/

		var rotation = this.rotation,
			costheta = mathCos(rotation * deg2rad),
			sintheta = mathSin(rotation * deg2rad);
					
		css(this.element, {
			filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
				', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
				', sizingMethod=\'auto expand\')'].join('') : NONE
		});
	},

	/**
	 * Get the positioning correction for the span after rotating. 
	 */
	getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

		var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
			sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
			height = pick(this.elemHeight, this.element.offsetHeight),
			quad,
			nonLeft = align && align !== 'left';

		// correct x and y
		this.xCorr = costheta < 0 && -width;
		this.yCorr = sintheta < 0 && -height;

		// correct for baseline and corners spilling out after rotation
		quad = costheta * sintheta < 0;
		this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
		this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
		// correct for the length/height of the text
		if (nonLeft) {
			this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
			if (rotation) {
				this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
			}
			css(this.element, {
				textAlign: align
			});
		}
	},

	/**
	 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
	 * as the parameter and returns a string.
	 */
	pathToVML: function (value) {
		// convert paths
		var i = value.length,
			path = [];

		while (i--) {

			// Multiply by 10 to allow subpixel precision.
			// Substracting half a pixel seems to make the coordinates
			// align with SVG, but this hasn't been tested thoroughly
			if (isNumber(value[i])) {
				path[i] = mathRound(value[i] * 10) - 5;
			} else if (value[i] === 'Z') { // close the path
				path[i] = 'x';
			} else {
				path[i] = value[i];

				// When the start X and end X coordinates of an arc are too close,
				// they are rounded to the same value above. In this case, substract or 
				// add 1 from the end X and Y positions. #186, #760, #1371, #1410.
				if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
					// Start and end X
					if (path[i + 5] === path[i + 7]) {
						path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
					}
					// Start and end Y
					if (path[i + 6] === path[i + 8]) {
						path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
					}
				}
			}
		}

		
		// Loop up again to handle path shortcuts (#2132)
		/*while (i++ < path.length) {
			if (path[i] === 'H') { // horizontal line to
				path[i] = 'L';
				path.splice(i + 2, 0, path[i - 1]);
			} else if (path[i] === 'V') { // vertical line to
				path[i] = 'L';
				path.splice(i + 1, 0, path[i - 2]);
			}
		}*/
		return path.join(' ') || 'x';
	},

	/**
	 * Set the element's clipping to a predefined rectangle
	 *
	 * @param {String} id The id of the clip rectangle
	 */
	clip: function (clipRect) {
		var wrapper = this,
			clipMembers,
			cssRet;

		if (clipRect) {
			clipMembers = clipRect.members;
			erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
			clipMembers.push(wrapper);
			wrapper.destroyClip = function () {
				erase(clipMembers, wrapper);
			};
			cssRet = clipRect.getCSS(wrapper);

		} else {
			if (wrapper.destroyClip) {
				wrapper.destroyClip();
			}
			cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
		}

		return wrapper.css(cssRet);

	},

	/**
	 * Set styles for the element
	 * @param {Object} styles
	 */
	css: SVGElement.prototype.htmlCss,

	/**
	 * Removes a child either by removeChild or move to garbageBin.
	 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	 */
	safeRemoveChild: function (element) {
		// discardElement will detach the node from its parent before attaching it
		// to the garbage bin. Therefore it is important that the node is attached and have parent.
		if (element.parentNode) {
			discardElement(element);
		}
	},

	/**
	 * Extend element.destroy by removing it from the clip members array
	 */
	destroy: function () {
		if (this.destroyClip) {
			this.destroyClip();
		}

		return SVGElement.prototype.destroy.apply(this);
	},

	/**
	 * Add an event listener. VML override for normalizing event parameters.
	 * @param {String} eventType
	 * @param {Function} handler
	 */
	on: function (eventType, handler) {
		// simplest possible event model for internal use
		this.element['on' + eventType] = function () {
			var evt = win.event;
			evt.target = evt.srcElement;
			handler(evt);
		};
		return this;
	},

	/**
	 * In stacked columns, cut off the shadows so that they don't overlap
	 */
	cutOffPath: function (path, length) {

		var len;

		path = path.split(/[ ,]/);
		len = path.length;

		if (len === 9 || len === 11) {
			path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
		}
		return path.join(' ');
	},

	/**
	 * Apply a drop shadow by copying elements and giving them different strokes
	 * @param {Boolean|Object} shadowOptions
	 */
	shadow: function (shadowOptions, group, cutOff) {
		var shadows = [],
			i,
			element = this.element,
			renderer = this.renderer,
			shadow,
			elemStyle = element.style,
			markup,
			path = element.path,
			strokeWidth,
			modifiedPath,
			shadowWidth,
			shadowElementOpacity;

		// some times empty paths are not strings
		if (path && typeof path.value !== 'string') {
			path = 'x';
		}
		modifiedPath = path;

		if (shadowOptions) {
			shadowWidth = pick(shadowOptions.width, 3);
			shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
			for (i = 1; i <= 3; i++) {

				strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

				// Cut off shadows for stacked column items
				if (cutOff) {
					modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
				}

				markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
					'" filled="false" path="', modifiedPath,
					'" coordsize="10 10" style="', element.style.cssText, '" />'];

				shadow = createElement(renderer.prepVML(markup),
					null, {
						left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
						top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
					}
				);
				if (cutOff) {
					shadow.cutOff = strokeWidth + 1;
				}

				// apply the opacity
				markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
				createElement(renderer.prepVML(markup), null, null, shadow);


				// insert it
				if (group) {
					group.element.appendChild(shadow);
				} else {
					element.parentNode.insertBefore(shadow, element);
				}

				// record it
				shadows.push(shadow);

			}

			this.shadows = shadows;
		}
		return this;
	},
	updateShadows: noop, // Used in SVG only

	setAttr: function (key, value) {
		if (docMode8) { // IE8 setAttribute bug
			this.element[key] = value;
		} else {
			this.element.setAttribute(key, value);
		}
	},
	classSetter: function (value) {
		// IE8 Standards mode has problems retrieving the className unless set like this
		this.element.className = value;
	},
	dashstyleSetter: function (value, key, element) {
		var strokeElem = element.getElementsByTagName('stroke')[0] ||
			createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
		strokeElem[key] = value || 'solid';
		this[key] = value; /* because changing stroke-width will change the dash length
			and cause an epileptic effect */
	},
	dSetter: function (value, key, element) {
		var i,
			shadows = this.shadows;
		value = value || [];
		this.d = value.join && value.join(' '); // used in getter for animation

		element.path = value = this.pathToVML(value);

		// update shadows
		if (shadows) {
			i = shadows.length;
			while (i--) {
				shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
			}
		}
		this.setAttr(key, value);
	},
	fillSetter: function (value, key, element) {
		var nodeName = element.nodeName;
		if (nodeName === 'SPAN') { // text color
			element.style.color = value;
		} else if (nodeName !== 'IMG') { // #1336
			element.filled = value !== NONE;
			this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
		}
	},
	opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
	rotationSetter: function (value, key, element) {
		var style = element.style;
		this[key] = style[key] = value; // style is for #1873

		// Correction for the 1x1 size of the shape container. Used in gauge needles.
		style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
		style.top = mathRound(mathCos(value * deg2rad)) + PX;
	},
	strokeSetter: function (value, key, element) {
		this.setAttr('strokecolor', this.renderer.color(value, element, key));
	},
	'stroke-widthSetter': function (value, key, element) {
		element.stroked = !!value; // VML "stroked" attribute
		this[key] = value; // used in getter, issue #113
		if (isNumber(value)) {
			value += PX;
		}
		this.setAttr('strokeweight', value);
	},
	titleSetter: function (value, key) {
		this.setAttr(key, value);
	},
	visibilitySetter: function (value, key, element) {

		// Handle inherited visibility
		if (value === 'inherit') {
			value = VISIBLE;
		}
		
		// Let the shadow follow the main element
		if (this.shadows) {
			each(this.shadows, function (shadow) {
				shadow.style[key] = value;
			});
		}

		// Instead of toggling the visibility CSS property, move the div out of the viewport.
		// This works around #61 and #586
		if (element.nodeName === 'DIV') {
			value = value === HIDDEN ? '-999em' : 0;

			// In order to redraw, IE7 needs the div to be visible when tucked away
			// outside the viewport. So the visibility is actually opposite of
			// the expected value. This applies to the tooltip only.
			if (!docMode8) {
				element.style[key] = value ? VISIBLE : HIDDEN;
			}
			key = 'top';
		}
		element.style[key] = value;
	},
	xSetter: function (value, key, element) {
		this[key] = value; // used in getter

		if (key === 'x') {
			key = 'left';
		} else if (key === 'y') {
			key = 'top';
		}/* else {
			value = mathMax(0, value); // don't set width or height below zero (#311)
		}*/

		// clipping rectangle special
		if (this.updateClipping) {
			this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
			this.updateClipping();
		} else {
			// normal
			element.style[key] = value;
		}
	},
	zIndexSetter: function (value, key, element) {
		element.style[key] = value;
	}
};
Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

// Some shared setters
VMLElement.prototype.ySetter =
	VMLElement.prototype.widthSetter = 
	VMLElement.prototype.heightSetter = 
	VMLElement.prototype.xSetter;


/**
 * The VML renderer
 */
var VMLRendererExtension = { // inherit SVGRenderer

	Element: VMLElement,
	isIE8: userAgent.indexOf('MSIE 8.0') > -1,


	/**
	 * Initialize the VMLRenderer
	 * @param {Object} container
	 * @param {Number} width
	 * @param {Number} height
	 */
	init: function (container, width, height, style) {
		var renderer = this,
			boxWrapper,
			box,
			css;

		renderer.alignedObjects = [];

		boxWrapper = renderer.createElement(DIV)
			.css(extend(this.getStyle(style), { position: RELATIVE}));
		box = boxWrapper.element;
		container.appendChild(boxWrapper.element);


		// generate the containing box
		renderer.isVML = true;
		renderer.box = box;
		renderer.boxWrapper = boxWrapper;
		renderer.cache = {};


		renderer.setSize(width, height, false);

		// The only way to make IE6 and IE7 print is to use a global namespace. However,
		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
		// seems to be to add the xmlns attribute and the behaviour style inline.
		if (!doc.namespaces.hcv) {

			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

			// Setup default CSS (#2153, #2368, #2384)
			css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
				'{ behavior:url(#default#VML); display: inline-block; } ';
			try {
				doc.createStyleSheet().cssText = css;
			} catch (e) {
				doc.styleSheets[0].cssText += css;
			}

		}
	},


	/**
	 * Detect whether the renderer is hidden. This happens when one of the parent elements
	 * has display: none
	 */
	isHidden: function () {
		return !this.box.offsetWidth;
	},

	/**
	 * Define a clipping rectangle. In VML it is accomplished by storing the values
	 * for setting the CSS style to all associated members.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	clipRect: function (x, y, width, height) {

		// create a dummy element
		var clipRect = this.createElement(),
			isObj = isObject(x);

		// mimic a rectangle with its style object for automatic updating in attr
		return extend(clipRect, {
			members: [],
			count: 0,
			left: (isObj ? x.x : x) + 1,
			top: (isObj ? x.y : y) + 1,
			width: (isObj ? x.width : width) - 1,
			height: (isObj ? x.height : height) - 1,
			getCSS: function (wrapper) {
				var element = wrapper.element,
					nodeName = element.nodeName,
					isShape = nodeName === 'shape',
					inverted = wrapper.inverted,
					rect = this,
					top = rect.top - (isShape ? element.offsetTop : 0),
					left = rect.left,
					right = left + rect.width,
					bottom = top + rect.height,
					ret = {
						clip: 'rect(' +
							mathRound(inverted ? left : top) + 'px,' +
							mathRound(inverted ? bottom : right) + 'px,' +
							mathRound(inverted ? right : bottom) + 'px,' +
							mathRound(inverted ? top : left) + 'px)'
					};

				// issue 74 workaround
				if (!inverted && docMode8 && nodeName === 'DIV') {
					extend(ret, {
						width: right + PX,
						height: bottom + PX
					});
				}
				return ret;
			},

			// used in attr and animation to update the clipping of all members
			updateClipping: function () {
				each(clipRect.members, function (member) {
					if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
						member.css(clipRect.getCSS(member));
					}
				});
			}
		});

	},


	/**
	 * Take a color and return it if it's a string, make it a gradient if it's a
	 * gradient configuration object, and apply opacity.
	 *
	 * @param {Object} color The color or config object
	 */
	color: function (color, elem, prop, wrapper) {
		var renderer = this,
			colorObject,
			regexRgba = /^rgba/,
			markup,
			fillType,
			ret = NONE;

		// Check for linear or radial gradient
		if (color && color.linearGradient) {
			fillType = 'gradient';
		} else if (color && color.radialGradient) {
			fillType = 'pattern';
		}


		if (fillType) {

			var stopColor,
				stopOpacity,
				gradient = color.linearGradient || color.radialGradient,
				x1,
				y1,
				x2,
				y2,
				opacity1,
				opacity2,
				color1,
				color2,
				fillAttr = '',
				stops = color.stops,
				firstStop,
				lastStop,
				colors = [],
				addFillNode = function () {
					// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
					// are reversed.
					markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
						'" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
					createElement(renderer.prepVML(markup), null, null, elem);
				};

			// Extend from 0 to 1
			firstStop = stops[0];
			lastStop = stops[stops.length - 1];
			if (firstStop[0] > 0) {
				stops.unshift([
					0,
					firstStop[1]
				]);
			}
			if (lastStop[0] < 1) {
				stops.push([
					1,
					lastStop[1]
				]);
			}

			// Compute the stops
			each(stops, function (stop, i) {
				if (regexRgba.test(stop[1])) {
					colorObject = Color(stop[1]);
					stopColor = colorObject.get('rgb');
					stopOpacity = colorObject.get('a');
				} else {
					stopColor = stop[1];
					stopOpacity = 1;
				}

				// Build the color attribute
				colors.push((stop[0] * 100) + '% ' + stopColor);

				// Only start and end opacities are allowed, so we use the first and the last
				if (!i) {
					opacity1 = stopOpacity;
					color2 = stopColor;
				} else {
					opacity2 = stopOpacity;
					color1 = stopColor;
				}
			});

			// Apply the gradient to fills only.
			if (prop === 'fill') {

				// Handle linear gradient angle
				if (fillType === 'gradient') {
					x1 = gradient.x1 || gradient[0] || 0;
					y1 = gradient.y1 || gradient[1] || 0;
					x2 = gradient.x2 || gradient[2] || 0;
					y2 = gradient.y2 || gradient[3] || 0;
					fillAttr = 'angle="' + (90  - math.atan(
						(y2 - y1) / // y vector
						(x2 - x1) // x vector
						) * 180 / mathPI) + '"';

					addFillNode();

				// Radial (circular) gradient
				} else {

					var r = gradient.r,
						sizex = r * 2,
						sizey = r * 2,
						cx = gradient.cx,
						cy = gradient.cy,
						radialReference = elem.radialReference,
						bBox,
						applyRadialGradient = function () {
							if (radialReference) {
								bBox = wrapper.getBBox();
								cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
								cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
								sizex *= radialReference[2] / bBox.width;
								sizey *= radialReference[2] / bBox.height;
							}
							fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
								'size="' + sizex + ',' + sizey + '" ' +
								'origin="0.5,0.5" ' +
								'position="' + cx + ',' + cy + '" ' +
								'color2="' + color2 + '" ';

							addFillNode();
						};

					// Apply radial gradient
					if (wrapper.added) {
						applyRadialGradient();
					} else {
						// We need to know the bounding box to get the size and position right
						wrapper.onAdd = applyRadialGradient;
					}

					// The fill element's color attribute is broken in IE8 standards mode, so we
					// need to set the parent shape's fillcolor attribute instead.
					ret = color1;
				}

			// Gradients are not supported for VML stroke, return the first color. #722.
			} else {
				ret = stopColor;
			}

		// if the color is an rgba color, split it and add a fill node
		// to hold the opacity component
		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

			colorObject = Color(color);

			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
			createElement(this.prepVML(markup), null, null, elem);

			ret = colorObject.get('rgb');


		} else {
			var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
			if (propNodes.length) {
				propNodes[0].opacity = 1;
				propNodes[0].type = 'solid';
			}
			ret = color;
		}

		return ret;
	},

	/**
	 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	 * @param {Array} markup A string array of the VML markup to prepare
	 */
	prepVML: function (markup) {
		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
			isIE8 = this.isIE8;

		markup = markup.join('');

		if (isIE8) { // add xmlns and style inline
			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
			if (markup.indexOf('style="') === -1) {
				markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
			} else {
				markup = markup.replace('style="', 'style="' + vmlStyle);
			}

		} else { // add namespace
			markup = markup.replace('<', '<hcv:');
		}

		return markup;
	},

	/**
	 * Create rotated and aligned text
	 * @param {String} str
	 * @param {Number} x
	 * @param {Number} y
	 */
	text: SVGRenderer.prototype.html,

	/**
	 * Create and return a path element
	 * @param {Array} path
	 */
	path: function (path) {
		var attr = {
			// subpixel precision down to 0.1 (width and height = 1px)
			coordsize: '10 10'
		};
		if (isArray(path)) {
			attr.d = path;
		} else if (isObject(path)) { // attributes
			extend(attr, path);
		}
		// create the shape
		return this.createElement('shape').attr(attr);
	},

	/**
	 * Create and return a circle element. In VML circles are implemented as
	 * shapes, which is faster than v:oval
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} r
	 */
	circle: function (x, y, r) {
		var circle = this.symbol('circle');
		if (isObject(x)) {
			r = x.r;
			y = x.y;
			x = x.x;
		}
		circle.isCircle = true; // Causes x and y to mean center (#1682)
		circle.r = r;
		return circle.attr({ x: x, y: y });
	},

	/**
	 * Create a group using an outer div and an inner v:group to allow rotating
	 * and flipping. A simple v:group would have problems with positioning
	 * child HTML elements and CSS clip.
	 *
	 * @param {String} name The name of the group
	 */
	g: function (name) {
		var wrapper,
			attribs;

		// set the class name
		if (name) {
			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
		}

		// the div to hold HTML and clipping
		wrapper = this.createElement(DIV).attr(attribs);

		return wrapper;
	},

	/**
	 * VML override to create a regular HTML image
	 * @param {String} src
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} width
	 * @param {Number} height
	 */
	image: function (src, x, y, width, height) {
		var obj = this.createElement('img')
			.attr({ src: src });

		if (arguments.length > 1) {
			obj.attr({
				x: x,
				y: y,
				width: width,
				height: height
			});
		}
		return obj;
	},

	/**
	 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
	 */
	createElement: function (nodeName) {
		return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	
	},

	/**
	 * In the VML renderer, each child of an inverted div (group) is inverted
	 * @param {Object} element
	 * @param {Object} parentNode
	 */
	invertChild: function (element, parentNode) {
		var ren = this,
			parentStyle = parentNode.style,
			imgStyle = element.tagName === 'IMG' && element.style; // #1111

		css(element, {
			flip: 'x',
			left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
			top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
			rotation: -90
		});

		// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
		each(element.childNodes, function (child) {
			ren.invertChild(child, element);
		});
	},

	/**
	 * Symbol definitions that override the parent SVG renderer's symbols
	 *
	 */
	symbols: {
		// VML specific arc function
		arc: function (x, y, w, h, options) {
			var start = options.start,
				end = options.end,
				radius = options.r || w || h,
				innerRadius = options.innerR,
				cosStart = mathCos(start),
				sinStart = mathSin(start),
				cosEnd = mathCos(end),
				sinEnd = mathSin(end),
				ret;

			if (end - start === 0) { // no angle, don't show it.
				return ['x'];
			}

			ret = [
				'wa', // clockwise arc to
				x - radius, // left
				y - radius, // top
				x + radius, // right
				y + radius, // bottom
				x + radius * cosStart, // start x
				y + radius * sinStart, // start y
				x + radius * cosEnd, // end x
				y + radius * sinEnd  // end y
			];

			if (options.open && !innerRadius) {
				ret.push(
					'e',
					M,
					x,// - innerRadius,
					y// - innerRadius
				);
			}

			ret.push(
				'at', // anti clockwise arc to
				x - innerRadius, // left
				y - innerRadius, // top
				x + innerRadius, // right
				y + innerRadius, // bottom
				x + innerRadius * cosEnd, // start x
				y + innerRadius * sinEnd, // start y
				x + innerRadius * cosStart, // end x
				y + innerRadius * sinStart, // end y
				'x', // finish path
				'e' // close
			);

			ret.isArc = true;
			return ret;

		},
		// Add circle symbol path. This performs significantly faster than v:oval.
		circle: function (x, y, w, h, wrapper) {

			if (wrapper) {
				w = h = 2 * wrapper.r;
			}

			// Center correction, #1682
			if (wrapper && wrapper.isCircle) {
				x -= w / 2;
				y -= h / 2;
			}

			// Return the path
			return [
				'wa', // clockwisearcto
				x, // left
				y, // top
				x + w, // right
				y + h, // bottom
				x + w, // start x
				y + h / 2,     // start y
				x + w, // end x
				y + h / 2,     // end y
				//'x', // finish path
				'e' // close
			];
		},
		/**
		 * Add rectangle symbol path which eases rotation and omits arcsize problems
		 * compared to the built-in VML roundrect shape. When borders are not rounded,
		 * use the simpler square path, else use the callout path without the arrow.
		 */
		rect: function (x, y, w, h, options) {
			return SVGRenderer.prototype.symbols[
				!defined(options) || !options.r ? 'square' : 'callout'
			].call(0, x, y, w, h, options);
		}
	}
};
Highcharts.VMLRenderer = VMLRenderer = function () {
	this.init.apply(this, arguments);
};
VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

	// general renderer
	Renderer = VMLRenderer;
}

// This method is used with exporting in old IE, when emulating SVG (see #2314)
SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
	var measuringSpan = doc.createElement('span'),
		offsetWidth,
	textNode = doc.createTextNode(text);

	measuringSpan.appendChild(textNode);
	css(measuringSpan, styles);
	this.box.appendChild(measuringSpan);
	offsetWidth = measuringSpan.offsetWidth;
	discardElement(measuringSpan); // #2463
	return offsetWidth;
};


/* ****************************************************************************
 *                                                                            *
 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
 *                                                                            *
 *****************************************************************************/
/* ****************************************************************************
 *                                                                            *
 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
 * TARGETING THAT SYSTEM.                                                     *
 *                                                                            *
 *****************************************************************************/
var CanVGRenderer,
	CanVGController;

if (useCanVG) {
	/**
	 * The CanVGRenderer is empty from start to keep the source footprint small.
	 * When requested, the CanVGController downloads the rest of the source packaged
	 * together with the canvg library.
	 */
	Highcharts.CanVGRenderer = CanVGRenderer = function () {
		// Override the global SVG namespace to fake SVG/HTML that accepts CSS
		SVG_NS = 'http://www.w3.org/1999/xhtml';
	};

	/**
	 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
	 * the implementation from SvgRenderer will not be merged in until first render.
	 */
	CanVGRenderer.prototype.symbols = {};

	/**
	 * Handles on demand download of canvg rendering support.
	 */
	CanVGController = (function () {
		// List of renderering calls
		var deferredRenderCalls = [];

		/**
		 * When downloaded, we are ready to draw deferred charts.
		 */
		function drawDeferred() {
			var callLength = deferredRenderCalls.length,
				callIndex;

			// Draw all pending render calls
			for (callIndex = 0; callIndex < callLength; callIndex++) {
				deferredRenderCalls[callIndex]();
			}
			// Clear the list
			deferredRenderCalls = [];
		}

		return {
			push: function (func, scriptLocation) {
				// Only get the script once
				if (deferredRenderCalls.length === 0) {
					getScript(scriptLocation, drawDeferred);
				}
				// Register render call
				deferredRenderCalls.push(func);
			}
		};
	}());

	Renderer = CanVGRenderer;
} // end CanVGRenderer

/* ****************************************************************************
 *                                                                            *
 * END OF ANDROID < 3 SPECIFIC CODE                                           *
 *                                                                            *
 *****************************************************************************/

/**
 * The Tick class
 */
function Tick(axis, pos, type, noLabel) {
	this.axis = axis;
	this.pos = pos;
	this.type = type || '';
	this.isNew = true;

	if (!type && !noLabel) {
		this.addLabel();
	}
}

Tick.prototype = {
	/**
	 * Write the tick label
	 */
	addLabel: function () {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			categories = axis.categories,
			names = axis.names,
			pos = tick.pos,
			labelOptions = options.labels,
			str,
			tickPositions = axis.tickPositions,
			isFirst = pos === tickPositions[0],
			isLast = pos === tickPositions[tickPositions.length - 1],
			value = categories ?
				pick(categories[pos], names[pos], pos) :
				pos,
			label = tick.label,
			tickPositionInfo = tickPositions.info,
			dateTimeLabelFormat;

		// Set the datetime label format. If a higher rank is set for this position, use that. If not,
		// use the general format.
		if (axis.isDatetimeAxis && tickPositionInfo) {
			dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
		}
		// set properties for access in render method
		tick.isFirst = isFirst;
		tick.isLast = isLast;

		// get the string
		str = axis.labelFormatter.call({
			axis: axis,
			chart: chart,
			isFirst: isFirst,
			isLast: isLast,
			dateTimeLabelFormat: dateTimeLabelFormat,
			value: axis.isLog ? correctFloat(lin2log(value)) : value
		});

		// prepare CSS
		//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };
		
		// first call
		if (!defined(label)) {

			tick.label = label =
				defined(str) && labelOptions.enabled ?
					chart.renderer.text(
							str,
							0,
							0,
							labelOptions.useHTML
						)
						//.attr(attr)
						// without position absolute, IE export sometimes is wrong
						.css(merge(labelOptions.style))
						.add(axis.labelGroup) :
					null;
			tick.labelLength = label && label.getBBox().width; // Un-rotated length
			tick.rotation = 0; // Base value to detect change for new calls to getBBox

		// update
		} else if (label) {
			label.attr({ text: str });
		}
	},

	/**
	 * Get the offset height or width of the label
	 */
	getLabelSize: function () {
		return this.label ?
			this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
			0;
	},

	/**
	 * Handle the label overflow by adjusting the labels to the left and right edge, or
	 * hide them if they collide into the neighbour label.
	 */
	handleOverflow: function (xy) {
		var axis = this.axis,
			pxPos = xy.x,
			chartWidth = axis.chart.chartWidth,
			spacing = axis.chart.spacing,
			leftBound = pick(axis.labelLeft, spacing[3]),
			rightBound = pick(axis.labelRight, chartWidth - spacing[1]),
			label = this.label,
			rotation = this.rotation,
			factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
			labelWidth = label.getBBox().width,
			slotWidth = axis.slotWidth,
			leftPos,
			rightPos,
			textWidth;

		// Check if the label overshoots the chart spacing box. If it does, move it.
		// If it now overshoots the slotWidth, add ellipsis.
		if (!rotation) {
			leftPos = pxPos - factor * labelWidth;
			rightPos = pxPos + factor * labelWidth;

			if (leftPos < leftBound) {
				slotWidth -= leftBound - leftPos;
				xy.x = leftBound;
				label.attr({ align: 'left' });				
			} else if (rightPos > rightBound) {
				slotWidth -= rightPos - rightBound;
				xy.x = rightBound;
				label.attr({ align: 'right' });
			}

			if (labelWidth > slotWidth) {
				textWidth = slotWidth;
			}
		

		// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
		} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
			textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
		} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
			textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
		}

		if (textWidth) {
			label.css({
				width: textWidth,
				textOverflow: 'ellipsis'
			});
		}
	},

	/**
	 * Get the x and y position for ticks and labels
	 */
	getPosition: function (horiz, pos, tickmarkOffset, old) {
		var axis = this.axis,
			chart = axis.chart,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

		return {
			x: horiz ?
				axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
				axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

			y: horiz ?
				cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
				cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
		};

	},

	/**
	 * Get the x, y position of the tick label
	 */
	getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
		var axis = this.axis,
			transA = axis.transA,
			reversed = axis.reversed,
			staggerLines = axis.staggerLines,
			rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
			yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
			line;

		x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
			tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
		y = y + yOffset - (tickmarkOffset && !horiz ?
			tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

		// Correct for staggered labels
		if (staggerLines) {
			line = (index / (step || 1) % staggerLines);
			y += line * (axis.labelOffset / staggerLines);
		}

		return {
			x: x,
			y: mathRound(y)
		};
	},

	/**
	 * Extendible method to return the path of the marker
	 */
	getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
		return renderer.crispLine([
				M,
				x,
				y,
				L,
				x + (horiz ? 0 : -tickLength),
				y + (horiz ? tickLength : 0)
			], tickWidth);
	},

	/**
	 * Put everything in place
	 *
	 * @param index {Number}
	 * @param old {Boolean} Use old coordinates to prepare an animation into new position
	 */
	render: function (index, old, opacity) {
		var tick = this,
			axis = tick.axis,
			options = axis.options,
			chart = axis.chart,
			renderer = chart.renderer,
			horiz = axis.horiz,
			type = tick.type,
			label = tick.label,
			pos = tick.pos,
			labelOptions = options.labels,
			gridLine = tick.gridLine,
			gridPrefix = type ? type + 'Grid' : 'grid',
			tickPrefix = type ? type + 'Tick' : 'tick',
			gridLineWidth = options[gridPrefix + 'LineWidth'],
			gridLineColor = options[gridPrefix + 'LineColor'],
			dashStyle = options[gridPrefix + 'LineDashStyle'],
			tickLength = options[tickPrefix + 'Length'],
			tickWidth = options[tickPrefix + 'Width'] || 0,
			tickColor = options[tickPrefix + 'Color'],
			tickPosition = options[tickPrefix + 'Position'],
			gridLinePath,
			mark = tick.mark,
			markPath,
			step = /*axis.labelStep || */labelOptions.step,
			attribs,
			show = true,
			tickmarkOffset = axis.tickmarkOffset,
			xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
			x = xy.x,
			y = xy.y,
			reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

		opacity = pick(opacity, 1);
		this.isActive = true;

		// create the grid line
		if (gridLineWidth) {
			gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

			if (gridLine === UNDEFINED) {
				attribs = {
					stroke: gridLineColor,
					'stroke-width': gridLineWidth
				};
				if (dashStyle) {
					attribs.dashstyle = dashStyle;
				}
				if (!type) {
					attribs.zIndex = 1;
				}
				if (old) {
					attribs.opacity = 0;
				}
				tick.gridLine = gridLine =
					gridLineWidth ?
						renderer.path(gridLinePath)
							.attr(attribs).add(axis.gridGroup) :
						null;
			}

			// If the parameter 'old' is set, the current call will be followed
			// by another call, therefore do not do any animations this time
			if (!old && gridLine && gridLinePath) {
				gridLine[tick.isNew ? 'attr' : 'animate']({
					d: gridLinePath,
					opacity: opacity
				});
			}
		}

		// create the tick mark
		if (tickWidth && tickLength) {

			// negate the length
			if (tickPosition === 'inside') {
				tickLength = -tickLength;
			}
			if (axis.opposite) {
				tickLength = -tickLength;
			}

			markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
			if (mark) { // updating
				mark.animate({
					d: markPath,
					opacity: opacity
				});
			} else { // first time
				tick.mark = renderer.path(
					markPath
				).attr({
					stroke: tickColor,
					'stroke-width': tickWidth,
					opacity: opacity
				}).add(axis.axisGroup);
			}
		}

		// the label is created on init - now move it into place
		if (label && !isNaN(x)) {
			label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

			// Apply show first and show last. If the tick is both first and last, it is
			// a single centered tick, in which case we show the label anyway (#2100).
			if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
					(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
				show = false;

			// Handle label overflow and show or hide accordingly
			} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
				tick.handleOverflow(xy);
			}

			// apply step
			if (step && index % step) {
				// show those indices dividable by step
				show = false;
			}

			// Set the new position, and show or hide
			if (show && !isNaN(xy.y)) {
				xy.opacity = opacity;
				label[tick.isNew ? 'attr' : 'animate'](xy);
				tick.isNew = false;
			} else {
				label.attr('y', -9999); // #1338
			}
		}
	},

	/**
	 * Destructor for the tick prototype
	 */
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	}
};

/**
 * The object wrapper for plot lines and plot bands
 * @param {Object} options
 */
Highcharts.PlotLineOrBand = function (axis, options) {
	this.axis = axis;

	if (options) {
		this.options = options;
		this.id = options.id;
	}
};

Highcharts.PlotLineOrBand.prototype = {
	
	/**
	 * Render the plot line or plot band. If it is already existing,
	 * move it.
	 */
	render: function () {
		var plotLine = this,
			axis = plotLine.axis,
			horiz = axis.horiz,
			options = plotLine.options,
			optionsLabel = options.label,
			label = plotLine.label,
			width = options.width,
			to = options.to,
			from = options.from,
			isBand = defined(from) && defined(to),
			value = options.value,
			dashStyle = options.dashStyle,
			svgElem = plotLine.svgElem,
			path = [],
			addEvent,
			eventType,
			xs,
			ys,
			x,
			y,
			color = options.color,
			zIndex = options.zIndex,
			events = options.events,
			attribs = {},
			renderer = axis.chart.renderer;

		// logarithmic conversion
		if (axis.isLog) {
			from = log2lin(from);
			to = log2lin(to);
			value = log2lin(value);
		}

		// plot line
		if (width) {
			path = axis.getPlotLinePath(value, width);
			attribs = {
				stroke: color,
				'stroke-width': width
			};
			if (dashStyle) {
				attribs.dashstyle = dashStyle;
			}
		} else if (isBand) { // plot band

			path = axis.getPlotBandPath(from, to, options);
			if (color) {
				attribs.fill = color;
			}
			if (options.borderWidth) {
				attribs.stroke = options.borderColor;
				attribs['stroke-width'] = options.borderWidth;
			}
		} else {
			return;
		}
		// zIndex
		if (defined(zIndex)) {
			attribs.zIndex = zIndex;
		}

		// common for lines and bands
		if (svgElem) {
			if (path) {
				svgElem.animate({
					d: path
				}, null, svgElem.onGetPath);
			} else {
				svgElem.hide();
				svgElem.onGetPath = function () {
					svgElem.show();
				};
				if (label) {
					plotLine.label = label = label.destroy();
				}
			}
		} else if (path && path.length) {
			plotLine.svgElem = svgElem = renderer.path(path)
				.attr(attribs).add();

			// events
			if (events) {
				addEvent = function (eventType) {
					svgElem.on(eventType, function (e) {
						events[eventType].apply(plotLine, [e]);
					});
				};
				for (eventType in events) {
					addEvent(eventType);
				}
			}
		}

		// the plot band/line label
		if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
			// apply defaults
			optionsLabel = merge({
				align: horiz && isBand && 'center',
				x: horiz ? !isBand && 4 : 10,
				verticalAlign : !horiz && isBand && 'middle',
				y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
				rotation: horiz && !isBand && 90
			}, optionsLabel);

			// add the SVG element
			if (!label) {
				attribs = {
					align: optionsLabel.textAlign || optionsLabel.align,
					rotation: optionsLabel.rotation
				};
				if (defined(zIndex)) {
					attribs.zIndex = zIndex;
				}
				plotLine.label = label = renderer.text(
						optionsLabel.text,
						0,
						0,
						optionsLabel.useHTML
					)
					.attr(attribs)
					.css(optionsLabel.style)
					.add();
			}

			// get the bounding box and align the label
			// #3000 changed to better handle choice between plotband or plotline
			xs = [path[1], path[4], (isBand ? path[6] : path[1])];
			ys = [path[2], path[5], (isBand ? path[7] : path[2])];
			x = arrayMin(xs);
			y = arrayMin(ys);

			label.align(optionsLabel, false, {
				x: x,
				y: y,
				width: arrayMax(xs) - x,
				height: arrayMax(ys) - y
			});
			label.show();

		} else if (label) { // move out of sight
			label.hide();
		}

		// chainable
		return plotLine;
	},

	/**
	 * Remove the plot line or band
	 */
	destroy: function () {
		// remove it from the lookup
		erase(this.axis.plotLinesAndBands, this);
		
		delete this.axis;
		destroyObjectProperties(this);
	}
};

/**
 * Object with members for extending the Axis prototype
 */

AxisPlotLineOrBandExtension = {

	/**
	 * Create the path for a plot band
	 */ 
	getPlotBandPath: function (from, to) {
		var toPath = this.getPlotLinePath(to, null, null, true),
			path = this.getPlotLinePath(from, null, null, true);

		if (path && toPath && path.toString() !== toPath.toString()) { // #3836
			path.push(
				toPath[4],
				toPath[5],
				toPath[1],
				toPath[2]
			);
		} else { // outside the axis area
			path = null;
		}
		
		return path;
	},

	addPlotBand: function (options) {
		return this.addPlotBandOrLine(options, 'plotBands');
	},
	
	addPlotLine: function (options) {
		return this.addPlotBandOrLine(options, 'plotLines');
	},

	/**
	 * Add a plot band or plot line after render time
	 *
	 * @param options {Object} The plotBand or plotLine configuration object
	 */
	addPlotBandOrLine: function (options, coll) {
		var obj = new Highcharts.PlotLineOrBand(this, options).render(),
			userOptions = this.userOptions;

		if (obj) { // #2189
			// Add it to the user options for exporting and Axis.update
			if (coll) {
				userOptions[coll] = userOptions[coll] || [];
				userOptions[coll].push(options); 
			}
			this.plotLinesAndBands.push(obj); 
		}
		
		return obj;
	},

	/**
	 * Remove a plot band or plot line from the chart by id
	 * @param {Object} id
	 */
	removePlotBandOrLine: function (id) {
		var plotLinesAndBands = this.plotLinesAndBands,
			options = this.options,
			userOptions = this.userOptions,
			i = plotLinesAndBands.length;
		while (i--) {
			if (plotLinesAndBands[i].id === id) {
				plotLinesAndBands[i].destroy();
			}
		}
		each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
			i = arr.length;
			while (i--) {
				if (arr[i].id === id) {
					erase(arr, arr[i]);
				}
			}
		});
	}
};

/**
 * Create a new axis object
 * @param {Object} chart
 * @param {Object} options
 */
var Axis = Highcharts.Axis = function () {
	this.init.apply(this, arguments);
};

Axis.prototype = {

	/**
	 * Default options for the X axis - the Y axis has extended defaults
	 */
	defaultOptions: {
		// allowDecimals: null,
		// alternateGridColor: null,
		// categories: [],
		dateTimeLabelFormats: {
			millisecond: '%H:%M:%S.%L',
			second: '%H:%M:%S',
			minute: '%H:%M',
			hour: '%H:%M',
			day: '%e. %b',
			week: '%e. %b',
			month: '%b \'%y',
			year: '%Y'
		},
		endOnTick: false,
		gridLineColor: '#D8D8D8',
		// gridLineDashStyle: 'solid',
		// gridLineWidth: 0,
		// reversed: false,

		labels: {
			enabled: true,
			// rotation: 0,
			// align: 'center',
			// step: null,
			style: {
				color: '#606060',
				cursor: 'default',
				fontSize: '11px'
			},
			x: 0,
			y: 15
			/*formatter: function () {
				return this.value;
			},*/
		},
		lineColor: '#C0D0E0',
		lineWidth: 1,
		//linkedTo: null,
		//max: undefined,
		//min: undefined,
		minPadding: 0.01,
		maxPadding: 0.01,
		//minRange: null,
		minorGridLineColor: '#E0E0E0',
		// minorGridLineDashStyle: null,
		minorGridLineWidth: 1,
		minorTickColor: '#A0A0A0',
		//minorTickInterval: null,
		minorTickLength: 2,
		minorTickPosition: 'outside', // inside or outside
		//minorTickWidth: 0,
		//opposite: false,
		//offset: 0,
		//plotBands: [{
		//	events: {},
		//	zIndex: 1,
		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
		//}],
		//plotLines: [{
		//	events: {}
		//  dashStyle: {}
		//	zIndex:
		//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
		//}],
		//reversed: false,
		// showFirstLabel: true,
		// showLastLabel: true,
		startOfWeek: 1,
		startOnTick: false,
		tickColor: '#C0D0E0',
		//tickInterval: null,
		tickLength: 10,
		tickmarkPlacement: 'between', // on or between
		tickPixelInterval: 100,
		tickPosition: 'outside',
		tickWidth: 1,
		title: {
			//text: null,
			align: 'middle', // low, middle or high
			//margin: 0 for horizontal, 10 for vertical axes,
			//rotation: 0,
			//side: 'outside',
			style: {
				color: '#707070'
			}
			//x: 0,
			//y: 0
		},
		type: 'linear' // linear, logarithmic or datetime
	},

	/**
	 * This options set extends the defaultOptions for Y axes
	 */
	defaultYAxisOptions: {
		endOnTick: true,
		gridLineWidth: 1,
		tickPixelInterval: 72,
		showLastLabel: true,
		labels: {
			x: -8,
			y: 3
		},
		lineWidth: 0,
		maxPadding: 0.05,
		minPadding: 0.05,
		startOnTick: true,
		tickWidth: 0,
		title: {
			rotation: 270,
			text: 'Values'
		},
		stackLabels: {
			enabled: false,
			//align: dynamic,
			//y: dynamic,
			//x: dynamic,
			//verticalAlign: dynamic,
			//textAlign: dynamic,
			//rotation: 0,
			formatter: function () {
				return Highcharts.numberFormat(this.total, -1);
			},
			style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
		}
	},

	/**
	 * These options extend the defaultOptions for left axes
	 */
	defaultLeftAxisOptions: {
		labels: {
			x: -15,
			y: null
		},
		title: {
			rotation: 270
		}
	},

	/**
	 * These options extend the defaultOptions for right axes
	 */
	defaultRightAxisOptions: {
		labels: {
			x: 15,
			y: null
		},
		title: {
			rotation: 90
		}
	},

	/**
	 * These options extend the defaultOptions for bottom axes
	 */
	defaultBottomAxisOptions: {
		labels: {
			autoRotation: [-45],
			x: 0,
			y: null // based on font size
			// overflow: undefined,
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},
	/**
	 * These options extend the defaultOptions for top axes
	 */
	defaultTopAxisOptions: {
		labels: {
			autoRotation: [-45],
			x: 0,
			y: -15
			// overflow: undefined
			// staggerLines: null
		},
		title: {
			rotation: 0
		}
	},

	/**
	 * Initialize the axis
	 */
	init: function (chart, userOptions) {


		var isXAxis = userOptions.isX,
			axis = this;

		// Flag, is the axis horizontal
		axis.horiz = chart.inverted ? !isXAxis : isXAxis;

		// Flag, isXAxis
		axis.isXAxis = isXAxis;
		axis.coll = isXAxis ? 'xAxis' : 'yAxis';

		axis.opposite = userOptions.opposite; // needed in setOptions
		axis.side = userOptions.side || (axis.horiz ?
				(axis.opposite ? 0 : 2) : // top : bottom
				(axis.opposite ? 1 : 3));  // right : left

		axis.setOptions(userOptions);


		var options = this.options,
			type = options.type,
			isDatetimeAxis = type === 'datetime';

		axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


		// Flag, stagger lines or not
		axis.userOptions = userOptions;

		//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
		axis.minPixelPadding = 0;
		//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
		//axis.ignoreMaxPadding = UNDEFINED;

		axis.chart = chart;
		axis.reversed = options.reversed;
		axis.zoomEnabled = options.zoomEnabled !== false;

		// Initial categories
		axis.categories = options.categories || type === 'category';
		axis.names = axis.names || []; // Preserve on update (#3830)

		// Elements
		//axis.axisGroup = UNDEFINED;
		//axis.gridGroup = UNDEFINED;
		//axis.axisTitle = UNDEFINED;
		//axis.axisLine = UNDEFINED;

		// Shorthand types
		axis.isLog = type === 'logarithmic';
		axis.isDatetimeAxis = isDatetimeAxis;

		// Flag, if axis is linked to another axis
		axis.isLinked = defined(options.linkedTo);
		// Linked axis.
		//axis.linkedParent = UNDEFINED;

		// Tick positions
		//axis.tickPositions = UNDEFINED; // array containing predefined positions
		// Tick intervals
		//axis.tickInterval = UNDEFINED;
		//axis.minorTickInterval = UNDEFINED;

		
		// Major ticks
		axis.ticks = {};
		axis.labelEdge = [];
		// Minor ticks
		axis.minorTicks = {};

		// List of plotLines/Bands
		axis.plotLinesAndBands = [];

		// Alternate bands
		axis.alternateBands = {};

		// Axis metrics
		//axis.left = UNDEFINED;
		//axis.top = UNDEFINED;
		//axis.width = UNDEFINED;
		//axis.height = UNDEFINED;
		//axis.bottom = UNDEFINED;
		//axis.right = UNDEFINED;
		//axis.transA = UNDEFINED;
		//axis.transB = UNDEFINED;
		//axis.oldTransA = UNDEFINED;
		axis.len = 0;
		//axis.oldMin = UNDEFINED;
		//axis.oldMax = UNDEFINED;
		//axis.oldUserMin = UNDEFINED;
		//axis.oldUserMax = UNDEFINED;
		//axis.oldAxisLength = UNDEFINED;
		axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
		axis.range = options.range;
		axis.offset = options.offset || 0;


		// Dictionary for stacks
		axis.stacks = {};
		axis.oldStacks = {};
		
		// Min and max in the data
		//axis.dataMin = UNDEFINED,
		//axis.dataMax = UNDEFINED,

		// The axis range
		axis.max = null;
		axis.min = null;

		// User set min and max
		//axis.userMin = UNDEFINED,
		//axis.userMax = UNDEFINED,

		// Crosshair options
		axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
		// Run Axis

		var eventType,
			events = axis.options.events;

		// Register
		if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
			if (isXAxis && !this.isColorAxis) { // #2713
				chart.axes.splice(chart.xAxis.length, 0, axis);
			} else {
				chart.axes.push(axis);
			}

			chart[axis.coll].push(axis);
		}

		axis.series = axis.series || []; // populated by Series

		// inverted charts have reversed xAxes as default
		if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
			axis.reversed = true;
		}

		axis.removePlotBand = axis.removePlotBandOrLine;
		axis.removePlotLine = axis.removePlotBandOrLine;


		// register event listeners
		for (eventType in events) {
			addEvent(axis, eventType, events[eventType]);
		}

		// extend logarithmic axis
		if (axis.isLog) {
			axis.val2lin = log2lin;
			axis.lin2val = lin2log;
		}
	},

	/**
	 * Merge and set options
	 */
	setOptions: function (userOptions) {
		this.options = merge(
			this.defaultOptions,
			this.isXAxis ? {} : this.defaultYAxisOptions,
			[this.defaultTopAxisOptions, this.defaultRightAxisOptions,
				this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
			merge(
				defaultOptions[this.coll], // if set in setOptions (#1053)
				userOptions
			)
		);
	},

	/**
	 * The default label formatter. The context is a special config object for the label.
	 */
	defaultLabelFormatter: function () {
		var axis = this.axis,
			value = this.value,
			categories = axis.categories,
			dateTimeLabelFormat = this.dateTimeLabelFormat,
			numericSymbols = defaultOptions.lang.numericSymbols,
			i = numericSymbols && numericSymbols.length,
			multi,
			ret,
			formatOption = axis.options.labels.format,

			// make sure the same symbol is added for all labels on a linear axis
			numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

		if (formatOption) {
			ret = format(formatOption, this);

		} else if (categories) {
			ret = value;

		} else if (dateTimeLabelFormat) { // datetime axis
			ret = dateFormat(dateTimeLabelFormat, value);

		} else if (i && numericSymbolDetector >= 1000) {
			// Decide whether we should add a numeric symbol like k (thousands) or M (millions).
			// If we are to enable this in tooltip or other places as well, we can move this
			// logic to the numberFormatter and enable it by a parameter.
			while (i-- && ret === UNDEFINED) {
				multi = Math.pow(1000, i + 1);
				if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {
					ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
				}
			}
		}

		if (ret === UNDEFINED) {
			if (mathAbs(value) >= 10000) { // add thousands separators
				ret = Highcharts.numberFormat(value, 0);

			} else { // small numbers
				ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
			}
		}

		return ret;
	},

	/**
	 * Get the minimum and maximum for the series of each axis
	 */
	getSeriesExtremes: function () {
		var axis = this,
			chart = axis.chart;

		axis.hasVisibleSeries = false;

		// Reset properties in case we're redrawing (#3353)
		axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;
		
		if (axis.buildStacks) {
			axis.buildStacks();
		}

		// loop through this axis' series
		each(axis.series, function (series) {

			if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

				var seriesOptions = series.options,
					xData,
					threshold = seriesOptions.threshold,
					seriesDataMin,
					seriesDataMax;

				axis.hasVisibleSeries = true;

				// Validate threshold in logarithmic axes
				if (axis.isLog && threshold <= 0) {
					threshold = null;
				}

				// Get dataMin and dataMax for X axes
				if (axis.isXAxis) {
					xData = series.xData;
					if (xData.length) {
						axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
						axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
					}

				// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
				} else {

					// Get this particular series extremes
					series.getExtremes();
					seriesDataMax = series.dataMax;
					seriesDataMin = series.dataMin;

					// Get the dataMin and dataMax so far. If percentage is used, the min and max are
					// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
					// doesn't have active y data, we continue with nulls
					if (defined(seriesDataMin) && defined(seriesDataMax)) {
						axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
						axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
					}

					// Adjust to threshold
					if (defined(threshold)) {
						if (axis.dataMin >= threshold) {
							axis.dataMin = threshold;
							axis.ignoreMinPadding = true;
						} else if (axis.dataMax < threshold) {
							axis.dataMax = threshold;
							axis.ignoreMaxPadding = true;
						}
					}
				}
			}
		});
	},

	/**
	 * Translate from axis value to pixel position on the chart, or back
	 *
	 */
	translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
		var axis = this,
			sign = 1,
			cvsOffset = 0,
			localA = old ? axis.oldTransA : axis.transA,
			localMin = old ? axis.oldMin : axis.min,
			returnValue,
			minPixelPadding = axis.minPixelPadding,
			doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

		if (!localA) {
			localA = axis.transA;
		}

		// In vertical axes, the canvas coordinates start from 0 at the top like in
		// SVG.
		if (cvsCoord) {
			sign *= -1; // canvas coordinates inverts the value
			cvsOffset = axis.len;
		}

		// Handle reversed axis
		if (axis.reversed) {
			sign *= -1;
			cvsOffset -= sign * (axis.sector || axis.len);
		}

		// From pixels to value
		if (backwards) { // reverse translation

			val = val * sign + cvsOffset;
			val -= minPixelPadding;
			returnValue = val / localA + localMin; // from chart pixel to value
			if (doPostTranslate) { // log and ordinal axes
				returnValue = axis.lin2val(returnValue);
			}

		// From value to pixels
		} else {
			if (doPostTranslate) { // log and ordinal axes
				val = axis.val2lin(val);
			}
			if (pointPlacement === 'between') {
				pointPlacement = 0.5;
			}
			returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
				(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
		}

		return returnValue;
	},

	/**
	 * Utility method to translate an axis value to pixel position.
	 * @param {Number} value A value in terms of axis units
	 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
	 *        or just the axis/pane itself.
	 */
	toPixels: function (value, paneCoordinates) {
		return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
	},

	/*
	 * Utility method to translate a pixel position in to an axis value
	 * @param {Number} pixel The pixel value coordinate
	 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
	 *        axis/pane itself.
	 */
	toValue: function (pixel, paneCoordinates) {
		return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
	},

	/**
	 * Create the path for a plot line that goes from the given value on
	 * this axis, across the plot to the opposite side
	 * @param {Number} value
	 * @param {Number} lineWidth Used for calculation crisp line
	 * @param {Number] old Use old coordinates (for resizing and rescaling)
	 */
	getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
		var axis = this,
			chart = axis.chart,
			axisLeft = axis.left,
			axisTop = axis.top,
			x1,
			y1,
			x2,
			y2,
			cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
			cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
			skip,
			transB = axis.transB,
			/**
			 * Check if x is between a and b. If not, either move to a/b or skip, 
			 * depending on the force parameter.
			 */
			between = function (x, a, b) {
				if (x < a || x > b) {
					if (force) {
						x = mathMin(mathMax(a, x), b);
					} else {
						skip = true;
					}
				}
				return x;
			};

		translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
		x1 = x2 = mathRound(translatedValue + transB);
		y1 = y2 = mathRound(cHeight - translatedValue - transB);

		if (isNaN(translatedValue)) { // no min or max
			skip = true;

		} else if (axis.horiz) {
			y1 = axisTop;
			y2 = cHeight - axis.bottom;
			x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
		} else {
			x1 = axisLeft;
			x2 = cWidth - axis.right;
			y1 = y2 = between(y1, axisTop, axisTop + axis.height);
		}
		return skip && !force ?
			null :
			chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
	},

	/**
	 * Set the tick positions of a linear axis to round values like whole tens or every five.
	 */
	getLinearTickPositions: function (tickInterval, min, max) {
		var pos,
			lastPos,
			roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
			roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
			tickPositions = [];

		// For single points, add a tick regardless of the relative position (#2662)
		if (min === max && isNumber(min)) {
			return [min];
		}

		// Populate the intermediate values
		pos = roundedMin;
		while (pos <= roundedMax) {

			// Place the tick on the rounded value
			tickPositions.push(pos);

			// Always add the raw tickInterval, not the corrected one.
			pos = correctFloat(pos + tickInterval);

			// If the interval is not big enough in the current min - max range to actually increase
			// the loop variable, we need to break out to prevent endless loop. Issue #619
			if (pos === lastPos) {
				break;
			}

			// Record the last value
			lastPos = pos;
		}
		return tickPositions;
	},

	/**
	 * Return the minor tick positions. For logarithmic axes, reuse the same logic
	 * as for major ticks.
	 */
	getMinorTickPositions: function () {
		var axis = this,
			options = axis.options,
			tickPositions = axis.tickPositions,
			minorTickInterval = axis.minorTickInterval,
			minorTickPositions = [],
			pos,
			i,
			min = axis.min,
			max = axis.max,
			range = max - min,
			len;

		// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
		if (range && range / minorTickInterval < axis.len / 3) { // #3875

			if (axis.isLog) {
				len = tickPositions.length;
				for (i = 1; i < len; i++) {
					minorTickPositions = minorTickPositions.concat(
						axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
					);
				}
			} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
				minorTickPositions = minorTickPositions.concat(
					axis.getTimeTicks(
						axis.normalizeTimeTickInterval(minorTickInterval),
						min,
						max,
						options.startOfWeek
					)
				);
			} else {
				for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
					minorTickPositions.push(pos);
				}
			}
		}

		axis.trimTicks(minorTickPositions); // #3652 #3743
		return minorTickPositions;
	},

	/**
	 * Adjust the min and max for the minimum range. Keep in mind that the series data is
	 * not yet processed, so we don't have information on data cropping and grouping, or
	 * updated axis.pointRange or series.pointRange. The data can't be processed until
	 * we have finally established min and max.
	 */
	adjustForMinRange: function () {
		var axis = this,
			options = axis.options,
			min = axis.min,
			max = axis.max,
			zoomOffset,
			spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
			closestDataRange,
			i,
			distance,
			xData,
			loopLength,
			minArgs,
			maxArgs;

		// Set the automatic minimum range based on the closest point distance
		if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

			if (defined(options.min) || defined(options.max)) {
				axis.minRange = null; // don't do this again

			} else {

				// Find the closest distance between raw data points, as opposed to
				// closestPointRange that applies to processed points (cropped and grouped)
				each(axis.series, function (series) {
					xData = series.xData;
					loopLength = series.xIncrement ? 1 : xData.length - 1;
					for (i = loopLength; i > 0; i--) {
						distance = xData[i] - xData[i - 1];
						if (closestDataRange === UNDEFINED || distance < closestDataRange) {
							closestDataRange = distance;
						}
					}
				});
				axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
			}
		}

		// if minRange is exceeded, adjust
		if (max - min < axis.minRange) {
			var minRange = axis.minRange;
			zoomOffset = (minRange - max + min) / 2;

			// if min and max options have been set, don't go beyond it
			minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
			if (spaceAvailable) { // if space is available, stay within the data range
				minArgs[2] = axis.dataMin;
			}
			min = arrayMax(minArgs);

			maxArgs = [min + minRange, pick(options.max, min + minRange)];
			if (spaceAvailable) { // if space is availabe, stay within the data range
				maxArgs[2] = axis.dataMax;
			}

			max = arrayMin(maxArgs);

			// now if the max is adjusted, adjust the min back
			if (max - min < minRange) {
				minArgs[0] = max - minRange;
				minArgs[1] = pick(options.min, max - minRange);
				min = arrayMax(minArgs);
			}
		}

		// Record modified extremes
		axis.min = min;
		axis.max = max;
	},

	/**
	 * Update translation information
	 */
	setAxisTranslation: function (saveOld) {
		var axis = this,
			range = axis.max - axis.min,
			pointRange = axis.axisPointRange || 0,
			closestPointRange,
			minPointOffset = 0,
			pointRangePadding = 0,
			linkedParent = axis.linkedParent,
			ordinalCorrection,
			hasCategories = !!axis.categories,
			transA = axis.transA;

		// Adjust translation for padding. Y axis with categories need to go through the same (#1784).
		if (axis.isXAxis || hasCategories || pointRange) {
			if (linkedParent) {
				minPointOffset = linkedParent.minPointOffset;
				pointRangePadding = linkedParent.pointRangePadding;

			} else {
				each(axis.series, function (series) {
					var seriesPointRange = hasCategories ? 1 : (axis.isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
						pointPlacement = series.options.pointPlacement,
						seriesClosestPointRange = series.closestPointRange;

					if (seriesPointRange > range) { // #1446
						seriesPointRange = 0;
					}
					pointRange = mathMax(pointRange, seriesPointRange);

					if (!axis.single) {
						// minPointOffset is the value padding to the left of the axis in order to make
						// room for points with a pointRange, typically columns. When the pointPlacement option
						// is 'between' or 'on', this padding does not apply.
						minPointOffset = mathMax(
							minPointOffset,
							isString(pointPlacement) ? 0 : seriesPointRange / 2
						);

						// Determine the total padding needed to the length of the axis to make room for the
						// pointRange. If the series' pointPlacement is 'on', no padding is added.
						pointRangePadding = mathMax(
							pointRangePadding,
							pointPlacement === 'on' ? 0 : seriesPointRange
						);
					}

					// Set the closestPointRange
					if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
						closestPointRange = defined(closestPointRange) ?
							mathMin(closestPointRange, seriesClosestPointRange) :
							seriesClosestPointRange;
					}
				});
			}

			// Record minPointOffset and pointRangePadding
			ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
			axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
			axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

			// pointRange means the width reserved for each point, like in a column chart
			axis.pointRange = mathMin(pointRange, range);

			// closestPointRange means the closest distance between points. In columns
			// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
			// is some other value
			axis.closestPointRange = closestPointRange;
		}

		// Secondary values
		if (saveOld) {
			axis.oldTransA = transA;
		}
		axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
		axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
		axis.minPixelPadding = transA * minPointOffset;
	},

	/**
	 * Set the tick positions to round values and optionally extend the extremes
	 * to the nearest tick
	 */
	setTickInterval: function (secondPass) {
		var axis = this,
			chart = axis.chart,
			options = axis.options,
			isLog = axis.isLog,
			isDatetimeAxis = axis.isDatetimeAxis,
			isXAxis = axis.isXAxis,
			isLinked = axis.isLinked,
			maxPadding = options.maxPadding,
			minPadding = options.minPadding,
			length,
			linkedParentExtremes,
			tickIntervalOption = options.tickInterval,
			minTickInterval,
			tickPixelIntervalOption = options.tickPixelInterval,
			categories = axis.categories;

		if (!isDatetimeAxis && !categories && !isLinked) {
			this.getTickAmount();
		}

		// linked axis gets the extremes from the parent axis
		if (isLinked) {
			axis.linkedParent = chart[axis.coll][options.linkedTo];
			linkedParentExtremes = axis.linkedParent.getExtremes();
			axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
			axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
			if (options.type !== axis.linkedParent.options.type) {
				error(11, 1); // Can't link axes of different type
			}
		} else { // initial min and max from the extreme data values
			axis.min = pick(axis.userMin, options.min, axis.dataMin);
			axis.max = pick(axis.userMax, options.max, axis.dataMax);
		}

		if (isLog) {
			if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
				error(10, 1); // Can't plot negative values on log axis
			}
			axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
			axis.max = correctFloat(log2lin(axis.max));
		}

		// handle zoomed range
		if (axis.range && defined(axis.max)) {
			axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
			axis.userMax = axis.max;

			axis.range = null;  // don't use it when running setExtremes
		}

		// Hook for adjusting this.min and this.max. Used by bubble series.
		if (axis.beforePadding) {
			axis.beforePadding();
		}

		// adjust min and max for the minimum range
		axis.adjustForMinRange();

		// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
		// into account, we do this after computing tick interval (#1337).
		if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
			length = axis.max - axis.min;
			if (length) {
				if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
					axis.min -= length * minPadding;
				}
				if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
					axis.max += length * maxPadding;
				}
			}
		}

		// Stay within floor and ceiling
		if (isNumber(options.floor)) {
			axis.min = mathMax(axis.min, options.floor);
		}
		if (isNumber(options.ceiling)) {
			axis.max = mathMin(axis.max, options.ceiling);
		}

		// get tickInterval
		if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
			axis.tickInterval = 1;
		} else if (isLinked && !tickIntervalOption &&
				tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
			axis.tickInterval = axis.linkedParent.tickInterval;
		} else {
			axis.tickInterval = pick(
				tickIntervalOption,
				this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
				categories ? // for categoried axis, 1 is default, for linear axis use tickPix
					1 :
					// don't let it be more than the data range
					(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
			);
		}

		// Now we're finished detecting min and max, crop and group series data. This
		// is in turn needed in order to find tick positions in ordinal axes.
		if (isXAxis && !secondPass) {
			each(axis.series, function (series) {
				series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
			});
		}

		// set the translation factor used in translate function
		axis.setAxisTranslation(true);

		// hook for ordinal axes and radial axes
		if (axis.beforeSetTickPositions) {
			axis.beforeSetTickPositions();
		}

		// hook for extensions, used in Highstock ordinal axes
		if (axis.postProcessTickInterval) {
			axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
		}

		// In column-like charts, don't cramp in more ticks than there are points (#1943)
		if (axis.pointRange) {
			axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
		}

		// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
		minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
		if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
			axis.tickInterval = minTickInterval;
		}

		// for linear axes, get magnitude and normalize the interval
		if (!isDatetimeAxis && !isLog) { // linear
			if (!tickIntervalOption) {
				axis.tickInterval = normalizeTickInterval(
					axis.tickInterval, 
					null, 
					getMagnitude(axis.tickInterval), 
					// If the tick interval is between 0.5 and 5 and the axis max is in the order of
					// thousands, chances are we are dealing with years. Don't allow decimals. #3363.
					pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
					!!this.tickAmount
				);
			}
		}

		// Prevent ticks from getting so close that we can't draw the labels
		if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
			axis.tickInterval = axis.unsquish();
		}

		this.setTickPositions();
	},

	/**
	 * Now we have computed the normalized tickInterval, get the tick positions
	 */
	setTickPositions: function () {

		var options = this.options,
			tickPositions,
			tickPositionsOption = options.tickPositions,
			tickPositioner = options.tickPositioner,
			startOnTick = options.startOnTick,
			endOnTick = options.endOnTick,
			single;

		// Set the tickmarkOffset
		this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && 
			this.tickInterval === 1) ? 0.5 : 0; // #3202


		// get minorTickInterval
		this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
			this.tickInterval / 5 : options.minorTickInterval;

		// Find the tick positions
		this.tickPositions = tickPositions = options.tickPositions && options.tickPositions.slice(); // Work on a copy (#1565)
		if (!tickPositions) {

			if (this.isDatetimeAxis) {
				tickPositions = this.getTimeTicks(
					this.normalizeTimeTickInterval(this.tickInterval, options.units),
					this.min,
					this.max,
					options.startOfWeek,
					this.ordinalPositions,
					this.closestPointRange,
					true
				);
			} else if (this.isLog) {
				tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
			} else {
				tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
			}

			this.tickPositions = tickPositions;

			// Run the tick positioner callback, that allows modifying auto tick positions.
			if (tickPositioner) {
				tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
				if (tickPositioner) {
					this.tickPositions = tickPositions = tickPositioner;
				}
			}

		}

		if (!this.isLinked) {

			// reset min/max or remove extremes based on start/end on tick
			this.trimTicks(tickPositions, startOnTick, endOnTick);

			// When there is only one point, or all points have the same value on this axis, then min
			// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
			// in order to center the point, but leave it with one tick. #1337.
			if (this.min === this.max && defined(this.min) && !this.tickAmount) {
				// Substract half a unit (#2619, #2846, #2515, #3390)
				single = true;
				this.min -= 0.5;
				this.max += 0.5;
			}
			this.single = single;

			if (!tickPositionsOption && !tickPositioner) {
				this.adjustTickAmount();
			}
		}
	},

	/**
	 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
	 */
	trimTicks: function (tickPositions, startOnTick, endOnTick) {
		var roundedMin = tickPositions[0],
			roundedMax = tickPositions[tickPositions.length - 1],
			minPointOffset = this.minPointOffset || 0;
			
		if (startOnTick) {
			this.min = roundedMin;
		} else if (this.min - minPointOffset > roundedMin) {
			tickPositions.shift();
		}

		if (endOnTick) {
			this.max = roundedMax;
		} else if (this.max + minPointOffset < roundedMax) {
			tickPositions.pop();
		}

		// If no tick are left, set one tick in the middle (#3195) 
		if (tickPositions.length === 0 && defined(roundedMin)) {
			tickPositions.push((roundedMax + roundedMin) / 2);
		}		
	},

	/**
	 * Set the max ticks of either the x and y axis collection
	 */
	getTickAmount: function () {
		var others = {}, // Whether there is another axis to pair with this one
			hasOther,
			options = this.options,
			tickAmount = options.tickAmount,
			tickPixelInterval = options.tickPixelInterval;

		if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
				!this.isLog && options.startOnTick && options.endOnTick) {
			tickAmount = 2;
		}

		if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
			// Check if there are multiple axes in the same pane
			each(this.chart[this.coll], function (axis) {
				var options = axis.options,
					horiz = axis.horiz,
					key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');
				
				if (others[key]) {
					hasOther = true;
				} else {
					others[key] = 1;
				}
			});

			if (hasOther) {
				// Add 1 because 4 tick intervals require 5 ticks (including first and last)
				tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
			}
		}

		// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
		// prevents the axis from adding ticks that are too far away from the data extremes.
		if (tickAmount < 4) {
			this.finalTickAmt = tickAmount;
			tickAmount = 5;
		}
		
		this.tickAmount = tickAmount;
	},

	/**
	 * When using multiple axes, adjust the number of ticks to match the highest
	 * number of ticks in that group
	 */
	adjustTickAmount: function () {
		var tickInterval = this.tickInterval,
			tickPositions = this.tickPositions,
			tickAmount = this.tickAmount,
			finalTickAmt = this.finalTickAmt,
			currentTickAmount = tickPositions && tickPositions.length,
			i,
			len;

		if (currentTickAmount < tickAmount) { // TODO: Check #3411
			while (tickPositions.length < tickAmount) {
				tickPositions.push(correctFloat(
					tickPositions[tickPositions.length - 1] + tickInterval
				));
			}
			this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
			this.max = tickPositions[tickPositions.length - 1];

		// We have too many ticks, run second pass to try to reduce ticks
		} else if (currentTickAmount > tickAmount) {
			this.tickInterval *= 2;
			this.setTickPositions();
		}

		// The finalTickAmt property is set in getTickAmount
		if (defined(finalTickAmt)) {
			i = len = tickPositions.length;
			while (i--) {
				if (
					(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
					(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
				) {
					tickPositions.splice(i, 1);
				}	
			}
			this.finalTickAmt = UNDEFINED;
		}
	},

	/**
	 * Set the scale based on data min and max, user set min and max or options
	 *
	 */
	setScale: function () {
		var axis = this,
			stacks = axis.stacks,
			type,
			i,
			isDirtyData,
			isDirtyAxisLength;

		axis.oldMin = axis.min;
		axis.oldMax = axis.max;
		axis.oldAxisLength = axis.len;

		// set the new axisLength
		axis.setAxisSize();
		//axisLength = horiz ? axisWidth : axisHeight;
		isDirtyAxisLength = axis.len !== axis.oldAxisLength;

		// is there new data?
		each(axis.series, function (series) {
			if (series.isDirtyData || series.isDirty ||
					series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
				isDirtyData = true;
			}
		});

		// do we really need to go through all this?
		if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
			axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

			// reset stacks
			if (!axis.isXAxis) {
				for (type in stacks) {
					for (i in stacks[type]) {
						stacks[type][i].total = null;
						stacks[type][i].cum = 0;
					}
				}
			}

			axis.forceRedraw = false;

			// get data extremes if needed
			axis.getSeriesExtremes();

			// get fixed positions based on tickInterval
			axis.setTickInterval();

			// record old values to decide whether a rescale is necessary later on (#540)
			axis.oldUserMin = axis.userMin;
			axis.oldUserMax = axis.userMax;

			// Mark as dirty if it is not already set to dirty and extremes have changed. #595.
			if (!axis.isDirty) {
				axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
			}
		} else if (!axis.isXAxis) {
			if (axis.oldStacks) {
				stacks = axis.stacks = axis.oldStacks;
			}

			// reset stacks
			for (type in stacks) {
				for (i in stacks[type]) {
					stacks[type][i].cum = stacks[type][i].total;
				}
			}
		}
	},

	/**
	 * Set the extremes and optionally redraw
	 * @param {Number} newMin
	 * @param {Number} newMax
	 * @param {Boolean} redraw
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 * @param {Object} eventArguments
	 *
	 */
	setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
		var axis = this,
			chart = axis.chart;

		redraw = pick(redraw, true); // defaults to true

		each(axis.series, function (serie) {
			delete serie.kdTree;
		});

		// Extend the arguments with min and max
		eventArguments = extend(eventArguments, {
			min: newMin,
			max: newMax
		});

		// Fire the event
		fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

			axis.userMin = newMin;
			axis.userMax = newMax;
			axis.eventArgs = eventArguments;

			// Mark for running afterSetExtremes
			axis.isDirtyExtremes = true;

			// redraw
			if (redraw) {
				chart.redraw(animation);
			}
		});
	},

	/**
	 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
	 * in stock charts.
	 */
	zoom: function (newMin, newMax) {
		var dataMin = this.dataMin,
			dataMax = this.dataMax,
			options = this.options;

		// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
		if (!this.allowZoomOutside) {
			if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {
				newMin = UNDEFINED;
			}
			if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {
				newMax = UNDEFINED;
			}
		}

		// In full view, displaying the reset zoom button is not required
		this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

		// Do it
		this.setExtremes(
			newMin,
			newMax,
			false,
			UNDEFINED,
			{ trigger: 'zoom' }
		);
		return true;
	},

	/**
	 * Update the axis metrics
	 */
	setAxisSize: function () {
		var chart = this.chart,
			options = this.options,
			offsetLeft = options.offsetLeft || 0,
			offsetRight = options.offsetRight || 0,
			horiz = this.horiz,
			width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
			height = pick(options.height, chart.plotHeight),
			top = pick(options.top, chart.plotTop),
			left = pick(options.left, chart.plotLeft + offsetLeft),
			percentRegex = /%$/;

		// Check for percentage based input values
		if (percentRegex.test(height)) {
			height = parseFloat(height) / 100 * chart.plotHeight;
		}
		if (percentRegex.test(top)) {
			top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
		}

		// Expose basic values to use in Series object and navigator
		this.left = left;
		this.top = top;
		this.width = width;
		this.height = height;
		this.bottom = chart.chartHeight - height - top;
		this.right = chart.chartWidth - width - left;

		// Direction agnostic properties
		this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
		this.pos = horiz ? left : top; // distance from SVG origin
	},

	/**
	 * Get the actual axis extremes
	 */
	getExtremes: function () {
		var axis = this,
			isLog = axis.isLog;

		return {
			min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
			max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
			dataMin: axis.dataMin,
			dataMax: axis.dataMax,
			userMin: axis.userMin,
			userMax: axis.userMax
		};
	},

	/**
	 * Get the zero plane either based on zero or on the min or max value.
	 * Used in bar and area plots
	 */
	getThreshold: function (threshold) {
		var axis = this,
			isLog = axis.isLog;

		var realMin = isLog ? lin2log(axis.min) : axis.min,
			realMax = isLog ? lin2log(axis.max) : axis.max;

		if (realMin > threshold || threshold === null) {
			threshold = realMin;
		} else if (realMax < threshold) {
			threshold = realMax;
		}

		return axis.translate(threshold, 0, 1, 0, 1);
	},

	/**
	 * Compute auto alignment for the axis label based on which side the axis is on
	 * and the given rotation for the label
	 */
	autoLabelAlign: function (rotation) {
		var ret,
			angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

		if (angle > 15 && angle < 165) {
			ret = 'right';
		} else if (angle > 195 && angle < 345) {
			ret = 'left';
		} else {
			ret = 'center';
		}
		return ret;
	},

	/**
	 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
	 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
	 * On a vertical axis remove ticks and add ellipsis.
	 */
	unsquish: function () {
		var chart = this.chart,
			ticks = this.ticks,
			labelOptions = this.options.labels,
			horiz = this.horiz,
			tickInterval = this.tickInterval,
			newTickInterval = tickInterval,
			slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
			rotation,
			rotationOption = labelOptions.rotation,
			labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
			step,
			bestScore = Number.MAX_VALUE,
			autoRotation,
			// Return the multiple of tickInterval that is needed to avoid collision
			getStep = function (spaceNeeded) {
				var step = spaceNeeded / (slotSize || 1);
				step = step > 1 ? mathCeil(step) : 1;
				return step * tickInterval;
			};
		
		if (horiz) {
			autoRotation = defined(rotationOption) ? 
				[rotationOption] :
				slotSize < 80 && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;

			if (autoRotation) {

				// Loop over the given autoRotation options, and determine which gives the best score. The 
				// best score is that with the lowest number of steps and a rotation closest to horizontal.
				each(autoRotation, function (rot) {
					var score;

					if (rot && rot >= -90 && rot <= 90) {
					
						step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

						score = step + mathAbs(rot / 360);

						if (score < bestScore) {
							bestScore = score;
							rotation = rot;
							newTickInterval = step;
						}
					}
				});
			}

		} else {
			newTickInterval = getStep(labelMetrics.h);
		}

		this.autoRotation = autoRotation;
		this.labelRotation = rotation;

		return newTickInterval;
	},

	renderUnsquish: function () {
		var chart = this.chart,
			renderer = chart.renderer,
			tickPositions = this.tickPositions,
			ticks = this.ticks,
			labelOptions = this.options.labels,
			horiz = this.horiz,
			margin = chart.margin,
			slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
				((this.staggerLines || 1) * chart.plotWidth) / tickPositions.length) ||
				(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
			innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
			attr = {},
			labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
			css,
			labelLength = 0,
			label,
			i,
			pos;

		// Set rotation option unless it is "auto", like in gauges
		if (!isString(labelOptions.rotation)) {
			attr.rotation = labelOptions.rotation;
		}
		
		// Handle auto rotation on horizontal axis
		if (this.autoRotation) {

			// Get the longest label length
			each(tickPositions, function (tick) {
				tick = ticks[tick];
				if (tick && tick.labelLength > labelLength) {
					labelLength = tick.labelLength;
				}
			});
			
			// Apply rotation only if the label is too wide for the slot, and
			// the label is wider than its height.
			if (labelLength > innerWidth && labelLength > labelMetrics.h) {
				attr.rotation = this.labelRotation;
			} else {
				this.labelRotation = 0;
			}

		// Handle word-wrap or ellipsis on vertical axis
		} else if (slotWidth) {
			// For word-wrap or ellipsis
			css = { width: innerWidth + PX, textOverflow: 'clip' };

			// On vertical axis, only allow word wrap if there is room for more lines.
			i = tickPositions.length;
			while (!horiz && i--) {
				pos = tickPositions[i];
				label = ticks[pos].label;
				if (label) {
					if (this.len / tickPositions.length - 4 < label.getBBox().height) {
						label.specCss = { textOverflow: 'ellipsis' };
					}
				}
			}
		}


		// Add ellipsis if the label length is significantly longer than ideal
		if (attr.rotation) {
			css = { 
				width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX,
				textOverflow: 'ellipsis'
			};
		}

		// Set the explicit or automatic label alignment
		this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

		// Apply general and specific CSS
		each(tickPositions, function (pos) {
			var tick = ticks[pos],
				label = tick && tick.label;
			if (label) {
				if (css) {
					label.css(merge(css, label.specCss));
				}
				delete label.specCss;
				label.attr(attr);
				tick.rotation = attr.rotation;
			}
		});

		// TODO: Why not part of getLabelPosition?
		this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
	},

	/**
	 * Render the tick labels to a preliminary position to get their sizes
	 */
	getOffset: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			tickPositions = axis.tickPositions,
			ticks = axis.ticks,
			horiz = axis.horiz,
			side = axis.side,
			invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
			hasData,
			showAxis,
			titleOffset = 0,
			titleOffsetOption,
			titleMargin = 0,
			axisTitleOptions = options.title,
			labelOptions = options.labels,
			labelOffset = 0, // reset
			labelOffsetPadded,
			axisOffset = chart.axisOffset,
			clipOffset = chart.clipOffset,
			directionFactor = [-1, 1, 1, -1][side],
			n,
			lineHeightCorrection;

		// For reuse in Axis.render
		axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));
		axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

		// Set/reset staggerLines
		axis.staggerLines = axis.horiz && labelOptions.staggerLines;

		// Create the axisGroup and gridGroup elements on first iteration
		if (!axis.axisGroup) {
			axis.gridGroup = renderer.g('grid')
				.attr({ zIndex: options.gridZIndex || 1 })
				.add();
			axis.axisGroup = renderer.g('axis')
				.attr({ zIndex: options.zIndex || 2 })
				.add();
			axis.labelGroup = renderer.g('axis-labels')
				.attr({ zIndex: labelOptions.zIndex || 7 })
				.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
				.add();
		}

		if (hasData || axis.isLinked) {
			
			// Generate ticks
			each(tickPositions, function (pos) {
				if (!ticks[pos]) {
					ticks[pos] = new Tick(axis, pos);
				} else {
					ticks[pos].addLabel(); // update labels depending on tick interval
				}
			});

			axis.renderUnsquish();

			each(tickPositions, function (pos) {
				// left side must be align: right and right side must have align: left for labels
				if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

					// get the highest offset
					labelOffset = mathMax(
						ticks[pos].getLabelSize(),
						labelOffset
					);
				}
			});

			if (axis.staggerLines) {
				labelOffset *= axis.staggerLines;
				axis.labelOffset = labelOffset;
			}


		} else { // doesn't have data
			for (n in ticks) {
				ticks[n].destroy();
				delete ticks[n];
			}
		}

		if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
			if (!axis.axisTitle) {
				axis.axisTitle = renderer.text(
					axisTitleOptions.text,
					0,
					0,
					axisTitleOptions.useHTML
				)
				.attr({
					zIndex: 7,
					rotation: axisTitleOptions.rotation || 0,
					align:
						axisTitleOptions.textAlign ||
						{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
				})
				.addClass(PREFIX + this.coll.toLowerCase() + '-title')
				.css(axisTitleOptions.style)
				.add(axis.axisGroup);
				axis.axisTitle.isNew = true;
			}

			if (showAxis) {
				titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
				titleOffsetOption = axisTitleOptions.offset;
				titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
			}

			// hide or show the title depending on whether showEmpty is set
			axis.axisTitle[showAxis ? 'show' : 'hide']();
		}

		// handle automatic or user set offset
		axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

		axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
		lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
		labelOffsetPadded = labelOffset + titleMargin +
			(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
		axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

		axisOffset[side] = mathMax(
			axisOffset[side],
			axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
			labelOffsetPadded // #3027
		);
		clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);
	},

	/**
	 * Get the path for the axis line
	 */
	getLinePath: function (lineWidth) {
		var chart = this.chart,
			opposite = this.opposite,
			offset = this.offset,
			horiz = this.horiz,
			lineLeft = this.left + (opposite ? this.width : 0) + offset,
			lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

		if (opposite) {
			lineWidth *= -1; // crispify the other way - #1480, #1687
		}

		return chart.renderer.crispLine([
				M,
				horiz ?
					this.left :
					lineLeft,
				horiz ?
					lineTop :
					this.top,
				L,
				horiz ?
					chart.chartWidth - this.right :
					lineLeft,
				horiz ?
					lineTop :
					chart.chartHeight - this.bottom
			], lineWidth);
	},

	/**
	 * Position the title
	 */
	getTitlePosition: function () {
		// compute anchor points for each of the title align options
		var horiz = this.horiz,
			axisLeft = this.left,
			axisTop = this.top,
			axisLength = this.len,
			axisTitleOptions = this.options.title,
			margin = horiz ? axisLeft : axisTop,
			opposite = this.opposite,
			offset = this.offset,
			fontSize = pInt(axisTitleOptions.style.fontSize || 12),

			// the position in the length direction of the axis
			alongAxis = {
				low: margin + (horiz ? 0 : axisLength),
				middle: margin + axisLength / 2,
				high: margin + (horiz ? axisLength : 0)
			}[axisTitleOptions.align],

			// the position in the perpendicular direction of the axis
			offAxis = (horiz ? axisTop + this.height : axisLeft) +
				(horiz ? 1 : -1) * // horizontal axis reverses the margin
				(opposite ? -1 : 1) * // so does opposite axes
				this.axisTitleMargin +
				(this.side === 2 ? fontSize : 0);

		return {
			x: horiz ?
				alongAxis :
				offAxis + (opposite ? this.width : 0) + offset +
					(axisTitleOptions.x || 0), // x
			y: horiz ?
				offAxis - (opposite ? this.height : 0) + offset :
				alongAxis + (axisTitleOptions.y || 0) // y
		};
	},

	/**
	 * Render the axis
	 */
	render: function () {
		var axis = this,
			chart = axis.chart,
			renderer = chart.renderer,
			options = axis.options,
			isLog = axis.isLog,
			isLinked = axis.isLinked,
			tickPositions = axis.tickPositions,
			axisTitle = axis.axisTitle,			
			ticks = axis.ticks,
			minorTicks = axis.minorTicks,
			alternateBands = axis.alternateBands,
			stackLabelOptions = options.stackLabels,
			alternateGridColor = options.alternateGridColor,
			tickmarkOffset = axis.tickmarkOffset,
			lineWidth = options.lineWidth,
			linePath,
			hasRendered = chart.hasRendered,
			slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
			hasData = axis.hasData,
			showAxis = axis.showAxis,
			from,
			to;

		// Reset
		axis.labelEdge.length = 0;
		//axis.justifyToPlot = overflow === 'justify';
		axis.overlap = false;

		// Mark all elements inActive before we go over and mark the active ones
		each([ticks, minorTicks, alternateBands], function (coll) {
			var pos;
			for (pos in coll) {
				coll[pos].isActive = false;
			}
		});

		// If the series has data draw the ticks. Else only the line and title
		if (hasData || isLinked) {

			// minor ticks
			if (axis.minorTickInterval && !axis.categories) {
				each(axis.getMinorTickPositions(), function (pos) {
					if (!minorTicks[pos]) {
						minorTicks[pos] = new Tick(axis, pos, 'minor');
					}

					// render new ticks in old position
					if (slideInTicks && minorTicks[pos].isNew) {
						minorTicks[pos].render(null, true);
					}

					minorTicks[pos].render(null, false, 1);
				});
			}

			// Major ticks. Pull out the first item and render it last so that
			// we can get the position of the neighbour label. #808.
			if (tickPositions.length) { // #1300
				each(tickPositions, function (pos, i) {

					// linked axes need an extra check to find out if
					if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

						if (!ticks[pos]) {
							ticks[pos] = new Tick(axis, pos);
						}

						// render new ticks in old position
						if (slideInTicks && ticks[pos].isNew) {
							ticks[pos].render(i, true, 0.1);
						}

						ticks[pos].render(i);
					}

				});
				// In a categorized axis, the tick marks are displayed between labels. So
				// we need to add a tick mark and grid line at the left edge of the X axis.
				if (tickmarkOffset && (axis.min === 0 || axis.single)) {
					if (!ticks[-1]) {
						ticks[-1] = new Tick(axis, -1, null, true);
					}
					ticks[-1].render(-1);
				}

			}

			// alternate grid color
			if (alternateGridColor) {
				each(tickPositions, function (pos, i) {
					if (i % 2 === 0 && pos < axis.max) {
						if (!alternateBands[pos]) {
							alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
						}
						from = pos + tickmarkOffset; // #949
						to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
						alternateBands[pos].options = {
							from: isLog ? lin2log(from) : from,
							to: isLog ? lin2log(to) : to,
							color: alternateGridColor
						};
						alternateBands[pos].render();
						alternateBands[pos].isActive = true;
					}
				});
			}

			// custom plot lines and bands
			if (!axis._addedPlotLB) { // only first time
				each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
					axis.addPlotBandOrLine(plotLineOptions);
				});
				axis._addedPlotLB = true;
			}

		} // end if hasData

		// Remove inactive ticks
		each([ticks, minorTicks, alternateBands], function (coll) {
			var pos,
				i,
				forDestruction = [],
				delay = globalAnimation ? globalAnimation.duration || 500 : 0,
				destroyInactiveItems = function () {
					i = forDestruction.length;
					while (i--) {
						// When resizing rapidly, the same items may be destroyed in different timeouts,
						// or the may be reactivated
						if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
							coll[forDestruction[i]].destroy();
							delete coll[forDestruction[i]];
						}
					}

				};

			for (pos in coll) {

				if (!coll[pos].isActive) {
					// Render to zero opacity
					coll[pos].render(pos, false, 0);
					coll[pos].isActive = false;
					forDestruction.push(pos);
				}
			}

			// When the objects are finished fading out, destroy them
			if (coll === alternateBands || !chart.hasRendered || !delay) {
				destroyInactiveItems();
			} else if (delay) {
				setTimeout(destroyInactiveItems, delay);
			}
		});

		// Static items. As the axis group is cleared on subsequent calls
		// to render, these items are added outside the group.
		// axis line
		if (lineWidth) {
			linePath = axis.getLinePath(lineWidth);
			if (!axis.axisLine) {
				axis.axisLine = renderer.path(linePath)
					.attr({
						stroke: options.lineColor,
						'stroke-width': lineWidth,
						zIndex: 7
					})
					.add(axis.axisGroup);
			} else {
				axis.axisLine.animate({ d: linePath });
			}

			// show or hide the line depending on options.showEmpty
			axis.axisLine[showAxis ? 'show' : 'hide']();
		}

		if (axisTitle && showAxis) {

			axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
				axis.getTitlePosition()
			);
			axisTitle.isNew = false;
		}

		// Stacked totals:
		if (stackLabelOptions && stackLabelOptions.enabled) {
			axis.renderStackTotals();
		}
		// End stacked totals

		axis.isDirty = false;
	},

	/**
	 * Redraw the axis to reflect changes in the data or axis extremes
	 */
	redraw: function () {
		
		// render the axis
		this.render();

		// move plot lines and bands
		each(this.plotLinesAndBands, function (plotLine) {
			plotLine.render();
		});

		// mark associated series as dirty and ready for redraw
		each(this.series, function (series) {
			series.isDirty = true;
		});

	},

	/**
	 * Destroys an Axis instance.
	 */
	destroy: function (keepEvents) {
		var axis = this,
			stacks = axis.stacks,
			stackKey,
			plotLinesAndBands = axis.plotLinesAndBands,
			i;

		// Remove the events
		if (!keepEvents) {
			removeEvent(axis);
		}

		// Destroy each stack total
		for (stackKey in stacks) {
			destroyObjectProperties(stacks[stackKey]);

			stacks[stackKey] = null;
		}

		// Destroy collections
		each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
			destroyObjectProperties(coll);
		});
		i = plotLinesAndBands.length;
		while (i--) { // #1975
			plotLinesAndBands[i].destroy();
		}

		// Destroy local variables
		each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
			if (axis[prop]) {
				axis[prop] = axis[prop].destroy();
			}
		});

		// Destroy crosshair
		if (this.cross) {
			this.cross.destroy();
		}
	},

	/**
	 * Draw the crosshair
	 */
	drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

		var path,
			options = this.crosshair,
			animation = options.animation,
			pos,
			attribs,
			categorized;
		
		if (
			// Disabled in options
			!this.crosshair || 
			// Snap
			((defined(point) || !pick(this.crosshair.snap, true)) === false)
		) {
			this.hideCrosshair();
		
		} else {			

			// Get the path
			if (!pick(options.snap, true)) {
				pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
			} else if (defined(point)) {
				/*jslint eqeq: true*/
				pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
				/*jslint eqeq: false*/
			}

			if (this.isRadial) {
				path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
			} else {
				path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
			}

			if (path === null) {
				this.hideCrosshair();
				return;
			}

			// Draw the cross
			if (this.cross) {
				this.cross
					.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
			} else {
				categorized = this.categories && !this.isRadial;
				attribs = {
					'stroke-width': options.width || (categorized ? this.transA : 1),
					stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
					zIndex: options.zIndex || 2
				};
				if (options.dashStyle) {
					attribs.dashstyle = options.dashStyle;
				}
				this.cross = this.chart.renderer.path(path).attr(attribs).add();
			}

		}

	},

	/**
	 *	Hide the crosshair.
	 */
	hideCrosshair: function () {
		if (this.cross) {
			this.cross.hide();
		}
	}
}; // end Axis

extend(Axis.prototype, AxisPlotLineOrBandExtension);

/**
 * Set the tick positions to a time unit that makes sense, for example
 * on the first of each month or on every Monday. Return an array
 * with the time positions. Used in datetime axes as well as for grouping
 * data on a datetime axis.
 *
 * @param {Object} normalizedInterval The interval in axis values (ms) and the count
 * @param {Number} min The minimum in axis values
 * @param {Number} max The maximum in axis values
 * @param {Number} startOfWeek
 */
Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
	var tickPositions = [],
		i,
		higherRanks = {},
		useUTC = defaultOptions.global.useUTC,
		minYear, // used in months and years as a basis for Date.UTC()
		minDate = new Date(min - getTZOffset(min)),
		interval = normalizedInterval.unitRange,
		count = normalizedInterval.count;

	if (defined(min)) { // #1300
		minDate.setMilliseconds(interval >= timeUnits.second ? 0 :
			count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

		if (interval >= timeUnits.second) { // second
			minDate.setSeconds(interval >= timeUnits.minute ? 0 :
				count * mathFloor(minDate.getSeconds() / count));
		}
	
		if (interval >= timeUnits.minute) { // minute
			minDate[setMinutes](interval >= timeUnits.hour ? 0 :
				count * mathFloor(minDate[getMinutes]() / count));
		}
	
		if (interval >= timeUnits.hour) { // hour
			minDate[setHours](interval >= timeUnits.day ? 0 :
				count * mathFloor(minDate[getHours]() / count));
		}
	
		if (interval >= timeUnits.day) { // day
			minDate[setDate](interval >= timeUnits.month ? 1 :
				count * mathFloor(minDate[getDate]() / count));
		}
	
		if (interval >= timeUnits.month) { // month
			minDate[setMonth](interval >= timeUnits.year ? 0 :
				count * mathFloor(minDate[getMonth]() / count));
			minYear = minDate[getFullYear]();
		}
	
		if (interval >= timeUnits.year) { // year
			minYear -= minYear % count;
			minDate[setFullYear](minYear);
		}
	
		// week is a special case that runs outside the hierarchy
		if (interval === timeUnits.week) {
			// get start of current week, independent of count
			minDate[setDate](minDate[getDate]() - minDate[getDay]() +
				pick(startOfWeek, 1));
		}
	
	
		// get tick positions
		i = 1;
		if (timezoneOffset || getTimezoneOffset) {
			minDate = minDate.getTime();
			minDate = new Date(minDate + getTZOffset(minDate));
		}
		minYear = minDate[getFullYear]();
		var time = minDate.getTime(),
			minMonth = minDate[getMonth](),
			minDateDate = minDate[getDate](),
			localTimezoneOffset = (timeUnits.day + 
					(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
				) % timeUnits.day; // #950, #3359
	
		// iterate and add tick positions at appropriate values
		while (time < max) {
			tickPositions.push(time);
	
			// if the interval is years, use Date.UTC to increase years
			if (interval === timeUnits.year) {
				time = makeTime(minYear + i * count, 0);
	
			// if the interval is months, use Date.UTC to increase months
			} else if (interval === timeUnits.month) {
				time = makeTime(minYear, minMonth + i * count);
	
			// if we're using global time, the interval is not fixed as it jumps
			// one hour at the DST crossover
			} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
				time = makeTime(minYear, minMonth, minDateDate +
					i * count * (interval === timeUnits.day ? 1 : 7));
	
			// else, the interval is fixed and we use simple addition
			} else {
				time += interval * count;
			}
	
			i++;
		}
	
		// push the last time
		tickPositions.push(time);


		// mark new days if the time is dividible by day (#1649, #1760)
		each(grep(tickPositions, function (time) {
			return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
		}), function (time) {
			higherRanks[time] = 'day';
		});
	}


	// record information on the chosen unit - for dynamic label formatter
	tickPositions.info = extend(normalizedInterval, {
		higherRanks: higherRanks,
		totalRange: interval * count
	});

	return tickPositions;
};

/**
 * Get a normalized tick interval for dates. Returns a configuration object with
 * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
 * of segments in stock charts, the normalizing logic was extracted in order to 
 * prevent it for running over again for each segment having the same interval. 
 * #662, #697.
 */
Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
	var units = unitsOption || [[
				'millisecond', // unit name
				[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
			], [
				'second',
				[1, 2, 5, 10, 15, 30]
			], [
				'minute',
				[1, 2, 5, 10, 15, 30]
			], [
				'hour',
				[1, 2, 3, 4, 6, 8, 12]
			], [
				'day',
				[1, 2]
			], [
				'week',
				[1, 2]
			], [
				'month',
				[1, 2, 3, 4, 6]
			], [
				'year',
				null
			]],
		unit = units[units.length - 1], // default unit is years
		interval = timeUnits[unit[0]],
		multiples = unit[1],
		count,
		i;
		
	// loop through the units to find the one that best fits the tickInterval
	for (i = 0; i < units.length; i++) {
		unit = units[i];
		interval = timeUnits[unit[0]];
		multiples = unit[1];


		if (units[i + 1]) {
			// lessThan is in the middle between the highest multiple and the next unit.
			var lessThan = (interval * multiples[multiples.length - 1] +
						timeUnits[units[i + 1][0]]) / 2;

			// break and keep the current unit
			if (tickInterval <= lessThan) {
				break;
			}
		}
	}

	// prevent 2.5 years intervals, though 25, 250 etc. are allowed
	if (interval === timeUnits.year && tickInterval < 5 * interval) {
		multiples = [1, 2, 5];
	}

	// get the count
	count = normalizeTickInterval(
		tickInterval / interval, 
		multiples,
		unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
	);
	
	return {
		unitRange: interval,
		count: count,
		unitName: unit[0]
	};
};/**
 * Methods defined on the Axis prototype
 */

/**
 * Set the tick positions of a logarithmic axis
 */
Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
	var axis = this,
		options = axis.options,
		axisLength = axis.len,
		// Since we use this method for both major and minor ticks,
		// use a local variable and return the result
		positions = []; 
	
	// Reset
	if (!minor) {
		axis._minorAutoInterval = null;
	}
	
	// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
	if (interval >= 0.5) {
		interval = mathRound(interval);
		positions = axis.getLinearTickPositions(interval, min, max);
		
	// Second case: We need intermediary ticks. For example 
	// 1, 2, 4, 6, 8, 10, 20, 40 etc. 
	} else if (interval >= 0.08) {
		var roundedMin = mathFloor(min),
			intermediate,
			i,
			j,
			len,
			pos,
			lastPos,
			break2;
			
		if (interval > 0.3) {
			intermediate = [1, 2, 4];
		} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
			intermediate = [1, 2, 4, 6, 8];
		} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
			intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
		}
		
		for (i = roundedMin; i < max + 1 && !break2; i++) {
			len = intermediate.length;
			for (j = 0; j < len && !break2; j++) {
				pos = log2lin(lin2log(i) * intermediate[j]);
				if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
					positions.push(lastPos);
				}
				
				if (lastPos > max) {
					break2 = true;
				}
				lastPos = pos;
			}
		}
		
	// Third case: We are so deep in between whole logarithmic values that
	// we might as well handle the tick positions like a linear axis. For
	// example 1.01, 1.02, 1.03, 1.04.
	} else {
		var realMin = lin2log(min),
			realMax = lin2log(max),
			tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
			filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
			tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
			totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
		
		interval = pick(
			filteredTickIntervalOption,
			axis._minorAutoInterval,
			(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
		);
		
		interval = normalizeTickInterval(
			interval, 
			null, 
			getMagnitude(interval)
		);
		
		positions = map(axis.getLinearTickPositions(
			interval, 
			realMin,
			realMax	
		), log2lin);
		
		if (!minor) {
			axis._minorAutoInterval = interval / 5;
		}
	}
	
	// Set the axis-level tickInterval variable 
	if (!minor) {
		axis.tickInterval = interval;
	}
	return positions;
};/**
 * The tooltip object
 * @param {Object} chart The chart instance
 * @param {Object} options Tooltip options
 */
var Tooltip = Highcharts.Tooltip = function () {
	this.init.apply(this, arguments);
};

Tooltip.prototype = {

	init: function (chart, options) {

		var borderWidth = options.borderWidth,
			style = options.style,
			padding = pInt(style.padding);

		// Save the chart and options
		this.chart = chart;
		this.options = options;

		// Keep track of the current series
		//this.currentSeries = UNDEFINED;

		// List of crosshairs
		this.crosshairs = [];

		// Current values of x and y when animating
		this.now = { x: 0, y: 0 };

		// The tooltip is initially hidden
		this.isHidden = true;


		// create the label		
		this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
			.attr({
				padding: padding,
				fill: options.backgroundColor,
				'stroke-width': borderWidth,
				r: options.borderRadius,
				zIndex: 8
			})
			.css(style)
			.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
			.add()
			.attr({ y: -9999 }); // #2301, #2657

		// When using canVG the shadow shows up as a gray circle
		// even if the tooltip is hidden.
		if (!useCanVG) {
			this.label.shadow(options.shadow);
		}

		// Public property for getting the shared state.
		this.shared = options.shared;
	},

	/**
	 * Destroy the tooltip and its elements.
	 */
	destroy: function () {
		// Destroy and clear local variables
		if (this.label) {
			this.label = this.label.destroy();
		}
		clearTimeout(this.hideTimer);
		clearTimeout(this.tooltipTimeout);
	},

	/**
	 * Provide a soft movement for the tooltip
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @private
	 */
	move: function (x, y, anchorX, anchorY) {
		var tooltip = this,
			now = tooltip.now,
			animate = tooltip.options.animation !== false && !tooltip.isHidden && 
				// When we get close to the target position, abort animation and land on the right place (#3056)
				(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
			skipAnchor = tooltip.followPointer || tooltip.len > 1;

		// Get intermediate values for animation
		extend(now, {
			x: animate ? (2 * now.x + x) / 3 : x,
			y: animate ? (now.y + y) / 2 : y,
			anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
			anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
		});

		// Move to the intermediate value
		tooltip.label.attr(now);

		
		// Run on next tick of the mouse tracker
		if (animate) {
		
			// Never allow two timeouts
			clearTimeout(this.tooltipTimeout);
			
			// Set the fixed interval ticking for the smooth tooltip
			this.tooltipTimeout = setTimeout(function () {
				// The interval function may still be running during destroy, so check that the chart is really there before calling.
				if (tooltip) {
					tooltip.move(x, y, anchorX, anchorY);
				}
			}, 32);
			
		}
	},

	/**
	 * Hide the tooltip
	 */
	hide: function (delay) {
		var tooltip = this,
			hoverPoints;
		
		clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
		if (!this.isHidden) {
			hoverPoints = this.chart.hoverPoints;

			this.hideTimer = setTimeout(function () {
				tooltip.label.fadeOut();
				tooltip.isHidden = true;
			}, pick(delay, this.options.hideDelay, 500));

			// hide previous hoverPoints and set new
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			this.chart.hoverPoints = null;
			this.chart.hoverSeries = null;
		}
	},
	
	/** 
	 * Extendable method to get the anchor position of the tooltip
	 * from a point or set of points
	 */
	getAnchor: function (points, mouseEvent) {
		var ret,
			chart = this.chart,
			inverted = chart.inverted,
			plotTop = chart.plotTop,
			plotLeft = chart.plotLeft,
			plotX = 0,
			plotY = 0,
			yAxis,
			xAxis;
		
		points = splat(points);
		
		// Pie uses a special tooltipPos
		ret = points[0].tooltipPos;
		
		// When tooltip follows mouse, relate the position to the mouse
		if (this.followPointer && mouseEvent) {
			if (mouseEvent.chartX === UNDEFINED) {
				mouseEvent = chart.pointer.normalize(mouseEvent);
			}
			ret = [
				mouseEvent.chartX - chart.plotLeft,
				mouseEvent.chartY - plotTop
			];
		}
		// When shared, use the average position
		if (!ret) {
			each(points, function (point) {
				yAxis = point.series.yAxis;
				xAxis = point.series.xAxis;
				plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); 
				plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
					(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
			});
			
			plotX /= points.length;
			plotY /= points.length;
			
			ret = [
				inverted ? chart.plotWidth - plotY : plotX,
				this.shared && !inverted && points.length > 1 && mouseEvent ? 
					mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
					inverted ? chart.plotHeight - plotX : plotY
			];
		}

		return map(ret, mathRound);
	},
	
	/**
	 * Place the tooltip in a chart without spilling over
	 * and not covering the point it self.
	 */
	getPosition: function (boxWidth, boxHeight, point) {
		
		var chart = this.chart,
			distance = this.distance,
			ret = {},
			swapped,
			first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
			second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
			// The far side is right or bottom
			preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
			/**
			 * Handle the preferred dimension. When the preferred dimension is tooltip
			 * on top or bottom of the point, it will look for space there.
			 */
			firstDimension = function (dim, outerSize, innerSize, point) {
				var roomLeft = innerSize < point - distance,
					roomRight = point + distance + innerSize < outerSize,
					alignedLeft = point - distance - innerSize,
					alignedRight = point + distance;

				if (preferFarSide && roomRight) {
					ret[dim] = alignedRight;
				} else if (!preferFarSide && roomLeft) {
					ret[dim] = alignedLeft;
				} else if (roomLeft) {
					ret[dim] = alignedLeft;
				} else if (roomRight) {
					ret[dim] = alignedRight;
				} else {
					return false;
				}
			},
			/**
			 * Handle the secondary dimension. If the preferred dimension is tooltip
			 * on top or bottom of the point, the second dimension is to align the tooltip
			 * above the point, trying to align center but allowing left or right
			 * align within the chart box.
			 */
			secondDimension = function (dim, outerSize, innerSize, point) {
				// Too close to the edge, return false and swap dimensions
				if (point < distance || point > outerSize - distance) {
					return false;
				
				// Align left/top
				} else if (point < innerSize / 2) {
					ret[dim] = 1;
				// Align right/bottom
				} else if (point > outerSize - innerSize / 2) {
					ret[dim] = outerSize - innerSize - 2;
				// Align center
				} else {
					ret[dim] = point - innerSize / 2;
				}
			},
			/**
			 * Swap the dimensions 
			 */
			swap = function (count) {
				var temp = first;
				first = second;
				second = temp;
				swapped = count;
			},
			run = function () {
				if (firstDimension.apply(0, first) !== false) {
					if (secondDimension.apply(0, second) === false && !swapped) {
						swap(true);
						run();
					}
				} else if (!swapped) {
					swap(true);
					run();
				} else {
					ret.x = ret.y = 0;
				}
			};

		// Under these conditions, prefer the tooltip on the side of the point
		if (chart.inverted || this.len > 1) {
			swap();
		}
		run();

		return ret;
	
	},

	/**
	 * In case no user defined formatter is given, this will be used. Note that the context
	 * here is an object holding point, series, x, y etc.
	 */
	defaultFormatter: function (tooltip) {
		var items = this.points || splat(this),
			s;

		// build the header
		s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

		// build the values
		s = s.concat(tooltip.bodyFormatter(items));

		// footer
		s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

		return s.join('');
	},

	/**
	 * Refresh the tooltip's text and position.
	 * @param {Object} point
	 */
	refresh: function (point, mouseEvent) {
		var tooltip = this,
			chart = tooltip.chart,
			label = tooltip.label,
			options = tooltip.options,
			x,
			y,
			anchor,
			textConfig = {},
			text,
			pointConfig = [],
			formatter = options.formatter || tooltip.defaultFormatter,
			hoverPoints = chart.hoverPoints,
			borderColor,
			shared = tooltip.shared,
			currentSeries;
			
		clearTimeout(this.hideTimer);
		
		// get the reference point coordinates (pie charts use tooltipPos)
		tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
		anchor = tooltip.getAnchor(point, mouseEvent);
		x = anchor[0];
		y = anchor[1];

		// shared tooltip, array is sent over
		if (shared && !(point.series && point.series.noSharedTooltip)) {
			
			// hide previous hoverPoints and set new
			
			chart.hoverPoints = point;
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			each(point, function (item) {
				item.setState(HOVER_STATE);

				pointConfig.push(item.getLabelConfig());
			});

			textConfig = {
				x: point[0].category,
				y: point[0].y
			};
			textConfig.points = pointConfig;
			this.len = pointConfig.length;
			point = point[0];

		// single point tooltip
		} else {
			textConfig = point.getLabelConfig();
		}
		text = formatter.call(textConfig, tooltip);

		// register the current series
		currentSeries = point.series;
		this.distance = pick(currentSeries.tooltipOptions.distance, 16);

		// update the inner HTML
		if (text === false) {
			this.hide();
		} else {

			// show it
			if (tooltip.isHidden) {
				stop(label);
				label.attr('opacity', 1).show();
			}

			// update text
			label.attr({
				text: text
			});

			// set the stroke color of the box
			borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
			label.attr({
				stroke: borderColor
			});
			
			tooltip.updatePosition({ plotX: x, plotY: y, negative: point.negative, ttBelow: point.ttBelow });
		
			this.isHidden = false;
		}
		fireEvent(chart, 'tooltipRefresh', {
				text: text,
				x: x + chart.plotLeft,
				y: y + chart.plotTop,
				borderColor: borderColor
			});
	},
	
	/**
	 * Find the new position and perform the move
	 */
	updatePosition: function (point) {
		var chart = this.chart,
			label = this.label, 
			pos = (this.options.positioner || this.getPosition).call(
				this,
				label.width,
				label.height,
				point
			);

		// do the move
		this.move(
			mathRound(pos.x), 
			mathRound(pos.y), 
			point.plotX + chart.plotLeft, 
			point.plotY + chart.plotTop
		);
	},

	/** 
	 * Get the best X date format based on the closest point range on the axis.
	 */
	getXDateFormat: function (point, options, xAxis) {
		var xDateFormat,
			dateTimeLabelFormats = options.dateTimeLabelFormats,
			closestPointRange = xAxis && xAxis.closestPointRange,
			n,
			blank = '01-01 00:00:00.000',
			strpos = {
				millisecond: 15,
				second: 12,
				minute: 9,
				hour: 6,
				day: 3
			},
			date,
			lastN;

		if (closestPointRange) {
			date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
			for (n in timeUnits) {

				// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
				if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && 
						date.substr(6) === blank.substr(6)) {
					n = 'week';
					break;

				// The first format that is too great for the range
				} else if (timeUnits[n] > closestPointRange) {
					n = lastN;
					break;
				
				// If the point is placed every day at 23:59, we need to show
				// the minutes as well. #2637.
				} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
					break;
				}

				// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
				if (n !== 'week') {
					lastN = n;
				}
			}
			
			if (n) {
				xDateFormat = dateTimeLabelFormats[n];
			}
		} else {
			xDateFormat = dateTimeLabelFormats.day;
		}

		return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
	},

	/**
	 * Format the footer/header of the tooltip
	 * #3397: abstraction to enable formatting of footer and header
	 */
	tooltipFooterHeaderFormatter: function (point, isFooter) {
		var footOrHead = isFooter ? 'footer' : 'header',
			series = point.series,
			tooltipOptions = series.tooltipOptions,
			xDateFormat = tooltipOptions.xDateFormat,
			xAxis = series.xAxis,
			isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
			formatString = tooltipOptions[footOrHead+'Format'];

		// Guess the best date format based on the closest point distance (#568, #3418)
		if (isDateTime && !xDateFormat) {
			xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
		}

		// Insert the footer date format if any
		if (isDateTime && xDateFormat) {
			formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
		}

		return format(formatString, {
			point: point,
			series: series
		});
	},

	/**
     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
     * abstracting this functionality allows to easily overwrite and extend it. 
	 */
	bodyFormatter: function (items) {
        return map(items, function (item) {
            var tooltipOptions = item.series.tooltipOptions;
            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
        });
    }
    
};

var hoverChartIndex;

// Global flag for touch support
hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

/**
 * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
 * Subsequent methods should be named differently from what they are doing.
 * @param {Object} chart The Chart instance
 * @param {Object} options The root options object
 */
var Pointer = Highcharts.Pointer = function (chart, options) {
	this.init(chart, options);
};

Pointer.prototype = {
	/**
	 * Initialize Pointer
	 */
	init: function (chart, options) {
		
		var chartOptions = options.chart,
			chartEvents = chartOptions.events,
			zoomType = useCanVG ? '' : chartOptions.zoomType,
			inverted = chart.inverted,
			zoomX,
			zoomY;

		// Store references
		this.options = options;
		this.chart = chart;
		
		// Zoom status
		this.zoomX = zoomX = /x/.test(zoomType);
		this.zoomY = zoomY = /y/.test(zoomType);
		this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
		this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
		this.hasZoom = zoomX || zoomY;

		// Do we need to handle click on a touch device?
		this.runChartClick = chartEvents && !!chartEvents.click;

		this.pinchDown = [];
		this.lastValidTouch = {};

		if (Highcharts.Tooltip && options.tooltip.enabled) {
			chart.tooltip = new Tooltip(chart, options.tooltip);
			this.followTouchMove = pick(options.tooltip.followTouchMove, true);
		}

		this.setDOMEvents();
	}, 

	/**
	 * Add crossbrowser support for chartX and chartY
	 * @param {Object} e The event object in standard browsers
	 */
	normalize: function (e, chartPosition) {
		var chartX,
			chartY,
			ePos;

		// common IE normalizing
		e = e || window.event;

		// Framework specific normalizing (#1165)
		e = washMouseEvent(e);

		// More IE normalizing, needs to go after washMouseEvent
		if (!e.target) {
			e.target = e.srcElement;
		}
		
		// iOS (#2757)
		ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

		// Get mouse position
		if (!chartPosition) {
			this.chartPosition = chartPosition = offset(this.chart.container);
		}

		// chartX and chartY
		if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
			chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
				// for IE10 quirks mode within framesets
			chartY = e.y;
		} else {
			chartX = ePos.pageX - chartPosition.left;
			chartY = ePos.pageY - chartPosition.top;
		}

		return extend(e, {
			chartX: mathRound(chartX),
			chartY: mathRound(chartY)
		});
	},

	/**
	 * Get the click position in terms of axis values.
	 *
	 * @param {Object} e A pointer event
	 */
	getCoordinates: function (e) {
		var coordinates = {
				xAxis: [],
				yAxis: []
			};

		each(this.chart.axes, function (axis) {
			coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
				axis: axis,
				value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
			});
		});
		return coordinates;
	},
	
	/**
	 * With line type charts with a single tracker, get the point closest to the mouse.
	 * Run Point.onMouseOver and display tooltip for the point or points.
	 */
	runPointActions: function (e) {

		var pointer = this,
			chart = pointer.chart,
			series = chart.series,
			tooltip = chart.tooltip,
			shared = tooltip ? tooltip.shared : false,
			followPointer,
			//point,
			//points,
			hoverPoint = chart.hoverPoint,
			hoverSeries = chart.hoverSeries,
			i,
			trueXkd,
			trueX,
			//j,
			distance = chart.chartWidth,
			rdistance = chart.chartWidth,
			anchor,
			noSharedTooltip,
			kdpoints = [],
			kdpoint,
			kdpointT;

		// For hovering over the empty parts of the plot area (hoverSeries is undefined). 
		// If there is one series with point tracking (combo chart), don't go to nearest neighbour.
		if (!shared && !hoverSeries) {
			for (i = 0; i < series.length; i++) {
				if (series[i].directTouch || !series[i].options.stickyTracking) {
					series = [];
				}
			}
		}

		if (!(hoverSeries && hoverSeries.noSharedTooltip) && (shared || !hoverSeries)) { // #3821 
			// Find nearest points on all series
			each(series, function (s) {
				// Skip hidden series
				noSharedTooltip = s.noSharedTooltip && shared;
				if (s.visible && !noSharedTooltip && pick(s.options.enableMouseTracking, true)) { // #3821
					kdpointT = s.searchPoint(e); // #3828
					if (kdpointT) {
						kdpoints.push(kdpointT);
					}
				}
			});
			// Find absolute nearest point
			each(kdpoints, function (p) {
				if (p && defined(p.plotX) && defined(p.plotY)) {
					if ((p.dist.distX < distance) || ((p.dist.distX === distance || p.series.kdDimensions > 1) && p.dist.distR < rdistance)) {
						distance = p.dist.distX;
						rdistance = p.dist.distR;
						kdpoint = p;
					}
				}
				//point = kdpoints[0];
			});	
		} else {
			kdpoint = hoverSeries ? hoverSeries.searchPoint(e) : UNDEFINED;
		}

		// Refresh tooltip for kdpoint
		if (kdpoint && kdpoint !== hoverPoint) {
			// Draw tooltip if necessary
			if (shared && !kdpoint.series.noSharedTooltip) {
				i = kdpoints.length;
				trueXkd = kdpoint.clientX;
				while (i--) {
					trueX = kdpoints[i].clientX;
					if (kdpoints[i].x !== kdpoint.x || trueX !== trueXkd || !defined(kdpoints[i].y) || (kdpoints[i].series.noSharedTooltip || false)) {
						kdpoints.splice(i, 1);
					}
				}
				if (tooltip) {
					tooltip.refresh(kdpoints, e);
				}
				each(kdpoints, function (point) {
					point.onMouseOver(e);
				});
			} else {
				if (tooltip) {
					tooltip.refresh(kdpoint, e);
				}
				kdpoint.onMouseOver(e);
			}
		
		// Update positions (regardless of kdpoint or hoverPoint)
		} else {
			followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
			if (tooltip && followPointer && !tooltip.isHidden) {
				anchor = tooltip.getAnchor([{}], e);
				tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			
			}
		}

		// Start the event listener to pick up the tooltip 
		if (tooltip && !pointer._onDocumentMouseMove) {
			pointer._onDocumentMouseMove = function (e) {
				pointer.onDocumentMouseMove(e);
			};
			addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
		}
		
		// Crosshair
		each(chart.axes, function (axis) {
			axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
		});	
				
	},



	/**
	 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
	 * 
	 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
	 */
	reset: function (allowMove, delay) {
		var pointer = this,
			chart = pointer.chart,
			hoverSeries = chart.hoverSeries,
			hoverPoint = chart.hoverPoint,
			tooltip = chart.tooltip,
			tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;
			
		// Narrow in allowMove
		allowMove = allowMove && tooltip && tooltipPoints;
			
		// Check if the points have moved outside the plot area, #1003		
		if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {
			allowMove = false;
		}	
		// Just move the tooltip, #349
		if (allowMove) {
			tooltip.refresh(tooltipPoints);
			if (hoverPoint) { // #2500
				hoverPoint.setState(hoverPoint.state, true);
				each(chart.axes, function (axis) {
					if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
						axis.drawCrosshair(null, allowMove);
					}  else {
						axis.hideCrosshair();
					}
				});
				
			}

		// Full reset
		} else {

			if (hoverPoint) {
				hoverPoint.onMouseOut();
			}

			if (hoverSeries) {
				hoverSeries.onMouseOut();
			}

			if (tooltip) {
				tooltip.hide(delay);
			}

			if (pointer._onDocumentMouseMove) {
				removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
				pointer._onDocumentMouseMove = null;
			}

			// Remove crosshairs
			each(chart.axes, function (axis) {
				axis.hideCrosshair();
			});
			
			pointer.hoverX = null;

		}
	},

	/**
	 * Scale series groups to a certain scale and translation
	 */
	scaleGroups: function (attribs, clip) {

		var chart = this.chart,
			seriesAttribs;

		// Scale each series
		each(chart.series, function (series) {
			seriesAttribs = attribs || series.getPlotBox(); // #1701
			if (series.xAxis && series.xAxis.zoomEnabled) {
				series.group.attr(seriesAttribs);
				if (series.markerGroup) {
					series.markerGroup.attr(seriesAttribs);
					series.markerGroup.clip(clip ? chart.clipRect : null);
				}
				if (series.dataLabelsGroup) {
					series.dataLabelsGroup.attr(seriesAttribs);
				}
			}
		});
		
		// Clip
		chart.clipRect.attr(clip || chart.clipBox);
	},

	/**
	 * Start a drag operation
	 */
	dragStart: function (e) {
		var chart = this.chart;

		// Record the start position
		chart.mouseIsDown = e.type;
		chart.cancelClick = false;
		chart.mouseDownX = this.mouseDownX = e.chartX;
		chart.mouseDownY = this.mouseDownY = e.chartY;
	},

	/**
	 * Perform a drag operation in response to a mousemove event while the mouse is down
	 */
	drag: function (e) {

		var chart = this.chart,
			chartOptions = chart.options.chart,
			chartX = e.chartX,
			chartY = e.chartY,
			zoomHor = this.zoomHor,
			zoomVert = this.zoomVert,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			clickedInside,
			size,
			mouseDownX = this.mouseDownX,
			mouseDownY = this.mouseDownY,
			panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

		// If the mouse is outside the plot area, adjust to cooordinates
		// inside to prevent the selection marker from going outside
		if (chartX < plotLeft) {
			chartX = plotLeft;
		} else if (chartX > plotLeft + plotWidth) {
			chartX = plotLeft + plotWidth;
		}

		if (chartY < plotTop) {
			chartY = plotTop;
		} else if (chartY > plotTop + plotHeight) {
			chartY = plotTop + plotHeight;
		}
		
		// determine if the mouse has moved more than 10px
		this.hasDragged = Math.sqrt(
			Math.pow(mouseDownX - chartX, 2) +
			Math.pow(mouseDownY - chartY, 2)
		);
		
		if (this.hasDragged > 10) {
			clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

			// make a selection
			if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
				if (!this.selectionMarker) {
					this.selectionMarker = chart.renderer.rect(
						plotLeft,
						plotTop,
						zoomHor ? 1 : plotWidth,
						zoomVert ? 1 : plotHeight,
						0
					)
					.attr({
						fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
						zIndex: 7
					})
					.add();
				}
			}

			// adjust the width of the selection marker
			if (this.selectionMarker && zoomHor) {
				size = chartX - mouseDownX;
				this.selectionMarker.attr({
					width: mathAbs(size),
					x: (size > 0 ? 0 : size) + mouseDownX
				});
			}
			// adjust the height of the selection marker
			if (this.selectionMarker && zoomVert) {
				size = chartY - mouseDownY;
				this.selectionMarker.attr({
					height: mathAbs(size),
					y: (size > 0 ? 0 : size) + mouseDownY
				});
			}

			// panning
			if (clickedInside && !this.selectionMarker && chartOptions.panning) {
				chart.pan(e, chartOptions.panning);
			}
		}
	},

	/**
	 * On mouse up or touch end across the entire document, drop the selection.
	 */
	drop: function (e) {
		var pointer = this,
			chart = this.chart,
			hasPinched = this.hasPinched;

		if (this.selectionMarker) {
			var selectionData = {
					xAxis: [],
					yAxis: [],
					originalEvent: e.originalEvent || e
				},
				selectionBox = this.selectionMarker,
				selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
				selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
				selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
				selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
				runZoom;

			// a selection has been made
			if (this.hasDragged || hasPinched) {

				// record each axis' min and max
				each(chart.axes, function (axis) {
					if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
						var horiz = axis.horiz,
							minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075
							selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
							selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

						selectionData[axis.coll].push({
							axis: axis,
							min: mathMin(selectionMin, selectionMax), // for reversed axes
							max: mathMax(selectionMin, selectionMax)
						});
						runZoom = true;
					}
				});
				if (runZoom) {
					fireEvent(chart, 'selection', selectionData, function (args) { 
						chart.zoom(extend(args, hasPinched ? { animation: false } : null)); 
					});
				}

			}
			this.selectionMarker = this.selectionMarker.destroy();

			// Reset scaling preview
			if (hasPinched) {
				this.scaleGroups();
			}
		}

		// Reset all
		if (chart) { // it may be destroyed on mouse up - #877
			css(chart.container, { cursor: chart._cursor });
			chart.cancelClick = this.hasDragged > 10; // #370
			chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
			this.pinchDown = [];
		}
	},

	onContainerMouseDown: function (e) {

		e = this.normalize(e);

		// issue #295, dragging not always working in Firefox
		if (e.preventDefault) {
			e.preventDefault();
		}
		
		this.dragStart(e);
	},

	

	onDocumentMouseUp: function (e) {
		if (charts[hoverChartIndex]) {
			charts[hoverChartIndex].pointer.drop(e);
		}
	},

	/**
	 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
	 * Issue #149 workaround. The mouseleave event does not always fire. 
	 */
	onDocumentMouseMove: function (e) {
		var chart = this.chart,
			chartPosition = this.chartPosition;

		e = this.normalize(e, chartPosition);

		// If we're outside, hide the tooltip
		if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
				!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
			this.reset();
		}
	},

	/**
	 * When mouse leaves the container, hide the tooltip.
	 */
	onContainerMouseLeave: function () {
		var chart = charts[hoverChartIndex];
		if (chart) {
			chart.pointer.reset();
			chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
		}
	},

	// The mousemove, touchmove and touchstart event handler
	onContainerMouseMove: function (e) {

		var chart = this.chart;

		hoverChartIndex = chart.index;

		e = this.normalize(e);		
		e.returnValue = false; // #2251, #3224
		
		if (chart.mouseIsDown === 'mousedown') {
			this.drag(e);
		} 
		
		// Show the tooltip and run mouse over events (#977)
		if ((this.inClass(e.target, 'highcharts-tracker') || 
				chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
			this.runPointActions(e);
		}
	},

	/**
	 * Utility to detect whether an element has, or has a parent with, a specific
	 * class name. Used on detection of tracker objects and on deciding whether
	 * hovering the tooltip should cause the active series to mouse out.
	 */
	inClass: function (element, className) {
		var elemClassName;
		while (element) {
			elemClassName = attr(element, 'class');
			if (elemClassName) {
				if (elemClassName.indexOf(className) !== -1) {
					return true;
				} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
					return false;
				}
			}
			element = element.parentNode;
		}		
	},

	onTrackerMouseOut: function (e) {
		var series = this.chart.hoverSeries,
			relatedTarget = e.relatedTarget || e.toElement,
			relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499
		
		if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
				relatedSeries !== series) {
			series.onMouseOut();
		}
	},

	onContainerClick: function (e) {
		var chart = this.chart,
			hoverPoint = chart.hoverPoint, 
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop;
		
		e = this.normalize(e);
		e.cancelBubble = true; // IE specific

		if (!chart.cancelClick) {
			
			// On tracker click, fire the series and point events. #783, #1583
			if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

				// the series click event
				fireEvent(hoverPoint.series, 'click', extend(e, {
					point: hoverPoint
				}));

				// the point click event
				if (chart.hoverPoint) { // it may be destroyed (#1844)
					hoverPoint.firePointEvent('click', e);
				}

			// When clicking outside a tracker, fire a chart event
			} else {
				extend(e, this.getCoordinates(e));

				// fire a click event in the chart
				if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
					fireEvent(chart, 'click', e);
				}
			}


		}
	},

	/**
	 * Set the JS DOM events on the container and document. This method should contain
	 * a one-to-one assignment between methods and their handlers. Any advanced logic should
	 * be moved to the handler reflecting the event's name.
	 */
	setDOMEvents: function () {

		var pointer = this,
			container = pointer.chart.container;

		container.onmousedown = function (e) {
			pointer.onContainerMouseDown(e);
		};
		container.onmousemove = function (e) {
			pointer.onContainerMouseMove(e);
		};
		container.onclick = function (e) {
			pointer.onContainerClick(e);
		};
		addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
		if (chartCount === 1) {
			addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
		}
		if (hasTouch) {
			container.ontouchstart = function (e) {
				pointer.onContainerTouchStart(e);
			};
			container.ontouchmove = function (e) {
				pointer.onContainerTouchMove(e);
			};
			if (chartCount === 1) {
				addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
			}
		}
		
	},

	/**
	 * Destroys the Pointer object and disconnects DOM events.
	 */
	destroy: function () {
		var prop;

		removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
		if (!chartCount) {
			removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
			removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
		}

		// memory and CPU leak
		clearInterval(this.tooltipTimeout);

		for (prop in this) {
			this[prop] = null;
		}
	}
};


/* Support for touch devices */
extend(Highcharts.Pointer.prototype, {

	/**
	 * Run translation operations
	 */
	pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
		if (this.zoomHor || this.pinchHor) {
			this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
		}
		if (this.zoomVert || this.pinchVert) {
			this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
		}
	},

	/**
	 * Run translation operations for each direction (horizontal and vertical) independently
	 */
	pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
		var chart = this.chart,
			xy = horiz ? 'x' : 'y',
			XY = horiz ? 'X' : 'Y',
			sChartXY = 'chart' + XY,
			wh = horiz ? 'width' : 'height',
			plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
			selectionWH,
			selectionXY,
			clipXY,
			scale = forcedScale || 1,
			inverted = chart.inverted,
			bounds = chart.bounds[horiz ? 'h' : 'v'],
			singleTouch = pinchDown.length === 1,
			touch0Start = pinchDown[0][sChartXY],
			touch0Now = touches[0][sChartXY],
			touch1Start = !singleTouch && pinchDown[1][sChartXY],
			touch1Now = !singleTouch && touches[1][sChartXY],
			outOfBounds,
			transformScale,
			scaleKey,
			setScale = function () {
				if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
					scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); 
				}
				
				clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
				selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
			};

		// Set the scale, first pass
		setScale();

		selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

		// Out of bounds
		if (selectionXY < bounds.min) {
			selectionXY = bounds.min;
			outOfBounds = true;
		} else if (selectionXY + selectionWH > bounds.max) {
			selectionXY = bounds.max - selectionWH;
			outOfBounds = true;
		}
		
		// Is the chart dragged off its bounds, determined by dataMin and dataMax?
		if (outOfBounds) {

			// Modify the touchNow position in order to create an elastic drag movement. This indicates
			// to the user that the chart is responsive but can't be dragged further.
			touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
			if (!singleTouch) {
				touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
			}

			// Set the scale, second pass to adapt to the modified touchNow positions
			setScale();

		} else {
			lastValidTouch[xy] = [touch0Now, touch1Now];
		}

		// Set geometry for clipping, selection and transformation
		if (!inverted) { // TODO: implement clipping for inverted charts
			clip[xy] = clipXY - plotLeftTop;
			clip[wh] = selectionWH;
		}
		scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
		transformScale = inverted ? 1 / scale : scale;

		selectionMarker[wh] = selectionWH;
		selectionMarker[xy] = selectionXY;
		transform[scaleKey] = scale;
		transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
	},
	
	/**
	 * Handle touch events with two touches
	 */
	pinch: function (e) {

		var self = this,
			chart = self.chart,
			pinchDown = self.pinchDown,
			touches = e.touches,
			touchesLength = touches.length,
			lastValidTouch = self.lastValidTouch,
			hasZoom = self.hasZoom,
			selectionMarker = self.selectionMarker,
			transform = {},
			fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && 
				chart.runTrackerClick) || self.runChartClick),
			clip = {};

		// On touch devices, only proceed to trigger click if a handler is defined
		if (hasZoom && !fireClickEvent) {
			e.preventDefault();
		}
		
		// Normalize each touch
		map(touches, function (e) {
			return self.normalize(e);
		});
		
		// Register the touch start position
		if (e.type === 'touchstart') {
			each(touches, function (e, i) {
				pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
			});
			lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
			lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

			// Identify the data bounds in pixels
			each(chart.axes, function (axis) {
				if (axis.zoomEnabled) {
					var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
						minPixelPadding = axis.minPixelPadding,
						min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
						max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
						absMin = mathMin(min, max),
						absMax = mathMax(min, max);

					// Store the bounds for use in the touchmove handler
					bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
					bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
				}
			});
			self.res = true; // reset on next move
		
		// Event type is touchmove, handle panning and pinching
		} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
			

			// Set the marker
			if (!selectionMarker) {
				self.selectionMarker = selectionMarker = extend({
					destroy: noop
				}, chart.plotBox);
			}
			
			self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

			self.hasPinched = hasZoom;

			// Scale and translate the groups to provide visual feedback during pinching
			self.scaleGroups(transform, clip);
			
			// Optionally move the tooltip on touchmove
			if (!hasZoom && self.followTouchMove && touchesLength === 1) {
				this.runPointActions(self.normalize(e));
			} else if (self.res) {
				self.res = false;
				this.reset(false, 0);
			}
		}
	},

	onContainerTouchStart: function (e) {
		var chart = this.chart;

		hoverChartIndex = chart.index;

		if (e.touches.length === 1) {

			e = this.normalize(e);

			if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

				// Run mouse events and display tooltip etc
				this.runPointActions(e);

				this.pinch(e);

			} else {
				// Hide the tooltip on touching outside the plot area (#1203)
				this.reset();
			}

		} else if (e.touches.length === 2) {
			this.pinch(e);
		}   
	},

	onContainerTouchMove: function (e) {
		if (e.touches.length === 1 || e.touches.length === 2) {
			this.pinch(e);
		}
	},

	onDocumentTouchEnd: function (e) {
		if (charts[hoverChartIndex]) {
			charts[hoverChartIndex].pointer.drop(e);
		}
	}

});
if (win.PointerEvent || win.MSPointerEvent) {
	
	// The touches object keeps track of the points being touched at all times
	var touches = {},
		hasPointerEvent = !!win.PointerEvent,
		getWebkitTouches = function () {
			var key, fake = [];
			fake.item = function (i) { return this[i]; };
			for (key in touches) {
				if (touches.hasOwnProperty(key)) {
					fake.push({
						pageX: touches[key].pageX,
						pageY: touches[key].pageY,
						target: touches[key].target
					});
				}
			}
			return fake;
		},
		translateMSPointer = function (e, method, wktype, callback) {
			var p;
			e = e.originalEvent || e;
			if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
				callback(e);
				p = charts[hoverChartIndex].pointer;
				p[method]({
					type: wktype,
					target: e.currentTarget,
					preventDefault: noop,
					touches: getWebkitTouches()
				});				
			}
		};

	/**
	 * Extend the Pointer prototype with methods for each event handler and more
	 */
	extend(Pointer.prototype, {
		onContainerPointerDown: function (e) {
			translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
				touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
			});
		},
		onContainerPointerMove: function (e) {
			translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
				touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
				if (!touches[e.pointerId].target) {
					touches[e.pointerId].target = e.currentTarget;
				}
			});
		},
		onDocumentPointerUp: function (e) {
			translateMSPointer(e, 'onContainerTouchEnd', 'touchend', function (e) {
				delete touches[e.pointerId];
			});
		},

		/**
		 * Add or remove the MS Pointer specific events
		 */
		batchMSEvents: function (fn) {
			fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
			fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
			fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
		}
	});

	// Disable default IE actions for pinch and such on chart element
	wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
		proceed.call(this, chart, options);
		if (this.hasZoom || this.followTouchMove) {
			css(chart.container, {
				'-ms-touch-action': NONE,
				'touch-action': NONE
			});
		}
	});

	// Add IE specific touch events to chart
	wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
		proceed.apply(this);
		if (this.hasZoom || this.followTouchMove) {
			this.batchMSEvents(addEvent);
		}
	});
	// Destroy MS events also
	wrap(Pointer.prototype, 'destroy', function (proceed) {
		this.batchMSEvents(removeEvent);
		proceed.call(this);
	});
}
/**
 * The overview of the chart's series
 */
var Legend = Highcharts.Legend = function (chart, options) {
	this.init(chart, options);
};

Legend.prototype = {
	
	/**
	 * Initialize the legend
	 */
	init: function (chart, options) {
		
		var legend = this,
			itemStyle = options.itemStyle,
			padding,
			itemMarginTop = options.itemMarginTop || 0;
	
		this.options = options;

		if (!options.enabled) {
			return;
		}
	
		legend.itemStyle = itemStyle;
		legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
		legend.itemMarginTop = itemMarginTop;
		legend.padding = padding = pick(options.padding, 8);
		legend.initialItemX = padding;
		legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
		legend.maxItemWidth = 0;
		legend.chart = chart;
		legend.itemHeight = 0;
		legend.symbolWidth = pick(options.symbolWidth, 16);
		legend.pages = [];


		// Render it
		legend.render();

		// move checkboxes
		addEvent(legend.chart, 'endResize', function () { 
			legend.positionCheckboxes();
		});

	},

	/**
	 * Set the colors for the legend item
	 * @param {Object} item A Series or Point instance
	 * @param {Object} visible Dimmed or colored
	 */
	colorizeItem: function (item, visible) {
		var legend = this,
			options = legend.options,
			legendItem = item.legendItem,
			legendLine = item.legendLine,
			legendSymbol = item.legendSymbol,
			hiddenColor = legend.itemHiddenStyle.color,
			textColor = visible ? options.itemStyle.color : hiddenColor,
			symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
			markerOptions = item.options && item.options.marker,
			symbolAttr = { fill: symbolColor },
			key,
			val;
		
		if (legendItem) {
			legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
		}
		if (legendLine) {
			legendLine.attr({ stroke: symbolColor });
		}
		
		if (legendSymbol) {
			
			// Apply marker options
			if (markerOptions && legendSymbol.isMarker) { // #585
				symbolAttr.stroke = symbolColor;
				markerOptions = item.convertAttribs(markerOptions);
				for (key in markerOptions) {
					val = markerOptions[key];
					if (val !== UNDEFINED) {
						symbolAttr[key] = val;
					}
				}
			}

			legendSymbol.attr(symbolAttr);
		}
	},

	/**
	 * Position the legend item
	 * @param {Object} item A Series or Point instance
	 */
	positionItem: function (item) {
		var legend = this,
			options = legend.options,
			symbolPadding = options.symbolPadding,
			ltr = !options.rtl,
			legendItemPos = item._legendItemPos,
			itemX = legendItemPos[0],
			itemY = legendItemPos[1],
			checkbox = item.checkbox;

		if (item.legendGroup) {
			item.legendGroup.translate(
				ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
				itemY
			);
		}

		if (checkbox) {
			checkbox.x = itemX;
			checkbox.y = itemY;
		}
	},

	/**
	 * Destroy a single legend item
	 * @param {Object} item The series or point
	 */
	destroyItem: function (item) {
		var checkbox = item.checkbox;

		// destroy SVG elements
		each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
			if (item[key]) {
				item[key] = item[key].destroy();
			}
		});

		if (checkbox) {
			discardElement(item.checkbox);
		}
	},

	/**
	 * Destroy all items.
	 */
	clearItems: function () {
		var legend = this;
		each(legend.getAllItems(), function (item) {
			legend.destroyItem(item); 
		});		
	},

	/**
	 * Destroys the legend.
	 */
	destroy: function () {
		var legend = this,
			legendGroup = legend.group,
			box = legend.box;

		if (box) {
			legend.box = box.destroy();
		}

		if (legendGroup) {
			legend.group = legendGroup.destroy();
		}
	},

	/**
	 * Position the checkboxes after the width is determined
	 */
	positionCheckboxes: function (scrollOffset) {
		var alignAttr = this.group.alignAttr,
			translateY,
			clipHeight = this.clipHeight || this.legendHeight;

		if (alignAttr) {
			translateY = alignAttr.translateY;
			each(this.allItems, function (item) {
				var checkbox = item.checkbox,
					top;
				
				if (checkbox) {
					top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
					css(checkbox, {
						left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
						top: top + PX,
						display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
					});
				}
			});
		}
	},
	
	/**
	 * Render the legend title on top of the legend
	 */
	renderTitle: function () {
		var options = this.options,
			padding = this.padding,
			titleOptions = options.title,
			titleHeight = 0,
			bBox;
		
		if (titleOptions.text) {
			if (!this.title) {
				this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
					.attr({ zIndex: 1 })
					.css(titleOptions.style)
					.add(this.group);
			}
			bBox = this.title.getBBox();
			titleHeight = bBox.height;
			this.offsetWidth = bBox.width; // #1717
			this.contentGroup.attr({ translateY: titleHeight });
		}
		this.titleHeight = titleHeight;
	},

	/**
	 * Render a single specific legend item
	 * @param {Object} item A series or point
	 */
	renderItem: function (item) {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			options = legend.options,
			horizontal = options.layout === 'horizontal',
			symbolWidth = legend.symbolWidth,
			symbolPadding = options.symbolPadding,
			itemStyle = legend.itemStyle,
			itemHiddenStyle = legend.itemHiddenStyle,
			padding = legend.padding,
			itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
			ltr = !options.rtl,
			itemHeight,
			widthOption = options.width,
			itemMarginBottom = options.itemMarginBottom || 0,
			itemMarginTop = legend.itemMarginTop,
			initialItemX = legend.initialItemX,
			bBox,
			itemWidth,
			li = item.legendItem,
			series = item.series && item.series.drawLegendSymbol ? item.series : item,
			seriesOptions = series.options,
			showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
			useHTML = options.useHTML;

		if (!li) { // generate it once, later move it

			// Generate the group box
			// A group to hold the symbol and text. Text is to be appended in Legend class.
			item.legendGroup = renderer.g('legend-item')
				.attr({ zIndex: 1 })
				.add(legend.scrollGroup);

			// Generate the list item text and add it to the group
			item.legendItem = li = renderer.text(
					options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),
					ltr ? symbolWidth + symbolPadding : -symbolPadding,
					legend.baseline || 0,
					useHTML
				)
				.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
				.attr({
					align: ltr ? 'left' : 'right',
					zIndex: 2
				})
				.add(item.legendGroup);

			// Get the baseline for the first item - the font size is equal for all
			if (!legend.baseline) {
				legend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;
				li.attr('y', legend.baseline);
			}

			// Draw the legend symbol inside the group box
			series.drawLegendSymbol(legend, item);

			if (legend.setItemEvents) {
				legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
			}			

			// Colorize the items
			legend.colorizeItem(item, item.visible);

			// add the HTML checkbox on top
			if (showCheckbox) {
				legend.createCheckboxForItem(item);				
			}
		}

		// calculate the positions for the next line
		bBox = li.getBBox();

		itemWidth = item.checkboxOffset = 
			options.itemWidth || 
			item.legendItemWidth || 
			symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
		legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

		// if the item exceeds the width, start a new line
		if (horizontal && legend.itemX - initialItemX + itemWidth >
				(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
			legend.itemX = initialItemX;
			legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
		}

		// If the item exceeds the height, start a new column
		/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
			legend.itemY = legend.initialItemY;
			legend.itemX += legend.maxItemWidth;
			legend.maxItemWidth = 0;
		}*/

		// Set the edge positions
		legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
		legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
		legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

		// cache the position of the newly generated or reordered items
		item._legendItemPos = [legend.itemX, legend.itemY];

		// advance
		if (horizontal) {
			legend.itemX += itemWidth;

		} else {
			legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
			legend.lastLineHeight = itemHeight;
		}

		// the width of the widest item
		legend.offsetWidth = widthOption || mathMax(
			(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
			legend.offsetWidth
		);
	},

	/**
	 * Get all items, which is one item per series for normal series and one item per point
	 * for pie series.
	 */
	getAllItems: function () {
		var allItems = [];
		each(this.chart.series, function (series) {
			var seriesOptions = series.options;

			// Handle showInLegend. If the series is linked to another series, defaults to false.
			if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
				return;
			}

			// use points or series for the legend item depending on legendType
			allItems = allItems.concat(
					series.legendItems ||
					(seriesOptions.legendType === 'point' ?
							series.data :
							series)
			);
		});
		return allItems;
	},

	/**
	 * Adjust the chart margins by reserving space for the legend on only one side
	 * of the chart. If the position is set to a corner, top or bottom is reserved
	 * for horizontal legends and left or right for vertical ones.
	 */
	adjustMargins: function (margin, spacing) {
		var chart = this.chart, 
			options = this.options,
			// Use the first letter of each alignment option in order to detect the side 
			alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];
			
		if (this.display && !options.floating) {

			each([
				/(lth|ct|rth)/,
				/(rtv|rm|rbv)/,
				/(rbh|cb|lbh)/,
				/(lbv|lm|ltv)/
			], function (alignments, side) {
				if (alignments.test(alignment) && !defined(margin[side])) {
					// Now we have detected on which side of the chart we should reserve space for the legend
					chart[marginNames[side]] = mathMax(
						chart[marginNames[side]],
						chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + 
							[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + 
							pick(options.margin, 12) +
							spacing[side]
					);
				}
			});
		}
	},

	/**
	 * Render the legend. This method can be called both before and after
	 * chart.render. If called after, it will only rearrange items instead
	 * of creating new ones.
	 */
	render: function () {
		var legend = this,
			chart = legend.chart,
			renderer = chart.renderer,
			legendGroup = legend.group,
			allItems,
			display,
			legendWidth,
			legendHeight,
			box = legend.box,
			options = legend.options,
			padding = legend.padding,
			legendBorderWidth = options.borderWidth,
			legendBackgroundColor = options.backgroundColor;

		legend.itemX = legend.initialItemX;
		legend.itemY = legend.initialItemY;
		legend.offsetWidth = 0;
		legend.lastItemY = 0;

		if (!legendGroup) {
			legend.group = legendGroup = renderer.g('legend')
				.attr({ zIndex: 7 }) 
				.add();
			legend.contentGroup = renderer.g()
				.attr({ zIndex: 1 }) // above background
				.add(legendGroup);
			legend.scrollGroup = renderer.g()
				.add(legend.contentGroup);
		}
		
		legend.renderTitle();

		// add each series or point
		allItems = legend.getAllItems();

		// sort by legendIndex
		stableSort(allItems, function (a, b) {
			return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
		});

		// reversed legend
		if (options.reversed) {
			allItems.reverse();
		}

		legend.allItems = allItems;
		legend.display = display = !!allItems.length;

		// render the items
		legend.lastLineHeight = 0;
		each(allItems, function (item) {
			legend.renderItem(item); 
		});

		// Get the box
		legendWidth = (options.width || legend.offsetWidth) + padding;
		legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
		legendHeight = legend.handleOverflow(legendHeight);
		legendHeight += padding;

		// Draw the border and/or background
		if (legendBorderWidth || legendBackgroundColor) {

			if (!box) {
				legend.box = box = renderer.rect(
					0,
					0,
					legendWidth,
					legendHeight,
					options.borderRadius,
					legendBorderWidth || 0
				).attr({
					stroke: options.borderColor,
					'stroke-width': legendBorderWidth || 0,
					fill: legendBackgroundColor || NONE
				})
				.add(legendGroup)
				.shadow(options.shadow);
				box.isNew = true;

			} else if (legendWidth > 0 && legendHeight > 0) {
				box[box.isNew ? 'attr' : 'animate'](
					box.crisp({ width: legendWidth, height: legendHeight })
				);
				box.isNew = false;
			}

			// hide the border if no items
			box[display ? 'show' : 'hide']();
		}
		
		legend.legendWidth = legendWidth;
		legend.legendHeight = legendHeight;

		// Now that the legend width and height are established, put the items in the 
		// final position
		each(allItems, function (item) {
			legend.positionItem(item);
		});

		// 1.x compatibility: positioning based on style
		/*var props = ['left', 'right', 'top', 'bottom'],
			prop,
			i = 4;
		while (i--) {
			prop = props[i];
			if (options.style[prop] && options.style[prop] !== 'auto') {
				options[i < 2 ? 'align' : 'verticalAlign'] = prop;
				options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
			}
		}*/

		if (display) {
			legendGroup.align(extend({
				width: legendWidth,
				height: legendHeight
			}, options), true, 'spacingBox');
		}

		if (!chart.isResizing) {
			this.positionCheckboxes();
		}
	},
	
	/**
	 * Set up the overflow handling by adding navigation with up and down arrows below the
	 * legend.
	 */
	handleOverflow: function (legendHeight) {
		var legend = this,
			chart = this.chart,
			renderer = chart.renderer,
			options = this.options,
			optionsY = options.y,
			alignTop = options.verticalAlign === 'top',
			spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
			maxHeight = options.maxHeight,
			clipHeight,
			clipRect = this.clipRect,
			navOptions = options.navigation,
			animation = pick(navOptions.animation, true),
			arrowSize = navOptions.arrowSize || 12,
			nav = this.nav,
			pages = this.pages,
			lastY,
			allItems = this.allItems;
			
		// Adjust the height
		if (options.layout === 'horizontal') {
			spaceHeight /= 2;
		}
		if (maxHeight) {
			spaceHeight = mathMin(spaceHeight, maxHeight);
		}
		
		// Reset the legend height and adjust the clipping rectangle
		pages.length = 0;
		if (legendHeight > spaceHeight && !options.useHTML) {

			this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);
			this.currentPage = pick(this.currentPage, 1);
			this.fullHeight = legendHeight;
			
			// Fill pages with Y positions so that the top of each a legend item defines
			// the scroll top for each page (#2098)
			each(allItems, function (item, i) {
				var y = item._legendItemPos[1],
					h = mathRound(item.legendItem.getBBox().height),
					len = pages.length;
				
				if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
					pages.push(lastY || y);
					len++;
				}
				
				if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
					pages.push(y);
				}
				if (y !== lastY) {
					lastY = y;
				}
			});

			// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
			if (!clipRect) {
				clipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);
				legend.contentGroup.clip(clipRect);
			}
			clipRect.attr({
				height: clipHeight
			});
			
			// Add navigation elements
			if (!nav) {
				this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
				this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
					.on('click', function () {
						legend.scroll(-1, animation);
					})
					.add(nav);
				this.pager = renderer.text('', 15, 10)
					.css(navOptions.style)
					.add(nav);
				this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
					.on('click', function () {
						legend.scroll(1, animation);
					})
					.add(nav);
			}
			
			// Set initial position
			legend.scroll(0);
			
			legendHeight = spaceHeight;
			
		} else if (nav) {
			clipRect.attr({
				height: chart.chartHeight
			});
			nav.hide();
			this.scrollGroup.attr({
				translateY: 1
			});
			this.clipHeight = 0; // #1379
		}
		
		return legendHeight;
	},
	
	/**
	 * Scroll the legend by a number of pages
	 * @param {Object} scrollBy
	 * @param {Object} animation
	 */
	scroll: function (scrollBy, animation) {
		var pages = this.pages,
			pageCount = pages.length,
			currentPage = this.currentPage + scrollBy,
			clipHeight = this.clipHeight,
			navOptions = this.options.navigation,
			activeColor = navOptions.activeColor,
			inactiveColor = navOptions.inactiveColor,
			pager = this.pager,
			padding = this.padding,
			scrollOffset;
		
		// When resizing while looking at the last page
		if (currentPage > pageCount) {
			currentPage = pageCount;
		}
		
		if (currentPage > 0) {
			
			if (animation !== UNDEFINED) {
				setAnimation(animation, this.chart);
			}
			
			this.nav.attr({
				translateX: padding,
				translateY: clipHeight + this.padding + 7 + this.titleHeight,
				visibility: VISIBLE
			});
			this.up.attr({
					fill: currentPage === 1 ? inactiveColor : activeColor
				})
				.css({
					cursor: currentPage === 1 ? 'default' : 'pointer'
				});
			pager.attr({
				text: currentPage + '/' + pageCount
			});
			this.down.attr({
					x: 18 + this.pager.getBBox().width, // adjust to text width
					fill: currentPage === pageCount ? inactiveColor : activeColor
				})
				.css({
					cursor: currentPage === pageCount ? 'default' : 'pointer'
				});
			
			scrollOffset = -pages[currentPage - 1] + this.initialItemY;

			this.scrollGroup.animate({
				translateY: scrollOffset
			});			
			
			this.currentPage = currentPage;
			this.positionCheckboxes(scrollOffset);
		}
			
	}
	
};

/*
 * LegendSymbolMixin
 */ 

var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

	/**
	 * Get the series' symbol in the legend
	 * 
	 * @param {Object} legend The legend object
	 * @param {Object} item The series (this) or point
	 */
	drawRectangle: function (legend, item) {
		var symbolHeight = legend.options.symbolHeight || 12;
		
		item.legendSymbol = this.chart.renderer.rect(
			0,
			legend.baseline - 5 - (symbolHeight / 2),
			legend.symbolWidth,
			symbolHeight,
			legend.options.symbolRadius || 0
		).attr({
			zIndex: 3
		}).add(item.legendGroup);		
		
	},

	/**
	 * Get the series' symbol in the legend. This method should be overridable to create custom 
	 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	 * 
	 * @param {Object} legend The legend object
	 */
	drawLineMarker: function (legend) {

		var options = this.options,
			markerOptions = options.marker,
			radius,
			legendOptions = legend.options,
			legendSymbol,
			symbolWidth = legend.symbolWidth,
			renderer = this.chart.renderer,
			legendItemGroup = this.legendGroup,
			verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),
			attr;

		// Draw the line
		if (options.lineWidth) {
			attr = {
				'stroke-width': options.lineWidth
			};
			if (options.dashStyle) {
				attr.dashstyle = options.dashStyle;
			}
			this.legendLine = renderer.path([
				M,
				0,
				verticalCenter,
				L,
				symbolWidth,
				verticalCenter
			])
			.attr(attr)
			.add(legendItemGroup);
		}
		
		// Draw the marker
		if (markerOptions && markerOptions.enabled !== false) {
			radius = markerOptions.radius;
			this.legendSymbol = legendSymbol = renderer.symbol(
				this.symbol,
				(symbolWidth / 2) - radius,
				verticalCenter - radius,
				2 * radius,
				2 * radius
			)
			.add(legendItemGroup);
			legendSymbol.isMarker = true;
		}
	}
};

// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
// and for #2580, a similar drawing flaw in Firefox 26.
// TODO: Explore if there's a general cause for this. The problem may be related 
// to nested group elements, as the legend item texts are within 4 group elements.
if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
	wrap(Legend.prototype, 'positionItem', function (proceed, item) {
		var legend = this,
			runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
				if (item._legendItemPos) {
					proceed.call(legend, item);
				}
			};

		// Do it now, for export and to get checkbox placement
		runPositionItem();
		
		// Do it after to work around the core issue
		setTimeout(runPositionItem);
	});
}
/**
 * The chart class
 * @param {Object} options
 * @param {Function} callback Function to run when the chart has loaded
 */
var Chart = Highcharts.Chart = function () {
	this.init.apply(this, arguments);
};

Chart.prototype = {

	/**
	 * Hook for modules
	 */
	callbacks: [],

	/**
	 * Initialize the chart
	 */
	init: function (userOptions, callback) {

		// Handle regular options
		var options,
			seriesOptions = userOptions.series; // skip merging data points to increase performance

		userOptions.series = null;
		options = merge(defaultOptions, userOptions); // do the merge
		options.series = userOptions.series = seriesOptions; // set back the series data
		this.userOptions = userOptions;

		var optionsChart = options.chart;
		
		// Create margin & spacing array
		this.margin = this.splashArray('margin', optionsChart);
		this.spacing = this.splashArray('spacing', optionsChart);

		var chartEvents = optionsChart.events;

		//this.runChartClick = chartEvents && !!chartEvents.click;
		this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

		this.callback = callback;
		this.isResizing = 0;
		this.options = options;
		//chartTitleOptions = UNDEFINED;
		//chartSubtitleOptions = UNDEFINED;

		this.axes = [];
		this.series = [];
		this.hasCartesianSeries = optionsChart.showAxes;
		//this.axisOffset = UNDEFINED;
		//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
		//this.inverted = UNDEFINED;
		//this.loadingShown = UNDEFINED;
		//this.container = UNDEFINED;
		//this.chartWidth = UNDEFINED;
		//this.chartHeight = UNDEFINED;
		//this.marginRight = UNDEFINED;
		//this.marginBottom = UNDEFINED;
		//this.containerWidth = UNDEFINED;
		//this.containerHeight = UNDEFINED;
		//this.oldChartWidth = UNDEFINED;
		//this.oldChartHeight = UNDEFINED;

		//this.renderTo = UNDEFINED;
		//this.renderToClone = UNDEFINED;

		//this.spacingBox = UNDEFINED

		//this.legend = UNDEFINED;

		// Elements
		//this.chartBackground = UNDEFINED;
		//this.plotBackground = UNDEFINED;
		//this.plotBGImage = UNDEFINED;
		//this.plotBorder = UNDEFINED;
		//this.loadingDiv = UNDEFINED;
		//this.loadingSpan = UNDEFINED;

		var chart = this,
			eventType;

		// Add the chart to the global lookup
		chart.index = charts.length;
		charts.push(chart);
		chartCount++;

		// Set up auto resize
		if (optionsChart.reflow !== false) {
			addEvent(chart, 'load', function () {
				chart.initReflow();
			});
		}

		// Chart event handlers
		if (chartEvents) {
			for (eventType in chartEvents) {
				addEvent(chart, eventType, chartEvents[eventType]);
			}
		}

		chart.xAxis = [];
		chart.yAxis = [];

		// Expose methods and variables
		chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
		chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

		chart.firstRender();
	},

	/**
	 * Initialize an individual series, called internally before render time
	 */
	initSeries: function (options) {
		var chart = this,
			optionsChart = chart.options.chart,
			type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
			series,
			constr = seriesTypes[type];

		// No such series type
		if (!constr) {
			error(17, true);
		}

		series = new constr();
		series.init(this, options);
		return series;
	},

	/**
	 * Check whether a given point is within the plot area
	 *
	 * @param {Number} plotX Pixel x relative to the plot area
	 * @param {Number} plotY Pixel y relative to the plot area
	 * @param {Boolean} inverted Whether the chart is inverted
	 */
	isInsidePlot: function (plotX, plotY, inverted) {
		var x = inverted ? plotY : plotX,
			y = inverted ? plotX : plotY;
			
		return x >= 0 &&
			x <= this.plotWidth &&
			y >= 0 &&
			y <= this.plotHeight;
	},

	/**
	 * Redraw legend, axes or series based on updated data
	 *
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	redraw: function (animation) {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			pointer = chart.pointer,
			legend = chart.legend,
			redrawLegend = chart.isDirtyLegend,
			hasStackedSeries,
			hasDirtyStacks,
			hasCartesianSeries = chart.hasCartesianSeries,
			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
			seriesLength = series.length,
			i = seriesLength,
			serie,
			renderer = chart.renderer,
			isHiddenChart = renderer.isHidden(),
			afterRedraw = [];
			
		setAnimation(animation, chart);
		
		if (isHiddenChart) {
			chart.cloneRenderTo();
		}

		// Adjust title layout (reflow multiline text)
		chart.layOutTitles();

		// link stacked series
		while (i--) {
			serie = series[i];

			if (serie.options.stacking) {
				hasStackedSeries = true;
				
				if (serie.isDirty) {
					hasDirtyStacks = true;
					break;
				}
			}
		}
		if (hasDirtyStacks) { // mark others as dirty
			i = seriesLength;
			while (i--) {
				serie = series[i];
				if (serie.options.stacking) {
					serie.isDirty = true;
				}
			}
		}

		// handle updated data in the series
		each(series, function (serie) {
			if (serie.isDirty) { // prepare the data so axis can read it
				if (serie.options.legendType === 'point') {
					redrawLegend = true;
				}
			}
		});

		// handle added or removed series
		if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
			// draw legend graphics
			legend.render();

			chart.isDirtyLegend = false;
		}

		// reset stacks
		if (hasStackedSeries) {
			chart.getStacks();
		}


		if (hasCartesianSeries) {
			if (!chart.isResizing) {

				// reset maxTicks
				chart.maxTicks = null;

				// set axes scales
				each(axes, function (axis) {
					axis.setScale();
				});
			}
		}

		chart.getMargins(); // #3098

		if (hasCartesianSeries) {
			// If one axis is dirty, all axes must be redrawn (#792, #2169)
			each(axes, function (axis) {
				if (axis.isDirty) {
					isDirtyBox = true;
				}
			});

			// redraw axes
			each(axes, function (axis) {
				
				// Fire 'afterSetExtremes' only if extremes are set
				if (axis.isDirtyExtremes) { // #821
					axis.isDirtyExtremes = false;
					afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
						fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
						delete axis.eventArgs;
					});
				}
				
				if (isDirtyBox || hasStackedSeries) {
					axis.redraw();
				}
			});
		}
		
		// the plot areas size has changed
		if (isDirtyBox) {
			chart.drawChartBox();
		}


		// redraw affected series
		each(series, function (serie) {
			if (serie.isDirty && serie.visible &&
					(!serie.isCartesian || serie.xAxis)) { // issue #153
				serie.redraw();
			}
		});

		// move tooltip or reset
		if (pointer) {
			pointer.reset(true);
		}

		// redraw if canvas
		renderer.draw();

		// fire the event
		fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw
		
		if (isHiddenChart) {
			chart.cloneRenderTo(true);
		}
		
		// Fire callbacks that are put on hold until after the redraw
		each(afterRedraw, function (callback) {
			callback.call();
		});
	},

	/**
	 * Get an axis, series or point object by id.
	 * @param id {String} The id as given in the configuration options
	 */
	get: function (id) {
		var chart = this,
			axes = chart.axes,
			series = chart.series;

		var i,
			j,
			points;

		// search axes
		for (i = 0; i < axes.length; i++) {
			if (axes[i].options.id === id) {
				return axes[i];
			}
		}

		// search series
		for (i = 0; i < series.length; i++) {
			if (series[i].options.id === id) {
				return series[i];
			}
		}

		// search points
		for (i = 0; i < series.length; i++) {
			points = series[i].points || [];
			for (j = 0; j < points.length; j++) {
				if (points[j].id === id) {
					return points[j];
				}
			}
		}
		return null;
	},

	/**
	 * Create the Axis instances based on the config options
	 */
	getAxes: function () {
		var chart = this,
			options = this.options,
			xAxisOptions = options.xAxis = splat(options.xAxis || {}),
			yAxisOptions = options.yAxis = splat(options.yAxis || {}),
			optionsArray,
			axis;

		// make sure the options are arrays and add some members
		each(xAxisOptions, function (axis, i) {
			axis.index = i;
			axis.isX = true;
		});

		each(yAxisOptions, function (axis, i) {
			axis.index = i;
		});

		// concatenate all axis options into one array
		optionsArray = xAxisOptions.concat(yAxisOptions);

		each(optionsArray, function (axisOptions) {
			axis = new Axis(chart, axisOptions);
		});
	},


	/**
	 * Get the currently selected points from all series
	 */
	getSelectedPoints: function () {
		var points = [];
		each(this.series, function (serie) {
			points = points.concat(grep(serie.points || [], function (point) {
				return point.selected;
			}));
		});
		return points;
	},

	/**
	 * Get the currently selected series
	 */
	getSelectedSeries: function () {
		return grep(this.series, function (serie) {
			return serie.selected;
		});
	},

	/**
	 * Generate stacks for each series and calculate stacks total values
	 */
	getStacks: function () {
		var chart = this;

		// reset stacks for each yAxis
		each(chart.yAxis, function (axis) {
			if (axis.stacks && axis.hasVisibleSeries) {
				axis.oldStacks = axis.stacks;
			}
		});

		each(chart.series, function (series) {
			if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
				series.stackKey = series.type + pick(series.options.stack, '');
			}
		});
	},	

	/**
	 * Show the title and subtitle of the chart
	 *
	 * @param titleOptions {Object} New title options
	 * @param subtitleOptions {Object} New subtitle options
	 *
	 */
	setTitle: function (titleOptions, subtitleOptions, redraw) {
		var chart = this,
			options = chart.options,
			chartTitleOptions,
			chartSubtitleOptions;

		chartTitleOptions = options.title = merge(options.title, titleOptions);
		chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

		// add title and subtitle
		each([
			['title', titleOptions, chartTitleOptions],
			['subtitle', subtitleOptions, chartSubtitleOptions]
		], function (arr) {
			var name = arr[0],
				title = chart[name],
				titleOptions = arr[1],
				chartTitleOptions = arr[2];

			if (title && titleOptions) {
				chart[name] = title = title.destroy(); // remove old
			}
			
			if (chartTitleOptions && chartTitleOptions.text && !title) {
				chart[name] = chart.renderer.text(
					chartTitleOptions.text,
					0,
					0,
					chartTitleOptions.useHTML
				)
				.attr({
					align: chartTitleOptions.align,
					'class': PREFIX + name,
					zIndex: chartTitleOptions.zIndex || 4
				})
				.css(chartTitleOptions.style)
				.add();
			}	
		});
		chart.layOutTitles(redraw);
	},

	/**
	 * Lay out the chart titles and cache the full offset height for use in getMargins
	 */
	layOutTitles: function (redraw) {
		var titleOffset = 0,
			title = this.title,
			subtitle = this.subtitle,
			options = this.options,
			titleOptions = options.title,
			subtitleOptions = options.subtitle,
			requiresDirtyBox,
			renderer = this.renderer,
			autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

		if (title) {
			title
				.css({ width: (titleOptions.width || autoWidth) + PX })
				.align(extend({ 
					y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
				}, titleOptions), false, 'spacingBox');
			
			if (!titleOptions.floating && !titleOptions.verticalAlign) {
				titleOffset = title.getBBox().height;
			}
		}
		if (subtitle) {
			subtitle
				.css({ width: (subtitleOptions.width || autoWidth) + PX })
				.align(extend({ 
					y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b 
				}, subtitleOptions), false, 'spacingBox');
			
			if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
				titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
			}
		}

		requiresDirtyBox = this.titleOffset !== titleOffset;				
		this.titleOffset = titleOffset; // used in getMargins

		if (!this.isDirtyBox && requiresDirtyBox) {
			this.isDirtyBox = requiresDirtyBox;
			// Redraw if necessary (#2719, #2744)		
			if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
				this.redraw();
			}
		}
	},

	/**
	 * Get chart width and height according to options and container size
	 */
	getChartSize: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			widthOption = optionsChart.width,
			heightOption = optionsChart.height,
			renderTo = chart.renderToClone || chart.renderTo;

		// get inner width and height from jQuery (#824)
		if (!defined(widthOption)) {
			chart.containerWidth = adapterRun(renderTo, 'width');
		}
		if (!defined(heightOption)) {
			chart.containerHeight = adapterRun(renderTo, 'height');
		}
		
		chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
		chart.chartHeight = mathMax(0, pick(heightOption,
			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
			chart.containerHeight > 19 ? chart.containerHeight : 400));
	},

	/**
	 * Create a clone of the chart's renderTo div and place it outside the viewport to allow
	 * size computation on chart.render and chart.redraw
	 */
	cloneRenderTo: function (revert) {
		var clone = this.renderToClone,
			container = this.container;
		
		// Destroy the clone and bring the container back to the real renderTo div
		if (revert) {
			if (clone) {
				this.renderTo.appendChild(container);
				discardElement(clone);
				delete this.renderToClone;
			}
		
		// Set up the clone
		} else {
			if (container && container.parentNode === this.renderTo) {
				this.renderTo.removeChild(container); // do not clone this
			}
			this.renderToClone = clone = this.renderTo.cloneNode(0);
			css(clone, {
				position: ABSOLUTE,
				top: '-9999px',
				display: 'block' // #833
			});
			if (clone.style.setProperty) { // #2631
				clone.style.setProperty('display', 'block', 'important');
			}
			doc.body.appendChild(clone);
			if (container) {
				clone.appendChild(container);
			}
		}
	},

	/**
	 * Get the containing element, determine the size and create the inner container
	 * div to hold the chart
	 */
	getContainer: function () {
		var chart = this,
			container,
			optionsChart = chart.options.chart,
			chartWidth,
			chartHeight,
			renderTo,
			indexAttrName = 'data-highcharts-chart',
			oldChartIndex,
			containerId;

		chart.renderTo = renderTo = optionsChart.renderTo;
		containerId = PREFIX + idCounter++;

		if (isString(renderTo)) {
			chart.renderTo = renderTo = doc.getElementById(renderTo);
		}
		
		// Display an error if the renderTo is wrong
		if (!renderTo) {
			error(13, true);
		}
		
		// If the container already holds a chart, destroy it. The check for hasRendered is there
		// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
		// attribute and the SVG contents, but not an interactive chart. So in this case,
		// charts[oldChartIndex] will point to the wrong chart if any (#2609).
		oldChartIndex = pInt(attr(renderTo, indexAttrName));
		if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
			charts[oldChartIndex].destroy();
		}		
		
		// Make a reference to the chart from the div
		attr(renderTo, indexAttrName, chart.index);

		// remove previous chart
		renderTo.innerHTML = '';

		// If the container doesn't have an offsetWidth, it has or is a child of a node
		// that has display:none. We need to temporarily move it out to a visible
		// state to determine the size, else the legend and tooltips won't render
		// properly. The allowClone option is used in sparklines as a micro optimization,
		// saving about 1-2 ms each chart.
		if (!optionsChart.skipClone && !renderTo.offsetWidth) {
			chart.cloneRenderTo();
		}

		// get the width and height
		chart.getChartSize();
		chartWidth = chart.chartWidth;
		chartHeight = chart.chartHeight;

		// create the inner container
		chart.container = container = createElement(DIV, {
				className: PREFIX + 'container' +
					(optionsChart.className ? ' ' + optionsChart.className : ''),
				id: containerId
			}, extend({
				position: RELATIVE,
				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
					// content overflow in IE
				width: chartWidth + PX,
				height: chartHeight + PX,
				textAlign: 'left',
				lineHeight: 'normal', // #427
				zIndex: 0, // #1072
				'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
			}, optionsChart.style),
			chart.renderToClone || renderTo
		);

		// cache the cursor (#1650)
		chart._cursor = container.style.cursor;

		// Initialize the renderer
		chart.renderer =
			optionsChart.forExport ? // force SVG, used for SVG export
				new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
				new Renderer(container, chartWidth, chartHeight, optionsChart.style);

		if (useCanVG) {
			// If we need canvg library, extend and configure the renderer
			// to get the tracker for translating mouse events
			chart.renderer.create(chart, container, chartWidth, chartHeight);
		}
		// Add a reference to the charts index
		chart.renderer.chartIndex = chart.index;
	},

	/**
	 * Calculate margins by rendering axis labels in a preliminary position. Title,
	 * subtitle and legend have already been rendered at this stage, but will be
	 * moved into their final positions
	 */
	getMargins: function (skipAxes) {
		var chart = this,
			spacing = chart.spacing,
			margin = chart.margin,
			titleOffset = chart.titleOffset;

		chart.resetMargins();

		// Adjust for title and subtitle
		if (titleOffset && !defined(margin[0])) {
			chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
		}
		
		// Adjust for legend
		chart.legend.adjustMargins(margin, spacing);

		// adjust for scroller
		if (chart.extraBottomMargin) {
			chart.marginBottom += chart.extraBottomMargin;
		}
		if (chart.extraTopMargin) {
			chart.plotTop += chart.extraTopMargin;
		}
		if (!skipAxes) {
			this.getAxisMargins();
		}
	},

	getAxisMargins: function () {

		var chart = this,
			axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
			margin = chart.margin;
		
		// pre-render axes to get labels offset width
		if (chart.hasCartesianSeries) {
			each(chart.axes, function (axis) {
				axis.getOffset();
			});
		}

		// Add the axis offsets
		each(marginNames, function (m, side) {
			if (!defined(margin[side])) {
				chart[m] += axisOffset[side];
			}		
		});

		chart.setChartSize();

	},

	/**
	 * Resize the chart to its container if size is not explicitly set
	 */
	reflow: function (e) {
		var chart = this,
			optionsChart = chart.options.chart,
			renderTo = chart.renderTo,
			width = optionsChart.width || adapterRun(renderTo, 'width'),
			height = optionsChart.height || adapterRun(renderTo, 'height'),
			target = e ? e.target : win, // #805 - MooTools doesn't supply e
			doReflow = function () {
				if (chart.container) { // It may have been destroyed in the meantime (#1257)
					chart.setSize(width, height, false);
					chart.hasUserSize = null;
				}
			};
			
		// Width and height checks for display:none. Target is doc in IE8 and Opera,
		// win in Firefox, Chrome and IE9.
		if (!chart.hasUserSize && width && height && (target === win || target === doc)) {
			if (width !== chart.containerWidth || height !== chart.containerHeight) {
				clearTimeout(chart.reflowTimeout);
				if (e) { // Called from window.resize
					chart.reflowTimeout = setTimeout(doReflow, 100);
				} else { // Called directly (#2224)
					doReflow();
				}
			}
			chart.containerWidth = width;
			chart.containerHeight = height;
		}
	},

	/**
	 * Add the event handlers necessary for auto resizing
	 */
	initReflow: function () {
		var chart = this,
			reflow = function (e) {
				chart.reflow(e);
			};
			
		
		addEvent(win, 'resize', reflow);
		addEvent(chart, 'destroy', function () {
			removeEvent(win, 'resize', reflow);
		});
	},

	/**
	 * Resize the chart to a given width and height
	 * @param {Number} width
	 * @param {Number} height
	 * @param {Object|Boolean} animation
	 */
	setSize: function (width, height, animation) {
		var chart = this,
			chartWidth,
			chartHeight,
			fireEndResize;

		// Handle the isResizing counter
		chart.isResizing += 1;
		fireEndResize = function () {
			if (chart) {
				fireEvent(chart, 'endResize', null, function () {
					chart.isResizing -= 1;
				});
			}
		};

		// set the animation for the current process
		setAnimation(animation, chart);

		chart.oldChartHeight = chart.chartHeight;
		chart.oldChartWidth = chart.chartWidth;
		if (defined(width)) {
			chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
			chart.hasUserSize = !!chartWidth;
		}
		if (defined(height)) {
			chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
		}

		// Resize the container with the global animation applied if enabled (#2503)
		(globalAnimation ? animate : css)(chart.container, {
			width: chartWidth + PX,
			height: chartHeight + PX
		}, globalAnimation);

		chart.setChartSize(true);
		chart.renderer.setSize(chartWidth, chartHeight, animation);

		// handle axes
		chart.maxTicks = null;
		each(chart.axes, function (axis) {
			axis.isDirty = true;
			axis.setScale();
		});

		// make sure non-cartesian series are also handled
		each(chart.series, function (serie) {
			serie.isDirty = true;
		});

		chart.isDirtyLegend = true; // force legend redraw
		chart.isDirtyBox = true; // force redraw of plot and chart border

		chart.layOutTitles(); // #2857
		chart.getMargins();

		chart.redraw(animation);


		chart.oldChartHeight = null;
		fireEvent(chart, 'resize');

		// fire endResize and set isResizing back
		// If animation is disabled, fire without delay
		if (globalAnimation === false) {
			fireEndResize();
		} else { // else set a timeout with the animation duration
			setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
		}
	},

	/**
	 * Set the public chart properties. This is done before and after the pre-render
	 * to determine margin sizes
	 */
	setChartSize: function (skipAxes) {
		var chart = this,
			inverted = chart.inverted,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			optionsChart = chart.options.chart,
			spacing = chart.spacing,
			clipOffset = chart.clipOffset,
			clipX,
			clipY,
			plotLeft,
			plotTop,
			plotWidth,
			plotHeight,
			plotBorderWidth;

		chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
		chart.plotTop = plotTop = mathRound(chart.plotTop);
		chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
		chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

		chart.plotSizeX = inverted ? plotHeight : plotWidth;
		chart.plotSizeY = inverted ? plotWidth : plotHeight;
		
		chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

		// Set boxes used for alignment
		chart.spacingBox = renderer.spacingBox = {
			x: spacing[3],
			y: spacing[0],
			width: chartWidth - spacing[3] - spacing[1],
			height: chartHeight - spacing[0] - spacing[2]
		};
		chart.plotBox = renderer.plotBox = {
			x: plotLeft,
			y: plotTop,
			width: plotWidth,
			height: plotHeight
		};

		plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
		clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
		clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
		chart.clipBox = {
			x: clipX, 
			y: clipY, 
			width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), 
			height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
		};

		if (!skipAxes) {
			each(chart.axes, function (axis) {
				axis.setAxisSize();
				axis.setAxisTranslation();
			});
		}
	},

	/**
	 * Initial margins before auto size margins are applied
	 */
	resetMargins: function () {
		var chart = this;

		each(marginNames, function (m, side) {
			chart[m] = pick(chart.margin[side], chart.spacing[side]);
		});
		chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
		chart.clipOffset = [0, 0, 0, 0];
	},

	/**
	 * Draw the borders and backgrounds for chart and plot area
	 */
	drawChartBox: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			renderer = chart.renderer,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			chartBackground = chart.chartBackground,
			plotBackground = chart.plotBackground,
			plotBorder = chart.plotBorder,
			plotBGImage = chart.plotBGImage,
			chartBorderWidth = optionsChart.borderWidth || 0,
			chartBackgroundColor = optionsChart.backgroundColor,
			plotBackgroundColor = optionsChart.plotBackgroundColor,
			plotBackgroundImage = optionsChart.plotBackgroundImage,
			plotBorderWidth = optionsChart.plotBorderWidth || 0,
			mgn,
			bgAttr,
			plotLeft = chart.plotLeft,
			plotTop = chart.plotTop,
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			plotBox = chart.plotBox,
			clipRect = chart.clipRect,
			clipBox = chart.clipBox;

		// Chart area
		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

		if (chartBorderWidth || chartBackgroundColor) {
			if (!chartBackground) {
				
				bgAttr = {
					fill: chartBackgroundColor || NONE
				};
				if (chartBorderWidth) { // #980
					bgAttr.stroke = optionsChart.borderColor;
					bgAttr['stroke-width'] = chartBorderWidth;
				}
				chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
						optionsChart.borderRadius, chartBorderWidth)
					.attr(bgAttr)
					.addClass(PREFIX + 'background')
					.add()
					.shadow(optionsChart.shadow);

			} else { // resize
				chartBackground.animate(
					chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
				);
			}
		}


		// Plot background
		if (plotBackgroundColor) {
			if (!plotBackground) {
				chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
					.attr({
						fill: plotBackgroundColor
					})
					.add()
					.shadow(optionsChart.plotShadow);
			} else {
				plotBackground.animate(plotBox);
			}
		}
		if (plotBackgroundImage) {
			if (!plotBGImage) {
				chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
					.add();
			} else {
				plotBGImage.animate(plotBox);
			}
		}
		
		// Plot clip
		if (!clipRect) {
			chart.clipRect = renderer.clipRect(clipBox);
		} else {
			clipRect.animate({
				width: clipBox.width,
				height: clipBox.height
			});
		}

		// Plot area border
		if (plotBorderWidth) {
			if (!plotBorder) {
				chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
					.attr({
						stroke: optionsChart.plotBorderColor,
						'stroke-width': plotBorderWidth,
						fill: NONE,
						zIndex: 1
					})
					.add();
			} else {
				plotBorder.animate(
					plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
				);
			}
		}

		// reset
		chart.isDirtyBox = false;
	},

	/**
	 * Detect whether a certain chart property is needed based on inspecting its options
	 * and series. This mainly applies to the chart.invert property, and in extensions to 
	 * the chart.angular and chart.polar properties.
	 */
	propFromSeries: function () {
		var chart = this,
			optionsChart = chart.options.chart,
			klass,
			seriesOptions = chart.options.series,
			i,
			value;
			
			
		each(['inverted', 'angular', 'polar'], function (key) {
			
			// The default series type's class
			klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
			
			// Get the value from available chart-wide properties
			value = (
				chart[key] || // 1. it is set before
				optionsChart[key] || // 2. it is set in the options
				(klass && klass.prototype[key]) // 3. it's default series class requires it
			);
	
			// 4. Check if any the chart's series require it
			i = seriesOptions && seriesOptions.length;
			while (!value && i--) {
				klass = seriesTypes[seriesOptions[i].type];
				if (klass && klass.prototype[key]) {
					value = true;
				}
			}
	
			// Set the chart property
			chart[key] = value;	
		});
		
	},

	/**
	 * Link two or more series together. This is done initially from Chart.render,
	 * and after Chart.addSeries and Series.remove.
	 */
	linkSeries: function () {
		var chart = this,
			chartSeries = chart.series;

		// Reset links
		each(chartSeries, function (series) {
			series.linkedSeries.length = 0;
		});

		// Apply new links
		each(chartSeries, function (series) {
			var linkedTo = series.options.linkedTo;
			if (isString(linkedTo)) {
				if (linkedTo === ':previous') {
					linkedTo = chart.series[series.index - 1];
				} else {
					linkedTo = chart.get(linkedTo);
				}
				if (linkedTo) {
					linkedTo.linkedSeries.push(series);
					series.linkedParent = linkedTo;
				}
			}
		});
	},

	/**
	 * Render series for the chart
	 */
	renderSeries: function () {
		each(this.series, function (serie) {
			serie.translate();
			serie.render();
		});
	},
		
	/**
	 * Render labels for the chart
	 */
	renderLabels: function () {
		var chart = this,
			labels = chart.options.labels;
		if (labels.items) {
			each(labels.items, function (label) {
				var style = extend(labels.style, label.style),
					x = pInt(style.left) + chart.plotLeft,
					y = pInt(style.top) + chart.plotTop + 12;

				// delete to prevent rewriting in IE
				delete style.left;
				delete style.top;

				chart.renderer.text(
					label.html,
					x,
					y
				)
				.attr({ zIndex: 2 })
				.css(style)
				.add();

			});
		}
	},

	/**
	 * Render all graphics for the chart
	 */
	render: function () {
		var chart = this,
			axes = chart.axes,
			renderer = chart.renderer,
			options = chart.options,
			tempWidth,
			tempHeight,
			redoHorizontal,
			redoVertical;

		// Title
		chart.setTitle();


		// Legend
		chart.legend = new Legend(chart, options.legend);

		chart.getStacks(); // render stacks

		// Get chart margins
		chart.getMargins(true);
		chart.setChartSize();

		// Record preliminary dimensions for later comparison
		tempWidth = chart.plotWidth;
		tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

		// Get margins by pre-rendering axes
		each(axes, function (axis) {
			axis.setScale();
		});
		chart.getAxisMargins();

		// If the plot area size has changed significantly, calculate tick positions again
		redoHorizontal = tempWidth / chart.plotWidth > 1.2;
		redoVertical = tempHeight / chart.plotHeight > 1.1;

		if (redoHorizontal || redoVertical) {

			chart.maxTicks = null; // reset for second pass
			each(axes, function (axis) {
				if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
					axis.setTickInterval(true); // update to reflect the new margins
				}
			});
			chart.getMargins(); // second pass to check for new labels
		}

		// Draw the borders and backgrounds
		chart.drawChartBox();		


		// Axes
		if (chart.hasCartesianSeries) {
			each(axes, function (axis) {
				axis.render();
			});
		}

		// The series
		if (!chart.seriesGroup) {
			chart.seriesGroup = renderer.g('series-group')
				.attr({ zIndex: 3 })
				.add();
		}
		chart.renderSeries();

		// Labels
		chart.renderLabels();

		// Credits
		chart.showCredits(options.credits);

		// Set flag
		chart.hasRendered = true;

	},

	/**
	 * Show chart credits based on config options
	 */
	showCredits: function (credits) {
		if (credits.enabled && !this.credits) {
			this.credits = this.renderer.text(
				credits.text,
				0,
				0
			)
			.on('click', function () {
				if (credits.href) {
					location.href = credits.href;
				}
			})
			.attr({
				align: credits.position.align,
				zIndex: 8
			})
			.css(credits.style)
			.add()
			.align(credits.position);
		}
	},

	/**
	 * Clean up memory usage
	 */
	destroy: function () {
		var chart = this,
			axes = chart.axes,
			series = chart.series,
			container = chart.container,
			i,
			parentNode = container && container.parentNode;
			
		// fire the chart.destoy event
		fireEvent(chart, 'destroy');
		
		// Delete the chart from charts lookup array
		charts[chart.index] = UNDEFINED;
		chartCount--;
		chart.renderTo.removeAttribute('data-highcharts-chart');

		// remove events
		removeEvent(chart);

		// ==== Destroy collections:
		// Destroy axes
		i = axes.length;
		while (i--) {
			axes[i] = axes[i].destroy();
		}

		// Destroy each series
		i = series.length;
		while (i--) {
			series[i] = series[i].destroy();
		}

		// ==== Destroy chart properties:
		each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 
				'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', 
				'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
			var prop = chart[name];

			if (prop && prop.destroy) {
				chart[name] = prop.destroy();
			}
		});

		// remove container and all SVG
		if (container) { // can break in IE when destroyed before finished loading
			container.innerHTML = '';
			removeEvent(container);
			if (parentNode) {
				discardElement(container);
			}

		}

		// clean it all up
		for (i in chart) {
			delete chart[i];
		}

	},


	/**
	 * VML namespaces can't be added until after complete. Listening
	 * for Perini's doScroll hack is not enough.
	 */
	isReadyToRender: function () {
		var chart = this;

		// Note: in spite of JSLint's complaints, win == win.top is required
		/*jslint eqeq: true*/
		if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
		/*jslint eqeq: false*/
			if (useCanVG) {
				// Delay rendering until canvg library is downloaded and ready
				CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
			} else {
				doc.attachEvent('onreadystatechange', function () {
					doc.detachEvent('onreadystatechange', chart.firstRender);
					if (doc.readyState === 'complete') {
						chart.firstRender();
					}
				});
			}
			return false;
		}
		return true;
	},

	/**
	 * Prepare for first rendering after all data are loaded
	 */
	firstRender: function () {
		var chart = this,
			options = chart.options,
			callback = chart.callback;

		// Check whether the chart is ready to render
		if (!chart.isReadyToRender()) {
			return;
		}

		// Create the container
		chart.getContainer();

		// Run an early event after the container and renderer are established
		fireEvent(chart, 'init');

		
		chart.resetMargins();
		chart.setChartSize();

		// Set the common chart properties (mainly invert) from the given series
		chart.propFromSeries();

		// get axes
		chart.getAxes();

		// Initialize the series
		each(options.series || [], function (serieOptions) {
			chart.initSeries(serieOptions);
		});

		chart.linkSeries();

		// Run an event after axes and series are initialized, but before render. At this stage,
		// the series data is indexed and cached in the xData and yData arrays, so we can access
		// those before rendering. Used in Highstock. 
		fireEvent(chart, 'beforeRender'); 

		// depends on inverted and on margins being set
		if (Highcharts.Pointer) {
			chart.pointer = new Pointer(chart, options);
		}

		chart.render();

		// add canvas
		chart.renderer.draw();
		// run callbacks
		if (callback) {
			callback.apply(chart, [chart]);
		}
		each(chart.callbacks, function (fn) {
			if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
				fn.apply(chart, [chart]);
			}
		});
		
		// Fire the load event
		fireEvent(chart, 'load');		
		
		// If the chart was rendered outside the top container, put it back in (#3679)
		chart.cloneRenderTo(true);

	},

	/**
	* Creates arrays for spacing and margin from given options.
	*/
	splashArray: function (target, options) {
		var oVar = options[target],
			tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

		return [pick(options[target + 'Top'], tArray[0]),
				pick(options[target + 'Right'], tArray[1]),
				pick(options[target + 'Bottom'], tArray[2]),
				pick(options[target + 'Left'], tArray[3])];
	}
}; // end Chart

var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
	/**
	 * Get the center of the pie based on the size and center options relative to the  
	 * plot area. Borrowed by the polar and gauge series types.
	 */
	getCenter: function () {
		
		var options = this.options,
			chart = this.chart,
			slicingRoom = 2 * (options.slicedOffset || 0),
			handleSlicingRoom,
			plotWidth = chart.plotWidth - 2 * slicingRoom,
			plotHeight = chart.plotHeight - 2 * slicingRoom,
			centerOption = options.center,
			positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
			smallestSize = mathMin(plotWidth, plotHeight),
			isPercent,
			i,
			value;

		for (i = 0; i < 4; ++i) {
			value = positions[i];
			isPercent = /%$/.test(value);
			handleSlicingRoom = i < 2 || (i === 2 && isPercent);
			positions[i] = (isPercent ?
				// i == 0: centerX, relative to width
				// i == 1: centerY, relative to height
				// i == 2: size, relative to smallestSize
				// i == 3: innerSize, relative to size
				[plotWidth, plotHeight, smallestSize, positions[2]][i] *
					pInt(value) / 100 :
				pInt(value)) + (handleSlicingRoom ? slicingRoom : 0);
		}
		return positions;
	}
};

/**
 * The Point object and prototype. Inheritable and used as base for PiePoint
 */
var Point = function () {};
Point.prototype = {

	/**
	 * Initialize the point
	 * @param {Object} series The series object containing this point
	 * @param {Object} options The data in either number, array or object format
	 */
	init: function (series, options, x) {

		var point = this,
			colors;
		point.series = series;
		point.color = series.color; // #3445
		point.applyOptions(options, x);
		point.pointAttr = {};

		if (series.options.colorByPoint) {
			colors = series.options.colors || series.chart.options.colors;
			point.color = point.color || colors[series.colorCounter++];
			// loop back to zero
			if (series.colorCounter === colors.length) {
				series.colorCounter = 0;
			}
		}

		series.chart.pointCount++;
		return point;
	},
	/**
	 * Apply the options containing the x and y data and possible some extra properties.
	 * This is called on point init or from point.update.
	 *
	 * @param {Object} options
	 */
	applyOptions: function (options, x) {
		var point = this,
			series = point.series,
			pointValKey = series.options.pointValKey || series.pointValKey;

		options = Point.prototype.optionsToObject.call(this, options);

		// copy options directly to point
		extend(point, options);
		point.options = point.options ? extend(point.options, options) : options;

		// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
		if (pointValKey) {
			point.y = point[pointValKey];
		}

		// If no x is set by now, get auto incremented value. All points must have an
		// x value, however the y value can be null to create a gap in the series
		if (point.x === UNDEFINED && series) {
			point.x = x === UNDEFINED ? series.autoIncrement() : x;
		}

		return point;
	},

	/**
	 * Transform number or array configs into objects
	 */
	optionsToObject: function (options) {
		var ret = {},
			series = this.series,
			pointArrayMap = series.pointArrayMap || ['y'],
			valueCount = pointArrayMap.length,
			firstItemType,
			i = 0,
			j = 0;

		if (typeof options === 'number' || options === null) {
			ret[pointArrayMap[0]] = options;

		} else if (isArray(options)) {
			// with leading x value
			if (options.length > valueCount) {
				firstItemType = typeof options[0];
				if (firstItemType === 'string') {
					ret.name = options[0];
				} else if (firstItemType === 'number') {
					ret.x = options[0];
				}
				i++;
			}
			while (j < valueCount) {
				ret[pointArrayMap[j++]] = options[i++];
			}
		} else if (typeof options === 'object') {
			ret = options;

			// This is the fastest way to detect if there are individual point dataLabels that need
			// to be considered in drawDataLabels. These can only occur in object configs.
			if (options.dataLabels) {
				series._hasPointLabels = true;
			}

			// Same approach as above for markers
			if (options.marker) {
				series._hasPointMarkers = true;
			}
		}
		return ret;
	},

	/**
	 * Destroy a point to clear memory. Its reference still stays in series.data.
	 */
	destroy: function () {
		var point = this,
			series = point.series,
			chart = series.chart,
			hoverPoints = chart.hoverPoints,
			prop;

		chart.pointCount--;

		if (hoverPoints) {
			point.setState();
			erase(hoverPoints, point);
			if (!hoverPoints.length) {
				chart.hoverPoints = null;
			}

		}
		if (point === chart.hoverPoint) {
			point.onMouseOut();
		}

		// remove all events
		if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
			removeEvent(point);
			point.destroyElements();
		}

		if (point.legendItem) { // pies have legend items
			chart.legend.destroyItem(point);
		}

		for (prop in point) {
			point[prop] = null;
		}


	},

	/**
	 * Destroy SVG elements associated with the point
	 */
	destroyElements: function () {
		var point = this,
			props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
			prop,
			i = 6;
		while (i--) {
			prop = props[i];
			if (point[prop]) {
				point[prop] = point[prop].destroy();
			}
		}
	},

	/**
	 * Return the configuration hash needed for the data label and tooltip formatters
	 */
	getLabelConfig: function () {
		var point = this;
		return {
			x: point.category,
			y: point.y,
			key: point.name || point.category,
			series: point.series,
			point: point,
			percentage: point.percentage,
			total: point.total || point.stackTotal
		};
	},	

	/**
	 * Extendable method for formatting each point's tooltip line
	 *
	 * @return {String} A string to be concatenated in to the common tooltip text
	 */
	tooltipFormatter: function (pointFormat) {

		// Insert options for valueDecimals, valuePrefix, and valueSuffix
		var series = this.series,
			seriesTooltipOptions = series.tooltipOptions,
			valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
			valuePrefix = seriesTooltipOptions.valuePrefix || '',
			valueSuffix = seriesTooltipOptions.valueSuffix || '';

		// Loop over the point array map and replace unformatted values with sprintf formatting markup
		each(series.pointArrayMap || ['y'], function (key) {
			key = '{point.' + key; // without the closing bracket
			if (valuePrefix || valueSuffix) {
				pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
			}
			pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
		});

		return format(pointFormat, {
			point: this,
			series: this.series
		});
	},

	/**
	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
	 * causes a name clash in MooTools
	 * @param {String} eventType
	 * @param {Object} eventArgs Additional event arguments
	 * @param {Function} defaultFunction Default event handler
	 */
	firePointEvent: function (eventType, eventArgs, defaultFunction) {
		var point = this,
			series = this.series,
			seriesOptions = series.options;

		// load event handlers on demand to save time on mouseover/out
		if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
			this.importEvents();
		}

		// add default handler if in selection mode
		if (eventType === 'click' && seriesOptions.allowPointSelect) {
			defaultFunction = function (event) {
				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
			};
		}

		fireEvent(this, eventType, eventArgs, defaultFunction);
	}
};/**
 * @classDescription The base function which all other series types inherit from. The data in the series is stored
 * in various arrays.
 *
 * - First, series.options.data contains all the original config options for
 * each point whether added by options or methods like series.addPoint.
 * - Next, series.data contains those values converted to points, but in case the series data length
 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
 * only contains the points that have been created on demand.
 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 * compared to series.data and series.options.data. If however the series data is grouped, these can't
 * be correlated one to one.
 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
 *
 * @param {Object} chart
 * @param {Object} options
 */
var Series = Highcharts.Series = function () {};

Series.prototype = {

	isCartesian: true,
	type: 'line',
	pointClass: Point,
	sorted: true, // requires the data to be sorted
	requireSorting: true,
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'lineColor',
		'stroke-width': 'lineWidth',
		fill: 'fillColor',
		r: 'radius'
	},
	axisTypes: ['xAxis', 'yAxis'],
	colorCounter: 0,
	parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
	init: function (chart, options) {
		var series = this,
			eventType,
			events,
			chartSeries = chart.series,
			sortByIndex = function (a, b) {
				return pick(a.options.index, a._i) - pick(b.options.index, b._i);
			};

		series.chart = chart;
		series.options = options = series.setOptions(options); // merge with plotOptions
		series.linkedSeries = [];

		// bind the axes
		series.bindAxes();

		// set some variables
		extend(series, {
			name: options.name,
			state: NORMAL_STATE,
			pointAttr: {},
			visible: options.visible !== false, // true by default
			selected: options.selected === true // false by default
		});

		// special
		if (useCanVG) {
			options.animation = false;
		}

		// register event listeners
		events = options.events;
		for (eventType in events) {
			addEvent(series, eventType, events[eventType]);
		}
		if (
			(events && events.click) ||
			(options.point && options.point.events && options.point.events.click) ||
			options.allowPointSelect
		) {
			chart.runTrackerClick = true;
		}

		series.getColor();
		series.getSymbol();

		// Set the data
		each(series.parallelArrays, function (key) {
			series[key + 'Data'] = [];
		});
		series.setData(options.data, false);

		// Mark cartesian
		if (series.isCartesian) {
			chart.hasCartesianSeries = true;
		}

		// Register it in the chart
		chartSeries.push(series);
		series._i = chartSeries.length - 1;

		// Sort series according to index option (#248, #1123, #2456)
		stableSort(chartSeries, sortByIndex);
		if (this.yAxis) {
			stableSort(this.yAxis.series, sortByIndex);
		}

		each(chartSeries, function (series, i) {
			series.index = i;
			series.name = series.name || 'Series ' + (i + 1);
		});

	},

	/**
	 * Set the xAxis and yAxis properties of cartesian series, and register the series
	 * in the axis.series array
	 */
	bindAxes: function () {
		var series = this,
			seriesOptions = series.options,
			chart = series.chart,
			axisOptions;

		each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

			each(chart[AXIS], function (axis) { // loop through the chart's axis objects
				axisOptions = axis.options;

				// apply if the series xAxis or yAxis option mathches the number of the
				// axis, or if undefined, use the first axis
				if ((seriesOptions[AXIS] === axisOptions.index) ||
						(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
						(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

					// register this series in the axis.series lookup
					axis.series.push(series);

					// set this series.xAxis or series.yAxis reference
					series[AXIS] = axis;

					// mark dirty for redraw
					axis.isDirty = true;
				}
			});

			// The series needs an X and an Y axis
			if (!series[AXIS] && series.optionalAxis !== AXIS) {
				error(18, true);
			}

		});
	},

	/**
	 * For simple series types like line and column, the data values are held in arrays like
	 * xData and yData for quick lookup to find extremes and more. For multidimensional series
	 * like bubble and map, this can be extended with arrays like zData and valueData by
	 * adding to the series.parallelArrays array.
	 */
	updateParallelArrays: function (point, i) {
		var series = point.series,
			args = arguments,
			fn = typeof i === 'number' ?
				 // Insert the value in the given position
				function (key) {
					var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
					series[key + 'Data'][i] = val;
				} :
				// Apply the method specified in i with the following arguments as arguments
				function (key) {
					Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
				};

		each(series.parallelArrays, fn);
	},

	/**
	 * Return an auto incremented x value based on the pointStart and pointInterval options.
	 * This is only used if an x value is not given for the point that calls autoIncrement.
	 */
	autoIncrement: function () {

		var options = this.options,
			xIncrement = this.xIncrement,
			date,
			pointInterval,
			pointIntervalUnit = options.pointIntervalUnit;
		
		xIncrement = pick(xIncrement, options.pointStart, 0);
		
		this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
		
		// Added code for pointInterval strings
		if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
			date = new Date(xIncrement);
			date = (pointIntervalUnit === 'month') ?
				+date[setMonth](date[getMonth]() + pointInterval) :
				+date[setFullYear](date[getFullYear]() + pointInterval);
			pointInterval = date - xIncrement;
		}
		
		this.xIncrement = xIncrement + pointInterval;
		return xIncrement;
	},

	/**
	 * Divide the series data into segments divided by null values.
	 */
	getSegments: function () {
		var series = this,
			lastNull = -1,
			segments = [],
			i,
			points = series.points,
			pointsLength = points.length;

		if (pointsLength) { // no action required for []

			// if connect nulls, just remove null points
			if (series.options.connectNulls) {
				i = pointsLength;
				while (i--) {
					if (points[i].y === null) {
						points.splice(i, 1);
					}
				}
				if (points.length) {
					segments = [points];
				}

			// else, split on null points
			} else {
				each(points, function (point, i) {
					if (point.y === null) {
						if (i > lastNull + 1) {
							segments.push(points.slice(lastNull + 1, i));
						}
						lastNull = i;
					} else if (i === pointsLength - 1) { // last value
						segments.push(points.slice(lastNull + 1, i + 1));
					}
				});
			}
		}

		// register it
		series.segments = segments;
	},

	/**
	 * Set the series options by merging from the options tree
	 * @param {Object} itemOptions
	 */
	setOptions: function (itemOptions) {
		var chart = this.chart,
			chartOptions = chart.options,
			plotOptions = chartOptions.plotOptions,
			userOptions = chart.userOptions || {},
			userPlotOptions = userOptions.plotOptions || {},
			typeOptions = plotOptions[this.type],
			options,
			zones;

		this.userOptions = itemOptions;

		// General series options take precedence over type options because otherwise, default
		// type options like column.animation would be overwritten by the general option.
		// But issues have been raised here (#3881), and the solution may be to distinguish 
		// between default option and userOptions like in the tooltip below.
		options = merge(
			typeOptions,
			plotOptions.series,
			itemOptions
		);

		// The tooltip options are merged between global and series specific options
		this.tooltipOptions = merge(
			defaultOptions.tooltip,
			defaultOptions.plotOptions[this.type].tooltip,
			userOptions.tooltip,
			userPlotOptions.series && userPlotOptions.series.tooltip,
			userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
			itemOptions.tooltip
		);

		// Delete marker object if not allowed (#1125)
		if (typeOptions.marker === null) {
			delete options.marker;
		}

		// Handle color zones
		this.zoneAxis = options.zoneAxis;
		zones = this.zones = (options.zones || []).slice();
		if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
			zones.push({
				value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
				color: options.negativeColor,
				fillColor: options.negativeFillColor
			});
		}
		if (zones.length) { // Push one extra zone for the rest
			if (defined(zones[zones.length - 1].value)) {
				zones.push({
					color: this.color,
					fillColor: this.fillColor
				});
			}
		}
		return options;
	},

	getCyclic: function (prop, value, defaults) {
		var i,
			userOptions = this.userOptions,
			indexName = '_' + prop + 'Index',
			counterName = prop + 'Counter';

		if (!value) {
			if (defined(userOptions[indexName])) { // after Series.update()
				i = userOptions[indexName];
			} else {
				userOptions[indexName] = i = this.chart[counterName] % defaults.length;
				this.chart[counterName] += 1;
			}
			value = defaults[i];
		}
		this[prop] = value;
	},

	/**
	 * Get the series' color
	 */
	getColor: function () {
		if (!this.options.colorByPoint) {
			this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
		}
	},
	/**
	 * Get the series' symbol
	 */
	getSymbol: function () {
		var seriesMarkerOption = this.options.marker;

		this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

		// don't substract radius in image symbols (#604)
		if (/^url/.test(this.symbol)) {
			seriesMarkerOption.radius = 0;
		}
	},

	drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

	/**
	 * Replace the series data with a new set of data
	 * @param {Object} data
	 * @param {Object} redraw
	 */
	setData: function (data, redraw, animation, updatePoints) {
		var series = this,
			oldData = series.points,
			oldDataLength = (oldData && oldData.length) || 0,
			dataLength,
			options = series.options,
			chart = series.chart,
			firstPoint = null,
			xAxis = series.xAxis,
			hasCategories = xAxis && !!xAxis.categories,
			i,
			turboThreshold = options.turboThreshold,
			pt,
			xData = this.xData,
			yData = this.yData,
			pointArrayMap = series.pointArrayMap,
			valueCount = pointArrayMap && pointArrayMap.length;

		data = data || [];
		dataLength = data.length;
		redraw = pick(redraw, true);

		// If the point count is the same as is was, just run Point.update which is
		// cheaper, allows animation, and keeps references to points.
		if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
			each(data, function (point, i) {
				oldData[i].update(point, false, null, false);
			});

		} else {

			// Reset properties
			series.xIncrement = null;
			series.pointRange = hasCategories ? 1 : options.pointRange;

			series.colorCounter = 0; // for series with colorByPoint (#1547)
			
			// Update parallel arrays
			each(this.parallelArrays, function (key) {
				series[key + 'Data'].length = 0;
			});

			// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
			// first value is tested, and we assume that all the rest are defined the same
			// way. Although the 'for' loops are similar, they are repeated inside each
			// if-else conditional for max performance.
			if (turboThreshold && dataLength > turboThreshold) {

				// find the first non-null point
				i = 0;
				while (firstPoint === null && i < dataLength) {
					firstPoint = data[i];
					i++;
				}


				if (isNumber(firstPoint)) { // assume all points are numbers
					var x = pick(options.pointStart, 0),
						pointInterval = pick(options.pointInterval, 1);

					for (i = 0; i < dataLength; i++) {
						xData[i] = x;
						yData[i] = data[i];
						x += pointInterval;
					}
					series.xIncrement = x;
				} else if (isArray(firstPoint)) { // assume all points are arrays
					if (valueCount) { // [x, low, high] or [x, o, h, l, c]
						for (i = 0; i < dataLength; i++) {
							pt = data[i];
							xData[i] = pt[0];
							yData[i] = pt.slice(1, valueCount + 1);
						}
					} else { // [x, y]
						for (i = 0; i < dataLength; i++) {
							pt = data[i];
							xData[i] = pt[0];
							yData[i] = pt[1];
						}
					}
				} else {
					error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
				}
			} else {
				for (i = 0; i < dataLength; i++) {
					if (data[i] !== UNDEFINED) { // stray commas in oldIE
						pt = { series: series };
						series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
						series.updateParallelArrays(pt, i);
						if (hasCategories && pt.name) {
							xAxis.names[pt.x] = pt.name; // #2046
						}
					}
				}
			}

			// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
			if (isString(yData[0])) {
				error(14, true);
			}

			series.data = [];
			series.options.data = data;
			//series.zData = zData;

			// destroy old points
			i = oldDataLength;
			while (i--) {
				if (oldData[i] && oldData[i].destroy) {
					oldData[i].destroy();
				}
			}

			// reset minRange (#878)
			if (xAxis) {
				xAxis.minRange = xAxis.userMinRange;
			}

			// redraw
			series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
			animation = false;
		}

		if (redraw) {
			chart.redraw(animation);
		}
	},

	/**
	 * Process the data by cropping away unused data points if the series is longer
	 * than the crop threshold. This saves computing time for lage series.
	 */
	processData: function (force) {
		var series = this,
			processedXData = series.xData, // copied during slice operation below
			processedYData = series.yData,
			dataLength = processedXData.length,
			croppedData,
			cropStart = 0,
			cropped,
			distance,
			closestPointRange,
			xAxis = series.xAxis,
			i, // loop variable
			options = series.options,
			cropThreshold = options.cropThreshold,
			isCartesian = series.isCartesian,
			xExtremes,
			min,
			max;

		// If the series data or axes haven't changed, don't go through this. Return false to pass
		// the message on to override methods like in data grouping.
		if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
			return false;
		}

		if (xAxis) {
			xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
			min = xExtremes.min;
			max = xExtremes.max;
		}

		// optionally filter out points outside the plot area
		if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
			
			// it's outside current extremes
			if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
				processedXData = [];
				processedYData = [];

			// only crop if it's actually spilling out
			} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
				croppedData = this.cropData(series.xData, series.yData, min, max);
				processedXData = croppedData.xData;
				processedYData = croppedData.yData;
				cropStart = croppedData.start;
				cropped = true;
			}
		}


		// Find the closest distance between processed points
		for (i = processedXData.length - 1; i >= 0; i--) {
			distance = processedXData[i] - processedXData[i - 1];
			
			if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
				closestPointRange = distance;

			// Unsorted data is not supported by the line tooltip, as well as data grouping and
			// navigation in Stock charts (#725) and width calculation of columns (#1900)
			} else if (distance < 0 && series.requireSorting) {
				error(15);
			}
		}

		// Record the properties
		series.cropped = cropped; // undefined or true
		series.cropStart = cropStart;
		series.processedXData = processedXData;
		series.processedYData = processedYData;

		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = closestPointRange || 1;
		}
		series.closestPointRange = closestPointRange;

	},

	/**
	 * Iterate over xData and crop values between min and max. Returns object containing crop start/end
	 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
	 */
	cropData: function (xData, yData, min, max) {
		var dataLength = xData.length,
			cropStart = 0,
			cropEnd = dataLength,
			cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
			i;

		// iterate up to find slice start
		for (i = 0; i < dataLength; i++) {
			if (xData[i] >= min) {
				cropStart = mathMax(0, i - cropShoulder);
				break;
			}
		}

		// proceed to find slice end
		for (; i < dataLength; i++) {
			if (xData[i] > max) {
				cropEnd = i + cropShoulder;
				break;
			}
		}

		return {
			xData: xData.slice(cropStart, cropEnd),
			yData: yData.slice(cropStart, cropEnd),
			start: cropStart,
			end: cropEnd
		};
	},


	/**
	 * Generate the data point after the data has been processed by cropping away
	 * unused points and optionally grouped in Highcharts Stock.
	 */
	generatePoints: function () {
		var series = this,
			options = series.options,
			dataOptions = options.data,
			data = series.data,
			dataLength,
			processedXData = series.processedXData,
			processedYData = series.processedYData,
			pointClass = series.pointClass,
			processedDataLength = processedXData.length,
			cropStart = series.cropStart || 0,
			cursor,
			hasGroupedData = series.hasGroupedData,
			point,
			points = [],
			i;

		if (!data && !hasGroupedData) {
			var arr = [];
			arr.length = dataOptions.length;
			data = series.data = arr;
		}

		for (i = 0; i < processedDataLength; i++) {
			cursor = cropStart + i;
			if (!hasGroupedData) {
				if (data[cursor]) {
					point = data[cursor];
				} else if (dataOptions[cursor] !== UNDEFINED) { // #970
					data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
				}
				points[i] = point;
			} else {
				// splat the y data in case of ohlc data array
				points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
			}
			points[i].index = cursor; // For faster access in Point.update
		}

		// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
		// swithching view from non-grouped data to grouped data (#637)
		if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
			for (i = 0; i < dataLength; i++) {
				if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
					i += processedDataLength;
				}
				if (data[i]) {
					data[i].destroyElements();
					data[i].plotX = UNDEFINED; // #1003
				}
			}
		}

		series.data = data;
		series.points = points;
	},

	/**
	 * Calculate Y extremes for visible data
	 */
	getExtremes: function (yData) {
		var xAxis = this.xAxis,
			yAxis = this.yAxis,
			xData = this.processedXData,
			yDataLength,
			activeYData = [],
			activeCounter = 0,
			xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
			xMin = xExtremes.min,
			xMax = xExtremes.max,
			validValue,
			withinRange,
			dataMin,
			dataMax,
			x,
			y,
			i,
			j;

		yData = yData || this.stackedYData || this.processedYData;
		yDataLength = yData.length;

		for (i = 0; i < yDataLength; i++) {

			x = xData[i];
			y = yData[i];

			// For points within the visible range, including the first point outside the
			// visible range, consider y extremes
			validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
			withinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin &&
				(xData[i - 1] || x) <= xMax);

			if (validValue && withinRange) {

				j = y.length;
				if (j) { // array, like ohlc or range data
					while (j--) {
						if (y[j] !== null) {
							activeYData[activeCounter++] = y[j];
						}
					}
				} else {
					activeYData[activeCounter++] = y;
				}
			}
		}
		this.dataMin = pick(dataMin, arrayMin(activeYData));
		this.dataMax = pick(dataMax, arrayMax(activeYData));
	},

	/**
	 * Translate data points from raw data values to chart specific positioning data
	 * needed later in drawPoints, drawGraph and drawTracker.
	 */
	translate: function () {
		if (!this.processedXData) { // hidden series
			this.processData();
		}
		this.generatePoints();
		var series = this,
			options = series.options,
			stacking = options.stacking,
			xAxis = series.xAxis,
			categories = xAxis.categories,
			yAxis = series.yAxis,
			points = series.points,
			dataLength = points.length,
			hasModifyValue = !!series.modifyValue,
			i,
			pointPlacement = options.pointPlacement,
			dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
			threshold = options.threshold,
			plotX,
			plotY,
			lastPlotX,
			closestPointRangePx = Number.MAX_VALUE;

		// Translate each point
		for (i = 0; i < dataLength; i++) {
			var point = points[i],
				xValue = point.x,
				yValue = point.y,
				yBottom = point.low,
				stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],
				pointStack,
				stackValues;

			// Discard disallowed y values for log axes (#3434)
			if (yAxis.isLog && yValue !== null && yValue <= 0) {
				point.y = yValue = null;
				error(10);
			}

			// Get the plotX translation
			point.plotX = plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591


			// Calculate the bottom y value for stacked series
			if (stacking && series.visible && stack && stack[xValue]) {

				pointStack = stack[xValue];
				stackValues = pointStack.points[series.index + ',' + i];
				yBottom = stackValues[0];
				yValue = stackValues[1];

				if (yBottom === 0) {
					yBottom = pick(threshold, yAxis.min);
				}
				if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
					yBottom = null;
				}

				point.total = point.stackTotal = pointStack.total;
				point.percentage = pointStack.total && (point.y / pointStack.total * 100);
				point.stackY = yValue;

				// Place the stack label
				pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

			}

			// Set translated yBottom or remove it
			point.yBottom = defined(yBottom) ?
				yAxis.translate(yBottom, 0, 1, 0, 1) :
				null;

			// general hook, used for Highstock compare mode
			if (hasModifyValue) {
				yValue = series.modifyValue(yValue, point);
			}

			// Set the the plotY value, reset it for redraws
			point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
				mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
				UNDEFINED;
			point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
				plotX >= 0 && plotX <= xAxis.len;


			// Set client related positions for mouse tracking
			point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

			point.negative = point.y < (threshold || 0);

			// some API data
			point.category = categories && categories[point.x] !== UNDEFINED ?
				categories[point.x] : point.x;

			// Determine auto enabling of markers (#3635)
			if (i) {
				closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
			}
			lastPlotX = plotX;

		}

		series.closestPointRangePx = closestPointRangePx;

		// now that we have the cropped data, build the segments
		series.getSegments();
	},

	/**
	 * Set the clipping for the series. For animated series it is called twice, first to initiate
	 * animating the clip then the second time without the animation to set the final clip.
	 */
	setClip: function (animation) {
		var chart = this.chart,
			renderer = chart.renderer,
			inverted = chart.inverted,
			seriesClipBox = this.clipBox,
			clipBox = seriesClipBox || chart.clipBox,
			sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),
			clipRect = chart[sharedClipKey],
			markerClipRect = chart[sharedClipKey + 'm'];

		// If a clipping rectangle with the same properties is currently present in the chart, use that.
		if (!clipRect) {

			// When animation is set, prepare the initial positions
			if (animation) { 
				clipBox.width = 0;

				chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
					-99, // include the width of the first marker
					inverted ? -chart.plotLeft : -chart.plotTop,
					99,
					inverted ? chart.chartWidth : chart.chartHeight
				);
			}
			chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
			
		}
		if (animation) {
			clipRect.count += 1;
		}

		if (this.options.clip !== false) {
			this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
			this.markerGroup.clip(markerClipRect);
			this.sharedClipKey = sharedClipKey;
		}

		// Remove the shared clipping rectancgle when all series are shown
		if (!animation) {
			clipRect.count -= 1;
			if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
				if (!seriesClipBox) {
					chart[sharedClipKey] = chart[sharedClipKey].destroy();
				}
				if (chart[sharedClipKey + 'm']) {
					chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
				}
			}
		}
	},

	/**
	 * Animate in the series
	 */
	animate: function (init) {
		var series = this,
			chart = series.chart,
			clipRect,
			animation = series.options.animation,
			sharedClipKey;

		// Animation option is set to true
		if (animation && !isObject(animation)) {
			animation = defaultPlotOptions[series.type].animation;
		}

		// Initialize the animation. Set up the clipping rectangle.
		if (init) {

			series.setClip(animation);

		// Run the animation
		} else {
			sharedClipKey = this.sharedClipKey;
			clipRect = chart[sharedClipKey];
			if (clipRect) {
				clipRect.animate({
					width: chart.plotSizeX
				}, animation);
			}
			if (chart[sharedClipKey + 'm']) {
				chart[sharedClipKey + 'm'].animate({
					width: chart.plotSizeX + 99
				}, animation);
			}

			// Delete this function to allow it only once
			series.animate = null;
 
		}
	},

	/**
	 * This runs after animation to land on the final plot clipping
	 */
	afterAnimate: function () {
		this.setClip();
		fireEvent(this, 'afterAnimate');
	},

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			points = series.points,
			chart = series.chart,
			plotX,
			plotY,
			i,
			point,
			radius,
			symbol,
			isImage,
			graphic,
			options = series.options,
			seriesMarkerOptions = options.marker,
			seriesPointAttr = series.pointAttr[''],
			pointMarkerOptions,
			hasPointMarker,
			enabled,
			isInside,
			markerGroup = series.markerGroup,
			xAxis = series.xAxis,
			globallyEnabled = pick(
				seriesMarkerOptions.enabled, 
				xAxis.isRadial,
				series.closestPointRangePx > 2 * seriesMarkerOptions.radius
			);

		if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

			i = points.length;
			while (i--) {
				point = points[i];
				plotX = mathFloor(point.plotX); // #1843
				plotY = point.plotY;
				graphic = point.graphic;
				pointMarkerOptions = point.marker || {};
				hasPointMarker = !!point.marker;
				enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
				isInside = point.isInside;

				// only draw the point if y is defined
				if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

					// shortcuts
					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
					radius = pointAttr.r;
					symbol = pick(pointMarkerOptions.symbol, series.symbol);
					isImage = symbol.indexOf('url') === 0;

					if (graphic) { // update
						graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
							.animate(extend({
								x: plotX - radius,
								y: plotY - radius
							}, graphic.symbolName ? { // don't apply to image symbols #507
								width: 2 * radius,
								height: 2 * radius
							} : {}));
					} else if (isInside && (radius > 0 || isImage)) {
						point.graphic = graphic = chart.renderer.symbol(
							symbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius,
							hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
						)
						.attr(pointAttr)
						.add(markerGroup);
					}

				} else if (graphic) {
					point.graphic = graphic.destroy(); // #1269
				}
			}
		}

	},

	/**
	 * Convert state properties from API naming conventions to SVG attributes
	 *
	 * @param {Object} options API options object
	 * @param {Object} base1 SVG attribute object to inherit from
	 * @param {Object} base2 Second level SVG attribute object to inherit from
	 */
	convertAttribs: function (options, base1, base2, base3) {
		var conversion = this.pointAttrToOptions,
			attr,
			option,
			obj = {};

		options = options || {};
		base1 = base1 || {};
		base2 = base2 || {};
		base3 = base3 || {};

		for (attr in conversion) {
			option = conversion[attr];
			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
		}
		return obj;
	},

	/**
	 * Get the state attributes. Each series type has its own set of attributes
	 * that are allowed to change on a point's state change. Series wide attributes are stored for
	 * all series, and additionally point specific attributes are stored for all
	 * points with individual marker options. If such options are not defined for the point,
	 * a reference to the series wide attributes is stored in point.pointAttr.
	 */
	getAttribs: function () {
		var series = this,
			seriesOptions = series.options,
			normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
			stateOptions = normalOptions.states,
			stateOptionsHover = stateOptions[HOVER_STATE],
			pointStateOptionsHover,
			seriesColor = series.color,
			seriesNegativeColor = series.options.negativeColor,
			normalDefaults = {
				stroke: seriesColor,
				fill: seriesColor
			},
			points = series.points || [], // #927
			i,
			point,
			seriesPointAttr = [],
			pointAttr,
			pointAttrToOptions = series.pointAttrToOptions,
			hasPointSpecificOptions = series.hasPointSpecificOptions,
			defaultLineColor = normalOptions.lineColor,
			defaultFillColor = normalOptions.fillColor,
			turboThreshold = seriesOptions.turboThreshold,
			zones = series.zones,
			zoneAxis = series.zoneAxis || 'y',
			attr,
			key;

		// series type specific modifications
		if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

			// if no hover radius is given, default to normal radius + 2
			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

		} else { // column, bar, pie

			// if no hover color is given, brighten the normal color
			stateOptionsHover.color = stateOptionsHover.color ||
				Color(stateOptionsHover.color || seriesColor)
					.brighten(stateOptionsHover.brightness).get();

			// if no hover negativeColor is given, brighten the normal negativeColor
			stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
				Color(stateOptionsHover.negativeColor || seriesNegativeColor)
					.brighten(stateOptionsHover.brightness).get();
		}

		// general point attributes for the series normal state
		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
		each([HOVER_STATE, SELECT_STATE], function (state) {
			seriesPointAttr[state] =
					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
		});

		// set it
		series.pointAttr = seriesPointAttr;


		// Generate the point-specific attribute collections if specific point
		// options are given. If not, create a referance to the series wide point
		// attributes
		i = points.length;
		if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
			while (i--) {
				point = points[i];
				normalOptions = (point.options && point.options.marker) || point.options;
				if (normalOptions && normalOptions.enabled === false) {
					normalOptions.radius = 0;
				}

				if (zones.length) {
					var j = 0,
						threshold = zones[j];
					while (point[zoneAxis] >= threshold.value) {				
						threshold = zones[++j];
					}
					
					point.color = point.fillColor = threshold.color;
				}

				hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

				// check if the point has specific visual options
				if (point.options) {
					for (key in pointAttrToOptions) {
						if (defined(normalOptions[pointAttrToOptions[key]])) {
							hasPointSpecificOptions = true;
						}
					}
				}

				// a specific marker config object is defined for the individual point:
				// create it's own attribute collection
				if (hasPointSpecificOptions) {
					normalOptions = normalOptions || {};
					pointAttr = [];
					stateOptions = normalOptions.states || {}; // reassign for individual point
					pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

					// Handle colors for column and pies
					if (!seriesOptions.marker) { // column, bar, point
						// If no hover color is given, brighten the normal color. #1619, #2579
						pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
							Color(point.color)
								.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
								.get();
					}

					// normal point state inherits series wide normal state
					attr = { color: point.color }; // #868
					if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
						attr.fillColor = point.color;
					}
					if (!defaultLineColor) {
						attr.lineColor = point.color; // Bubbles take point color, line markers use white
					}
					pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

					// inherit from point normal and series hover
					pointAttr[HOVER_STATE] = series.convertAttribs(
						stateOptions[HOVER_STATE],
						seriesPointAttr[HOVER_STATE],
						pointAttr[NORMAL_STATE]
					);

					// inherit from point normal and series hover
					pointAttr[SELECT_STATE] = series.convertAttribs(
						stateOptions[SELECT_STATE],
						seriesPointAttr[SELECT_STATE],
						pointAttr[NORMAL_STATE]
					);


				// no marker config object is created: copy a reference to the series-wide
				// attribute collection
				} else {
					pointAttr = seriesPointAttr;
				}

				point.pointAttr = pointAttr;
			}
		}
	},

	/**
	 * Clear DOM objects and free up memory
	 */
	destroy: function () {
		var series = this,
			chart = series.chart,
			issue134 = /AppleWebKit\/533/.test(userAgent),
			destroy,
			i,
			data = series.data || [],
			point,
			prop,
			axis;

		// add event hook
		fireEvent(series, 'destroy');

		// remove all events
		removeEvent(series);

		// erase from axes
		each(series.axisTypes || [], function (AXIS) {
			axis = series[AXIS];
			if (axis) {
				erase(axis.series, series);
				axis.isDirty = axis.forceRedraw = true;
			}
		});

		// remove legend items
		if (series.legendItem) {
			series.chart.legend.destroyItem(series);
		}

		// destroy all points with their elements
		i = data.length;
		while (i--) {
			point = data[i];
			if (point && point.destroy) {
				point.destroy();
			}
		}
		series.points = null;

		// Clear the animation timeout if we are destroying the series during initial animation
		clearTimeout(series.animationTimeout);

		// destroy all SVGElements associated to the series
		each(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',
				'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {
			if (series[prop]) {

				// issue 134 workaround
				destroy = issue134 && prop === 'group' ?
					'hide' :
					'destroy';

				series[prop][destroy]();
			}
		});

		// remove from hoverSeries
		if (chart.hoverSeries === series) {
			chart.hoverSeries = null;
		}
		erase(chart.series, series);

		// clear all members
		for (prop in series) {
			delete series[prop];
		}
	},

	/**
	 * Return the graph path of a segment
	 */
	getSegmentPath: function (segment) {
		var series = this,
			segmentPath = [],
			step = series.options.step;

		// build the segment line
		each(segment, function (point, i) {

			var plotX = point.plotX,
				plotY = point.plotY,
				lastPoint;

			if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
				segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

			} else {

				// moveTo or lineTo
				segmentPath.push(i ? L : M);

				// step line?
				if (step && i) {
					lastPoint = segment[i - 1];
					if (step === 'right') {
						segmentPath.push(
							lastPoint.plotX,
							plotY
						);

					} else if (step === 'center') {
						segmentPath.push(
							(lastPoint.plotX + plotX) / 2,
							lastPoint.plotY,
							(lastPoint.plotX + plotX) / 2,
							plotY
						);

					} else {
						segmentPath.push(
							plotX,
							lastPoint.plotY
						);
					}
				}

				// normal line to next point
				segmentPath.push(
					point.plotX,
					point.plotY
				);
			}
		});

		return segmentPath;
	},

	/**
	 * Get the graph path
	 */
	getGraphPath: function () {
		var series = this,
			graphPath = [],
			segmentPath,
			singlePoints = []; // used in drawTracker

		// Divide into segments and build graph and area paths
		each(series.segments, function (segment) {

			segmentPath = series.getSegmentPath(segment);

			// add the segment to the graph, or a single point for tracking
			if (segment.length > 1) {
				graphPath = graphPath.concat(segmentPath);
			} else {
				singlePoints.push(segment[0]);
			}
		});

		// Record it for use in drawGraph and drawTracker, and return graphPath
		series.singlePoints = singlePoints;
		series.graphPath = graphPath;

		return graphPath;

	},

	/**
	 * Draw the actual graph
	 */
	drawGraph: function () {
		var series = this,
			options = this.options,
			props = [['graph', options.lineColor || this.color, options.dashStyle]],
			lineWidth = options.lineWidth,
			roundCap = options.linecap !== 'square',
			graphPath = this.getGraphPath(),
			fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
			zones = this.zones;

		each(zones, function (threshold, i) {
			props.push(['colorGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
		});
		
		// Draw the graph
		each(props, function (prop, i) {
			var graphKey = prop[0],
				graph = series[graphKey],
				attribs;

			if (graph) {
				stop(graph); // cancel running animations, #459
				graph.animate({ d: graphPath });

			} else if ((lineWidth || fillColor) && graphPath.length) { // #1487
				attribs = {
					stroke: prop[1],
					'stroke-width': lineWidth,
					fill: fillColor,
					zIndex: 1 // #1069
				};
				if (prop[2]) {
					attribs.dashstyle = prop[2];
				} else if (roundCap) {
					attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
				}

				series[graphKey] = series.chart.renderer.path(graphPath)
					.attr(attribs)
					.add(series.group)
					.shadow(!i && options.shadow);
			}
		});
	},

	/**
	 * Clip the graphs into the positive and negative coloured graphs
	 */
	applyZones: function () {
		var series = this,
			chart = this.chart,
			renderer = chart.renderer,
			zones = this.zones,
			translatedFrom,
			translatedTo,
			clips = this.clips || [],
			clipAttr,
			graph = this.graph,
			area = this.area,
			chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
			zoneAxis = this.zoneAxis || 'y',
			axis = this[zoneAxis + 'Axis'],
			reversed = axis.reversed,
			horiz = axis.horiz,
			ignoreZones = false;

		if (zones.length && (graph || area)) {
			// The use of the Color Threshold assumes there are no gaps
			// so it is safe to hide the original graph and area
			graph.hide();
			if (area) { area.hide(); }

			// Create the clips
			each(zones, function (threshold, i) {
				translatedFrom = pick(translatedTo, (reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : axis.toPixels(axis.min))));
				translatedTo = mathRound(axis.toPixels(pick(threshold.value, axis.max), true));

				if (ignoreZones) {
					translatedFrom = translatedTo = axis.toPixels(axis.max);
				}

				if (axis.isXAxis) {
					clipAttr = {
						x: reversed ? translatedTo : translatedFrom,
						y: 0,
						width: Math.abs(translatedFrom - translatedTo), 
						height: chartSizeMax
					};
					if (!horiz) {
						clipAttr.x = chart.plotHeight - clipAttr.x;
					}
				} else {
					clipAttr = {
						x: 0,
						y: reversed ? translatedFrom : translatedTo,
						width: chartSizeMax, 
						height: Math.abs(translatedFrom - translatedTo)
					};
					if (horiz) {
						clipAttr.y = chart.plotWidth - clipAttr.y;
					}
				} 

				/// VML SUPPPORT
				if (chart.inverted && renderer.isVML) {
					if (axis.isXAxis) {			
						clipAttr = {
							x: 0,
							y: reversed ? translatedFrom : translatedTo,
							height: clipAttr.width,
							width: chart.chartWidth
						};		
					} else {				
						clipAttr = {
							x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
							y: 0,
							width: clipAttr.height,
							height: chart.chartHeight
						};	
					}				
				}
				/// END OF VML SUPPORT

				if (clips[i]) {
					clips[i].animate(clipAttr);
				} else {
					clips[i] = renderer.clipRect(clipAttr);

					series['colorGraph' + i].clip(clips[i]);

					if (area) {
						series['colorArea' + i].clip(clips[i]);
					}
				}
				// if this zone extends out of the axis, ignore the others
				ignoreZones = threshold.value > axis.max;
			});
			this.clips = clips;
		}
	},

	/**
	 * Initialize and perform group inversion on series.group and series.markerGroup
	 */
	invertGroups: function () {
		var series = this,
			chart = series.chart;

		// Pie, go away (#1736)
		if (!series.xAxis) {
			return;
		}

		// A fixed size is needed for inversion to work
		function setInvert() {
			var size = {
				width: series.yAxis.len,
				height: series.xAxis.len
			};

			each(['group', 'markerGroup'], function (groupName) {
				if (series[groupName]) {
					series[groupName].attr(size).invert();
				}
			});
		}

		addEvent(chart, 'resize', setInvert); // do it on resize
		addEvent(series, 'destroy', function () {
			removeEvent(chart, 'resize', setInvert);
		});

		// Do it now
		setInvert(); // do it now

		// On subsequent render and redraw, just do setInvert without setting up events again
		series.invertGroups = setInvert;
	},

	/**
	 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
	 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
	 */
	plotGroup: function (prop, name, visibility, zIndex, parent) {
		var group = this[prop],
			isNew = !group;

		// Generate it on first call
		if (isNew) {
			this[prop] = group = this.chart.renderer.g(name)
				.attr({
					visibility: visibility,
					zIndex: zIndex || 0.1 // IE8 needs this
				})
				.add(parent);
		}
		// Place it on first and subsequent (redraw) calls
		group[isNew ? 'attr' : 'animate'](this.getPlotBox());
		return group;
	},

	/**
	 * Get the translation and scale for the plot area of this series
	 */
	getPlotBox: function () {
		var chart = this.chart,
			xAxis = this.xAxis,
			yAxis = this.yAxis;

		// Swap axes for inverted (#2339)
		if (chart.inverted) {
			xAxis = yAxis;
			yAxis = this.xAxis;
		}
		return {
			translateX: xAxis ? xAxis.left : chart.plotLeft,
			translateY: yAxis ? yAxis.top : chart.plotTop,
			scaleX: 1, // #1623
			scaleY: 1
		};
	},

	/**
	 * Render the graph and markers
	 */
	render: function () {
		var series = this,
			chart = series.chart,
			group,
			options = series.options,
			animation = options.animation,
			// Animation doesn't work in IE8 quirks when the group div is hidden,
			// and looks bad in other oldIE
			animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
			visibility = series.visible ? VISIBLE : HIDDEN,
			zIndex = options.zIndex,
			hasRendered = series.hasRendered,
			chartSeriesGroup = chart.seriesGroup;

		// the group
		group = series.plotGroup(
			'group',
			'series',
			visibility,
			zIndex,
			chartSeriesGroup
		);

		series.markerGroup = series.plotGroup(
			'markerGroup',
			'markers',
			visibility,
			zIndex,
			chartSeriesGroup
		);

		// initiate the animation
		if (animDuration) {
			series.animate(true);
		}

		// cache attributes for shapes
		series.getAttribs();

		// SVGRenderer needs to know this before drawing elements (#1089, #1795)
		group.inverted = series.isCartesian ? chart.inverted : false;

		// draw the graph if any
		if (series.drawGraph) {
			series.drawGraph();
			series.applyZones();
		}

		each(series.points, function (point) {
			if (point.redraw) {
				point.redraw();
			}
		});

		// draw the data labels (inn pies they go before the points)
		if (series.drawDataLabels) {
			series.drawDataLabels();
		}

		// draw the points
		if (series.visible) {
			series.drawPoints();
		}


		// draw the mouse tracking area
		if (series.drawTracker && series.options.enableMouseTracking !== false) {
			series.drawTracker();
		}

		// Handle inverted series and tracker groups
		if (chart.inverted) {
			series.invertGroups();
		}

		// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
		if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
			group.clip(chart.clipRect);
		}

		// Run the animation
		if (animDuration) {
			series.animate();
		} 

		// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
		// which should be available to the user).
		if (!hasRendered) {
			if (animDuration) {
				series.animationTimeout = setTimeout(function () {
					series.afterAnimate();
				}, animDuration);
			} else {
				series.afterAnimate();
			}
		}

		series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
		series.hasRendered = true;
	},

	/**
	 * Redraw the series after an update in the axes.
	 */
	redraw: function () {
		var series = this,
			chart = series.chart,
			wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
			group = series.group,
			xAxis = series.xAxis,
			yAxis = series.yAxis;

		// reposition on resize
		if (group) {
			if (chart.inverted) {
				group.attr({
					width: chart.plotWidth,
					height: chart.plotHeight
				});
			}

			group.animate({
				translateX: pick(xAxis && xAxis.left, chart.plotLeft),
				translateY: pick(yAxis && yAxis.top, chart.plotTop)
			});
		}

		series.translate();
		series.render();

		if (wasDirtyData) {
			delete this.kdTree; // #3868 recalculate the kdtree with dirty data
			fireEvent(series, 'updatedData');
		}
	},

	/**
	 * KD Tree && PointSearching Implementation
	 */

	kdDimensions: 1,
	kdTree: null,
	kdAxisArray: ['plotX', 'plotY'],
	kdComparer: 'distX',

	searchPoint: function (e) {
		var series = this,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			inverted = series.chart.inverted;
		
		e.plotX = inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos;
		e.plotY = inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos;

		return this.searchKDTree(e);
	},

	buildKDTree: function () {
		var series = this,
			dimensions = series.kdDimensions;

		// Internal function
		function _kdtree(points, depth, dimensions) {
			var axis, median, length = points && points.length;

			if (length) {

				// alternate between the axis
				axis = series.kdAxisArray[depth % dimensions];

				// sort point array
				points.sort(function(a, b) {
					return a[axis] - b[axis];
				});
			
				median = Math.floor(length / 2);
				
				// build and return node
				return {
					point: points[median],
					left: _kdtree(points.slice(0, median), depth + 1, dimensions),
					right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
				};
			
			}
		}

		// Start the recursive build process with a clone of the points array (#3873)
		function startRecursive() {
			series.kdTree = _kdtree(series.points.slice(), dimensions, dimensions);		
		}

		delete series.kdTree;
		
		if (series.options.kdSync) {  // For testing tooltips, don't build async
			startRecursive();
		} else {
			setTimeout(startRecursive);
		}
	},

	searchKDTree: function (point) {
		var series = this,
			kdComparer = this.kdComparer,
			kdX = this.kdAxisArray[0],
			kdY = this.kdAxisArray[1];

		// Internal function
		function _distance(p1, p2) {
			var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
				y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
				r = (x || 0) + (y || 0);
				
			return {
				distX: defined(x) ? Math.sqrt(x) : Number.MAX_VALUE,
				distY: defined(y) ? Math.sqrt(y) : Number.MAX_VALUE,
				distR: defined(r) ? Math.sqrt(r) : Number.MAX_VALUE
			};
		}
		function _search(search, tree, depth, dimensions) {
			var point = tree.point,
				axis = series.kdAxisArray[depth % dimensions],
				tdist,
				sideA,
				sideB,
				ret = point,
				nPoint1,
				nPoint2;
			point.dist = _distance(search, point);

			// Pick side based on distance to splitting point
			tdist = search[axis] - point[axis];
			sideA = tdist < 0 ? 'left' : 'right';

			// End of tree
			if (tree[sideA]) {
				nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);

				ret = (nPoint1.dist[kdComparer] < ret.dist[kdComparer] ? nPoint1 : point);

				sideB = tdist < 0 ? 'right' : 'left';
				if (tree[sideB]) {
					// compare distance to current best to splitting point to decide wether to check side B or not
					if (Math.sqrt(tdist*tdist) < ret.dist[kdComparer]) {
						nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
						ret = (nPoint2.dist[kdComparer] < ret.dist[kdComparer] ? nPoint2 : ret);
					}
				}
			}
			return ret;
		}

		if (!this.kdTree) {
			this.buildKDTree();
		}

		if (this.kdTree) {
			return _search(point, 
				this.kdTree, this.kdDimensions, this.kdDimensions);
		}
	}

}; // end Series prototype

/**
 * The class for stack items
 */
function StackItem(axis, options, isNegative, x, stackOption) {
	
	var inverted = axis.chart.inverted;

	this.axis = axis;

	// Tells if the stack is negative
	this.isNegative = isNegative;

	// Save the options to be able to style the label
	this.options = options;

	// Save the x value to be able to position the label later
	this.x = x;

	// Initialize total value
	this.total = null;

	// This will keep each points' extremes stored by series.index and point index
	this.points = {};

	// Save the stack option on the series configuration object, and whether to treat it as percent
	this.stack = stackOption;

	// The align options and text align varies on whether the stack is negative and
	// if the chart is inverted or not.
	// First test the user supplied value, then use the dynamic.
	this.alignOptions = {
		align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
		verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
		y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
		x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
	};

	this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
}

StackItem.prototype = {
	destroy: function () {
		destroyObjectProperties(this, this.axis);
	},

	/**
	 * Renders the stack total label and adds it to the stack label group.
	 */
	render: function (group) {
		var options = this.options,
			formatOption = options.format,
			str = formatOption ?
				format(formatOption, this) : 
				options.formatter.call(this);  // format the text in the label

		// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
		if (this.label) {
			this.label.attr({text: str, visibility: HIDDEN});
		// Create new label
		} else {
			this.label =
				this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
					.css(options.style)				// apply style
					.attr({
						align: this.textAlign,				// fix the text-anchor
						rotation: options.rotation,	// rotation
						visibility: HIDDEN					// hidden until setOffset is called
					})				
					.add(group);							// add to the labels-group
		}
	},

	/**
	 * Sets the offset that the stack has from the x value and repositions the label.
	 */
	setOffset: function (xOffset, xWidth) {
		var stackItem = this,
			axis = stackItem.axis,
			chart = axis.chart,
			inverted = chart.inverted,
			neg = this.isNegative,							// special treatment is needed for negative stacks
			y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
			yZero = axis.translate(0),						// stack origin
			h = mathAbs(y - yZero),							// stack height
			x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
			plotHeight = chart.plotHeight,
			stackBox = {	// this is the box for the complete stack
				x: inverted ? (neg ? y : y - h) : x,
				y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
				width: inverted ? h : xWidth,
				height: inverted ? xWidth : h
			},
			label = this.label,
			alignAttr;
		
		if (label) {
			label.align(this.alignOptions, null, stackBox);	// align the label to the box
				
			// Set visibility (#678)
			alignAttr = label.alignAttr;
			label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
		}
	}
};


// Stacking methods defined on the Axis prototype

/**
 * Build the stacks from top down
 */
Axis.prototype.buildStacks = function () {
	var series = this.series,
		reversedStacks = pick(this.options.reversedStacks, true),
		i = series.length;
	if (!this.isXAxis) {
		this.usePercentage = false;
		while (i--) {
			series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
		}
		// Loop up again to compute percent stack
		if (this.usePercentage) {
			for (i = 0; i < series.length; i++) {
				series[i].setPercentStacks();
			}
		}
	}
};

Axis.prototype.renderStackTotals = function () {
	var axis = this,
		chart = axis.chart,
		renderer = chart.renderer,
		stacks = axis.stacks,
		stackKey, 
		oneStack, 
		stackCategory,
		stackTotalGroup = axis.stackTotalGroup;

	// Create a separate group for the stack total labels
	if (!stackTotalGroup) {
		axis.stackTotalGroup = stackTotalGroup =
			renderer.g('stack-labels')
				.attr({
					visibility: VISIBLE,
					zIndex: 6
				})
				.add();
	}

	// plotLeft/Top will change when y axis gets wider so we need to translate the
	// stackTotalGroup at every render call. See bug #506 and #516
	stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

	// Render each stack total
	for (stackKey in stacks) {
		oneStack = stacks[stackKey];
		for (stackCategory in oneStack) {
			oneStack[stackCategory].render(stackTotalGroup);
		}
	}
};


// Stacking methods defnied for Series prototype

/**
 * Adds series' points value to corresponding stack
 */
Series.prototype.setStackedPoints = function () {
	if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
		return;
	}

	var series = this,
		xData = series.processedXData,
		yData = series.processedYData,
		stackedYData = [],
		yDataLength = yData.length,
		seriesOptions = series.options,
		threshold = seriesOptions.threshold,
		stackOption = seriesOptions.stack,
		stacking = seriesOptions.stacking,
		stackKey = series.stackKey,
		negKey = '-' + stackKey,
		negStacks = series.negStacks,
		yAxis = series.yAxis,
		stacks = yAxis.stacks,
		oldStacks = yAxis.oldStacks,
		isNegative,
		stack,
		other,
		key,
		pointKey,
		i,
		x,
		y;

	// loop over the non-null y values and read them into a local array
	for (i = 0; i < yDataLength; i++) {
		x = xData[i];
		y = yData[i];
		pointKey = series.index + ',' + i;

		// Read stacked values into a stack based on the x value,
		// the sign of y and the stack key. Stacking is also handled for null values (#739)
		isNegative = negStacks && y < threshold;
		key = isNegative ? negKey : stackKey;

		// Create empty object for this stack if it doesn't exist yet
		if (!stacks[key]) {
			stacks[key] = {};
		}

		// Initialize StackItem for this x
		if (!stacks[key][x]) {
			if (oldStacks[key] && oldStacks[key][x]) {
				stacks[key][x] = oldStacks[key][x];
				stacks[key][x].total = null;
			} else {
				stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
			}
		}

		// If the StackItem doesn't exist, create it first
		stack = stacks[key][x];
		stack.points[pointKey] = [stack.cum || 0];

		// Add value to the stack total
		if (stacking === 'percent') {

			// Percent stacked column, totals are the same for the positive and negative stacks
			other = isNegative ? stackKey : negKey;
			if (negStacks && stacks[other] && stacks[other][x]) {
				other = stacks[other][x];
				stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

			// Percent stacked areas
			} else {
				stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
			}
		} else {
			stack.total = correctFloat(stack.total + (y || 0));
		}

		stack.cum = (stack.cum || 0) + (y || 0);

		stack.points[pointKey].push(stack.cum);
		stackedYData[i] = stack.cum;

	}

	if (stacking === 'percent') {
		yAxis.usePercentage = true;
	}

	this.stackedYData = stackedYData; // To be used in getExtremes

	// Reset old stacks
	yAxis.oldStacks = {};
};

/**
 * Iterate over all stacks and compute the absolute values to percent
 */
Series.prototype.setPercentStacks = function () {
	var series = this,
		stackKey = series.stackKey,
		stacks = series.yAxis.stacks,
		processedXData = series.processedXData;

	each([stackKey, '-' + stackKey], function (key) {
		var i = processedXData.length,
			x,
			stack,
			pointExtremes,
			totalFactor;

		while (i--) {
			x = processedXData[i];
			stack = stacks[key] && stacks[key][x];
			pointExtremes = stack && stack.points[series.index + ',' + i];
			if (pointExtremes) {
				totalFactor = stack.total ? 100 / stack.total : 0;
				pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
				pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
				series.stackedYData[i] = pointExtremes[1];
			}
		}
	});
};

// Extend the Chart prototype for dynamic methods
extend(Chart.prototype, {

	/**
	 * Add a series dynamically after  time
	 *
	 * @param {Object} options The config options
	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 * @return {Object} series The newly created series object
	 */
	addSeries: function (options, redraw, animation) {
		var series,
			chart = this;

		if (options) {
			redraw = pick(redraw, true); // defaults to true

			fireEvent(chart, 'addSeries', { options: options }, function () {
				series = chart.initSeries(options);

				chart.isDirtyLegend = true; // the series array is out of sync with the display
				chart.linkSeries();
				if (redraw) {
					chart.redraw(animation);
				}
			});
		}

		return series;
	},

	/**
     * Add an axis to the chart
     * @param {Object} options The axis option
     * @param {Boolean} isX Whether it is an X axis or a value axis
     */
	addAxis: function (options, isX, redraw, animation) {
		var key = isX ? 'xAxis' : 'yAxis',
			chartOptions = this.options,
			axis;

		/*jslint unused: false*/
		axis = new Axis(this, merge(options, {
			index: this[key].length,
			isX: isX
		}));
		/*jslint unused: true*/

		// Push the new axis options to the chart options
		chartOptions[key] = splat(chartOptions[key] || {});
		chartOptions[key].push(options);

		if (pick(redraw, true)) {
			this.redraw(animation);
		}
	},

	/**
	 * Dim the chart and show a loading text or symbol
	 * @param {String} str An optional text to show in the loading label instead of the default one
	 */
	showLoading: function (str) {
		var chart = this,
			options = chart.options,
			loadingDiv = chart.loadingDiv,
			loadingOptions = options.loading,
			setLoadingSize = function () {
				if (loadingDiv) {
					css(loadingDiv, {
						left: chart.plotLeft + PX,
						top: chart.plotTop + PX,
						width: chart.plotWidth + PX,
						height: chart.plotHeight + PX
					});
				}
			};

		// create the layer at the first call
		if (!loadingDiv) {
			chart.loadingDiv = loadingDiv = createElement(DIV, {
				className: PREFIX + 'loading'
			}, extend(loadingOptions.style, {
				zIndex: 10,
				display: NONE
			}), chart.container);

			chart.loadingSpan = createElement(
				'span',
				null,
				loadingOptions.labelStyle,
				loadingDiv
			);
			addEvent(chart, 'redraw', setLoadingSize); // #1080
		}

		// update text
		chart.loadingSpan.innerHTML = str || options.lang.loading;

		// show it
		if (!chart.loadingShown) {
			css(loadingDiv, {
				opacity: 0,
				display: ''				
			});
			animate(loadingDiv, {
				opacity: loadingOptions.style.opacity
			}, {
				duration: loadingOptions.showDuration || 0
			});
			chart.loadingShown = true;
		}
		setLoadingSize();
	},

	/**
	 * Hide the loading layer
	 */
	hideLoading: function () {
		var options = this.options,
			loadingDiv = this.loadingDiv;

		if (loadingDiv) {
			animate(loadingDiv, {
				opacity: 0
			}, {
				duration: options.loading.hideDuration || 100,
				complete: function () {
					css(loadingDiv, { display: NONE });
				}
			});
		}
		this.loadingShown = false;
	}
});

// extend the Point prototype for dynamic methods
extend(Point.prototype, {
	/**
	 * Update the point with new options (typically x/y data) and optionally redraw the series.
	 *
	 * @param {Object} options Point options as defined in the series.data array
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 *
	 */
	update: function (options, redraw, animation, runEvent) {
		var point = this,
			series = point.series,
			graphic = point.graphic,
			i,
			chart = series.chart,
			seriesOptions = series.options,
			names = series.xAxis && series.xAxis.names;

		redraw = pick(redraw, true);

		function update() {

			point.applyOptions(options);

			// Update visuals
			if (isObject(options) && !isArray(options)) {
				// Defer the actual redraw until getAttribs has been called (#3260)
				point.redraw = function () {
					if (graphic) {
						if (options && options.marker && options.marker.symbol) {
							point.graphic = graphic.destroy();
						} else {
							graphic.attr(point.pointAttr[point.state || '']);
						}
					}
					if (options && options.dataLabels && point.dataLabel) { // #2468
						point.dataLabel = point.dataLabel.destroy();
					}
					point.redraw = null;
				};
			}

			// record changes in the parallel arrays
			i = point.index;
			series.updateParallelArrays(point, i);
			if (names && point.name) {
				names[point.x] = point.name;
			}

			seriesOptions.data[i] = point.options;

			// redraw
			series.isDirty = series.isDirtyData = true;
			if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
				chart.isDirtyBox = true;
			}

			if (seriesOptions.legendType === 'point') { // #1831, #1885
				series.updateTotals();
				chart.legend.clearItems();
			}
			if (redraw) {
				chart.redraw(animation);
			}
		}

		// Fire the event with a default handler of doing the update
		if (runEvent === false) { // When called from setData
			update();
		} else {
			point.firePointEvent('update', { options: options }, update);
		}
	},

	/**
	 * Remove a point and optionally redraw the series and if necessary the axes
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	remove: function (redraw, animation) {
		this.series.removePoint(inArray(this, this.series.data), redraw, animation);
	}
});

// Extend the series prototype for dynamic methods
extend(Series.prototype, {
	/**
	 * Add a point dynamically after chart load time
	 * @param {Object} options Point options as given in series.data
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean} shift If shift is true, a point is shifted off the start
	 *    of the series as one is appended to the end.
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */
	addPoint: function (options, redraw, shift, animation) {
		var series = this,
			seriesOptions = series.options,
			data = series.data,
			graph = series.graph,
			area = series.area,
			chart = series.chart,
			names = series.xAxis && series.xAxis.names,
			currentShift = (graph && graph.shift) || 0,
			dataOptions = seriesOptions.data,
			point,
			isInTheMiddle,
			xData = series.xData,
			x,
			i;

		setAnimation(animation, chart);

		// Make graph animate sideways
		if (shift) {
			each([graph, area, series.graphNeg, series.areaNeg], function (shape) {
				if (shape) {
					shape.shift = currentShift + 1;
				}
			});
		}
		if (area) {
			area.isArea = true; // needed in animation, both with and without shift
		}

		// Optional redraw, defaults to true
		redraw = pick(redraw, true);

		// Get options and push the point to xData, yData and series.options. In series.generatePoints
		// the Point instance will be created on demand and pushed to the series.data array.
		point = { series: series };
		series.pointClass.prototype.applyOptions.apply(point, [options]);
		x = point.x;

		// Get the insertion point
		i = xData.length;
		if (series.requireSorting && x < xData[i - 1]) {
			isInTheMiddle = true;
			while (i && xData[i - 1] > x) {
				i--;
			}
		}

		series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
		series.updateParallelArrays(point, i); // update it

		if (names && point.name) {
			names[x] = point.name;
		}
		dataOptions.splice(i, 0, options);

		if (isInTheMiddle) {
			series.data.splice(i, 0, null);
			series.processData();
		}

		// Generate points to be added to the legend (#1329)
		if (seriesOptions.legendType === 'point') {
			series.generatePoints();
		}

		// Shift the first point off the parallel arrays
		// todo: consider series.removePoint(i) method
		if (shift) {
			if (data[0] && data[0].remove) {
				data[0].remove(false);
			} else {
				data.shift();
				series.updateParallelArrays(point, 'shift');

				dataOptions.shift();
			}
		}

		// redraw
		series.isDirty = true;
		series.isDirtyData = true;
		if (redraw) {
			series.getAttribs(); // #1937
			chart.redraw();
		}
	},

	/**
	 * Remove a point (rendered or not), by index
	 */
	removePoint: function (i, redraw, animation) {

		var series = this,
			data = series.data,
			point = data[i],
			points = series.points,
			chart = series.chart,
			remove = function () {

				if (data.length === points.length) {
					points.splice(i, 1);
				}
				data.splice(i, 1);
				series.options.data.splice(i, 1);
				series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

				if (point) {
					point.destroy();
				}

				// redraw
				series.isDirty = true;
				series.isDirtyData = true;
				if (redraw) {
					chart.redraw();
				}
			};

		setAnimation(animation, chart);
		redraw = pick(redraw, true);

		// Fire the event with a default handler of removing the point
		if (point) {
			point.firePointEvent('remove', null, remove);
		} else {
			remove();
		}
	},

	/**
	 * Remove a series and optionally redraw the chart
	 *
	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
	 *    configuration
	 */

	remove: function (redraw, animation) {
		var series = this,
			chart = series.chart;
		redraw = pick(redraw, true);

		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
			series.isRemoving = true;

			// fire the event with a default handler of removing the point
			fireEvent(series, 'remove', null, function () {


				// destroy elements
				series.destroy();


				// redraw
				chart.isDirtyLegend = chart.isDirtyBox = true;
				chart.linkSeries();

				if (redraw) {
					chart.redraw(animation);
				}
			});

		}
		series.isRemoving = false;
	},

	/**
	 * Update the series with a new set of options
	 */
	update: function (newOptions, redraw) {
		var series = this,
			chart = this.chart,
			// must use user options when changing type because this.options is merged
			// in with type specific plotOptions
			oldOptions = this.userOptions,
			oldType = this.type,
			proto = seriesTypes[oldType].prototype,
			preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
			n;

		// If we're changing type or zIndex, create new groups (#3380, #3404)
		if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
			preserve.length = 0;
		}

		// Make sure groups are not destroyed (#3094)
		each(preserve, function (prop) {
			preserve[prop] = series[prop];
			delete series[prop];
		});

		// Do the merge, with some forced options
		newOptions = merge(oldOptions, {
			animation: false,
			index: this.index,
			pointStart: this.xData[0] // when updating after addPoint
		}, { data: this.options.data }, newOptions);

		// Destroy the series and delete all properties. Reinsert all methods 
		// and properties from the new type prototype (#2270, #3719)
		this.remove(false);
		for (n in proto) {
			this[n] = UNDEFINED;
		}
		extend(this, seriesTypes[newOptions.type || oldType].prototype);

		// Re-register groups (#3094)
		each(preserve, function (prop) {
			series[prop] = preserve[prop];
		});

		this.init(chart, newOptions);
		chart.linkSeries(); // Links are lost in this.remove (#3028)
		if (pick(redraw, true)) {
			chart.redraw(false);
		}
	}
});

// Extend the Axis.prototype for dynamic methods
extend(Axis.prototype, {

	/**
	 * Update the axis with a new options structure
	 */
	update: function (newOptions, redraw) {
		var chart = this.chart;

		newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

		this.destroy(true);
		this._addedPlotLB = UNDEFINED; // #1611, #2887

		this.init(chart, extend(newOptions, { events: UNDEFINED }));

		chart.isDirtyBox = true;
		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
     * Remove the axis from the chart
     */
	remove: function (redraw) {
		var chart = this.chart,
			key = this.coll, // xAxis or yAxis
			axisSeries = this.series,
			i = axisSeries.length;

		// Remove associated series (#2687)
		while (i--) {
			if (axisSeries[i]) {
				axisSeries[i].remove(false);
			}
		}

		// Remove the axis
		erase(chart.axes, this);
		erase(chart[key], this);
		chart.options[key].splice(this.options.index, 1);
		each(chart[key], function (axis, i) { // Re-index, #1706
			axis.options.index = i;
		});
		this.destroy();
		chart.isDirtyBox = true;

		if (pick(redraw, true)) {
			chart.redraw();
		}
	},

	/**
	 * Update the axis title by options
	 */
	setTitle: function (newTitleOptions, redraw) {
		this.update({ title: newTitleOptions }, redraw);
	},

	/**
	 * Set new axis categories and optionally redraw
	 * @param {Array} categories
	 * @param {Boolean} redraw
	 */
	setCategories: function (categories, redraw) {
		this.update({ categories: categories }, redraw);
	}

});


/**
 * LineSeries object
 */
var LineSeries = extendClass(Series);
seriesTypes.line = LineSeries;

/**
 * Set the default options for area
 */
defaultPlotOptions.area = merge(defaultSeriesOptions, {
	threshold: 0
	// trackByArea: false,
	// lineColor: null, // overrides color, but lets fillColor be unaltered
	// fillOpacity: 0.75,
	// fillColor: null
});

/**
 * AreaSeries object
 */
var AreaSeries = extendClass(Series, {
	type: 'area',
	/**
	 * For stacks, don't split segments on null values. Instead, draw null values with 
	 * no marker. Also insert dummy points for any X position that exists in other series
	 * in the stack.
	 */ 
	getSegments: function () {
		var series = this,
			segments = [],
			segment = [],
			keys = [],
			xAxis = this.xAxis,
			yAxis = this.yAxis,
			stack = yAxis.stacks[this.stackKey],
			pointMap = {},
			plotX,
			plotY,
			points = this.points,
			connectNulls = this.options.connectNulls,
			i,
			x;

		if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
			// Create a map where we can quickly look up the points by their X value.
			for (i = 0; i < points.length; i++) {
				pointMap[points[i].x] = points[i];
			}

			// Sort the keys (#1651)
			for (x in stack) {
				if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
					keys.push(+x);
				}
			}
			keys.sort(function (a, b) {
				return a - b;
			});

			each(keys, function (x) {
				var y = 0,
					stackPoint;

				if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
					return;

				// The point exists, push it to the segment
				} else if (pointMap[x]) {
					segment.push(pointMap[x]);

				// There is no point for this X value in this series, so we 
				// insert a dummy point in order for the areas to be drawn
				// correctly.
				} else {

					// Loop down the stack to find the series below this one that has
					// a value (#1991)
					for (i = series.index; i <= yAxis.series.length; i++) {
						stackPoint = stack[x].points[i + ',' + x];
						if (stackPoint) {
							y = stackPoint[1];
							break;
						}
					}

					plotX = xAxis.translate(x);
					plotY = yAxis.toPixels(y, true);
					segment.push({ 
						y: null, 
						plotX: plotX,
						clientX: plotX, 
						plotY: plotY, 
						yBottom: plotY,
						onMouseOver: noop
					});
				}
			});

			if (segment.length) {
				segments.push(segment);
			}

		} else {
			Series.prototype.getSegments.call(this);
			segments = this.segments;
		}

		this.segments = segments;
	},
	
	/**
	 * Extend the base Series getSegmentPath method by adding the path for the area.
	 * This path is pushed to the series.areaPath property.
	 */
	getSegmentPath: function (segment) {
		
		var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
			areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
			i,
			options = this.options,
			segLength = segmentPath.length,
			translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
			yBottom;
		
		if (segLength === 3) { // for animation from 1 to two points
			areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
		}
		if (options.stacking && !this.closedStacks) {
			
			// Follow stack back. Todo: implement areaspline. A general solution could be to 
			// reverse the entire graphPath of the previous series, though may be hard with
			// splines and with series with different extremes
			for (i = segment.length - 1; i >= 0; i--) {

				yBottom = pick(segment[i].yBottom, translatedThreshold);
			
				// step line?
				if (i < segment.length - 1 && options.step) {
					areaSegmentPath.push(segment[i + 1].plotX, yBottom);
				}
				
				areaSegmentPath.push(segment[i].plotX, yBottom);
			}

		} else { // follow zero line back
			this.closeSegment(areaSegmentPath, segment, translatedThreshold);
		}
		this.areaPath = this.areaPath.concat(areaSegmentPath);
		return segmentPath;
	},
	
	/**
	 * Extendable method to close the segment path of an area. This is overridden in polar 
	 * charts.
	 */
	closeSegment: function (path, segment, translatedThreshold) {
		path.push(
			L,
			segment[segment.length - 1].plotX,
			translatedThreshold,
			L,
			segment[0].plotX,
			translatedThreshold
		);
	},
	
	/**
	 * Draw the graph and the underlying area. This method calls the Series base
	 * function and adds the area. The areaPath is calculated in the getSegmentPath
	 * method called from Series.prototype.drawGraph.
	 */
	drawGraph: function () {
		
		// Define or reset areaPath
		this.areaPath = [];
		
		// Call the base method
		Series.prototype.drawGraph.apply(this);
		
		// Define local variables
		var series = this,
			areaPath = this.areaPath,
			options = this.options,
			zones = this.zones,
			props = [['area', this.color, options.fillColor]]; // area name, main color, fill color
		
		each(zones, function (threshold, i) {
			props.push(['colorArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
		});
		each(props, function (prop) {
			var areaKey = prop[0],
				area = series[areaKey];
				
			// Create or update the area
			if (area) { // update
				area.animate({ d: areaPath });
	
			} else { // create
				series[areaKey] = series.chart.renderer.path(areaPath)
					.attr({
						fill: pick(
							prop[2],
							Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
						),
						zIndex: 0 // #1069
					}).add(series.group);
			}
		});
	},

	drawLegendSymbol: LegendSymbolMixin.drawRectangle
});

seriesTypes.area = AreaSeries;
/**
 * Set the default options for spline
 */
defaultPlotOptions.spline = merge(defaultSeriesOptions);

/**
 * SplineSeries object
 */
var SplineSeries = extendClass(Series, {
	type: 'spline',

	/**
	 * Get the spline segment from a given point's previous neighbour to the given point
	 */
	getPointSpline: function (segment, point, i) {
		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
			denom = smoothing + 1,
			plotX = point.plotX,
			plotY = point.plotY,
			lastPoint = segment[i - 1],
			nextPoint = segment[i + 1],
			leftContX,
			leftContY,
			rightContX,
			rightContY,
			ret;

		// find control points
		if (lastPoint && nextPoint) {
		
			var lastX = lastPoint.plotX,
				lastY = lastPoint.plotY,
				nextX = nextPoint.plotX,
				nextY = nextPoint.plotY,
				correction;

			leftContX = (smoothing * plotX + lastX) / denom;
			leftContY = (smoothing * plotY + lastY) / denom;
			rightContX = (smoothing * plotX + nextX) / denom;
			rightContY = (smoothing * plotY + nextY) / denom;

			// have the two control points make a straight line through main point
			correction = ((rightContY - leftContY) * (rightContX - plotX)) /
				(rightContX - leftContX) + plotY - rightContY;

			leftContY += correction;
			rightContY += correction;

			// to prevent false extremes, check that control points are between
			// neighbouring points' y values
			if (leftContY > lastY && leftContY > plotY) {
				leftContY = mathMax(lastY, plotY);
				rightContY = 2 * plotY - leftContY; // mirror of left control point
			} else if (leftContY < lastY && leftContY < plotY) {
				leftContY = mathMin(lastY, plotY);
				rightContY = 2 * plotY - leftContY;
			}
			if (rightContY > nextY && rightContY > plotY) {
				rightContY = mathMax(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			} else if (rightContY < nextY && rightContY < plotY) {
				rightContY = mathMin(nextY, plotY);
				leftContY = 2 * plotY - rightContY;
			}

			// record for drawing in next point
			point.rightContX = rightContX;
			point.rightContY = rightContY;

		}
		
		// Visualize control points for debugging
		/*
		if (leftContX) {
			this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
				.attr({
					stroke: 'red',
					'stroke-width': 1,
					fill: 'none'
				})
				.add();
			this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'red',
					'stroke-width': 1
				})
				.add();
			this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
				.attr({
					stroke: 'green',
					'stroke-width': 1,
					fill: 'none'
				})
				.add();
			this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
				'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
				.attr({
					stroke: 'green',
					'stroke-width': 1
				})
				.add();
		}
		*/

		// moveTo or lineTo
		if (!i) {
			ret = [M, plotX, plotY];
		} else { // curve from last point to this
			ret = [
				'C',
				lastPoint.rightContX || lastPoint.plotX,
				lastPoint.rightContY || lastPoint.plotY,
				leftContX || plotX,
				leftContY || plotY,
				plotX,
				plotY
			];
			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
		}
		return ret;
	}
});
seriesTypes.spline = SplineSeries;

/**
 * Set the default options for areaspline
 */
defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

/**
 * AreaSplineSeries object
 */
var areaProto = AreaSeries.prototype,
	AreaSplineSeries = extendClass(SplineSeries, {
		type: 'areaspline',
		closedStacks: true, // instead of following the previous graph back, follow the threshold back
		
		// Mix in methods from the area series
		getSegmentPath: areaProto.getSegmentPath,
		closeSegment: areaProto.closeSegment,
		drawGraph: areaProto.drawGraph,
		drawLegendSymbol: LegendSymbolMixin.drawRectangle
	});

seriesTypes.areaspline = AreaSplineSeries;

/**
 * Set the default options for column
 */
defaultPlotOptions.column = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	//borderWidth: 1,
	borderRadius: 0,
	//colorByPoint: undefined,
	groupPadding: 0.2,
	//grouping: true,
	marker: null, // point options are specified in the base options
	pointPadding: 0.1,
	//pointWidth: null,
	minPointLength: 0,
	cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
	pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
	states: {
		hover: {
			brightness: 0.1,
			shadow: false,
			halo: false
		},
		select: {
			color: '#C0C0C0',
			borderColor: '#000000',
			shadow: false
		}
	},
	dataLabels: {
		align: null, // auto
		verticalAlign: null, // auto
		y: null
	},
	stickyTracking: false,
	tooltip: {
		distance: 6
	},
	threshold: 0
});

/**
 * ColumnSeries object
 */
var ColumnSeries = extendClass(Series, {
	type: 'column',
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		fill: 'color',
		r: 'borderRadius'
	},
	cropShoulder: 0,
	directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
	trackerGroups: ['group', 'dataLabelsGroup'],
	negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
		// point is substracted from previous (#1910)
	
	/**
	 * Initialize the series
	 */
	init: function () {
		Series.prototype.init.apply(this, arguments);

		var series = this,
			chart = series.chart;

		// if the series is added dynamically, force redraw of other
		// series affected by a new column
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}
	},

	/**
	 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
	 * pointWidth etc. 
	 */
	getColumnMetrics: function () {

		var series = this,
			options = series.options,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			reversedXAxis = xAxis.reversed,
			stackKey,
			stackGroups = {},
			columnIndex,
			columnCount = 0;

		// Get the total number of column type series.
		// This is called on every series. Consider moving this logic to a
		// chart.orderStacks() function and call it on init, addSeries and removeSeries
		if (options.grouping === false) {
			columnCount = 1;
		} else {
			each(series.chart.series, function (otherSeries) {
				var otherOptions = otherSeries.options,
					otherYAxis = otherSeries.yAxis;
				if (otherSeries.type === series.type && otherSeries.visible &&
						yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
					if (otherOptions.stacking) {
						stackKey = otherSeries.stackKey;
						if (stackGroups[stackKey] === UNDEFINED) {
							stackGroups[stackKey] = columnCount++;
						}
						columnIndex = stackGroups[stackKey];
					} else if (otherOptions.grouping !== false) { // #1162
						columnIndex = columnCount++;
					}
					otherSeries.columnIndex = columnIndex;
				}
			});
		}

		var categoryWidth = mathMin(
				mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
				xAxis.len // #1535
			),
			groupPadding = categoryWidth * options.groupPadding,
			groupWidth = categoryWidth - 2 * groupPadding,
			pointOffsetWidth = groupWidth / columnCount,
			optionPointWidth = options.pointWidth,
			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
				pointOffsetWidth * options.pointPadding,
			pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
			colIndex = (reversedXAxis ? 
				columnCount - (series.columnIndex || 0) : // #1251
				series.columnIndex) || 0,
			pointXOffset = pointPadding + (groupPadding + colIndex *
				pointOffsetWidth - (categoryWidth / 2)) *
				(reversedXAxis ? -1 : 1);

		// Save it for reading in linked series (Error bars particularly)
		return (series.columnMetrics = { 
			width: pointWidth, 
			offset: pointXOffset 
		});
			
	},

	/**
	 * Translate each point to the plot area coordinate system and find shape positions
	 */
	translate: function () {
		var series = this,
			chart = series.chart,
			options = series.options,
			borderWidth = series.borderWidth = pick(
				options.borderWidth, 
				series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
			),
			yAxis = series.yAxis,
			threshold = options.threshold,
			translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
			minPointLength = pick(options.minPointLength, 5),
			metrics = series.getColumnMetrics(),
			pointWidth = metrics.width,
			seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
			pointXOffset = series.pointXOffset = metrics.offset,
			xCrisp = -(borderWidth % 2 ? 0.5 : 0),
			yCrisp = borderWidth % 2 ? 0.5 : 1;

		if (chart.renderer.isVML && chart.inverted) {
			yCrisp += 1;
		}

		// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
		// columns to have individual sizes. When pointPadding is greater, we strive for equal-width
		// columns (#2694).
		if (options.pointPadding) {
			seriesBarW = mathCeil(seriesBarW);
		}

		Series.prototype.translate.apply(series);

		// Record the new values
		each(series.points, function (point) {
			var yBottom = pick(point.yBottom, translatedThreshold),
				plotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)
				barX = point.plotX + pointXOffset,
				barW = seriesBarW,
				barY = mathMin(plotY, yBottom),
				right,
				bottom,
				fromTop,
				barH = mathMax(plotY, yBottom) - barY;

			// Handle options.minPointLength
			if (mathAbs(barH) < minPointLength) {
				if (minPointLength) {
					barH = minPointLength;
					barY =
						mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
							yBottom - minPointLength : // keep position
							translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)
				}
			}

			// Cache for access in polar
			point.barX = barX;
			point.pointWidth = pointWidth;

			// Fix the tooltip on center of grouped columns (#1216, #424, #3648)
			point.tooltipPos = chart.inverted ? 
				[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2] : 
				[barX + barW / 2, plotY + yAxis.pos - chart.plotTop];

			// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
			right = mathRound(barX + barW) + xCrisp;
			barX = mathRound(barX) + xCrisp;
			barW = right - barX;

			fromTop = mathAbs(barY) < 0.5;
			bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575
			barY = mathRound(barY) + yCrisp;
			barH = bottom - barY;

			// Top edges are exceptions
			if (fromTop) {
				barY -= 1;
				barH += 1;
			}

			// Register shape type and arguments to be used in drawPoints
			point.shapeType = 'rect';
			point.shapeArgs = {
				x: barX,
				y: barY,
				width: barW,
				height: barH
			};

		});

	},

	getSymbol: noop,
	
	/**
	 * Use a solid rectangle like the area series types
	 */
	drawLegendSymbol: LegendSymbolMixin.drawRectangle,
	
	
	/**
	 * Columns have no graph
	 */
	drawGraph: noop,

	/**
	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	 * apply for columns and bars. This method is inherited by scatter series.
	 *
	 */
	drawPoints: function () {
		var series = this,
			chart = this.chart,
			options = series.options,
			renderer = chart.renderer,
			animationLimit = options.animationLimit || 250,
			shapeArgs,
			pointAttr;

		// draw the columns
		each(series.points, function (point) {
			var plotY = point.plotY,
				graphic = point.graphic,
				borderAttr;

			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
				shapeArgs = point.shapeArgs;

				borderAttr = defined(series.borderWidth) ? {
					'stroke-width': series.borderWidth
				} : {};

				pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];
				
				if (graphic) { // update
					stop(graphic);
					graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

				} else {
					point.graphic = graphic = renderer[point.shapeType](shapeArgs)
						.attr(borderAttr)
						.attr(pointAttr)
						.add(series.group)
						.shadow(options.shadow, null, options.stacking && !options.borderRadius);
				}

			} else if (graphic) {
				point.graphic = graphic.destroy(); // #1269
			}
		});
	},

	/**
	 * Animate the column heights one by one from zero
	 * @param {Boolean} init Whether to initialize the animation or run it
	 */
	animate: function (init) {
		var series = this,
			yAxis = this.yAxis,
			options = series.options,
			inverted = this.chart.inverted,
			attr = {},
			translatedThreshold;

		if (hasSVG) { // VML is too slow anyway
			if (init) {
				attr.scaleY = 0.001;
				translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
				if (inverted) {
					attr.translateX = translatedThreshold - yAxis.len;
				} else {
					attr.translateY = translatedThreshold;
				}
				series.group.attr(attr);

			} else { // run the animation
				
				attr.scaleY = 1;
				attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
				series.group.animate(attr, series.options.animation);

				// delete this function to allow it only once
				series.animate = null;
			}
		}
	},
	
	/**
	 * Remove this series from the chart
	 */
	remove: function () {
		var series = this,
			chart = series.chart;

		// column and bar series affects other series of the same type
		// as they are either stacked or grouped
		if (chart.hasRendered) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.type === series.type) {
					otherSeries.isDirty = true;
				}
			});
		}

		Series.prototype.remove.apply(series, arguments);
	}
});
seriesTypes.column = ColumnSeries;
/**
 * Set the default options for bar
 */
defaultPlotOptions.bar = merge(defaultPlotOptions.column);
/**
 * The Bar series class
 */
var BarSeries = extendClass(ColumnSeries, {
	type: 'bar',
	inverted: true
});
seriesTypes.bar = BarSeries;

/**
 * Set the default options for scatter
 */
defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
	lineWidth: 0,
	marker: {
		enabled: true // Overrides auto-enabling in line series (#3647)
	},
	tooltip: {
		headerFormat: '<span style="color:{series.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
		pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	}
});

/**
 * The scatter series class
 */
var ScatterSeries = extendClass(Series, {
	type: 'scatter',
	sorted: false,
	requireSorting: false,
	noSharedTooltip: true,
	trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	takeOrdinalPosition: false, // #2342
	kdDimensions: 2,
	kdComparer: 'distR',
	drawGraph: function () {
		if (this.options.lineWidth) {
			Series.prototype.drawGraph.call(this);
		}
	}
});

seriesTypes.scatter = ScatterSeries;

/**
 * Set the default options for pie
 */
defaultPlotOptions.pie = merge(defaultSeriesOptions, {
	borderColor: '#FFFFFF',
	borderWidth: 1,
	center: [null, null],
	clip: false,
	colorByPoint: true, // always true for pies
	dataLabels: {
		// align: null,
		// connectorWidth: 1,
		// connectorColor: point.color,
		// connectorPadding: 5,
		distance: 30,
		enabled: true,
		formatter: function () { // #2945
			return this.point.name;
		},
		// softConnector: true,
		x: 0
		// y: 0
	},
	ignoreHiddenPoint: true,
	//innerSize: 0,
	legendType: 'point',
	marker: null, // point options are specified in the base options
	size: null,
	showInLegend: false,
	slicedOffset: 10,
	states: {
		hover: {
			brightness: 0.1,
			shadow: false
		}
	},
	stickyTracking: false,
	tooltip: {
		followPointer: true
	}
});

/**
 * Extended point object for pies
 */
var PiePoint = extendClass(Point, {
	/**
	 * Initiate the pie slice
	 */
	init: function () {

		Point.prototype.init.apply(this, arguments);

		var point = this,
			toggleSlice;

		extend(point, {
			visible: point.visible !== false,
			name: pick(point.name, 'Slice')
		});

		// add event listener for select
		toggleSlice = function (e) {
			point.slice(e.type === 'select');
		};
		addEvent(point, 'select', toggleSlice);
		addEvent(point, 'unselect', toggleSlice);

		return point;
	},

	/**
	 * Toggle the visibility of the pie slice
	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
	 *    visibility is toggled
	 */
	setVisible: function (vis) {
		var point = this,
			series = point.series,
			chart = series.chart,
			doRedraw = !series.isDirty && series.options.ignoreHiddenPoint;

		// if called without an argument, toggle visibility
		point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
		series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

		// Show and hide associated elements
		each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
			if (point[key]) {
				point[key][vis ? 'show' : 'hide'](true);
			}
		});

		if (point.legendItem) {
			if (chart.hasRendered) {
				series.updateTotals();
				chart.legend.clearItems();
				if (!doRedraw) {
					chart.legend.render();
				}
			}
			chart.legend.colorizeItem(point, vis);
		}

		// Handle ignore hidden slices
		if (doRedraw) {
			series.isDirty = true;
			chart.redraw();
		}
	},

	/**
	 * Set or toggle whether the slice is cut out from the pie
	 * @param {Boolean} sliced When undefined, the slice state is toggled
	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
	 */
	slice: function (sliced, redraw, animation) {
		var point = this,
			series = point.series,
			chart = series.chart,
			translation;

		setAnimation(animation, chart);

		// redraw is true by default
		redraw = pick(redraw, true);

		// if called without an argument, toggle
		point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
		series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

		translation = sliced ? point.slicedTranslation : {
			translateX: 0,
			translateY: 0
		};

		point.graphic.animate(translation);
		
		if (point.shadowGroup) {
			point.shadowGroup.animate(translation);
		}

	},

	haloPath: function (size) {
		var shapeArgs = this.shapeArgs,
			chart = this.series.chart;

		return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
			innerR: this.shapeArgs.r,
			start: shapeArgs.start,
			end: shapeArgs.end
		});
	}
});

/**
 * The Pie series class
 */
var PieSeries = {
	type: 'pie',
	isCartesian: false,
	pointClass: PiePoint,
	requireSorting: false,
	noSharedTooltip: true,
	trackerGroups: ['group', 'dataLabelsGroup'],
	axisTypes: [],
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'borderColor',
		'stroke-width': 'borderWidth',
		fill: 'color'
	},

	/**
	 * Pies have one color each point
	 */
	getColor: noop,

	/**
	 * Animate the pies in
	 */
	animate: function (init) {
		var series = this,
			points = series.points,
			startAngleRad = series.startAngleRad;

		if (!init) {
			each(points, function (point) {
				var graphic = point.graphic,
					args = point.shapeArgs;

				if (graphic) {
					// start values
					graphic.attr({
						r: series.center[3] / 2, // animate from inner radius (#779)
						start: startAngleRad,
						end: startAngleRad
					});

					// animate
					graphic.animate({
						r: args.r,
						start: args.start,
						end: args.end
					}, series.options.animation);
				}
			});

			// delete this function to allow it only once
			series.animate = null;
		}
	},

	/**
	 * Extend the basic setData method by running processData and generatePoints immediately,
	 * in order to access the points from the legend.
	 */
	setData: function (data, redraw, animation, updatePoints) {
		Series.prototype.setData.call(this, data, false, animation, updatePoints);
		this.processData();
		this.generatePoints();
		if (pick(redraw, true)) {
			this.chart.redraw(animation);
		} 
	},

	/**
	 * Recompute total chart sum and update percentages of points.
	 */
	updateTotals: function () {
		var i,
			total = 0,
			points,
			len,
			point,
			ignoreHiddenPoint = this.options.ignoreHiddenPoint;

		// Populate local vars
		points = this.points;
		len = points.length;
		
		// Get the total sum
		for (i = 0; i < len; i++) {
			point = points[i];

			// Disallow negative values (#1530, #3623)
			if (point.y < 0) {
				point.y = null;
			}
			
			total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
		}
		this.total = total;

		// Set each point's properties
		for (i = 0; i < len; i++) {
			point = points[i];
			//point.percentage = (total <= 0 || ignoreHiddenPoint && !point.visible) ? 0 : point.y / total * 100;
			point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
			point.total = total;
		}
	},

	/**
	 * Extend the generatePoints method by adding total and percentage properties to each point
	 */
	generatePoints: function () {
		Series.prototype.generatePoints.call(this);
		this.updateTotals();
	},
	
	/**
	 * Do translation for pie slices
	 */
	translate: function (positions) {
		this.generatePoints();
		
		var series = this,
			cumulative = 0,
			precision = 1000, // issue #172
			options = series.options,
			slicedOffset = options.slicedOffset,
			connectorOffset = slicedOffset + options.borderWidth,
			start,
			end,
			angle,
			startAngle = options.startAngle || 0,
			startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
			endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
			circ = endAngleRad - startAngleRad, //2 * mathPI,
			points = series.points,
			radiusX, // the x component of the radius vector for a given point
			radiusY,
			labelDistance = options.dataLabels.distance,
			ignoreHiddenPoint = options.ignoreHiddenPoint,
			i,
			len = points.length,
			point;

		// Get positions - either an integer or a percentage string must be given.
		// If positions are passed as a parameter, we're in a recursive loop for adjusting
		// space for data labels.
		if (!positions) {
			series.center = positions = series.getCenter();
		}

		// utility for getting the x value from a given y, used for anticollision logic in data labels
		series.getX = function (y, left) {

			angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

			return positions[0] +
				(left ? -1 : 1) *
				(mathCos(angle) * (positions[2] / 2 + labelDistance));
		};

		// Calculate the geometry for each point
		for (i = 0; i < len; i++) {
			
			point = points[i];
			
			// set start and end angle
			start = startAngleRad + (cumulative * circ);
			if (!ignoreHiddenPoint || point.visible) {
				cumulative += point.percentage / 100;
			}
			end = startAngleRad + (cumulative * circ);

			// set the shape
			point.shapeType = 'arc';
			point.shapeArgs = {
				x: positions[0],
				y: positions[1],
				r: positions[2] / 2,
				innerR: positions[3] / 2,
				start: mathRound(start * precision) / precision,
				end: mathRound(end * precision) / precision
			};

			// The angle must stay within -90 and 270 (#2645)
			angle = (end + start) / 2;
			if (angle > 1.5 * mathPI) {
				angle -= 2 * mathPI;
			} else if (angle < -mathPI / 2) {
				angle += 2 * mathPI;
			}

			// Center for the sliced out slice
			point.slicedTranslation = {
				translateX: mathRound(mathCos(angle) * slicedOffset),
				translateY: mathRound(mathSin(angle) * slicedOffset)
			};

			// set the anchor point for tooltips
			radiusX = mathCos(angle) * positions[2] / 2;
			radiusY = mathSin(angle) * positions[2] / 2;
			point.tooltipPos = [
				positions[0] + radiusX * 0.7,
				positions[1] + radiusY * 0.7
			];
			
			point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
			point.angle = angle;

			// set the anchor point for data labels
			connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
			point.labelPos = [
				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
				positions[0] + radiusX, // landing point for connector
				positions[1] + radiusY, // a/a
				labelDistance < 0 ? // alignment
					'center' :
					point.half ? 'right' : 'left', // alignment
				angle // center angle
			];

		}
	},
	
	drawGraph: null,

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			chart = series.chart,
			renderer = chart.renderer,
			groupTranslation,
			//center,
			graphic,
			//group,
			shadow = series.options.shadow,
			shadowGroup,
			shapeArgs;

		if (shadow && !series.shadowGroup) {
			series.shadowGroup = renderer.g('shadow')
				.add(series.group);
		}

		// draw the slices
		each(series.points, function (point) {
			graphic = point.graphic;
			shapeArgs = point.shapeArgs;
			shadowGroup = point.shadowGroup;

			// put the shadow behind all points
			if (shadow && !shadowGroup) {
				shadowGroup = point.shadowGroup = renderer.g('shadow')
					.add(series.shadowGroup);
			}

			// if the point is sliced, use special translation, else use plot area traslation
			groupTranslation = point.sliced ? point.slicedTranslation : {
				translateX: 0,
				translateY: 0
			};

			//group.translate(groupTranslation[0], groupTranslation[1]);
			if (shadowGroup) {
				shadowGroup.attr(groupTranslation);
			}

			// draw the slice
			if (graphic) {
				graphic.animate(extend(shapeArgs, groupTranslation));
			} else {
				point.graphic = graphic = renderer[point.shapeType](shapeArgs)
					.setRadialReference(series.center)
					.attr(
						point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
					)
					.attr({ 
						'stroke-linejoin': 'round'
						//zIndex: 1 // #2722 (reversed)
					})
					.attr(groupTranslation)
					.add(series.group)
					.shadow(shadow, shadowGroup);	
			}

			// detect point specific visibility (#2430)
			if (point.visible !== undefined) {
				point.setVisible(point.visible);
			}

		});

	},


	searchPoint: noop,

	/**
	 * Utility for sorting data labels
	 */
	sortByAngle: function (points, sign) {
		points.sort(function (a, b) {
			return a.angle !== undefined && (b.angle - a.angle) * sign;
		});
	},		

	/**
	 * Use a simple symbol from LegendSymbolMixin
	 */
	drawLegendSymbol: LegendSymbolMixin.drawRectangle,

	/**
	 * Use the getCenter method from drawLegendSymbol
	 */
	getCenter: CenteredSeriesMixin.getCenter,

	/**
	 * Pies don't have point marker symbols
	 */
	getSymbol: noop

};
PieSeries = extendClass(Series, PieSeries);
seriesTypes.pie = PieSeries;

/**
 * Draw the data labels
 */
Series.prototype.drawDataLabels = function () {

	var series = this,
		seriesOptions = series.options,
		cursor = seriesOptions.cursor,
		options = seriesOptions.dataLabels,
		points = series.points,
		pointOptions,
		generalOptions,
		hasRendered = series.hasRendered || 0,
		str,
		dataLabelsGroup,
		renderer = series.chart.renderer;

	if (options.enabled || series._hasPointLabels) {

		// Process default alignment of data labels for columns
		if (series.dlProcessOptions) {
			series.dlProcessOptions(options);
		}

		// Create a separate group for the data labels to avoid rotation
		dataLabelsGroup = series.plotGroup(
			'dataLabelsGroup',
			'data-labels',
			options.defer ? HIDDEN : VISIBLE,
			options.zIndex || 6
		);

		if (pick(options.defer, true)) {
			dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
			if (!hasRendered) {
				addEvent(series, 'afterAnimate', function () {
					if (series.visible) { // #3023, #3024
						dataLabelsGroup.show();
					}
					dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
				});
			}
		}

		// Make the labels for each point
		generalOptions = options;
		each(points, function (point) {

			var enabled,
				dataLabel = point.dataLabel,
				labelConfig,
				attr,
				name,
				rotation,
				connector = point.connector,
				isNew = true,
				style,
				moreStyle = {};

			// Determine if each data label is enabled
			pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
			enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


			// If the point is outside the plot area, destroy it. #678, #820
			if (dataLabel && !enabled) {
				point.dataLabel = dataLabel.destroy();

			// Individual labels are disabled if the are explicitly disabled
			// in the point options, or if they fall outside the plot area.
			} else if (enabled) {

				// Create individual options structure that can be extended without
				// affecting others
				options = merge(generalOptions, pointOptions);
				style = options.style;

				rotation = options.rotation;

				// Get the string
				labelConfig = point.getLabelConfig();
				str = options.format ?
					format(options.format, labelConfig) :
					options.formatter.call(labelConfig, options);

				// Determine the color
				style.color = pick(options.color, style.color, series.color, 'black');


				// update existing label
				if (dataLabel) {

					if (defined(str)) {
						dataLabel
							.attr({
								text: str
							});
						isNew = false;

					} else { // #1437 - the label is shown conditionally
						point.dataLabel = dataLabel = dataLabel.destroy();
						if (connector) {
							point.connector = connector.destroy();
						}
					}

				// create new label
				} else if (defined(str)) {
					attr = {
						//align: align,
						fill: options.backgroundColor,
						stroke: options.borderColor,
						'stroke-width': options.borderWidth,
						r: options.borderRadius || 0,
						rotation: rotation,
						padding: options.padding,
						zIndex: 1
					};
					
					// Get automated contrast color
					if (style.color === 'contrast') {
						moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? 
							renderer.getContrast(point.color || series.color) : 
							'#000000';
					}
					if (cursor) {
						moreStyle.cursor = cursor;
					}
					

					// Remove unused attributes (#947)
					for (name in attr) {
						if (attr[name] === UNDEFINED) {
							delete attr[name];
						}
					}

					dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
						str,
						0,
						-999,
						options.shape,
						null,
						null,
						options.useHTML
					)
					.attr(attr)
					.css(extend(style, moreStyle))
					.add(dataLabelsGroup)
					.shadow(options.shadow);

				}

				if (dataLabel) {
					// Now the data label is created and placed at 0,0, so we need to align it
					series.alignDataLabel(point, dataLabel, options, null, isNew);
				}
			}
		});
	}
};

/**
 * Align each individual data label
 */
Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
	var chart = this.chart,
		inverted = chart.inverted,
		plotX = pick(point.plotX, -999),
		plotY = pick(point.plotY, -999),
		bBox = dataLabel.getBBox(),
		baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
		rotCorr, // rotation correction
		// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
		visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
			(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
		alignAttr; // the final position;

	if (visible) {

		// The alignment box is a singular point
		alignTo = extend({
			x: inverted ? chart.plotWidth - plotY : plotX,
			y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
			width: 0,
			height: 0
		}, alignTo);

		// Add the text size for alignment calculation
		extend(options, {
			width: bBox.width,
			height: bBox.height
		});

		// Allow a hook for changing alignment in the last moment, then do the alignment
		if (options.rotation) { // Fancy box alignment isn't supported for rotated text
			rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
			dataLabel[isNew ? 'attr' : 'animate']({
					x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
					y: alignTo.y + options.y + alignTo.height / 2
				})
				.attr({ // #3003
					align: options.align
				});
		} else {
			dataLabel.align(options, null, alignTo);
			alignAttr = dataLabel.alignAttr;

			// Handle justify or crop
			if (pick(options.overflow, 'justify') === 'justify') {
				this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

			} else if (pick(options.crop, true)) {
				// Now check that the data label is within the plot area
				visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

			}

			// When we're using a shape, make it possible with a connector or an arrow pointing to thie point
			if (options.shape) {
				dataLabel.attr({
					anchorX: point.plotX,
					anchorY: point.plotY
				});
			}

		}
	}

	// Show or hide based on the final aligned position
	if (!visible) {
		dataLabel.attr({ y: -999 });
		dataLabel.placed = false; // don't animate back in
	}

};

/**
 * If data labels fall partly outside the plot area, align them back in, in a way that
 * doesn't hide the point.
 */
Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
	var chart = this.chart,
		align = options.align,
		verticalAlign = options.verticalAlign,
		off,
		justified,
		padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

	// Off left
	off = alignAttr.x + padding;
	if (off < 0) {
		if (align === 'right') {
			options.align = 'left';
		} else {
			options.x = -off;
		}
		justified = true;
	}

	// Off right
	off = alignAttr.x + bBox.width - padding;
	if (off > chart.plotWidth) {
		if (align === 'left') {
			options.align = 'right';
		} else {
			options.x = chart.plotWidth - off;
		}
		justified = true;
	}

	// Off top
	off = alignAttr.y + padding;
	if (off < 0) {
		if (verticalAlign === 'bottom') {
			options.verticalAlign = 'top';
		} else {
			options.y = -off;
		}
		justified = true;
	}

	// Off bottom
	off = alignAttr.y + bBox.height - padding;
	if (off > chart.plotHeight) {
		if (verticalAlign === 'top') {
			options.verticalAlign = 'bottom';
		} else {
			options.y = chart.plotHeight - off;
		}
		justified = true;
	}

	if (justified) {
		dataLabel.placed = !isNew;
		dataLabel.align(options, null, alignTo);
	}
};

/**
 * Override the base drawDataLabels method by pie specific functionality
 */
if (seriesTypes.pie) {
	seriesTypes.pie.prototype.drawDataLabels = function () {
		var series = this,
			data = series.data,
			point,
			chart = series.chart,
			options = series.options.dataLabels,
			connectorPadding = pick(options.connectorPadding, 10),
			connectorWidth = pick(options.connectorWidth, 1),
			plotWidth = chart.plotWidth,
			plotHeight = chart.plotHeight,
			connector,
			connectorPath,
			softConnector = pick(options.softConnector, true),
			distanceOption = options.distance,
			seriesCenter = series.center,
			radius = seriesCenter[2] / 2,
			centerY = seriesCenter[1],
			outside = distanceOption > 0,
			dataLabel,
			dataLabelWidth,
			labelPos,
			labelHeight,
			halves = [// divide the points into right and left halves for anti collision
				[], // right
				[]  // left
			],
			x,
			y,
			visibility,
			rankArr,
			i,
			j,
			overflow = [0, 0, 0, 0], // top, right, bottom, left
			sort = function (a, b) {
				return b.y - a.y;
			};

		// get out if not enabled
		if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
			return;
		}

		// run parent method
		Series.prototype.drawDataLabels.apply(series);

		// arrange points for detection collision
		each(data, function (point) {
			if (point.dataLabel && point.visible) { // #407, #2510
				halves[point.half].push(point);
			}
		});

		/* Loop over the points in each half, starting from the top and bottom
		 * of the pie to detect overlapping labels.
		 */
		i = 2;
		while (i--) {

			var slots = [],
				slotsLength,
				usedSlots = [],
				points = halves[i],
				pos,
				bottom,
				length = points.length,
				slotIndex;

			if (!length) {
				continue;
			}

			// Sort by angle
			series.sortByAngle(points, i - 0.5);

			// Assume equal label heights on either hemisphere (#2630)
			j = labelHeight = 0;
			while (!labelHeight && points[j]) { // #1569
				labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
				j++;
			}

			// Only do anti-collision when we are outside the pie and have connectors (#856)
			if (distanceOption > 0) {

				// Build the slots
				bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
				for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
					slots.push(pos);
				}
				slotsLength = slots.length;


				/* Visualize the slots
				if (!series.slotElements) {
					series.slotElements = [];
				}
				if (i === 1) {
					series.slotElements.forEach(function (elem) {
						elem.destroy();
					});
					series.slotElements.length = 0;
				}
					
				slots.forEach(function (pos, no) {
					var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
						slotY = pos + chart.plotTop;
					
					if (!isNaN(slotX)) {
						series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
							.attr({
								'stroke-width': 1,
								stroke: 'silver',
								fill: 'rgba(0,0,255,0.1)'
							})
							.add());
						series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
							.attr({
								fill: 'silver'
							}).add());
					}
				});
				// */

				// if there are more values than available slots, remove lowest values
				if (length > slotsLength) {
					// create an array for sorting and ranking the points within each quarter
					rankArr = [].concat(points);
					rankArr.sort(sort);
					j = length;
					while (j--) {
						rankArr[j].rank = j;
					}
					j = length;
					while (j--) {
						if (points[j].rank >= slotsLength) {
							points.splice(j, 1);
						}
					}
					length = points.length;
				}

				// The label goes to the nearest open slot, but not closer to the edge than
				// the label's index.
				for (j = 0; j < length; j++) {

					point = points[j];
					labelPos = point.labelPos;

					var closest = 9999,
						distance,
						slotI;

					// find the closest slot index
					for (slotI = 0; slotI < slotsLength; slotI++) {
						distance = mathAbs(slots[slotI] - labelPos[1]);
						if (distance < closest) {
							closest = distance;
							slotIndex = slotI;
						}
					}

					// if that slot index is closer to the edges of the slots, move it
					// to the closest appropriate slot
					if (slotIndex < j && slots[j] !== null) { // cluster at the top
						slotIndex = j;
					} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
						slotIndex = slotsLength - length + j;
						while (slots[slotIndex] === null) { // make sure it is not taken
							slotIndex++;
						}
					} else {
						// Slot is taken, find next free slot below. In the next run, the next slice will find the
						// slot above these, because it is the closest one
						while (slots[slotIndex] === null) { // make sure it is not taken
							slotIndex++;
						}
					}

					usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
					slots[slotIndex] = null; // mark as taken
				}
				// sort them in order to fill in from the top
				usedSlots.sort(sort);
			}

			// now the used slots are sorted, fill them up sequentially
			for (j = 0; j < length; j++) {

				var slot, naturalY;

				point = points[j];
				labelPos = point.labelPos;
				dataLabel = point.dataLabel;
				visibility = point.visible === false ? HIDDEN : VISIBLE;
				naturalY = labelPos[1];

				if (distanceOption > 0) {
					slot = usedSlots.pop();
					slotIndex = slot.i;

					// if the slot next to currrent slot is free, the y value is allowed
					// to fall back to the natural position
					y = slot.y;
					if ((naturalY > y && slots[slotIndex + 1] !== null) ||
							(naturalY < y &&  slots[slotIndex - 1] !== null)) {
						y = mathMin(mathMax(0, naturalY), chart.plotHeight);
					}

				} else {
					y = naturalY;
				}

				// get the x - use the natural x position for first and last slot, to prevent the top
				// and botton slice connectors from touching each other on either side
				x = options.justify ?
					seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
					series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


				// Record the placement and visibility
				dataLabel._attr = {
					visibility: visibility,
					align: labelPos[6]
				};
				dataLabel._pos = {
					x: x + options.x +
						({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
					y: y + options.y - 10 // 10 is for the baseline (label vs text)
				};
				dataLabel.connX = x;
				dataLabel.connY = y;


				// Detect overflowing data labels
				if (this.options.size === null) {
					dataLabelWidth = dataLabel.width;
					// Overflow left
					if (x - dataLabelWidth < connectorPadding) {
						overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

					// Overflow right
					} else if (x + dataLabelWidth > plotWidth - connectorPadding) {
						overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
					}

					// Overflow top
					if (y - labelHeight / 2 < 0) {
						overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

					// Overflow left
					} else if (y + labelHeight / 2 > plotHeight) {
						overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
					}
				}
			} // for each point
		} // for each half

		// Do not apply the final placement and draw the connectors until we have verified
		// that labels are not spilling over.
		if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

			// Place the labels in the final position
			this.placeDataLabels();

			// Draw the connectors
			if (outside && connectorWidth) {
				each(this.points, function (point) {
					connector = point.connector;
					labelPos = point.labelPos;
					dataLabel = point.dataLabel;

					if (dataLabel && dataLabel._pos) {
						visibility = dataLabel._attr.visibility;
						x = dataLabel.connX;
						y = dataLabel.connY;
						connectorPath = softConnector ? [
							M,
							x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
							'C',
							x, y, // first break, next to the label
							2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
							labelPos[2], labelPos[3], // second break
							L,
							labelPos[4], labelPos[5] // base
						] : [
							M,
							x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
							L,
							labelPos[2], labelPos[3], // second break
							L,
							labelPos[4], labelPos[5] // base
						];

						if (connector) {
							connector.animate({ d: connectorPath });
							connector.attr('visibility', visibility);

						} else {
							point.connector = connector = series.chart.renderer.path(connectorPath).attr({
								'stroke-width': connectorWidth,
								stroke: options.connectorColor || point.color || '#606060',
								visibility: visibility
								//zIndex: 0 // #2722 (reversed)
							})
							.add(series.dataLabelsGroup);
						}
					} else if (connector) {
						point.connector = connector.destroy();
					}
				});
			}
		}
	};
	/**
	 * Perform the final placement of the data labels after we have verified that they
	 * fall within the plot area.
	 */
	seriesTypes.pie.prototype.placeDataLabels = function () {
		each(this.points, function (point) {
			var dataLabel = point.dataLabel,
				_pos;

			if (dataLabel) {
				_pos = dataLabel._pos;
				if (_pos) {
					dataLabel.attr(dataLabel._attr);
					dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
					dataLabel.moved = true;
				} else if (dataLabel) {
					dataLabel.attr({ y: -999 });
				}
			}
		});
	};

	seriesTypes.pie.prototype.alignDataLabel =  noop;

	/**
	 * Verify whether the data labels are allowed to draw, or we should run more translation and data
	 * label positioning to keep them inside the plot area. Returns true when data labels are ready
	 * to draw.
	 */
	seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

		var center = this.center,
			options = this.options,
			centerOption = options.center,
			minSize = options.minSize || 80,
			newSize = minSize,
			ret;

		// Handle horizontal size and center
		if (centerOption[0] !== null) { // Fixed center
			newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

		} else { // Auto center
			newSize = mathMax(
				center[2] - overflow[1] - overflow[3], // horizontal overflow
				minSize
			);
			center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
		}

		// Handle vertical size and center
		if (centerOption[1] !== null) { // Fixed center
			newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

		} else { // Auto center
			newSize = mathMax(
				mathMin(
					newSize,
					center[2] - overflow[0] - overflow[2] // vertical overflow
				),
				minSize
			);
			center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
		}

		// If the size must be decreased, we need to run translate and drawDataLabels again
		if (newSize < center[2]) {
			center[2] = newSize;
			this.translate(center);
			each(this.points, function (point) {
				if (point.dataLabel) {
					point.dataLabel._pos = null; // reset
				}
			});

			if (this.drawDataLabels) {
				this.drawDataLabels();
			}
		// Else, return true to indicate that the pie and its labels is within the plot area
		} else {
			ret = true;
		}
		return ret;
	};
}

if (seriesTypes.column) {

	/**
	 * Override the basic data label alignment by adjusting for the position of the column
	 */
	seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
		var inverted = this.chart.inverted,
			series = point.series,
			dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
			below = point.below || (point.plotY > pick(this.translatedThreshold, series.yAxis.len)),
			inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

		// Align to the column itself, or the top of it
		if (dlBox) { // Area range uses this method but not alignTo
			alignTo = merge(dlBox);

			if (inverted) {
				alignTo = {
					x: series.yAxis.len - alignTo.y - alignTo.height,
					y: series.xAxis.len - alignTo.x - alignTo.width,
					width: alignTo.height,
					height: alignTo.width
				};
			}

			// Compute the alignment box
			if (!inside) {
				if (inverted) {
					alignTo.x += below ? 0 : alignTo.width;
					alignTo.width = 0;
				} else {
					alignTo.y += below ? alignTo.height : 0;
					alignTo.height = 0;
				}
			}
		}


		// When alignment is undefined (typically columns and bars), display the individual
		// point below or above the point depending on the threshold
		options.align = pick(
			options.align,
			!inverted || inside ? 'center' : below ? 'right' : 'left'
		);
		options.verticalAlign = pick(
			options.verticalAlign,
			inverted || inside ? 'middle' : below ? 'top' : 'bottom'
		);

		// Call the parent method
		Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
	};
}



/**
 * Highstock JS v2.1.3 (2015-02-27)
 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
 *
 * (c) 2010-2014 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

/*global Highcharts, HighchartsAdapter */
(function (H) {
	var Chart = H.Chart,
		each = H.each,
		addEvent = HighchartsAdapter.addEvent;

	// Collect potensial overlapping data labels. Stack labels probably don't need to be 
	// considered because they are usually accompanied by data labels that lie inside the columns.
	Chart.prototype.callbacks.push(function (chart) {
		function collectAndHide() {
			var labels = [];

			each(chart.series, function (series) {
				var dlOptions = series.options.dataLabels;
				if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
					each(series.points, function (point) { 
						if (point.dataLabel) {
							point.dataLabel.labelrank = point.labelrank;
							labels.push(point.dataLabel);
						}
					});
				}
			});
			chart.hideOverlappingLabels(labels);
		}

		// Do it now ...
		collectAndHide();

		// ... and after each chart redraw
		addEvent(chart, 'redraw', collectAndHide);

	});

	/**
	 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
	 * visual imression.
	 */		
	Chart.prototype.hideOverlappingLabels = function (labels) {

		var len = labels.length,
			label,
			i,
			j,
			label1,
			label2,
			intersectRect = function (pos1, pos2, size1, size2) {
				return !(
					pos2.x > pos1.x + size1.width ||
					pos2.x + size2.width < pos1.x ||
					pos2.y > pos1.y + size1.height ||
					pos2.y + size2.height < pos1.y
				);
			};
	
		// Mark with initial opacity
		for (i = 0; i < len; i++) {
			label = labels[i];
			if (label) {
				label.oldOpacity = label.opacity;
				label.newOpacity = 1;
			}
		}

		// Detect overlapping labels
		for (i = 0; i < len; i++) {
			label1 = labels[i];

			for (j = i + 1; j < len; ++j) {
				label2 = labels[j];
				if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && 
						intersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {
					(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
				}
			}
		}

		// Hide or show
		for (i = 0; i < len; i++) {
			label = labels[i];
			if (label) {
				if (label.oldOpacity !== label.newOpacity && label.placed) {
					label.alignAttr.opacity = label.newOpacity;
					label[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);
				}
				label.isOld = true;
			}
		}
	};

}(Highcharts));/**
 * TrackerMixin for points and graphs
 */

var TrackerMixin = Highcharts.TrackerMixin = {

	drawTrackerPoint: function () {
		var series = this,
			chart = series.chart,
			pointer = chart.pointer,
			cursor = series.options.cursor,
			css = cursor && { cursor: cursor },
			onMouseOver = function (e) {
				var target = e.target,
				point;

				if (chart.hoverSeries !== series) {
					series.onMouseOver();
				}

				while (target && !point) {
					point = target.point;
					target = target.parentNode;
				}

				if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
					point.onMouseOver(e);
				}
			};

		// Add reference to the point
		each(series.points, function (point) {
			if (point.graphic) {
				point.graphic.element.point = point;
			}
			if (point.dataLabel) {
				point.dataLabel.element.point = point;
			}
		});

		// Add the event listeners, we need to do this only once
		if (!series._hasTracking) {
			each(series.trackerGroups, function (key) {
				if (series[key]) { // we don't always have dataLabelsGroup
					series[key]
						.addClass(PREFIX + 'tracker')
						.on('mouseover', onMouseOver)
						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
						.css(css);
					if (hasTouch) {
						series[key].on('touchstart', onMouseOver);
					}
				}
			});
			series._hasTracking = true;
		}
	},

	/**
	 * Draw the tracker object that sits above all data labels and markers to
	 * track mouse events on the graph or points. For the line type charts
	 * the tracker uses the same graphPath, but with a greater stroke width
	 * for better control.
	 */
	drawTrackerGraph: function () {
		var series = this,
			options = series.options,
			trackByArea = options.trackByArea,
			trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
			trackerPathLength = trackerPath.length,
			chart = series.chart,
			pointer = chart.pointer,
			renderer = chart.renderer,
			snap = chart.options.tooltip.snap,
			tracker = series.tracker,
			cursor = options.cursor,
			css = cursor && { cursor: cursor },
			singlePoints = series.singlePoints,
			singlePoint,
			i,
			onMouseOver = function () {
				if (chart.hoverSeries !== series) {
					series.onMouseOver();
				}
			},
			/*
			 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
			 * IE6: 0.002
			 * IE7: 0.002
			 * IE8: 0.002
			 * IE9: 0.00000000001 (unlimited)
			 * IE10: 0.0001 (exporting only)
			 * FF: 0.00000000001 (unlimited)
			 * Chrome: 0.000001
			 * Safari: 0.000001
			 * Opera: 0.00000000001 (unlimited)
			 */
			TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

		// Extend end points. A better way would be to use round linecaps,
		// but those are not clickable in VML.
		if (trackerPathLength && !trackByArea) {
			i = trackerPathLength + 1;
			while (i--) {
				if (trackerPath[i] === M) { // extend left side
					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
				}
				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
				}
			}
		}

		// handle single points
		for (i = 0; i < singlePoints.length; i++) {
			singlePoint = singlePoints[i];
			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
			L, singlePoint.plotX + snap, singlePoint.plotY);
		}

		// draw the tracker
		if (tracker) {
			tracker.attr({ d: trackerPath });
		} else { // create

			series.tracker = renderer.path(trackerPath)
			.attr({
				'stroke-linejoin': 'round', // #1225
				visibility: series.visible ? VISIBLE : HIDDEN,
				stroke: TRACKER_FILL,
				fill: trackByArea ? TRACKER_FILL : NONE,
				'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),
				zIndex: 2
			})
			.add(series.group);

			// The tracker is added to the series group, which is clipped, but is covered
			// by the marker group. So the marker group also needs to capture events.
			each([series.tracker, series.markerGroup], function (tracker) {
				tracker.addClass(PREFIX + 'tracker')
					.on('mouseover', onMouseOver)
					.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
					.css(css);

				if (hasTouch) {
					tracker.on('touchstart', onMouseOver);
				}
			});
		}
	}
};
/* End TrackerMixin */


/**
 * Add tracking event listener to the series group, so the point graphics
 * themselves act as trackers
 */ 

if (seriesTypes.column) {
	ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	
}

if (seriesTypes.pie) {
	seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

if (seriesTypes.scatter) {
	ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
}

/* 
 * Extend Legend for item events 
 */ 
extend(Legend.prototype, {

	setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
	var legend = this;
	// Set the events on the item group, or in case of useHTML, the item itself (#1249)
	(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
			item.setState(HOVER_STATE);
			legendItem.css(legend.options.itemHoverStyle);
		})
		.on('mouseout', function () {
			legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
			item.setState();
		})
		.on('click', function (event) {
			var strLegendItemClick = 'legendItemClick',
				fnLegendItemClick = function () {
					item.setVisible();
				};
				
			// Pass over the click/touch event. #4.
			event = {
				browserEvent: event
			};

			// click the name or symbol
			if (item.firePointEvent) { // point
				item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
			} else {
				fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
			}
		});
	},

	createCheckboxForItem: function (item) {
		var legend = this;

		item.checkbox = createElement('input', {
			type: 'checkbox',
			checked: item.selected,
			defaultChecked: item.selected // required by IE7
		}, legend.options.itemCheckboxStyle, legend.chart.container);

		addEvent(item.checkbox, 'click', function (event) {
			var target = event.target;
			fireEvent(item.series || item, 'checkboxClick', { // #3712
					checked: target.checked,
					item: item
				},
				function () {
					item.select();
				}
			);
		});
	}	
});

/* 
 * Add pointer cursor to legend itemstyle in defaultOptions
 */
defaultOptions.legend.itemStyle.cursor = 'pointer';


/* 
 * Extend the Chart object with interaction
 */

extend(Chart.prototype, {
	/**
	 * Display the zoom button
	 */
	showResetZoom: function () {
		var chart = this,
			lang = defaultOptions.lang,
			btnOptions = chart.options.chart.resetZoomButton,
			theme = btnOptions.theme,
			states = theme.states,
			alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
			
		this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
			.attr({
				align: btnOptions.position.align,
				title: lang.resetZoomTitle
			})
			.add()
			.align(btnOptions.position, false, alignTo);
			
	},

	/**
	 * Zoom out to 1:1
	 */
	zoomOut: function () {
		var chart = this;
		fireEvent(chart, 'selection', { resetSelection: true }, function () { 
			chart.zoom();
		});
	},

	/**
	 * Zoom into a given portion of the chart given by axis coordinates
	 * @param {Object} event
	 */
	zoom: function (event) {
		var chart = this,
			hasZoomed,
			pointer = chart.pointer,
			displayButton = false,
			resetZoomButton;

		// If zoom is called with no arguments, reset the axes
		if (!event || event.resetSelection) {
			each(chart.axes, function (axis) {
				hasZoomed = axis.zoom();
			});
		} else { // else, zoom in on all axes
			each(event.xAxis.concat(event.yAxis), function (axisData) {
				var axis = axisData.axis,
					isXAxis = axis.isXAxis;

				// don't zoom more than minRange
				if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
					hasZoomed = axis.zoom(axisData.min, axisData.max);
					if (axis.displayBtn) {
						displayButton = true;
					}
				}
			});
		}
		
		// Show or hide the Reset zoom button
		resetZoomButton = chart.resetZoomButton;
		if (displayButton && !resetZoomButton) {
			chart.showResetZoom();
		} else if (!displayButton && isObject(resetZoomButton)) {
			chart.resetZoomButton = resetZoomButton.destroy();
		}
		

		// Redraw
		if (hasZoomed) {
			chart.redraw(
				pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
			);
		}
	},

	/**
	 * Pan the chart by dragging the mouse across the pane. This function is called
	 * on mouse move, and the distance to pan is computed from chartX compared to
	 * the first chartX position in the dragging operation.
	 */
	pan: function (e, panning) {

		var chart = this,
			hoverPoints = chart.hoverPoints,
			doRedraw;

		// remove active points for shared tooltip
		if (hoverPoints) {
			each(hoverPoints, function (point) {
				point.setState();
			});
		}

		each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
			var mousePos = e[isX ? 'chartX' : 'chartY'],
				axis = chart[isX ? 'xAxis' : 'yAxis'][0],
				startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
				halfPointRange = (axis.pointRange || 0) / 2,
				extremes = axis.getExtremes(),
				newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
				newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
				goingLeft = startPos > mousePos; // #3613

			if (axis.series.length && 
					(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && 
					(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
				axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
				doRedraw = true;
			}

			chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
		});

		if (doRedraw) {
			chart.redraw(false);
		}
		css(chart.container, { cursor: 'move' });
	}
});

/*
 * Extend the Point object with interaction
 */
extend(Point.prototype, {
	/**
	 * Toggle the selection status of a point
	 * @param {Boolean} selected Whether to select or unselect the point.
	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
	 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
	 */
	select: function (selected, accumulate) {
		var point = this,
			series = point.series,
			chart = series.chart;

		selected = pick(selected, !point.selected);

		// fire the event with the defalut handler
		point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
			point.selected = point.options.selected = selected;
			series.options.data[inArray(point, series.data)] = point.options;

			point.setState(selected && SELECT_STATE);

			// unselect all other points unless Ctrl or Cmd + click
			if (!accumulate) {
				each(chart.getSelectedPoints(), function (loopPoint) {
					if (loopPoint.selected && loopPoint !== point) {
						loopPoint.selected = loopPoint.options.selected = false;
						series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
						loopPoint.setState(NORMAL_STATE);
							loopPoint.firePointEvent('unselect');
					}
				});
			}
		});
	},

	/**
	 * Runs on mouse over the point
	 */
	onMouseOver: function (e) {
		var point = this,
			series = point.series,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// set normal state to previous series
		if (hoverPoint && hoverPoint !== point) {
			hoverPoint.onMouseOut();
		}

		// trigger the event
		point.firePointEvent('mouseOver');

		// update the tooltip
		if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.refresh(point, e);
		}

		// hover this
		point.setState(HOVER_STATE);
		chart.hoverPoint = point;
	},

	/**
	 * Runs on mouse out from the point
	 */
	onMouseOut: function () {
		var chart = this.series.chart,
			hoverPoints = chart.hoverPoints;

		this.firePointEvent('mouseOut');

		if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
			this.setState();
			chart.hoverPoint = null;
		}
	},

	/**
	 * Import events from the series' and point's options. Only do it on
	 * demand, to save processing time on hovering.
	 */
	importEvents: function () {
		if (!this.hasImportedEvents) {
			var point = this,
				options = merge(point.series.options.point, point.options),
				events = options.events,
				eventType;

			point.events = events;

			for (eventType in events) {
				addEvent(point, eventType, events[eventType]);
			}
			this.hasImportedEvents = true;

		}
	},

	/**
	 * Set the point's state
	 * @param {String} state
	 */
	setState: function (state, move) {
		var point = this,
			plotX = point.plotX,
			plotY = point.plotY,
			series = point.series,
			stateOptions = series.options.states,
			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
			normalDisabled = markerOptions && !markerOptions.enabled,
			markerStateOptions = markerOptions && markerOptions.states[state],
			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
			stateMarkerGraphic = series.stateMarkerGraphic,
			pointMarker = point.marker || {},
			chart = series.chart,
			radius,
			halo = series.halo,
			haloOptions,
			newSymbol,
			pointAttr;

		state = state || NORMAL_STATE; // empty string
		pointAttr = point.pointAttr[state] || series.pointAttr[state];

		if (
				// already has this state
				(state === point.state && !move) ||
				// selected points don't respond to hover
				(point.selected && state !== SELECT_STATE) ||
				// series' state options is disabled
				(stateOptions[state] && stateOptions[state].enabled === false) ||
				// general point marker's state options is disabled
				(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
				// individual point marker's state options is disabled
				(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

			) {
			return;
		}

		// apply hover styles to the existing point
		if (point.graphic) {
			radius = markerOptions && point.graphic.symbolName && pointAttr.r;
			point.graphic.attr(merge(
				pointAttr,
				radius ? { // new symbol attributes (#507, #612)
					x: plotX - radius,
					y: plotY - radius,
					width: 2 * radius,
					height: 2 * radius
				} : {}
			));

			// Zooming in from a range with no markers to a range with markers
			if (stateMarkerGraphic) {
				stateMarkerGraphic.hide();
			}
		} else {
			// if a graphic is not applied to each point in the normal state, create a shared
			// graphic for the hover state
			if (state && markerStateOptions) {
				radius = markerStateOptions.radius;
				newSymbol = pointMarker.symbol || series.symbol;

				// If the point has another symbol than the previous one, throw away the
				// state marker graphic and force a new one (#1459)
				if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
					stateMarkerGraphic = stateMarkerGraphic.destroy();
				}

				// Add a new state marker graphic
				if (!stateMarkerGraphic) {
					if (newSymbol) {
						series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
							newSymbol,
							plotX - radius,
							plotY - radius,
							2 * radius,
							2 * radius
						)
						.attr(pointAttr)
						.add(series.markerGroup);
						stateMarkerGraphic.currentSymbol = newSymbol;
					}

				// Move the existing graphic
				} else {
					stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
						x: plotX - radius,
						y: plotY - radius
					});
				}
			}

			if (stateMarkerGraphic) {
				stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
			}
		}

		// Show me your halo
		haloOptions = stateOptions[state] && stateOptions[state].halo;
		if (haloOptions && haloOptions.size) {
			if (!halo) {
				series.halo = halo = chart.renderer.path()
					.add(chart.seriesGroup);
			}
			halo.attr(extend({
				fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
			}, haloOptions.attributes))[move ? 'animate' : 'attr']({
				d: point.haloPath(haloOptions.size)
			});
		} else if (halo) {
			halo.attr({ d: [] });
		}

		point.state = state;
	},

	haloPath: function (size) {
		var series = this.series,
			chart = series.chart,
			plotBox = series.getPlotBox(),
			inverted = chart.inverted;

		return chart.renderer.symbols.circle(
			plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, 
			plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, 
			size * 2, 
			size * 2
		);
	}
});

/*
 * Extend the Series object with interaction
 */

extend(Series.prototype, {
	/**
	 * Series mouse over handler
	 */
	onMouseOver: function () {
		var series = this,
			chart = series.chart,
			hoverSeries = chart.hoverSeries;

		// set normal state to previous series
		if (hoverSeries && hoverSeries !== series) {
			hoverSeries.onMouseOut();
		}

		// trigger the event, but to save processing time,
		// only if defined
		if (series.options.events.mouseOver) {
			fireEvent(series, 'mouseOver');
		}

		// hover this
		series.setState(HOVER_STATE);
		chart.hoverSeries = series;
	},

	/**
	 * Series mouse out handler
	 */
	onMouseOut: function () {
		// trigger the event only if listeners exist
		var series = this,
			options = series.options,
			chart = series.chart,
			tooltip = chart.tooltip,
			hoverPoint = chart.hoverPoint;

		// trigger mouse out on the point, which must be in this series
		if (hoverPoint) {
			hoverPoint.onMouseOut();
		}

		// fire the mouse out event
		if (series && options.events.mouseOut) {
			fireEvent(series, 'mouseOut');
		}


		// hide the tooltip
		if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
			tooltip.hide();
		}

		// set normal state
		series.setState();
		chart.hoverSeries = null;
	},

	/**
	 * Set the state of the graph
	 */
	setState: function (state) {
		var series = this,
			options = series.options,
			graph = series.graph,
			graphNeg = series.graphNeg,
			stateOptions = options.states,
			lineWidth = options.lineWidth,
			attribs;

		state = state || NORMAL_STATE;

		if (series.state !== state) {
			series.state = state;

			if (stateOptions[state] && stateOptions[state].enabled === false) {
				return;
			}

			if (state) {
				lineWidth = (stateOptions[state].lineWidth || lineWidth) + (stateOptions[state].lineWidthPlus || 0);
			}

			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
				attribs = {
					'stroke-width': lineWidth
				};
				// use attr because animate will cause any other animation on the graph to stop
				graph.attr(attribs);
				if (graphNeg) {
					graphNeg.attr(attribs);
				}
			}
		}
	},

	/**
	 * Set the visibility of the graph
	 *
	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
	 *				the visibility is toggled.
	 */
	setVisible: function (vis, redraw) {
		var series = this,
			chart = series.chart,
			legendItem = series.legendItem,
			showOrHide,
			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
			oldVisibility = series.visible;

		// if called without an argument, toggle visibility
		series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
		showOrHide = vis ? 'show' : 'hide';

		// show or hide elements
		each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
			if (series[key]) {
				series[key][showOrHide]();
			}
		});


		// hide tooltip (#1361)
		if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
			series.onMouseOut();
		}


		if (legendItem) {
			chart.legend.colorizeItem(series, vis);
		}


		// rescale or adapt to resized chart
		series.isDirty = true;
		// in a stack, all other series are affected
		if (series.options.stacking) {
			each(chart.series, function (otherSeries) {
				if (otherSeries.options.stacking && otherSeries.visible) {
					otherSeries.isDirty = true;
				}
			});
		}

		// show or hide linked series
		each(series.linkedSeries, function (otherSeries) {
			otherSeries.setVisible(vis, false);
		});

		if (ignoreHiddenSeries) {
			chart.isDirtyBox = true;
		}
		if (redraw !== false) {
			chart.redraw();
		}

		fireEvent(series, showOrHide);
	},

	/**
	 * Show the graph
	 */
	show: function () {
		this.setVisible(true);
	},

	/**
	 * Hide the graph
	 */
	hide: function () {
		this.setVisible(false);
	},


	/**
	 * Set the selected state of the graph
	 *
	 * @param selected {Boolean} True to select the series, false to unselect. If
	 *				UNDEFINED, the selection state is toggled.
	 */
	select: function (selected) {
		var series = this;
		// if called without an argument, toggle
		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

		if (series.checkbox) {
			series.checkbox.checked = selected;
		}

		fireEvent(series, selected ? 'select' : 'unselect');
	},

	drawTracker: TrackerMixin.drawTrackerGraph
});/* ****************************************************************************
 * Start ordinal axis logic                                                   *
 *****************************************************************************/


wrap(Series.prototype, 'init', function (proceed) {
	var series = this,
		xAxis;

	// call the original function
	proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	xAxis = series.xAxis;

	// Destroy the extended ordinal index on updated data
	if (xAxis && xAxis.options.ordinal) {
		addEvent(series, 'updatedData', function () {
			delete xAxis.ordinalIndex;
		});
	}
});

/**
 * In an ordinal axis, there might be areas with dense consentrations of points, then large
 * gaps between some. Creating equally distributed ticks over this entire range
 * may lead to a huge number of ticks that will later be removed. So instead, break the
 * positions up in segments, find the tick positions for each segment then concatenize them.
 * This method is used from both data grouping logic and X axis tick position logic.
 */
wrap(Axis.prototype, 'getTimeTicks', function (proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks) {

	var start = 0,
		end = 0,
		segmentPositions,
		higherRanks = {},
		hasCrossedHigherRank,
		info,
		posLength,
		outsideMax,
		groupPositions = [],
		lastGroupPosition = -Number.MAX_VALUE,
		tickPixelIntervalOption = this.options.tickPixelInterval;

	// The positions are not always defined, for example for ordinal positions when data
	// has regular interval (#1557, #2090)
	if ((!this.options.ordinal && !this.options.breaks) || !positions || positions.length < 3 || min === UNDEFINED) {
		return proceed.call(this, normalizedInterval, min, max, startOfWeek);
	}

	// Analyze the positions array to split it into segments on gaps larger than 5 times
	// the closest distance. The closest distance is already found at this point, so
	// we reuse that instead of computing it again.
	posLength = positions.length;

	for (; end < posLength; end++) {

		outsideMax = end && positions[end - 1] > max;

		if (positions[end] < min) { // Set the last position before min
			start = end;
		}

		if (end === posLength - 1 || positions[end + 1] - positions[end] > closestDistance * 5 || outsideMax) {

			// For each segment, calculate the tick positions from the getTimeTicks utility
			// function. The interval will be the same regardless of how long the segment is.
			if (positions[end] > lastGroupPosition) { // #1475

				segmentPositions = proceed.call(this, normalizedInterval, positions[start], positions[end], startOfWeek);

				// Prevent duplicate groups, for example for multiple segments within one larger time frame (#1475)
				while (segmentPositions.length && segmentPositions[0] <= lastGroupPosition) {
					segmentPositions.shift();
				}
				if (segmentPositions.length) {
					lastGroupPosition = segmentPositions[segmentPositions.length - 1];
				}

				groupPositions = groupPositions.concat(segmentPositions);
			}
			// Set start of next segment
			start = end + 1;
		}

		if (outsideMax) {
			break;
		}
	}

	// Get the grouping info from the last of the segments. The info is the same for
	// all segments.
	info = segmentPositions.info;

	// Optionally identify ticks with higher rank, for example when the ticks
	// have crossed midnight.
	if (findHigherRanks && info.unitRange <= timeUnits.hour) {
		end = groupPositions.length - 1;

		// Compare points two by two
		for (start = 1; start < end; start++) {
			if (dateFormat('%d', groupPositions[start]) !== dateFormat('%d', groupPositions[start - 1])) {
				higherRanks[groupPositions[start]] = 'day';
				hasCrossedHigherRank = true;
			}
		}

		// If the complete array has crossed midnight, we want to mark the first
		// positions also as higher rank
		if (hasCrossedHigherRank) {
			higherRanks[groupPositions[0]] = 'day';
		}
		info.higherRanks = higherRanks;
	}

	// Save the info
	groupPositions.info = info;



	// Don't show ticks within a gap in the ordinal axis, where the space between
	// two points is greater than a portion of the tick pixel interval
	if (findHigherRanks && defined(tickPixelIntervalOption)) { // check for squashed ticks

		var length = groupPositions.length,
			i = length,
			itemToRemove,
			translated,
			translatedArr = [],
			lastTranslated,
			medianDistance,
			distance,
			distances = [];

		// Find median pixel distance in order to keep a reasonably even distance between
		// ticks (#748)
		while (i--) {
			translated = this.translate(groupPositions[i]);
			if (lastTranslated) {
				distances[i] = lastTranslated - translated;
			}
			translatedArr[i] = lastTranslated = translated;
		}
		distances.sort();
		medianDistance = distances[mathFloor(distances.length / 2)];
		if (medianDistance < tickPixelIntervalOption * 0.6) {
			medianDistance = null;
		}

		// Now loop over again and remove ticks where needed
		i = groupPositions[length - 1] > max ? length - 1 : length; // #817
		lastTranslated = undefined;
		while (i--) {
			translated = translatedArr[i];
			distance = lastTranslated - translated;

			// Remove ticks that are closer than 0.6 times the pixel interval from the one to the right,
			// but not if it is close to the median distance (#748).
			if (lastTranslated && distance < tickPixelIntervalOption * 0.8 &&
					(medianDistance === null || distance < medianDistance * 0.8)) {

				// Is this a higher ranked position with a normal position to the right?
				if (higherRanks[groupPositions[i]] && !higherRanks[groupPositions[i + 1]]) {

					// Yes: remove the lower ranked neighbour to the right
					itemToRemove = i + 1;
					lastTranslated = translated; // #709

				} else {

					// No: remove this one
					itemToRemove = i;
				}

				groupPositions.splice(itemToRemove, 1);

			} else {
				lastTranslated = translated;
			}
		}
	}
	return groupPositions;
});

// Extend the Axis prototype
extend(Axis.prototype, {

	/**
	 * Calculate the ordinal positions before tick positions are calculated.
	 */
	beforeSetTickPositions: function () {
		var axis = this,
			len,
			ordinalPositions = [],
			useOrdinal = false,
			dist,
			extremes = axis.getExtremes(),
			min = extremes.min,
			max = extremes.max,
			minIndex,
			maxIndex,
			slope,
			i;

		// apply the ordinal logic
		if (axis.options.ordinal || axis.options.breaks) {

			each(axis.series, function (series, i) {

				if (series.visible !== false && (series.takeOrdinalPosition !== false || axis.options.breaks)) {

					// concatenate the processed X data into the existing positions, or the empty array
					ordinalPositions = ordinalPositions.concat(series.processedXData);
					len = ordinalPositions.length;

					// remove duplicates (#1588)
					ordinalPositions.sort(function (a, b) {
						return a - b; // without a custom function it is sorted as strings
					});

					if (len) {
						i = len - 1;
						while (i--) {
							if (ordinalPositions[i] === ordinalPositions[i + 1]) {
								ordinalPositions.splice(i, 1);
							}
						}
					}
				}

			});

			// cache the length
			len = ordinalPositions.length;

			// Check if we really need the overhead of mapping axis data against the ordinal positions.
			// If the series consist of evenly spaced data any way, we don't need any ordinal logic.
			if (len > 2) { // two points have equal distance by default
				dist = ordinalPositions[1] - ordinalPositions[0];
				i = len - 1;
				while (i-- && !useOrdinal) {
					if (ordinalPositions[i + 1] - ordinalPositions[i] !== dist) {
						useOrdinal = true;
					}
				}

				// When zooming in on a week, prevent axis padding for weekends even though the data within
				// the week is evenly spaced.
				if (!axis.options.keepOrdinalPadding && (ordinalPositions[0] - min > dist || max - ordinalPositions[ordinalPositions.length - 1] > dist)) {
					useOrdinal = true;
				}
			}

			// Record the slope and offset to compute the linear values from the array index.
			// Since the ordinal positions may exceed the current range, get the start and
			// end positions within it (#719, #665b)
			if (useOrdinal) {

				// Register
				axis.ordinalPositions = ordinalPositions;

				// This relies on the ordinalPositions being set. Use mathMax and mathMin to prevent
				// padding on either sides of the data.
				minIndex = axis.val2lin(mathMax(min, ordinalPositions[0]), true);
				maxIndex = mathMax(axis.val2lin(mathMin(max, ordinalPositions[ordinalPositions.length - 1]), true), 1); // #3339

				// Set the slope and offset of the values compared to the indices in the ordinal positions
				axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
				axis.ordinalOffset = min - (minIndex * slope);

			} else {
				axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = UNDEFINED;
			}
			if (axis.options.ordinal) {
				axis.doPostTranslate = useOrdinal; // #3818
			}
		}
		axis.groupIntervalFactor = null; // reset for next run
	},
	/**
	 * Translate from a linear axis value to the corresponding ordinal axis position. If there
	 * are no gaps in the ordinal axis this will be the same. The translated value is the value
	 * that the point would have if the axis were linear, using the same min and max.
	 *
	 * @param Number val The axis value
	 * @param Boolean toIndex Whether to return the index in the ordinalPositions or the new value
	 */
	val2lin: function (val, toIndex) {
		var axis = this,
			ordinalPositions = axis.ordinalPositions;

		if (!ordinalPositions) {
			return val;

		} else {

			var ordinalLength = ordinalPositions.length,
				i,
				distance,
				ordinalIndex;

			// first look for an exact match in the ordinalpositions array
			i = ordinalLength;
			while (i--) {
				if (ordinalPositions[i] === val) {
					ordinalIndex = i;
					break;
				}
			}

			// if that failed, find the intermediate position between the two nearest values
			i = ordinalLength - 1;
			while (i--) {
				if (val > ordinalPositions[i] || i === 0) { // interpolate
					distance = (val - ordinalPositions[i]) / (ordinalPositions[i + 1] - ordinalPositions[i]); // something between 0 and 1
					ordinalIndex = i + distance;
					break;
				}
			}
			return toIndex ?
				ordinalIndex :
				axis.ordinalSlope * (ordinalIndex || 0) + axis.ordinalOffset;
		}
	},
	/**
	 * Translate from linear (internal) to axis value
	 *
	 * @param Number val The linear abstracted value
	 * @param Boolean fromIndex Translate from an index in the ordinal positions rather than a value
	 */
	lin2val: function (val, fromIndex) {
		var axis = this,
			ordinalPositions = axis.ordinalPositions;

		if (!ordinalPositions) { // the visible range contains only equally spaced values
			return val;

		} else {

			var ordinalSlope = axis.ordinalSlope,
				ordinalOffset = axis.ordinalOffset,
				i = ordinalPositions.length - 1,
				linearEquivalentLeft,
				linearEquivalentRight,
				distance;


			// Handle the case where we translate from the index directly, used only
			// when panning an ordinal axis
			if (fromIndex) {

				if (val < 0) { // out of range, in effect panning to the left
					val = ordinalPositions[0];
				} else if (val > i) { // out of range, panning to the right
					val = ordinalPositions[i];
				} else { // split it up
					i = mathFloor(val);
					distance = val - i; // the decimal
				}

			// Loop down along the ordinal positions. When the linear equivalent of i matches
			// an ordinal position, interpolate between the left and right values.
			} else {
				while (i--) {
					linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
					if (val >= linearEquivalentLeft) {
						linearEquivalentRight = (ordinalSlope * (i + 1)) + ordinalOffset;
						distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft); // something between 0 and 1
						break;
					}
				}
			}

			// If the index is within the range of the ordinal positions, return the associated
			// or interpolated value. If not, just return the value
			return distance !== UNDEFINED && ordinalPositions[i] !== UNDEFINED ?
				ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + 1] - ordinalPositions[i]) : 0) :
				val;
		}
	},
	/**
	 * Get the ordinal positions for the entire data set. This is necessary in chart panning
	 * because we need to find out what points or data groups are available outside the
	 * visible range. When a panning operation starts, if an index for the given grouping
	 * does not exists, it is created and cached. This index is deleted on updated data, so
	 * it will be regenerated the next time a panning operation starts.
	 */
	getExtendedPositions: function () {
		var axis = this,
			chart = axis.chart,
			grouping = axis.series[0].currentDataGrouping,
			ordinalIndex = axis.ordinalIndex,
			key = grouping ? grouping.count + grouping.unitName : 'raw',
			extremes = axis.getExtremes(),
			fakeAxis,
			fakeSeries;

		// If this is the first time, or the ordinal index is deleted by updatedData,
		// create it.
		if (!ordinalIndex) {
			ordinalIndex = axis.ordinalIndex = {};
		}


		if (!ordinalIndex[key]) {

			// Create a fake axis object where the extended ordinal positions are emulated
			fakeAxis = {
				series: [],
				getExtremes: function () {
					return {
						min: extremes.dataMin,
						max: extremes.dataMax
					};
				},
				options: {
					ordinal: true
				},
				val2lin: Axis.prototype.val2lin // #2590
			};

			// Add the fake series to hold the full data, then apply processData to it
			each(axis.series, function (series) {
				fakeSeries = {
					xAxis: fakeAxis,
					xData: series.xData,
					chart: chart,
					destroyGroupedData: noop
				};
				fakeSeries.options = {
					dataGrouping : grouping ? {
						enabled: true,
						forced: true,
						approximation: 'open', // doesn't matter which, use the fastest
						units: [[grouping.unitName, [grouping.count]]]
					} : {
						enabled: false
					}
				};
				series.processData.apply(fakeSeries);

				fakeAxis.series.push(fakeSeries);
			});

			// Run beforeSetTickPositions to compute the ordinalPositions
			axis.beforeSetTickPositions.apply(fakeAxis);

			// Cache it
			ordinalIndex[key] = fakeAxis.ordinalPositions;
		}
		return ordinalIndex[key];
	},

	/**
	 * Find the factor to estimate how wide the plot area would have been if ordinal
	 * gaps were included. This value is used to compute an imagined plot width in order
	 * to establish the data grouping interval.
	 *
	 * A real world case is the intraday-candlestick
	 * example. Without this logic, it would show the correct data grouping when viewing
	 * a range within each day, but once moving the range to include the gap between two
	 * days, the interval would include the cut-away night hours and the data grouping
	 * would be wrong. So the below method tries to compensate by identifying the most
	 * common point interval, in this case days.
	 *
	 * An opposite case is presented in issue #718. We have a long array of daily data,
	 * then one point is appended one hour after the last point. We expect the data grouping
	 * not to change.
	 *
	 * In the future, if we find cases where this estimation doesn't work optimally, we
	 * might need to add a second pass to the data grouping logic, where we do another run
	 * with a greater interval if the number of data groups is more than a certain fraction
	 * of the desired group count.
	 */
	getGroupIntervalFactor: function (xMin, xMax, series) {
		var i = 0,
			processedXData = series.processedXData,
			len = processedXData.length,
			distances = [],
			median,
			groupIntervalFactor = this.groupIntervalFactor;

		// Only do this computation for the first series, let the other inherit it (#2416)
		if (!groupIntervalFactor) {

			// Register all the distances in an array
			for (; i < len - 1; i++) {
				distances[i] = processedXData[i + 1] - processedXData[i];
			}

			// Sort them and find the median
			distances.sort(function (a, b) {
					return a - b;
			});
			median = distances[mathFloor(len / 2)];

			// Compensate for series that don't extend through the entire axis extent. #1675.
			xMin = mathMax(xMin, processedXData[0]);
			xMax = mathMin(xMax, processedXData[len - 1]);

			this.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);
		}

		// Return the factor needed for data grouping
		return groupIntervalFactor;
	},

	/**
	 * Make the tick intervals closer because the ordinal gaps make the ticks spread out or cluster
	 */
	postProcessTickInterval: function (tickInterval) {
		// TODO: http://jsfiddle.net/highcharts/FQm4E/1/
		// This is a case where this algorithm doesn't work optimally. In this case, the
		// tick labels are spread out per week, but all the gaps reside within weeks. So
		// we have a situation where the labels are courser than the ordinal gaps, and
		// thus the tick interval should not be altered
		var ordinalSlope = this.ordinalSlope;


		if (ordinalSlope) {
			if (!this.options.breaks) {
				return tickInterval / (ordinalSlope / this.closestPointRange); 
			} else {
				return this.closestPointRange;
			}
		} else {
			return tickInterval;
		}
	}
});

// Extending the Chart.pan method for ordinal axes
wrap(Chart.prototype, 'pan', function (proceed, e) {
	var chart = this,
		xAxis = chart.xAxis[0],
		chartX = e.chartX,
		runBase = false;

	if (xAxis.options.ordinal && xAxis.series.length) {

		var mouseDownX = chart.mouseDownX,
			extremes = xAxis.getExtremes(),
			dataMax = extremes.dataMax,
			min = extremes.min,
			max = extremes.max,
			trimmedRange,
			hoverPoints = chart.hoverPoints,
			closestPointRange = xAxis.closestPointRange,
			pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
			movedUnits = (mouseDownX - chartX) / pointPixelWidth, // how many ordinal units did we move?
			extendedAxis = { ordinalPositions: xAxis.getExtendedPositions() }, // get index of all the chart's points
			ordinalPositions,
			searchAxisLeft,
			lin2val = xAxis.lin2val,
			val2lin = xAxis.val2lin,
			searchAxisRight;

		if (!extendedAxis.ordinalPositions) { // we have an ordinal axis, but the data is equally spaced
			runBase = true;

		} else if (mathAbs(movedUnits) > 1) {

			// Remove active points for shared tooltip
			if (hoverPoints) {
				each(hoverPoints, function (point) {
					point.setState();
				});
			}

			if (movedUnits < 0) {
				searchAxisLeft = extendedAxis;
				searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
			} else {
				searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
				searchAxisRight = extendedAxis;
			}

			// In grouped data series, the last ordinal position represents the grouped data, which is
			// to the left of the real data max. If we don't compensate for this, we will be allowed
			// to pan grouped data series passed the right of the plot area.
			ordinalPositions = searchAxisRight.ordinalPositions;
			if (dataMax > ordinalPositions[ordinalPositions.length - 1]) {
				ordinalPositions.push(dataMax);
			}

			// Get the new min and max values by getting the ordinal index for the current extreme,
			// then add the moved units and translate back to values. This happens on the
			// extended ordinal positions if the new position is out of range, else it happens
			// on the current x axis which is smaller and faster.
			chart.fixedRange = max - min;
			trimmedRange = xAxis.toFixedRange(null, null,
				lin2val.apply(searchAxisLeft, [
					val2lin.apply(searchAxisLeft, [min, true]) + movedUnits, // the new index
					true // translate from index
				]),
				lin2val.apply(searchAxisRight, [
					val2lin.apply(searchAxisRight, [max, true]) + movedUnits, // the new index
					true // translate from index
				])
			);

			// Apply it if it is within the available data range
			if (trimmedRange.min >= mathMin(extremes.dataMin, min) && trimmedRange.max <= mathMax(dataMax, max)) {
				xAxis.setExtremes(trimmedRange.min, trimmedRange.max, true, false, { trigger: 'pan' });
			}

			chart.mouseDownX = chartX; // set new reference for next run
			css(chart.container, { cursor: 'move' });
		}

	} else {
		runBase = true;
	}

	// revert to the linear chart.pan version
	if (runBase) {
		// call the original function
		proceed.apply(this, Array.prototype.slice.call(arguments, 1));
	}
});



/**
 * Extend getSegments by identifying gaps in the ordinal data so that we can draw a gap in the
 * line or area
 */
wrap(Series.prototype, 'getSegments', function (proceed) {

	var series = this,
		segments,
		gapSize = series.options.gapSize,
		xAxis = series.xAxis;

	// call base method
	proceed.apply(this, Array.prototype.slice.call(arguments, 1));

	if (gapSize) {

		// properties
		segments = series.segments;

		// extension for ordinal breaks
		each(segments, function (segment, no) {
			var i = segment.length - 1;
			while (i--) {
				if (segment[i + 1].x - segment[i].x > xAxis.closestPointRange * gapSize) {
					segments.splice( // insert after this one
						no + 1,
						0,
						segment.splice(i + 1, segment.length - i)
					);
				}
			}
		});
	}
});

/* ****************************************************************************
 * End ordinal axis logic                                                   *
 *****************************************************************************/
/**
 * Highstock JS v2.1.3 (2015-02-27)
 * Highcharts Broken Axis module
 * 
 * Author: Stephane Vanraes, Torstein Honsi
 * License: www.highcharts.com/license
 */

/*global HighchartsAdapter*/
(function (H) {	

	"use strict";

	var pick = H.pick,
		wrap = H.wrap,
		extend = H.extend,
		fireEvent = HighchartsAdapter.fireEvent,
		Axis = H.Axis,
		Series = H.Series;

	function stripArguments() {
		return Array.prototype.slice.call(arguments, 1);
	}

	extend(Axis.prototype, {
		isInBreak: function (brk, val) {
			var repeat = brk.repeat || Infinity,
				from = brk.from,
				length = brk.to - brk.from,
				test = (val >= from ? (val - from) % repeat :  repeat - ((from - val) % repeat));

			if (!brk.inclusive) {
				return (test < length && test !== 0);
			} else {
				return (test <= length);
			}
		},

		isInAnyBreak: function (val, testKeep) {
			// Sanity Check			
			if (!this.options.breaks) { return false; }

			var breaks = this.options.breaks,
				i = breaks.length,
				inbrk = false,
				keep = false;


			while (i--) {
				if (this.isInBreak(breaks[i], val)) {
					inbrk = true;
					if (!keep) {
						keep = pick(breaks[i].showPoints, this.isXAxis ? false : true);
					}
				}
			}

			if (inbrk && testKeep) {
				return inbrk && !keep;
			} else {
				return inbrk;
			}
		}
	});

	wrap(Axis.prototype, 'setTickPositions', function (proceed) {
		proceed.apply(this, Array.prototype.slice.call(arguments, 1));
		
		if (this.options.breaks) {
			var axis = this,
				tickPositions = this.tickPositions,
				info = this.tickPositions.info,
				newPositions = [],
				i;

			if (info && info.totalRange >= axis.closestPointRange) { 
				return;
			}

			for (i = 0; i < tickPositions.length; i++) {
				if (!axis.isInAnyBreak(tickPositions[i])) {
					newPositions.push(tickPositions[i]);
				}
			}

			this.tickPositions = newPositions;
			this.tickPositions.info = info;
		}
	});
	
	wrap(Axis.prototype, 'init', function (proceed, chart, userOptions) {
		// Force Axis to be not-ordinal when breaks are defined
		if (userOptions.breaks && userOptions.breaks.length) {
			userOptions.ordinal = false;
		}

		proceed.call(this, chart, userOptions);

		if (this.options.breaks) {

			var axis = this;
			
			axis.doPostTranslate = true;

			this.val2lin = function (val) {
				var nval = val,
					brk,
					i;

				for (i = 0; i < axis.breakArray.length; i++) {
					brk = axis.breakArray[i];
					if (brk.to <= val) {
						nval -= (brk.len);
					} else if (brk.from >= val) {
						break;
					} else if (axis.isInBreak(brk, val)) {
						nval -= (val - brk.from);
						break;
					}
				}

				return nval;
			};
			
			this.lin2val = function (val) {
				var nval = val,
					brk,
					i;

				for (i = 0; i < axis.breakArray.length; i++) {
					brk = axis.breakArray[i];
					if (brk.from >= nval) {
						break;
					} else if (brk.to < nval) {
						nval += (brk.to - brk.from);
					} else if (axis.isInBreak(brk, nval)) {
						nval += (brk.to - brk.from);
					}
				}

				return nval;
			};

			this.setExtremes = function (newMin, newMax, redraw, animation, eventArguments) {
				// If trying to set extremes inside a break, extend it to before and after the break ( #3857 )
				while (this.isInAnyBreak(newMin)) {
					newMin -= this.closestPointRange;
				}				
				while (this.isInAnyBreak(newMax)) {
					newMax -= this.closestPointRange;
				}
				Axis.prototype.setExtremes.call(this, newMin, newMax, redraw, animation, eventArguments);
			};

			this.setAxisTranslation = function (saveOld) {
				Axis.prototype.setAxisTranslation.call(this, saveOld);

				var breaks = axis.options.breaks,
					breakArrayT = [],	// Temporary one
					breakArray = [],
					length = 0, 
					inBrk,
					repeat,
					brk,
					min = axis.userMin || axis.min,
					max = axis.userMax || axis.max,
					start,
					i,
					j;

				// Min & Max Check
				for (i in breaks) {
					brk = breaks[i];
					if (axis.isInBreak(brk, min)) {
						min += (brk.to % brk.repeat) - (min % brk.repeat);
					}
					if (axis.isInBreak(brk, max)) {
						max -= (max % brk.repeat) - (brk.from % brk.repeat);
					}
				}

				// Construct an array holding all breaks in the axis
				for (i in breaks) {
					brk = breaks[i];
					start = brk.from;
					repeat = brk.repeat || Infinity;

					while (start - repeat > min) {
						start -= repeat;
					}
					while (start < min) {
						start += repeat;
					}

					for (j = start; j < max; j += repeat) {
						breakArrayT.push({
							value: j,
							move: 'in'
						});
						breakArrayT.push({
							value: j + (brk.to - brk.from),
							move: 'out',
							size: brk.breakSize
						});
					}
				}

				breakArrayT.sort(function (a, b) {
					if (a.value === b.value) {
						return (a.move === 'in' ? 0 : 1) - (b.move === 'in' ? 0 : 1);
					} else {
						return a.value - b.value;
					}
				});
				
				// Simplify the breaks
				inBrk = 0;
				start = min;

				for (i in breakArrayT) {
					brk = breakArrayT[i];
					inBrk += (brk.move === 'in' ? 1 : -1);

					if (inBrk === 1 && brk.move === 'in') {
						start = brk.value;
					}
					if (inBrk === 0) {
						breakArray.push({
							from: start,
							to: brk.value,
							len: brk.value - start - (brk.size || 0)
						});
						length += brk.value - start - (brk.size || 0);
					}
				}

				axis.breakArray = breakArray;

				fireEvent(axis, 'afterBreaks');
				
				axis.transA *= ((max - axis.min) / (max - min - length));

				axis.min = min;
				axis.max = max;

			};
		}
	});

	wrap(Series.prototype, 'generatePoints', function (proceed) {

		proceed.apply(this, stripArguments(arguments));

		var series = this,
			xAxis = series.xAxis,
			yAxis = series.yAxis,
			points = series.points,
			point,
			i = points.length;


		if (xAxis && yAxis && (xAxis.options.breaks || yAxis.options.breaks)) {
			while (i--) {
				point = points[i];

				if (xAxis.isInAnyBreak(point.x, true) || yAxis.isInAnyBreak(point.y, true)) {
					points.splice(i, 1);
					this.data[i].destroyElements(); // removes the graphics for this point if they exist
				}
			}
		}

	});

	wrap(H.seriesTypes.column.prototype, 'drawPoints', function (proceed) {
		proceed.apply(this);

		var series = this,
			points = series.points,
			yAxis = series.yAxis,
			breaks = yAxis.breakArray || [],
			point,
			brk,
			i,
			j,
			y;

		for (i = 0; i < points.length; i++) {
			point = points[i];
			y = point.stackY || point.y;
			for (j = 0; j < breaks.length; j++) {
				brk = breaks[j];
				if (y < brk.from) {
					break;
				} else if (y > brk.to) {
					fireEvent(yAxis, 'pointBreak', {point: point, brk: brk});
				} else {
					fireEvent(yAxis, 'pointInBreak', {point: point, brk: brk});
				}
			}
		}

	});
}(Highcharts));
/* ****************************************************************************
 * Start data grouping module												 *
 ******************************************************************************/
/*jslint white:true */
var DATA_GROUPING = 'dataGrouping',
	seriesProto = Series.prototype,
	tooltipProto = Tooltip.prototype,
	baseProcessData = seriesProto.processData,
	baseGeneratePoints = seriesProto.generatePoints,
	baseDestroy = seriesProto.destroy,
	baseTooltipFooterHeaderFormatter = tooltipProto.tooltipFooterHeaderFormatter,
	NUMBER = 'number',

	commonOptions = {
		approximation: 'average', // average, open, high, low, close, sum
		//enabled: null, // (true for stock charts, false for basic),
		//forced: undefined,
		groupPixelWidth: 2,
		// the first one is the point or start value, the second is the start value if we're dealing with range,
		// the third one is the end value if dealing with a range
		dateTimeLabelFormats: {
			millisecond: ['%A, %b %e, %H:%M:%S.%L', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L'],
			second: ['%A, %b %e, %H:%M:%S', '%A, %b %e, %H:%M:%S', '-%H:%M:%S'],
			minute: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
			hour: ['%A, %b %e, %H:%M', '%A, %b %e, %H:%M', '-%H:%M'],
			day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
			week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
			month: ['%B %Y', '%B', '-%B %Y'],
			year: ['%Y', '%Y', '-%Y']
		}
		// smoothed = false, // enable this for navigator series only
	},

	specificOptions = { // extends common options
		line: {},
		spline: {},
		area: {},
		areaspline: {},
		column: {
			approximation: 'sum',
			groupPixelWidth: 10
		},
		arearange: {
			approximation: 'range'
		},
		areasplinerange: {
			approximation: 'range'
		},
		columnrange: {
			approximation: 'range',
			groupPixelWidth: 10
		},
		candlestick: {
			approximation: 'ohlc',
			groupPixelWidth: 10
		},
		ohlc: {
			approximation: 'ohlc',
			groupPixelWidth: 5
		}
	},

	// units are defined in a separate array to allow complete overriding in case of a user option
	defaultDataGroupingUnits = [[
			'millisecond', // unit name
			[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
		], [
			'second',
			[1, 2, 5, 10, 15, 30]
		], [
			'minute',
			[1, 2, 5, 10, 15, 30]
		], [
			'hour',
			[1, 2, 3, 4, 6, 8, 12]
		], [
			'day',
			[1]
		], [
			'week',
			[1]
		], [
			'month',
			[1, 3, 6]
		], [
			'year',
			null
		]
	],


	/**
	 * Define the available approximation types. The data grouping approximations takes an array
	 * or numbers as the first parameter. In case of ohlc, four arrays are sent in as four parameters.
	 * Each array consists only of numbers. In case null values belong to the group, the property
	 * .hasNulls will be set to true on the array.
	 */
	approximations = {
		sum: function (arr) {
			var len = arr.length,
				ret;

			// 1. it consists of nulls exclusively
			if (!len && arr.hasNulls) {
				ret = null;
			// 2. it has a length and real values
			} else if (len) {
				ret = 0;
				while (len--) {
					ret += arr[len];
				}
			}
			// 3. it has zero length, so just return undefined
			// => doNothing()

			return ret;
		},
		average: function (arr) {
			var len = arr.length,
				ret = approximations.sum(arr);

			// If we have a number, return it divided by the length. If not, return
			// null or undefined based on what the sum method finds.
			if (typeof ret === NUMBER && len) {
				ret = ret / len;
			}

			return ret;
		},
		open: function (arr) {
			return arr.length ? arr[0] : (arr.hasNulls ? null : UNDEFINED);
		},
		high: function (arr) {
			return arr.length ? arrayMax(arr) : (arr.hasNulls ? null : UNDEFINED);
		},
		low: function (arr) {
			return arr.length ? arrayMin(arr) : (arr.hasNulls ? null : UNDEFINED);
		},
		close: function (arr) {
			return arr.length ? arr[arr.length - 1] : (arr.hasNulls ? null : UNDEFINED);
		},
		// ohlc and range are special cases where a multidimensional array is input and an array is output
		ohlc: function (open, high, low, close) {
			open = approximations.open(open);
			high = approximations.high(high);
			low = approximations.low(low);
			close = approximations.close(close);

			if (typeof open === NUMBER || typeof high === NUMBER || typeof low === NUMBER || typeof close === NUMBER) {
				return [open, high, low, close];
			}
			// else, return is undefined
		},
		range: function (low, high) {
			low = approximations.low(low);
			high = approximations.high(high);

			if (typeof low === NUMBER || typeof high === NUMBER) {
				return [low, high];
			}
			// else, return is undefined
		}
	};

/*jslint white:false */

/**
 * Takes parallel arrays of x and y data and groups the data into intervals defined by groupPositions, a collection
 * of starting x values for each group.
 */
seriesProto.groupData = function (xData, yData, groupPositions, approximation) {
	var series = this,
		data = series.data,
		dataOptions = series.options.data,
		groupedXData = [],
		groupedYData = [],
		dataLength = xData.length,
		pointX,
		pointY,
		groupedY,
		handleYData = !!yData, // when grouping the fake extended axis for panning, we don't need to consider y
		values = [[], [], [], []],
		approximationFn = typeof approximation === 'function' ? approximation : approximations[approximation],
		pointArrayMap = series.pointArrayMap,
		pointArrayMapLength = pointArrayMap && pointArrayMap.length,
		i;

	// Start with the first point within the X axis range (#2696)
	for (i = 0; i <= dataLength; i++) {
		if (xData[i] >= groupPositions[0]) {
			break;
		}
	}

	for (; i <= dataLength; i++) {

		// when a new group is entered, summarize and initiate the previous group
		while ((groupPositions[1] !== UNDEFINED && xData[i] >= groupPositions[1]) ||
				i === dataLength) { // get the last group

			// get group x and y
			pointX = groupPositions.shift();
			groupedY = approximationFn.apply(0, values);

			// push the grouped data
			if (groupedY !== UNDEFINED) {
				groupedXData.push(pointX);
				groupedYData.push(groupedY);
			}

			// reset the aggregate arrays
			values[0] = [];
			values[1] = [];
			values[2] = [];
			values[3] = [];

			// don't loop beyond the last group
			if (i === dataLength) {
				break;
			}
		}

		// break out
		if (i === dataLength) {
			break;
		}

		// for each raw data point, push it to an array that contains all values for this specific group
		if (pointArrayMap) {

			var index = series.cropStart + i,
				point = (data && data[index]) || series.pointClass.prototype.applyOptions.apply({ series: series }, [dataOptions[index]]),
				j,
				val;

			for (j = 0; j < pointArrayMapLength; j++) {
				val = point[pointArrayMap[j]];
				if (typeof val === NUMBER) {
					values[j].push(val);
				} else if (val === null) {
					values[j].hasNulls = true;
				}
			}

		} else {
			pointY = handleYData ? yData[i] : null;

			if (typeof pointY === NUMBER) {
				values[0].push(pointY);
			} else if (pointY === null) {
				values[0].hasNulls = true;
			}
		}
	}
		
	return [groupedXData, groupedYData];
};

/**
 * Extend the basic processData method, that crops the data to the current zoom
 * range, with data grouping logic.
 */
seriesProto.processData = function () {
	var series = this,
		chart = series.chart,
		options = series.options,
		dataGroupingOptions = options[DATA_GROUPING],
		groupingEnabled = series.allowDG !== false && dataGroupingOptions && pick(dataGroupingOptions.enabled, chart.options._stock),
		hasGroupedData;

	// run base method
	series.forceCrop = groupingEnabled; // #334
	series.groupPixelWidth = null; // #2110
	series.hasProcessed = true; // #2692

	// skip if processData returns false or if grouping is disabled (in that order)
	if (baseProcessData.apply(series, arguments) === false || !groupingEnabled) {
		return;

	} else {
		series.destroyGroupedData();

	}
	var i,
		processedXData = series.processedXData,
		processedYData = series.processedYData,
		plotSizeX = chart.plotSizeX,
		xAxis = series.xAxis,
		ordinal = xAxis.options.ordinal,
		groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth && xAxis.getGroupPixelWidth(),
		nonGroupedPointRange = series.pointRange;

	// Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
	if (groupPixelWidth) {
		hasGroupedData = true;

		series.points = null; // force recreation of point instances in series.translate

		var extremes = xAxis.getExtremes(),
			xMin = extremes.min,
			xMax = extremes.max,
			groupIntervalFactor = (ordinal && xAxis.getGroupIntervalFactor(xMin, xMax, series)) || 1,
			interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,
			groupPositions = xAxis.getTimeTicks(
				xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
				xMin,
				xMax,
				xAxis.options.startOfWeek,
				processedXData,
				series.closestPointRange
			),
			groupedXandY = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
			groupedXData = groupedXandY[0],
			groupedYData = groupedXandY[1];

		// prevent the smoothed data to spill out left and right, and make
		// sure data is not shifted to the left
		if (dataGroupingOptions.smoothed) {
			i = groupedXData.length - 1;
			groupedXData[i] = xMax;
			while (i-- && i > 0) {
				groupedXData[i] += interval / 2;
			}
			groupedXData[0] = xMin;
		}

		// record what data grouping values were used
		series.currentDataGrouping = groupPositions.info;
		if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
			series.pointRange = groupPositions.info.totalRange;
		}
		series.closestPointRange = groupPositions.info.totalRange;

		// Make sure the X axis extends to show the first group (#2533)
		if (defined(groupedXData[0]) && groupedXData[0] < xAxis.dataMin) {
			if (xAxis.min === xAxis.dataMin) {
				xAxis.min = groupedXData[0];
			}
			xAxis.dataMin = groupedXData[0];
		}

		// set series props
		series.processedXData = groupedXData;
		series.processedYData = groupedYData;
	} else {
		series.currentDataGrouping = null;
		series.pointRange = nonGroupedPointRange;
	}
	series.hasGroupedData = hasGroupedData;
};

/**
 * Destroy the grouped data points. #622, #740
 */
seriesProto.destroyGroupedData = function () {

	var groupedData = this.groupedData;

	// clear previous groups
	each(groupedData || [], function (point, i) {
		if (point) {
			groupedData[i] = point.destroy ? point.destroy() : null;
		}
	});
	this.groupedData = null;
};

/**
 * Override the generatePoints method by adding a reference to grouped data
 */
seriesProto.generatePoints = function () {

	baseGeneratePoints.apply(this);

	// record grouped data in order to let it be destroyed the next time processData runs
	this.destroyGroupedData(); // #622
	this.groupedData = this.hasGroupedData ? this.points : null;
};

/**
 * Extend the original method, make the tooltip's header reflect the grouped range
 */
tooltipProto.tooltipFooterHeaderFormatter = function (point, isFooter) {
	var tooltip = this,
		series = point.series,
		options = series.options,
		tooltipOptions = series.tooltipOptions,
		dataGroupingOptions = options.dataGrouping,
		xDateFormat = tooltipOptions.xDateFormat,
		xDateFormatEnd,
		xAxis = series.xAxis,
		currentDataGrouping,
		dateTimeLabelFormats,
		labelFormats,
		formattedKey,
		ret;

	// apply only to grouped series
	if (xAxis && xAxis.options.type === 'datetime' && dataGroupingOptions && isNumber(point.key)) {

		// set variables
		currentDataGrouping = series.currentDataGrouping;
		dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;

		// if we have grouped data, use the grouping information to get the right format
		if (currentDataGrouping) {
			labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
			if (currentDataGrouping.count === 1) {
				xDateFormat = labelFormats[0];
			} else {
				xDateFormat = labelFormats[1];
				xDateFormatEnd = labelFormats[2];
			}
		// if not grouped, and we don't have set the xDateFormat option, get the best fit,
		// so if the least distance between points is one minute, show it, but if the
		// least distance is one day, skip hours and minutes etc.
		} else if (!xDateFormat && dateTimeLabelFormats) {
			xDateFormat = tooltip.getXDateFormat(point, tooltipOptions, xAxis);
		}

		// now format the key
		formattedKey = dateFormat(xDateFormat, point.key);
		if (xDateFormatEnd) {
			formattedKey += dateFormat(xDateFormatEnd, point.key + currentDataGrouping.totalRange - 1);
		}

		// return the replaced format
		ret = tooltipOptions[(isFooter ? 'footer' : 'header') + 'Format'].replace('{point.key}', formattedKey);

	// else, fall back to the regular formatter
	} else {
		ret = baseTooltipFooterHeaderFormatter.call(tooltip, point, isFooter);
	}

	return ret;
};

/**
 * Extend the series destroyer
 */
seriesProto.destroy = function () {
	var series = this,
		groupedData = series.groupedData || [],
		i = groupedData.length;

	while (i--) {
		if (groupedData[i]) {
			groupedData[i].destroy();
		}
	}
	baseDestroy.apply(series);
};


// Handle default options for data grouping. This must be set at runtime because some series types are
// defined after this.
wrap(seriesProto, 'setOptions', function (proceed, itemOptions) {

	var options = proceed.call(this, itemOptions),
		type = this.type,
		plotOptions = this.chart.options.plotOptions,
		defaultOptions = defaultPlotOptions[type].dataGrouping;

	if (specificOptions[type]) { // #1284
		if (!defaultOptions) {
			defaultOptions = merge(commonOptions, specificOptions[type]);
		}

		options.dataGrouping = merge(
			defaultOptions,
			plotOptions.series && plotOptions.series.dataGrouping, // #1228
			plotOptions[type].dataGrouping, // Set by the StockChart constructor
			itemOptions.dataGrouping
		);
	}

	if (this.chart.options._stock) {
		this.requireSorting = true;
	}

	return options;
});


/**
 * When resetting the scale reset the hasProccessed flag to avoid taking previous data grouping
 * of neighbour series into accound when determining group pixel width (#2692).
 */
wrap(Axis.prototype, 'setScale', function (proceed) {
	proceed.call(this);
	each(this.series, function (series) {
		series.hasProcessed = false;
	});
});

/**
 * Get the data grouping pixel width based on the greatest defined individual width
 * of the axis' series, and if whether one of the axes need grouping.
 */
Axis.prototype.getGroupPixelWidth = function () {

	var series = this.series,
		len = series.length,
		i,
		groupPixelWidth = 0,
		doGrouping = false,
		dataLength,
		dgOptions;

	// If multiple series are compared on the same x axis, give them the same
	// group pixel width (#334)
	i = len;
	while (i--) {
		dgOptions = series[i].options.dataGrouping;
		if (dgOptions) {
			groupPixelWidth = mathMax(groupPixelWidth, dgOptions.groupPixelWidth);

		}
	}

	// If one of the series needs grouping, apply it to all (#1634)
	i = len;
	while (i--) {
		dgOptions = series[i].options.dataGrouping;
			
		if (dgOptions && series[i].hasProcessed) { // #2692

			dataLength = (series[i].processedXData || series[i].data).length;

			// Execute grouping if the amount of points is greater than the limit defined in groupPixelWidth
			if (series[i].groupPixelWidth || dataLength > (this.chart.plotSizeX / groupPixelWidth) || (dataLength && dgOptions.forced)) {
				doGrouping = true;
			}
		}
	}

	return doGrouping ? groupPixelWidth : 0;
};



/* ****************************************************************************
 * End data grouping module												   *
 ******************************************************************************//* ****************************************************************************
 * Start OHLC series code													 *
 *****************************************************************************/

// 1 - Set default options
defaultPlotOptions.ohlc = merge(defaultPlotOptions.column, {
	lineWidth: 1,
	tooltip: {
		pointFormat: '<span style="color:{point.color}">\u25CF</span> <b> {series.name}</b><br/>' + // docs
			'Open: {point.open}<br/>' +
			'High: {point.high}<br/>' +
			'Low: {point.low}<br/>' +
			'Close: {point.close}<br/>'
	},
	states: {
		hover: {
			lineWidth: 3
		}
	},
	threshold: null
	//upColor: undefined
});

// 2 - Create the OHLCSeries object
var OHLCSeries = extendClass(seriesTypes.column, {
	type: 'ohlc',
	pointArrayMap: ['open', 'high', 'low', 'close'], // array point configs are mapped to this
	toYData: function (point) { // return a plain array for speedy calculation
		return [point.open, point.high, point.low, point.close];
	},
	pointValKey: 'high',

	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		stroke: 'color',
		'stroke-width': 'lineWidth'
	},
	upColorProp: 'stroke',

	/**
	 * Postprocess mapping between options and SVG attributes
	 */
	getAttribs: function () {
		seriesTypes.column.prototype.getAttribs.apply(this, arguments);
		var series = this,
			options = series.options,
			stateOptions = options.states,
			upColor = options.upColor || series.color,
			seriesDownPointAttr = merge(series.pointAttr),
			upColorProp = series.upColorProp;

		seriesDownPointAttr[''][upColorProp] = upColor;
		seriesDownPointAttr.hover[upColorProp] = stateOptions.hover.upColor || upColor;
		seriesDownPointAttr.select[upColorProp] = stateOptions.select.upColor || upColor;

		each(series.points, function (point) {
			if (point.open < point.close && !point.options.color) {
				point.pointAttr = seriesDownPointAttr;
			}
		});
	},

	/**
	 * Translate data points from raw values x and y to plotX and plotY
	 */
	translate: function () {
		var series = this,
			yAxis = series.yAxis;

		seriesTypes.column.prototype.translate.apply(series);

		// do the translation
		each(series.points, function (point) {
			// the graphics
			if (point.open !== null) {
				point.plotOpen = yAxis.translate(point.open, 0, 1, 0, 1);
			}
			if (point.close !== null) {
				point.plotClose = yAxis.translate(point.close, 0, 1, 0, 1);
			}

		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,
			points = series.points,
			chart = series.chart,
			pointAttr,
			plotOpen,
			plotClose,
			crispCorr,
			halfWidth,
			path,
			graphic,
			crispX;


		each(points, function (point) {
			if (point.plotY !== UNDEFINED) {

				graphic = point.graphic;
				pointAttr = point.pointAttr[point.selected ? 'selected' : ''] || series.pointAttr[NORMAL_STATE];

				// crisp vector coordinates
				crispCorr = (pointAttr['stroke-width'] % 2) / 2;
				crispX = mathRound(point.plotX) - crispCorr;  // #2596
				halfWidth = mathRound(point.shapeArgs.width / 2);

				// the vertical stem
				path = [
					'M',
					crispX, mathRound(point.yBottom),
					'L',
					crispX, mathRound(point.plotY)
				];

				// open
				if (point.open !== null) {
					plotOpen = mathRound(point.plotOpen) + crispCorr;
					path.push(
						'M',
						crispX,
						plotOpen,
						'L',
						crispX - halfWidth,
						plotOpen
					);
				}

				// close
				if (point.close !== null) {
					plotClose = mathRound(point.plotClose) + crispCorr;
					path.push(
						'M',
						crispX,
						plotClose,
						'L',
						crispX + halfWidth,
						plotClose
					);
				}

				// create and/or update the graphic
				if (graphic) {
					graphic.animate({ d: path });
				} else {
					point.graphic = chart.renderer.path(path)
						.attr(pointAttr)
						.add(series.group);
				}

			}


		});

	},

	/**
	 * Disable animation
	 */
	animate: null


});
seriesTypes.ohlc = OHLCSeries;
/* ****************************************************************************
 * End OHLC series code													   *
 *****************************************************************************/
/* ****************************************************************************
 * Start Candlestick series code											  *
 *****************************************************************************/

// 1 - set default options
defaultPlotOptions.candlestick = merge(defaultPlotOptions.column, {
	lineColor: 'black',
	lineWidth: 1,
	states: {
		hover: {
			lineWidth: 2
		}
	},
	tooltip: defaultPlotOptions.ohlc.tooltip,
	threshold: null,
	upColor: 'white'
	// upLineColor: null
});

// 2 - Create the CandlestickSeries object
var CandlestickSeries = extendClass(OHLCSeries, {
	type: 'candlestick',

	/**
	 * One-to-one mapping from options to SVG attributes
	 */
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		fill: 'color',
		stroke: 'lineColor',
		'stroke-width': 'lineWidth'
	},
	upColorProp: 'fill',

	/**
	 * Postprocess mapping between options and SVG attributes
	 */
	getAttribs: function () {
		seriesTypes.ohlc.prototype.getAttribs.apply(this, arguments);
		var series = this,
			options = series.options,
			stateOptions = options.states,			
			upLineColor = options.upLineColor || options.lineColor,
			hoverStroke = stateOptions.hover.upLineColor || upLineColor, 
			selectStroke = stateOptions.select.upLineColor || upLineColor;

		// Add custom line color for points going up (close > open).
		// Fill is handled by OHLCSeries' getAttribs.
		each(series.points, function (point) {
			if (point.open < point.close) {
				point.pointAttr[''].stroke = upLineColor;
				point.pointAttr.hover.stroke = hoverStroke;
				point.pointAttr.select.stroke = selectStroke;
			}
		});
	},

	/**
	 * Draw the data points
	 */
	drawPoints: function () {
		var series = this,  //state = series.state,
			points = series.points,
			chart = series.chart,
			pointAttr,
			seriesPointAttr = series.pointAttr[''],
			plotOpen,
			plotClose,
			topBox,
			bottomBox,
			hasTopWhisker,
			hasBottomWhisker,
			crispCorr,
			crispX,
			graphic,
			path,
			halfWidth;


		each(points, function (point) {

			graphic = point.graphic;
			if (point.plotY !== UNDEFINED) {

				pointAttr = point.pointAttr[point.selected ? 'selected' : ''] || seriesPointAttr;

				// crisp vector coordinates
				crispCorr = (pointAttr['stroke-width'] % 2) / 2;
				crispX = mathRound(point.plotX) - crispCorr; // #2596
				plotOpen = point.plotOpen;
				plotClose = point.plotClose;
				topBox = math.min(plotOpen, plotClose);
				bottomBox = math.max(plotOpen, plotClose);
				halfWidth = mathRound(point.shapeArgs.width / 2);
				hasTopWhisker = mathRound(topBox) !== mathRound(point.plotY);
				hasBottomWhisker = bottomBox !== point.yBottom;
				topBox = mathRound(topBox) + crispCorr;
				bottomBox = mathRound(bottomBox) + crispCorr;

				// create the path
				path = [
					'M',
					crispX - halfWidth, bottomBox,
					'L',
					crispX - halfWidth, topBox,
					'L',
					crispX + halfWidth, topBox,
					'L',
					crispX + halfWidth, bottomBox,
					'Z', // Use a close statement to ensure a nice rectangle #2602
					'M',
					crispX, topBox,
					'L',
					crispX, hasTopWhisker ? mathRound(point.plotY) : topBox, // #460, #2094
					'M',
					crispX, bottomBox,
					'L',
					crispX, hasBottomWhisker ? mathRound(point.yBottom) : bottomBox // #460, #2094
				];

				if (graphic) {
					graphic.animate({ d: path });
				} else {
					point.graphic = chart.renderer.path(path)
						.attr(pointAttr)
						.add(series.group)
						.shadow(series.options.shadow);
				}

			}
		});

	}


});

seriesTypes.candlestick = CandlestickSeries;

/* ****************************************************************************
 * End Candlestick series code												*
 *****************************************************************************/
/* ****************************************************************************
 * Start Flags series code													*
 *****************************************************************************/

var symbols = SVGRenderer.prototype.symbols;

// 1 - set default options
defaultPlotOptions.flags = merge(defaultPlotOptions.column, {
	fillColor: 'white',
	lineWidth: 1,
	pointRange: 0, // #673
	//radius: 2,
	shape: 'flag',
	stackDistance: 12,
	states: {
		hover: {
			lineColor: 'black',
			fillColor: '#FCFFC5'
		}
	},
	style: {
		fontSize: '11px',
		fontWeight: 'bold',
		textAlign: 'center'
	},
	tooltip: {
		pointFormat: '{point.text}<br/>'
	},
	threshold: null,
	y: -30
});

// 2 - Create the CandlestickSeries object
seriesTypes.flags = extendClass(seriesTypes.column, {
	type: 'flags',
	sorted: false,
	noSharedTooltip: true,
	allowDG: false,
	takeOrdinalPosition: false, // #1074
	trackerGroups: ['markerGroup'],
	forceCrop: true,
	/**
	 * Inherit the initialization from base Series
	 */
	init: Series.prototype.init,

	/**
	 * One-to-one mapping from options to SVG attributes
	 */
	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
		fill: 'fillColor',
		stroke: 'color',
		'stroke-width': 'lineWidth',
		r: 'radius'
	},

	/**
	 * Extend the translate method by placing the point on the related series
	 */
	translate: function () {

		seriesTypes.column.prototype.translate.apply(this);

		var series = this,
			options = series.options,
			chart = series.chart,
			points = series.points,
			cursor = points.length - 1,
			point,
			lastPoint,
			optionsOnSeries = options.onSeries,
			onSeries = optionsOnSeries && chart.get(optionsOnSeries),
			step = onSeries && onSeries.options.step,
			onData = onSeries && onSeries.points,
			i = onData && onData.length,
			xAxis = series.xAxis,
			xAxisExt = xAxis.getExtremes(),
			leftPoint,
			lastX,
			rightPoint,
			currentDataGrouping;

		// relate to a master series
		if (onSeries && onSeries.visible && i) {
			currentDataGrouping = onSeries.currentDataGrouping;
			lastX = onData[i - 1].x + (currentDataGrouping ? currentDataGrouping.totalRange : 0); // #2374

			// sort the data points
			points.sort(function (a, b) {
				return (a.x - b.x);
			});

			while (i-- && points[cursor]) {
				point = points[cursor];
				leftPoint = onData[i];
				
				if (leftPoint.x <= point.x && leftPoint.plotY !== UNDEFINED) {
					if (point.x <= lastX) { // #803
					
						point.plotY = leftPoint.plotY;
					
						// interpolate between points, #666
						if (leftPoint.x < point.x && !step) { 
							rightPoint = onData[i + 1];
							if (rightPoint && rightPoint.plotY !== UNDEFINED) {
								point.plotY += 
									((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) * // the distance ratio, between 0 and 1 
									(rightPoint.plotY - leftPoint.plotY); // the y distance
							}
						}
					}
					cursor--;
					i++; // check again for points in the same x position
					if (cursor < 0) {
						break;
					}
				}
			}
		}

		// Add plotY position and handle stacking
		each(points, function (point, i) {

			var stackIndex;
			
			// Undefined plotY means the point is either on axis, outside series range or hidden series.
			// If the series is outside the range of the x axis it should fall through with 
			// an undefined plotY, but then we must remove the shapeArgs (#847).
			if (point.plotY === UNDEFINED) {
				if (point.x >= xAxisExt.min && point.x <= xAxisExt.max) { // we're inside xAxis range
					point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : 0) + xAxis.offset - chart.plotTop;
				} else {
					point.shapeArgs = {}; // 847
				}
			}
			// if multiple flags appear at the same x, order them into a stack
			lastPoint = points[i - 1];
			if (lastPoint && lastPoint.plotX === point.plotX) {
				if (lastPoint.stackIndex === UNDEFINED) {
					lastPoint.stackIndex = 0;
				}
				stackIndex = lastPoint.stackIndex + 1;
			}
			point.stackIndex = stackIndex; // #3639		
		});


	},

	/**
	 * Draw the markers
	 */
	drawPoints: function () {
		var series = this,
			pointAttr,
			seriesPointAttr = series.pointAttr[''],
			points = series.points,
			chart = series.chart,
			renderer = chart.renderer,
			plotX,
			plotY,
			options = series.options,
			optionsY = options.y,
			shape,
			i,
			point,
			graphic,
			stackIndex,
			crisp = (options.lineWidth % 2 / 2),
			anchorX,
			anchorY,
			outsideRight;

		i = points.length;
		while (i--) {
			point = points[i];
			outsideRight = point.plotX > series.xAxis.len;
			plotX = point.plotX + (outsideRight ? crisp : -crisp);
			stackIndex = point.stackIndex;
			shape = point.options.shape || options.shape;
			plotY = point.plotY;
			if (plotY !== UNDEFINED) {
				plotY = point.plotY + optionsY + crisp - (stackIndex !== UNDEFINED && stackIndex * options.stackDistance);
			}
			anchorX = stackIndex ? UNDEFINED : point.plotX + crisp; // skip connectors for higher level stacked points
			anchorY = stackIndex ? UNDEFINED : point.plotY;

			graphic = point.graphic;

			// only draw the point if y is defined and the flag is within the visible area
			if (plotY !== UNDEFINED && plotX >= 0 && !outsideRight) {
				// shortcuts
				pointAttr = point.pointAttr[point.selected ? 'select' : ''] || seriesPointAttr;
				if (graphic) { // update
					graphic.attr({
						x: plotX,
						y: plotY,
						r: pointAttr.r,
						anchorX: anchorX,
						anchorY: anchorY
					});
				} else {
					graphic = point.graphic = renderer.label(
						point.options.title || options.title || 'A',
						plotX,
						plotY,
						shape,
						anchorX,
						anchorY,
						options.useHTML
					)
					.css(merge(options.style, point.style))
					.attr(pointAttr)
					.attr({
						align: shape === 'flag' ? 'left' : 'center',
						width: options.width,
						height: options.height
					})
					.add(series.markerGroup)
					.shadow(options.shadow);

				}

				// Set the tooltip anchor position
				point.tooltipPos = [plotX, plotY];

			} else if (graphic) {
				point.graphic = graphic.destroy();
			}

		}

	},

	/**
	 * Extend the column trackers with listeners to expand and contract stacks
	 */
	drawTracker: function () {
		var series = this,
			points = series.points;
		
		TrackerMixin.drawTrackerPoint.apply(this);

		// Bring each stacked flag up on mouse over, this allows readability of vertically
		// stacked elements as well as tight points on the x axis. #1924.
		each(points, function (point) {
			var graphic = point.graphic;
			if (graphic) {
				addEvent(graphic.element, 'mouseover', function () {

					// Raise this point
					if (point.stackIndex > 0 && !point.raised) {
						point._y = graphic.y;
						graphic.attr({
							y: point._y - 8
						});
						point.raised = true;
					}

					// Revert other raised points
					each(points, function (otherPoint) {
						if (otherPoint !== point && otherPoint.raised && otherPoint.graphic) {
							otherPoint.graphic.attr({
								y: otherPoint._y
							});
							otherPoint.raised = false;
						}
					});
				});
			}
		});
	},

	/**
	 * Disable animation
	 */
	animate: noop,
	buildKDTree: noop,
	setClip: noop

});

// create the flag icon with anchor
symbols.flag = function (x, y, w, h, options) {
	var anchorX = (options && options.anchorX) || x,
		anchorY = (options &&  options.anchorY) || y;

	return [
		'M', anchorX, anchorY,
		'L', x, y + h,
		x, y,
		x + w, y,
		x + w, y + h,
		x, y + h,
		'M', anchorX, anchorY,
		'Z'
	];
};

// create the circlepin and squarepin icons with anchor
each(['circle', 'square'], function (shape) {
	symbols[shape + 'pin'] = function (x, y, w, h, options) {

		var anchorX = options && options.anchorX,
			anchorY = options &&  options.anchorY,
			path = symbols[shape](x, y, w, h),
			labelTopOrBottomY;

		if (anchorX && anchorY) {
			// if the label is below the anchor, draw the connecting line from the top edge of the label
			// otherwise start drawing from the bottom edge
			labelTopOrBottomY = (y > anchorY) ? y : y + h;
			path.push('M', anchorX, labelTopOrBottomY, 'L', anchorX, anchorY);
		}

		return path;
	};
});

// The symbol callbacks are generated on the SVGRenderer object in all browsers. Even
// VML browsers need this in order to generate shapes in export. Now share
// them with the VMLRenderer.
if (Renderer === Highcharts.VMLRenderer) {
	each(['flag', 'circlepin', 'squarepin'], function (shape) {
		VMLRenderer.prototype.symbols[shape] = symbols[shape];
	});
}

/* ****************************************************************************
 * End Flags series code													  *
 *****************************************************************************/
/* ****************************************************************************
 * Start Scroller code														*
 *****************************************************************************/
var units = [].concat(defaultDataGroupingUnits), // copy
	defaultSeriesType,
	
	// Finding the min or max of a set of variables where we don't know if they are defined,
	// is a pattern that is repeated several places in Highcharts. Consider making this
	// a global utility method.
	numExt = function (extreme) {
		var numbers = grep(arguments, function (n) { return typeof n === 'number'; });
		if (numbers.length) {
			return Math[extreme].apply(0, numbers);
		}
	};

// add more resolution to units
units[4] = ['day', [1, 2, 3, 4]]; // allow more days
units[5] = ['week', [1, 2, 3]]; // allow more weeks

defaultSeriesType = seriesTypes.areaspline === UNDEFINED ? 'line' : 'areaspline';

extend(defaultOptions, {
	navigator: {
		//enabled: true,
		handles: {
			backgroundColor: '#ebe7e8',
			borderColor: '#b2b1b6'
		},
		height: 40,
		margin: 25,
		maskFill: 'rgba(128,179,236,0.3)',
		maskInside: true,
		outlineColor: '#b2b1b6',
		outlineWidth: 1,
		series: {
			type: defaultSeriesType,
			color: '#4572A7',
			compare: null,
			fillOpacity: 0.05,
			dataGrouping: {
				approximation: 'average',
				enabled: true,
				groupPixelWidth: 2,
				smoothed: true,
				units: units
			},
			dataLabels: {
				enabled: false,
				zIndex: 2 // #1839
			},
			id: PREFIX + 'navigator-series',
			lineColor: '#4572A7',
			lineWidth: 1,
			marker: {
				enabled: false
			},
			pointRange: 0,
			shadow: false,
			threshold: null
		},
		//top: undefined,
		xAxis: {
			tickWidth: 0,
			lineWidth: 0,
			gridLineColor: '#EEE',
			gridLineWidth: 1,
			tickPixelInterval: 200,
			labels: {
				align: 'left',
				style: {
					color: '#888'
				},
				x: 3,
				y: -4
			},
			crosshair: false
		},
		yAxis: {
			gridLineWidth: 0,
			startOnTick: false,
			endOnTick: false,
			minPadding: 0.1,
			maxPadding: 0.1,
			labels: {
				enabled: false
			},
			crosshair: false,
			title: {
				text: null
			},
			tickWidth: 0
		}
	},
	scrollbar: {
		//enabled: true
		height: isTouchDevice ? 20 : 14,
		barBackgroundColor: '#bfc8d1',
		barBorderRadius: 0,
		barBorderWidth: 1,
		barBorderColor: '#bfc8d1',
		buttonArrowColor: '#666',
		buttonBackgroundColor: '#ebe7e8',
		buttonBorderColor: '#bbb',
		buttonBorderRadius: 0,
		buttonBorderWidth: 1,
		minWidth: 6,
		rifleColor: '#666',
		trackBackgroundColor: '#eeeeee',
		trackBorderColor: '#eeeeee',
		trackBorderWidth: 1,
		// trackBorderRadius: 0
		liveRedraw: hasSVG && !isTouchDevice
	}
});

/**
 * The Scroller class
 * @param {Object} chart
 */
function Scroller(chart) {
	var chartOptions = chart.options,
		navigatorOptions = chartOptions.navigator,
		navigatorEnabled = navigatorOptions.enabled,
		scrollbarOptions = chartOptions.scrollbar,
		scrollbarEnabled = scrollbarOptions.enabled,
		height = navigatorEnabled ? navigatorOptions.height : 0,
		scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : 0;


	this.handles = [];
	this.scrollbarButtons = [];
	this.elementsToDestroy = []; // Array containing the elements to destroy when Scroller is destroyed

	this.chart = chart;
	this.setBaseSeries();

	this.height = height;
	this.scrollbarHeight = scrollbarHeight;
	this.scrollbarEnabled = scrollbarEnabled;
	this.navigatorEnabled = navigatorEnabled;
	this.navigatorOptions = navigatorOptions;
	this.scrollbarOptions = scrollbarOptions;
	this.outlineHeight = height + scrollbarHeight;

	// Run scroller
	this.init();
}

Scroller.prototype = {
	/**
	 * Draw one of the handles on the side of the zoomed range in the navigator
	 * @param {Number} x The x center for the handle
	 * @param {Number} index 0 for left and 1 for right
	 */
	drawHandle: function (x, index) {
		var scroller = this,
			chart = scroller.chart,
			renderer = chart.renderer,
			elementsToDestroy = scroller.elementsToDestroy,
			handles = scroller.handles,
			handlesOptions = scroller.navigatorOptions.handles,
			attr = {
				fill: handlesOptions.backgroundColor,
				stroke: handlesOptions.borderColor,
				'stroke-width': 1
			},
			tempElem;

		// create the elements
		if (!scroller.rendered) {
			// the group
			handles[index] = renderer.g('navigator-handle-' + ['left', 'right'][index])
				.css({ cursor: 'ew-resize' })
				.attr({ zIndex: 4 - index }) // zIndex = 3 for right handle, 4 for left
				.add();

			// the rectangle
			tempElem = renderer.rect(-4.5, 0, 9, 16, 0, 1)
				.attr(attr)
				.add(handles[index]);
			elementsToDestroy.push(tempElem);

			// the rifles
			tempElem = renderer.path([
					'M',
					-1.5, 4,
					'L',
					-1.5, 12,
					'M',
					0.5, 4,
					'L',
					0.5, 12
				]).attr(attr)
				.add(handles[index]);
			elementsToDestroy.push(tempElem);
		}

		// Place it
		handles[index][chart.isResizing ? 'animate' : 'attr']({
			translateX: scroller.scrollerLeft + scroller.scrollbarHeight + parseInt(x, 10),
			translateY: scroller.top + scroller.height / 2 - 8
		});
	},

	/**
	 * Draw the scrollbar buttons with arrows
	 * @param {Number} index 0 is left, 1 is right
	 */
	drawScrollbarButton: function (index) {
		var scroller = this,
			chart = scroller.chart,
			renderer = chart.renderer,
			elementsToDestroy = scroller.elementsToDestroy,
			scrollbarButtons = scroller.scrollbarButtons,
			scrollbarHeight = scroller.scrollbarHeight,
			scrollbarOptions = scroller.scrollbarOptions,
			tempElem;

		if (!scroller.rendered) {
			scrollbarButtons[index] = renderer.g().add(scroller.scrollbarGroup);

			tempElem = renderer.rect(
					-0.5,
					-0.5,
					scrollbarHeight + 1, // +1 to compensate for crispifying in rect method
					scrollbarHeight + 1,
					scrollbarOptions.buttonBorderRadius,
					scrollbarOptions.buttonBorderWidth
				).attr({
					stroke: scrollbarOptions.buttonBorderColor,
					'stroke-width': scrollbarOptions.buttonBorderWidth,
					fill: scrollbarOptions.buttonBackgroundColor
				}).add(scrollbarButtons[index]);
			elementsToDestroy.push(tempElem);

			tempElem = renderer.path([
					'M',
					scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 - 3,
					'L',
					scrollbarHeight / 2 + (index ? -1 : 1), scrollbarHeight / 2 + 3,
					scrollbarHeight / 2 + (index ? 2 : -2), scrollbarHeight / 2
				]).attr({
					fill: scrollbarOptions.buttonArrowColor
				}).add(scrollbarButtons[index]);
			elementsToDestroy.push(tempElem);
		}

		// adjust the right side button to the varying length of the scroll track
		if (index) {
			scrollbarButtons[index].attr({
				translateX: scroller.scrollerWidth - scrollbarHeight
			});
		}
	},

	/**
	 * Render the navigator and scroll bar
	 * @param {Number} min X axis value minimum
	 * @param {Number} max X axis value maximum
	 * @param {Number} pxMin Pixel value minimum
	 * @param {Number} pxMax Pixel value maximum
	 */
	render: function (min, max, pxMin, pxMax) {
		var scroller = this,
			chart = scroller.chart,
			renderer = chart.renderer,
			navigatorLeft,
			navigatorWidth,
			scrollerLeft,
			scrollerWidth,
			scrollbarGroup = scroller.scrollbarGroup,
			navigatorGroup = scroller.navigatorGroup,
			scrollbar = scroller.scrollbar,
			xAxis = scroller.xAxis,
			scrollbarTrack = scroller.scrollbarTrack,
			scrollbarHeight = scroller.scrollbarHeight,
			scrollbarEnabled = scroller.scrollbarEnabled,
			navigatorOptions = scroller.navigatorOptions,
			scrollbarOptions = scroller.scrollbarOptions,
			scrollbarMinWidth = scrollbarOptions.minWidth,
			height = scroller.height,
			top = scroller.top,
			navigatorEnabled = scroller.navigatorEnabled,
			outlineWidth = navigatorOptions.outlineWidth,
			halfOutline = outlineWidth / 2,
			zoomedMin,
			zoomedMax,
			range,
			scrX,
			scrWidth,
			scrollbarPad = 0,
			outlineHeight = scroller.outlineHeight,
			barBorderRadius = scrollbarOptions.barBorderRadius,
			strokeWidth,
			scrollbarStrokeWidth = scrollbarOptions.barBorderWidth,
			centerBarX,
			outlineTop = top + halfOutline,
			verb,
			unionExtremes;

		// don't render the navigator until we have data (#486)
		if (isNaN(min)) {
			return;
		}

		scroller.navigatorLeft = navigatorLeft = pick(
			xAxis.left,
			chart.plotLeft + scrollbarHeight // in case of scrollbar only, without navigator
		);
		scroller.navigatorWidth = navigatorWidth = pick(xAxis.len, chart.plotWidth - 2 * scrollbarHeight);
		scroller.scrollerLeft = scrollerLeft = navigatorLeft - scrollbarHeight;
		scroller.scrollerWidth = scrollerWidth = scrollerWidth = navigatorWidth + 2 * scrollbarHeight;

		// Set the scroller x axis extremes to reflect the total. The navigator extremes
		// should always be the extremes of the union of all series in the chart as
		// well as the navigator series.
		if (xAxis.getExtremes) {
			unionExtremes = scroller.getUnionExtremes(true);

			if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
				xAxis.setExtremes(unionExtremes.dataMin, unionExtremes.dataMax, true, false);
			}
		}

		// Get the pixel position of the handles
		pxMin = pick(pxMin, xAxis.translate(min));
		pxMax = pick(pxMax, xAxis.translate(max));
		if (isNaN(pxMin) || mathAbs(pxMin) === Infinity) { // Verify (#1851, #2238)
			pxMin = 0;
			pxMax = scrollerWidth;
		}

		// Are we below the minRange? (#2618)
		if (xAxis.translate(pxMax, true) - xAxis.translate(pxMin, true) < chart.xAxis[0].minRange) {
			return;
		}


		// handles are allowed to cross, but never exceed the plot area
		scroller.zoomedMax = mathMin(mathMax(pxMin, pxMax), navigatorWidth);
		scroller.zoomedMin = 
			mathMax(scroller.fixedWidth ? scroller.zoomedMax - scroller.fixedWidth : mathMin(pxMin, pxMax), 0);
		scroller.range = scroller.zoomedMax - scroller.zoomedMin;
		zoomedMax = mathRound(scroller.zoomedMax);
		zoomedMin = mathRound(scroller.zoomedMin);
		range = zoomedMax - zoomedMin;



		// on first render, create all elements
		if (!scroller.rendered) {

			if (navigatorEnabled) {

				// draw the navigator group
				scroller.navigatorGroup = navigatorGroup = renderer.g('navigator')
					.attr({
						zIndex: 3
					})
					.add();

				scroller.leftShade = renderer.rect()
					.attr({
						fill: navigatorOptions.maskFill
					}).add(navigatorGroup);
				
				if (navigatorOptions.maskInside) {
					scroller.leftShade.css({ cursor: 'ew-resize '});
				} else {
					scroller.rightShade = renderer.rect()
						.attr({
							fill: navigatorOptions.maskFill
						}).add(navigatorGroup);
				}


				scroller.outline = renderer.path()
					.attr({
						'stroke-width': outlineWidth,
						stroke: navigatorOptions.outlineColor
					})
					.add(navigatorGroup);
			}

			if (scrollbarEnabled) {

				// draw the scrollbar group
				scroller.scrollbarGroup = scrollbarGroup = renderer.g('scrollbar').add();

				// the scrollbar track
				strokeWidth = scrollbarOptions.trackBorderWidth;
				scroller.scrollbarTrack = scrollbarTrack = renderer.rect().attr({
					x: 0,
					y: -strokeWidth % 2 / 2,
					fill: scrollbarOptions.trackBackgroundColor,
					stroke: scrollbarOptions.trackBorderColor,
					'stroke-width': strokeWidth,
					r: scrollbarOptions.trackBorderRadius || 0,
					height: scrollbarHeight
				}).add(scrollbarGroup);

				// the scrollbar itself
				scroller.scrollbar = scrollbar = renderer.rect()
					.attr({
						y: -scrollbarStrokeWidth % 2 / 2,
						height: scrollbarHeight,
						fill: scrollbarOptions.barBackgroundColor,
						stroke: scrollbarOptions.barBorderColor,
						'stroke-width': scrollbarStrokeWidth,
						r: barBorderRadius
					})
					.add(scrollbarGroup);

				scroller.scrollbarRifles = renderer.path()
					.attr({
						stroke: scrollbarOptions.rifleColor,
						'stroke-width': 1
					})
					.add(scrollbarGroup);
			}
		}

		// place elements
		verb = chart.isResizing ? 'animate' : 'attr';

		if (navigatorEnabled) {
			scroller.leftShade[verb](navigatorOptions.maskInside ? {
				x: navigatorLeft + zoomedMin,
				y: top,
				width: zoomedMax - zoomedMin,
				height: height
			} : {
				x: navigatorLeft,
				y: top,
				width: zoomedMin,
				height: height
			});
			if (scroller.rightShade) {
				scroller.rightShade[verb]({
					x: navigatorLeft + zoomedMax,
					y: top,
					width: navigatorWidth - zoomedMax,
					height: height
				});
			}
	
			scroller.outline[verb]({ d: [
				M,
				scrollerLeft, outlineTop, // left
				L,
				navigatorLeft + zoomedMin - halfOutline, outlineTop, // upper left of zoomed range
				navigatorLeft + zoomedMin - halfOutline, outlineTop + outlineHeight, // lower left of z.r.
				L,
				navigatorLeft + zoomedMax - halfOutline, outlineTop + outlineHeight, // lower right of z.r.
				L,
				navigatorLeft + zoomedMax - halfOutline, outlineTop, // upper right of z.r.
				scrollerLeft + scrollerWidth, outlineTop // right
			].concat(navigatorOptions.maskInside ? [
				M,
				navigatorLeft + zoomedMin + halfOutline, outlineTop, // upper left of zoomed range
				L,
				navigatorLeft + zoomedMax - halfOutline, outlineTop // upper right of z.r.
			] : [])});
			// draw handles
			scroller.drawHandle(zoomedMin + halfOutline, 0);
			scroller.drawHandle(zoomedMax + halfOutline, 1);
		}

		// draw the scrollbar
		if (scrollbarEnabled && scrollbarGroup) {

			// draw the buttons
			scroller.drawScrollbarButton(0);
			scroller.drawScrollbarButton(1);

			scrollbarGroup[verb]({
				translateX: scrollerLeft,
				translateY: mathRound(outlineTop + height)
			});

			scrollbarTrack[verb]({
				width: scrollerWidth
			});

			// prevent the scrollbar from drawing to small (#1246)
			scrX = scrollbarHeight + zoomedMin;
			scrWidth = range - scrollbarStrokeWidth;
			if (scrWidth < scrollbarMinWidth) {
				scrollbarPad = (scrollbarMinWidth - scrWidth) / 2;
				scrWidth = scrollbarMinWidth;
				scrX -= scrollbarPad;
			}
			scroller.scrollbarPad = scrollbarPad;
			scrollbar[verb]({
				x: mathFloor(scrX) + (scrollbarStrokeWidth % 2 / 2),
				width: scrWidth
			});

			centerBarX = scrollbarHeight + zoomedMin + range / 2 - 0.5;

			scroller.scrollbarRifles
				.attr({
					visibility: range > 12 ? VISIBLE : HIDDEN
				})[verb]({
					d: [
						M,
						centerBarX - 3, scrollbarHeight / 4,
						L,
						centerBarX - 3, 2 * scrollbarHeight / 3,
						M,
						centerBarX, scrollbarHeight / 4,
						L,
						centerBarX, 2 * scrollbarHeight / 3,
						M,
						centerBarX + 3, scrollbarHeight / 4,
						L,
						centerBarX + 3, 2 * scrollbarHeight / 3
					]
				});
		}

		scroller.scrollbarPad = scrollbarPad;
		scroller.rendered = true;
	},

	/**
	 * Set up the mouse and touch events for the navigator and scrollbar
	 */
	addEvents: function () {
		var container = this.chart.container,
			mouseDownHandler = this.mouseDownHandler,
			mouseMoveHandler = this.mouseMoveHandler,
			mouseUpHandler = this.mouseUpHandler,
			_events;

		// Mouse events
		_events = [
			[container, 'mousedown', mouseDownHandler],
			[container, 'mousemove', mouseMoveHandler],
			[document, 'mouseup', mouseUpHandler]
		];

		// Touch events
		if (hasTouch) {
			_events.push(
				[container, 'touchstart', mouseDownHandler],
				[container, 'touchmove', mouseMoveHandler],
				[document, 'touchend', mouseUpHandler]
			);
		}

		// Add them all
		each(_events, function (args) {
			addEvent.apply(null, args);
		});
		this._events = _events;
	},

	/**
	 * Removes the event handlers attached previously with addEvents.
	 */
	removeEvents: function () {

		each(this._events, function (args) {
			removeEvent.apply(null, args);
		});
		this._events = UNDEFINED;
		if (this.navigatorEnabled && this.baseSeries) {
			removeEvent(this.baseSeries, 'updatedData', this.updatedDataHandler);
		}
	},

	/**
	 * Initiate the Scroller object
	 */
	init: function () {
		var scroller = this,
			chart = scroller.chart,
			xAxis,
			yAxis,
			scrollbarHeight = scroller.scrollbarHeight,
			navigatorOptions = scroller.navigatorOptions,
			height = scroller.height,
			top = scroller.top,
			dragOffset,
			hasDragged,
			baseSeries = scroller.baseSeries;

		/**
		 * Event handler for the mouse down event.
		 */
		scroller.mouseDownHandler = function (e) {
			e = chart.pointer.normalize(e);

			var zoomedMin = scroller.zoomedMin,
				zoomedMax = scroller.zoomedMax,
				top = scroller.top,
				scrollbarHeight = scroller.scrollbarHeight,
				scrollerLeft = scroller.scrollerLeft,
				scrollerWidth = scroller.scrollerWidth,
				navigatorLeft = scroller.navigatorLeft,
				navigatorWidth = scroller.navigatorWidth,
				scrollbarPad = scroller.scrollbarPad,
				range = scroller.range,
				chartX = e.chartX,
				chartY = e.chartY,
				baseXAxis = chart.xAxis[0],
				fixedMax,
				ext,
				handleSensitivity = isTouchDevice ? 10 : 7,
				left,
				isOnNavigator;

			if (chartY > top && chartY < top + height + scrollbarHeight) { // we're vertically inside the navigator
				isOnNavigator = !scroller.scrollbarEnabled || chartY < top + height;

				// grab the left handle
				if (isOnNavigator && math.abs(chartX - zoomedMin - navigatorLeft) < handleSensitivity) {
					scroller.grabbedLeft = true;
					scroller.otherHandlePos = zoomedMax;
					scroller.fixedExtreme = baseXAxis.max;
					chart.fixedRange = null;

				// grab the right handle
				} else if (isOnNavigator && math.abs(chartX - zoomedMax - navigatorLeft) < handleSensitivity) {
					scroller.grabbedRight = true;
					scroller.otherHandlePos = zoomedMin;
					scroller.fixedExtreme = baseXAxis.min;
					chart.fixedRange = null;

				// grab the zoomed range
				} else if (chartX > navigatorLeft + zoomedMin - scrollbarPad && chartX < navigatorLeft + zoomedMax + scrollbarPad) {
					scroller.grabbedCenter = chartX;
					scroller.fixedWidth = range;

					dragOffset = chartX - zoomedMin;


				// shift the range by clicking on shaded areas, scrollbar track or scrollbar buttons
				} else if (chartX > scrollerLeft && chartX < scrollerLeft + scrollerWidth) {

					// Center around the clicked point
					if (isOnNavigator) {
						left = chartX - navigatorLeft - range / 2;
					
					// Click on scrollbar
					} else {

						// Click left scrollbar button
						if (chartX < navigatorLeft) { 
							left = zoomedMin - range * 0.2;

						// Click right scrollbar button
						} else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
							left = zoomedMin + range * 0.2;
						
						// Click on scrollbar track, shift the scrollbar by one range
						} else {
							left = chartX < navigatorLeft + zoomedMin ? // on the left
								zoomedMin - range :
								zoomedMax;
						}
					}
					if (left < 0) {
						left = 0;
					} else if (left + range >= navigatorWidth) {
						left = navigatorWidth - range;
						fixedMax = scroller.getUnionExtremes().dataMax; // #2293, #3543
					}
					if (left !== zoomedMin) { // it has actually moved
						scroller.fixedWidth = range; // #1370

						ext = xAxis.toFixedRange(left, left + range, null, fixedMax);
						baseXAxis.setExtremes(
							ext.min,
							ext.max,
							true,
							false,
							{ trigger: 'navigator' }
						);
					}
				}

			}
		};

		/**
		 * Event handler for the mouse move event.
		 */
		scroller.mouseMoveHandler = function (e) {
			var scrollbarHeight = scroller.scrollbarHeight,
				navigatorLeft = scroller.navigatorLeft,
				navigatorWidth = scroller.navigatorWidth,
				scrollerLeft = scroller.scrollerLeft,
				scrollerWidth = scroller.scrollerWidth,
				range = scroller.range,
				chartX;

			// In iOS, a mousemove event with e.pageX === 0 is fired when holding the finger
			// down in the center of the scrollbar. This should be ignored.
			if (e.pageX !== 0) {

				e = chart.pointer.normalize(e);
				chartX = e.chartX;

				// validation for handle dragging
				if (chartX < navigatorLeft) {
					chartX = navigatorLeft;
				} else if (chartX > scrollerLeft + scrollerWidth - scrollbarHeight) {
					chartX = scrollerLeft + scrollerWidth - scrollbarHeight;
				}

				// drag left handle
				if (scroller.grabbedLeft) {
					hasDragged = true;
					scroller.render(0, 0, chartX - navigatorLeft, scroller.otherHandlePos);

				// drag right handle
				} else if (scroller.grabbedRight) {
					hasDragged = true;
					scroller.render(0, 0, scroller.otherHandlePos, chartX - navigatorLeft);

				// drag scrollbar or open area in navigator
				} else if (scroller.grabbedCenter) {

					hasDragged = true;
					if (chartX < dragOffset) { // outside left
						chartX = dragOffset;
					} else if (chartX > navigatorWidth + dragOffset - range) { // outside right
						chartX = navigatorWidth + dragOffset - range;
					}

					scroller.render(0, 0, chartX - dragOffset, chartX - dragOffset + range);

				}
				if (hasDragged && scroller.scrollbarOptions.liveRedraw) {
					setTimeout(function () {
						scroller.mouseUpHandler(e);
					}, 0);
				}
			}
		};

		/**
		 * Event handler for the mouse up event.
		 */
		scroller.mouseUpHandler = function (e) {
			var ext,
				fixedMin,
				fixedMax;

			if (hasDragged) {
				// When dragging one handle, make sure the other one doesn't change
				if (scroller.zoomedMin === scroller.otherHandlePos) {
					fixedMin = scroller.fixedExtreme;
				} else if (scroller.zoomedMax === scroller.otherHandlePos) {
					fixedMax = scroller.fixedExtreme;
				}
				
				ext = xAxis.toFixedRange(scroller.zoomedMin, scroller.zoomedMax, fixedMin, fixedMax);
				chart.xAxis[0].setExtremes(
					ext.min,
					ext.max,
					true,
					false,
					{
						trigger: 'navigator',
						triggerOp: 'navigator-drag',
						DOMEvent: e // #1838
					}
				);
			}

			if (e.type !== 'mousemove') {
				scroller.grabbedLeft = scroller.grabbedRight = scroller.grabbedCenter = scroller.fixedWidth =
					scroller.fixedExtreme = scroller.otherHandlePos = hasDragged = dragOffset = null;
			}

		};



		var xAxisIndex = chart.xAxis.length,
			yAxisIndex = chart.yAxis.length;

		// make room below the chart
		chart.extraBottomMargin = scroller.outlineHeight + navigatorOptions.margin;

		if (scroller.navigatorEnabled) {
			// an x axis is required for scrollbar also
			scroller.xAxis = xAxis = new Axis(chart, merge({
				// inherit base xAxis' break and ordinal options
				breaks: baseSeries && baseSeries.xAxis.options.breaks,
				ordinal: baseSeries && baseSeries.xAxis.options.ordinal 
			}, navigatorOptions.xAxis, {
				id: 'navigator-x-axis',
				isX: true,
				type: 'datetime',
				index: xAxisIndex,
				height: height,
				offset: 0,
				offsetLeft: scrollbarHeight,
				offsetRight: -scrollbarHeight,
				keepOrdinalPadding: true, // #2436
				startOnTick: false,
				endOnTick: false,
				minPadding: 0,
				maxPadding: 0,
				zoomEnabled: false
			}));

			scroller.yAxis = yAxis = new Axis(chart, merge(navigatorOptions.yAxis, {
				id: 'navigator-y-axis',
				alignTicks: false,
				height: height,
				offset: 0,
				index: yAxisIndex,
				zoomEnabled: false
			}));

			// If we have a base series, initialize the navigator series
			if (baseSeries || navigatorOptions.series.data) {
				scroller.addBaseSeries();

			// If not, set up an event to listen for added series
			} else if (chart.series.length === 0) {

				wrap(chart, 'redraw', function (proceed, animation) {
					// We've got one, now add it as base and reset chart.redraw
					if (chart.series.length > 0 && !scroller.series) {
						scroller.setBaseSeries();
						chart.redraw = proceed; // reset
					}
					proceed.call(chart, animation);
				});
			}


		// in case of scrollbar only, fake an x axis to get translation
		} else {
			scroller.xAxis = xAxis = {
				translate: function (value, reverse) {
					var axis = chart.xAxis[0],
						ext = axis.getExtremes(),
						scrollTrackWidth = chart.plotWidth - 2 * scrollbarHeight,
						min = numExt('min', axis.options.min, ext.dataMin),
						valueRange = numExt('max', axis.options.max, ext.dataMax) - min;

					return reverse ?
						// from pixel to value
						(value * valueRange / scrollTrackWidth) + min :
						// from value to pixel
						scrollTrackWidth * (value - min) / valueRange;
				},
				toFixedRange: Axis.prototype.toFixedRange
			};
		}


		/**
		 * For stock charts, extend the Chart.getMargins method so that we can set the final top position
		 * of the navigator once the height of the chart, including the legend, is determined. #367.
		 */
		wrap(chart, 'getMargins', function (proceed) {

			var legend = this.legend,
				legendOptions = legend.options;

			proceed.apply(this, [].slice.call(arguments, 1));

			// Compute the top position
			scroller.top = top = scroller.navigatorOptions.top ||
				this.chartHeight - scroller.height - scroller.scrollbarHeight - this.spacing[2] -
						(legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ?
							legend.legendHeight + pick(legendOptions.margin, 10) : 0);

			if (xAxis && yAxis) { // false if navigator is disabled (#904)

				xAxis.options.top = yAxis.options.top = top;

				xAxis.setAxisSize();
				yAxis.setAxisSize();
			}
		});


		scroller.addEvents();
	},

	/**
	 * Get the union data extremes of the chart - the outer data extremes of the base
	 * X axis and the navigator axis.
	 */
	getUnionExtremes: function (returnFalseOnNoBaseSeries) {
		var baseAxis = this.chart.xAxis[0],
			navAxis = this.xAxis,
			navAxisOptions = navAxis.options,
			baseAxisOptions = baseAxis.options;

		if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
			return {
				dataMin: numExt(
					'min',
					navAxisOptions && navAxisOptions.min,
					baseAxisOptions.min,
					baseAxis.dataMin, 
					navAxis.dataMin
				),
				dataMax: numExt(
					'max',
					navAxisOptions && navAxisOptions.max,
					baseAxisOptions.max,
					baseAxis.dataMax, 
					navAxis.dataMax
				)
			};
		}
	},

	/**
	 * Set the base series. With a bit of modification we should be able to make
	 * this an API method to be called from the outside
	 */
	setBaseSeries: function (baseSeriesOption) {
		var chart = this.chart;

		baseSeriesOption = baseSeriesOption || chart.options.navigator.baseSeries;

		// If we're resetting, remove the existing series
		if (this.series) {
			this.series.remove();
		}

		// Set the new base series
		this.baseSeries = chart.series[baseSeriesOption] ||
			(typeof baseSeriesOption === 'string' && chart.get(baseSeriesOption)) ||
			chart.series[0];

		// When run after render, this.xAxis already exists
		if (this.xAxis) {
			this.addBaseSeries();
		}
	},

	addBaseSeries: function () {
		var baseSeries = this.baseSeries,
			baseOptions = baseSeries ? baseSeries.options : {},
			baseData = baseOptions.data,
			mergedNavSeriesOptions,
			navigatorSeriesOptions = this.navigatorOptions.series,
			navigatorData;

		// remove it to prevent merging one by one
		navigatorData = navigatorSeriesOptions.data;
		this.hasNavigatorData = !!navigatorData;

		// Merge the series options
		mergedNavSeriesOptions = merge(baseOptions, navigatorSeriesOptions, {
			enableMouseTracking: false,
			group: 'nav', // for columns
			padXAxis: false,
			xAxis: 'navigator-x-axis',
			yAxis: 'navigator-y-axis',
			name: 'Navigator',
			showInLegend: false,
			isInternal: true,
			visible: true
		});

		// set the data back
		mergedNavSeriesOptions.data = navigatorData || baseData;

		// add the series
		this.series = this.chart.initSeries(mergedNavSeriesOptions);

		// Respond to updated data in the base series.
		// Abort if lazy-loading data from the server.
		if (baseSeries && this.navigatorOptions.adaptToUpdatedData !== false) {
			addEvent(baseSeries, 'updatedData', this.updatedDataHandler);
			// Survive Series.update()
			baseSeries.userOptions.events = extend(baseSeries.userOptions.event, { updatedData: this.updatedDataHandler });

		}
	},

	updatedDataHandler: function () {
		var scroller = this.chart.scroller,
			baseSeries = scroller.baseSeries,
			baseXAxis = baseSeries.xAxis,
			baseExtremes = baseXAxis.getExtremes(),
			baseMin = baseExtremes.min,
			baseMax = baseExtremes.max,
			baseDataMin = baseExtremes.dataMin,
			baseDataMax = baseExtremes.dataMax,
			range = baseMax - baseMin,
			stickToMin,
			stickToMax,
			newMax,
			newMin,
			doRedraw,
			navigatorSeries = scroller.series,
			navXData = navigatorSeries.xData,
			hasSetExtremes = !!baseXAxis.setExtremes;

		// detect whether to move the range
		stickToMax = baseMax >= navXData[navXData.length - 1] - (this.closestPointRange || 0); // #570
		stickToMin = baseMin <= baseDataMin;

		// set the navigator series data to the new data of the base series
		if (!scroller.hasNavigatorData) {
			navigatorSeries.options.pointStart = baseSeries.xData[0];
			navigatorSeries.setData(baseSeries.options.data, false);
			doRedraw = true;
		}

		// if the zoomed range is already at the min, move it to the right as new data
		// comes in
		if (stickToMin) {
			newMin = baseDataMin;
			newMax = newMin + range;
		}

		// if the zoomed range is already at the max, move it to the right as new data
		// comes in
		if (stickToMax) {
			newMax = baseDataMax;
			if (!stickToMin) { // if stickToMin is true, the new min value is set above
				newMin = mathMax(newMax - range, navigatorSeries.xData[0]);
			}
		}

		// update the extremes
		if (hasSetExtremes && (stickToMin || stickToMax)) {
			if (!isNaN(newMin)) {
				baseXAxis.setExtremes(newMin, newMax, true, false, { trigger: 'updatedData' });
			}

		// if it is not at any edge, just move the scroller window to reflect the new series data
		} else {
			if (doRedraw) {
				this.chart.redraw(false);
			}

			scroller.render(
				mathMax(baseMin, baseDataMin),
				mathMin(baseMax, baseDataMax)
			);
		}
	},

	/**
	 * Destroys allocated elements.
	 */
	destroy: function () {
		var scroller = this;

		// Disconnect events added in addEvents
		scroller.removeEvents();

		// Destroy properties
		each([scroller.xAxis, scroller.yAxis, scroller.leftShade, scroller.rightShade, scroller.outline, scroller.scrollbarTrack, scroller.scrollbarRifles, scroller.scrollbarGroup, scroller.scrollbar], function (prop) {
			if (prop && prop.destroy) {
				prop.destroy();
			}
		});
		scroller.xAxis = scroller.yAxis = scroller.leftShade = scroller.rightShade = scroller.outline = scroller.scrollbarTrack = scroller.scrollbarRifles = scroller.scrollbarGroup = scroller.scrollbar = null;

		// Destroy elements in collection
		each([scroller.scrollbarButtons, scroller.handles, scroller.elementsToDestroy], function (coll) {
			destroyObjectProperties(coll);
		});
	}
};

Highcharts.Scroller = Scroller;


/**
 * For Stock charts, override selection zooming with some special features because
 * X axis zooming is already allowed by the Navigator and Range selector.
 */
wrap(Axis.prototype, 'zoom', function (proceed, newMin, newMax) {
	var chart = this.chart,
		chartOptions = chart.options,
		zoomType = chartOptions.chart.zoomType,
		previousZoom,
		navigator = chartOptions.navigator,
		rangeSelector = chartOptions.rangeSelector,
		ret;

	if (this.isXAxis && ((navigator && navigator.enabled) ||
			(rangeSelector && rangeSelector.enabled))) {

		// For x only zooming, fool the chart.zoom method not to create the zoom button
		// because the property already exists
		if (zoomType === 'x') {
			chart.resetZoomButton = 'blocked';

		// For y only zooming, ignore the X axis completely
		} else if (zoomType === 'y') {
			ret = false;

		// For xy zooming, record the state of the zoom before zoom selection, then when
		// the reset button is pressed, revert to this state
		} else if (zoomType === 'xy') {
			previousZoom = this.previousZoom;
			if (defined(newMin)) {
				this.previousZoom = [this.min, this.max];
			} else if (previousZoom) {
				newMin = previousZoom[0];
				newMax = previousZoom[1];
				delete this.previousZoom;
			}
		}

	}
	return ret !== UNDEFINED ? ret : proceed.call(this, newMin, newMax);
});

// Initialize scroller for stock charts
wrap(Chart.prototype, 'init', function (proceed, options, callback) {

	addEvent(this, 'beforeRender', function () {
		var options = this.options;
		if (options.navigator.enabled || options.scrollbar.enabled) {
			this.scroller = new Scroller(this);
		}
	});

	proceed.call(this, options, callback);

});

// Pick up badly formatted point options to addPoint
wrap(Series.prototype, 'addPoint', function (proceed, options, redraw, shift, animation) {
	var turboThreshold = this.options.turboThreshold;
	if (turboThreshold && this.xData.length > turboThreshold && isObject(options) && !isArray(options) && this.chart.scroller) {
		error(20, true);
	}
	proceed.call(this, options, redraw, shift, animation);
});

/* ****************************************************************************
 * End Scroller code														  *
 *****************************************************************************/
/* ****************************************************************************
 * Start Range Selector code												  *
 *****************************************************************************/
extend(defaultOptions, {
	rangeSelector: {
		// allButtonsEnabled: false,
		// enabled: true,
		// buttons: {Object}
		// buttonSpacing: 0,
		buttonTheme: {
			width: 28,
			height: 18,
			fill: '#f7f7f7',
			padding: 2,
			r: 0,
			'stroke-width': 0,
			style: {
				color: '#444',
				cursor: 'pointer',
				fontWeight: 'normal'
			},
			zIndex: 7, // #484, #852
			states: {
				hover: {
					fill: '#e7e7e7'
				},
				select: {
					fill: '#e7f0f9',
					style: {
						color: 'black',
						fontWeight: 'bold'
					}
				}
			}
		},
		inputPosition: {
			align: 'right'
		},
		// inputDateFormat: '%b %e, %Y',
		// inputEditDateFormat: '%Y-%m-%d',
		// inputEnabled: true,
		// inputStyle: {},
		labelStyle: {
			color: '#666'
		}
		// selected: undefined
	}
});
defaultOptions.lang = merge(defaultOptions.lang, {
	rangeSelectorZoom: 'Zoom',
	rangeSelectorFrom: 'From',
	rangeSelectorTo: 'To'
});

/**
 * The object constructor for the range selector
 * @param {Object} chart
 */
function RangeSelector(chart) {

	// Run RangeSelector
	this.init(chart);
}

RangeSelector.prototype = {
	/**
	 * The method to run when one of the buttons in the range selectors is clicked
	 * @param {Number} i The index of the button
	 * @param {Object} rangeOptions
	 * @param {Boolean} redraw
	 */
	clickButton: function (i, redraw) {
		var rangeSelector = this,
			selected = rangeSelector.selected,
			chart = rangeSelector.chart,
			buttons = rangeSelector.buttons,
			rangeOptions = rangeSelector.buttonOptions[i],
			baseAxis = chart.xAxis[0],
			unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {},
			dataMin = unionExtremes.dataMin,
			dataMax = unionExtremes.dataMax,
			newMin,
			newMax = baseAxis && mathRound(mathMin(baseAxis.max, pick(dataMax, baseAxis.max))), // #1568
			now,
			date = new Date(newMax),
			type = rangeOptions.type,
			count = rangeOptions.count,
			baseXAxisOptions,
			range = rangeOptions._range,
			rangeMin,
			year,
			timeName;

		if (dataMin === null || dataMax === null || // chart has no data, base series is removed
				i === rangeSelector.selected) { // same button is clicked twice
			return;
		}

		if (type === 'month' || type === 'year') {
			timeName = { month: 'Month', year: 'FullYear'}[type];
			date['set' + timeName](date['get' + timeName]() - count);

			newMin = date.getTime();
			dataMin = pick(dataMin, Number.MIN_VALUE);
			if (isNaN(newMin) || newMin < dataMin) {
				newMin = dataMin;
				newMax = mathMin(newMin + range, dataMax);
			} else {
				range = newMax - newMin;
			}

		// Fixed times like minutes, hours, days
		} else if (range) {
			newMin = mathMax(newMax - range, dataMin);
			newMax = mathMin(newMin + range, dataMax);
		
		} else if (type === 'ytd') {

			// On user clicks on the buttons, or a delayed action running from the beforeRender 
			// event (below), the baseAxis is defined.
			if (baseAxis) {

				// When "ytd" is the pre-selected button for the initial view, its calculation
				// is delayed and rerun in the beforeRender event (below). When the series
				// are initialized, but before the chart is rendered, we have access to the xData
				// array (#942).
				if (dataMax === UNDEFINED) {
					dataMin = Number.MAX_VALUE;
					dataMax = Number.MIN_VALUE;
					each(chart.series, function (series) {
						var xData = series.xData; // reassign it to the last item
						dataMin = mathMin(xData[0], dataMin);
						dataMax = mathMax(xData[xData.length - 1], dataMax);
					});
					redraw = false;
				}
				now = new Date(dataMax);
				year = now.getFullYear();
				newMin = rangeMin = mathMax(dataMin || 0, Date.UTC(year, 0, 1));
				now = now.getTime();
				newMax = mathMin(dataMax || now, now);

			// "ytd" is pre-selected. We don't yet have access to processed point and extremes data
			// (things like pointStart and pointInterval are missing), so we delay the process (#942)
			} else {
				addEvent(chart, 'beforeRender', function () {
					rangeSelector.clickButton(i);
				});
				return;
			}
		} else if (type === 'all' && baseAxis) {
			newMin = dataMin;
			newMax = dataMax;
		}

		// Deselect previous button
		if (buttons[selected]) {
			buttons[selected].setState(0);
		}
		// Select this button
		if (buttons[i]) {
			buttons[i].setState(2);
		}

		chart.fixedRange = range;

		// update the chart
		if (!baseAxis) { // axis not yet instanciated
			baseXAxisOptions = chart.options.xAxis;
			baseXAxisOptions[0] = merge(
				baseXAxisOptions[0],
				{
					range: range,
					min: rangeMin
				}
			);
			rangeSelector.setSelected(i);
		} else { // existing axis object; after render time
			baseAxis.setExtremes(
				newMin,
				newMax,
				pick(redraw, 1),
				0, 
				{ 
					trigger: 'rangeSelectorButton',
					rangeSelectorButton: rangeOptions
				}
			);
			rangeSelector.setSelected(i);
		}
	},

	/**
	 * Set the selected option. This method only sets the internal flag, it doesn't
	 * update the buttons or the actual zoomed range.
	 */
	setSelected: function (selected) {
		this.selected = this.options.selected = selected;
	},
	
	/**
	 * The default buttons for pre-selecting time frames
	 */
	defaultButtons: [{
		type: 'month',
		count: 1,
		text: '1m'
	}, {
		type: 'month',
		count: 3,
		text: '3m'
	}, {
		type: 'month',
		count: 6,
		text: '6m'
	}, {
		type: 'ytd',
		text: 'YTD'
	}, {
		type: 'year',
		count: 1,
		text: '1y'
	}, {
		type: 'all',
		text: 'All'
	}],

	/**
	 * Initialize the range selector
	 */
	init: function (chart) {
		
		var rangeSelector = this,
			options = chart.options.rangeSelector,
			buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),
			selectedOption = options.selected,
			blurInputs = rangeSelector.blurInputs = function () {
				var minInput = rangeSelector.minInput,
					maxInput = rangeSelector.maxInput;
				if (minInput && minInput.blur) { //#3274 in some case blur is not defined
					fireEvent(minInput, 'blur'); //#3274
				}
				if (maxInput && maxInput.blur) { //#3274 in some case blur is not defined
					fireEvent(maxInput, 'blur'); //#3274
				}
			};

		rangeSelector.chart = chart;
		rangeSelector.options = options;
		rangeSelector.buttons = [];
		
		chart.extraTopMargin = 35;
		rangeSelector.buttonOptions = buttonOptions;

		addEvent(chart.container, 'mousedown', blurInputs);
		addEvent(chart, 'resize', blurInputs);

		// Extend the buttonOptions with actual range
		each(buttonOptions, rangeSelector.computeButtonRange);

		// zoomed range based on a pre-selected button index
		if (selectedOption !== UNDEFINED && buttonOptions[selectedOption]) {
			this.clickButton(selectedOption, false);
		}

		// normalize the pressed button whenever a new range is selected
		addEvent(chart, 'load', function () {
			addEvent(chart.xAxis[0], 'afterSetExtremes', function () {
				rangeSelector.updateButtonStates(true);
			});
		});
	},

	/**
	 * Dynamically update the range selector buttons after a new range has been set
	 */
	updateButtonStates: function (updating) {
		var rangeSelector = this,
			chart = this.chart,
			baseAxis = chart.xAxis[0],
			unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis,
			dataMin = unionExtremes.dataMin,
			dataMax = unionExtremes.dataMax,
			selected = rangeSelector.selected,
			allButtonsEnabled = rangeSelector.options.allButtonsEnabled,
			buttons = rangeSelector.buttons;

		if (updating && chart.fixedRange !== mathRound(baseAxis.max - baseAxis.min)) {
			if (buttons[selected]) {
				buttons[selected].setState(0);
			}
			rangeSelector.setSelected(null);
		}

		each(rangeSelector.buttonOptions, function (rangeOptions, i) {
			var range = rangeOptions._range,
				// Disable buttons where the range exceeds what is allowed in the current view
				isTooGreatRange = range > dataMax - dataMin,
				// Disable buttons where the range is smaller than the minimum range
				isTooSmallRange = range < baseAxis.minRange,
				// Disable the All button if we're already showing all 
				isAllButAlreadyShowingAll = rangeOptions.type === 'all' && baseAxis.max - baseAxis.min >= dataMax - dataMin && 
					buttons[i].state !== 2,
				// Disable the YTD button if the complete range is within the same year
				isYTDButNotAvailable = rangeOptions.type === 'ytd' && dateFormat('%Y', dataMin) === dateFormat('%Y', dataMax);

			// The new zoom area happens to match the range for a button - mark it selected.
			// This happens when scrolling across an ordinal gap. It can be seen in the intraday
			// demos when selecting 1h and scroll across the night gap.
			if (range === mathRound(baseAxis.max - baseAxis.min) && i !== selected) {
				rangeSelector.setSelected(i);
				buttons[i].setState(2);
			
			} else if (!allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || isYTDButNotAvailable)) {
				buttons[i].setState(3);

			} else if (buttons[i].state === 3) {
				buttons[i].setState(0);
			}
		});
	},

	/** 
	 * Compute and cache the range for an individual button
	 */
	computeButtonRange: function (rangeOptions) {
		var type = rangeOptions.type,
			count = rangeOptions.count || 1,

			// these time intervals have a fixed number of milliseconds, as opposed
			// to month, ytd and year
			fixedTimes = {
				millisecond: 1,
				second: 1000,
				minute: 60 * 1000,
				hour: 3600 * 1000,
				day: 24 * 3600 * 1000,
				week: 7 * 24 * 3600 * 1000
			};
		
		// Store the range on the button object
		if (fixedTimes[type]) {
			rangeOptions._range = fixedTimes[type] * count;				
		} else if (type === 'month' || type === 'year') {
			rangeOptions._range = { month: 30, year: 365 }[type] * 24 * 36e5 * count;
		}
	},
	
	/**
	 * Set the internal and displayed value of a HTML input for the dates
	 * @param {String} name
	 * @param {Number} time
	 */
	setInputValue: function (name, time) {
		var options = this.chart.options.rangeSelector;

		if (defined(time)) {
			this[name + 'Input'].HCTime = time;
		}
		
		this[name + 'Input'].value = dateFormat(options.inputEditDateFormat || '%Y-%m-%d', this[name + 'Input'].HCTime);
		this[name + 'DateBox'].attr({ text: dateFormat(options.inputDateFormat || '%b %e, %Y', this[name + 'Input'].HCTime) });
	},

	/**
	 * Draw either the 'from' or the 'to' HTML input box of the range selector
	 * @param {Object} name
	 */
	drawInput: function (name) {
		var rangeSelector = this,
			chart = rangeSelector.chart,
			chartStyle = chart.renderer.style,
			renderer = chart.renderer,
			options = chart.options.rangeSelector,
			lang = defaultOptions.lang,
			div = rangeSelector.div,
			isMin = name === 'min',
			input,
			label,
			dateBox,
			inputGroup = this.inputGroup;

		// Create the text label
		this[name + 'Label'] = label = renderer.label(lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'], this.inputGroup.offset)
			.attr({
				padding: 2
			})
			.css(merge(chartStyle, options.labelStyle))
			.add(inputGroup);
		inputGroup.offset += label.width + 5;
		
		// Create an SVG label that shows updated date ranges and and records click events that 
		// bring in the HTML input.
		this[name + 'DateBox'] = dateBox = renderer.label('', inputGroup.offset)
			.attr({
				padding: 2,
				width: options.inputBoxWidth || 90,
				height: options.inputBoxHeight || 17,
				stroke: options.inputBoxBorderColor || 'silver',
				'stroke-width': 1
			})
			.css(merge({
				textAlign: 'center',
				color: '#444'
			}, chartStyle, options.inputStyle))
			.on('click', function () {
				rangeSelector[name + 'Input'].focus();
			})
			.add(inputGroup);
		inputGroup.offset += dateBox.width + (isMin ? 10 : 0);
		

		// Create the HTML input element. This is rendered as 1x1 pixel then set to the right size 
		// when focused.
		this[name + 'Input'] = input = createElement('input', {
			name: name,
			className: PREFIX + 'range-selector',
			type: 'text'
		}, extend({
			position: ABSOLUTE,
			border: 0,
			width: '1px', // Chrome needs a pixel to see it
			height: '1px',
			padding: 0,
			textAlign: 'center',
			fontSize: chartStyle.fontSize,
			fontFamily: chartStyle.fontFamily,
			top: chart.plotTop + PX // prevent jump on focus in Firefox
		}, options.inputStyle), div);

		// Blow up the input box
		input.onfocus = function () {
			css(this, {
				left: (inputGroup.translateX + dateBox.x) + PX,
				top: inputGroup.translateY + PX,
				width: (dateBox.width - 2) + PX,
				height: (dateBox.height - 2) + PX,
				border: '2px solid silver'
			});
		};
		// Hide away the input box
		input.onblur = function () {
			css(this, {
				border: 0,
				width: '1px',
				height: '1px'
			});
			rangeSelector.setInputValue(name);
		};

		// handle changes in the input boxes
		input.onchange = function () {
			var inputValue = input.value,
				value = (options.inputDateParser || Date.parse)(inputValue),
				xAxis = chart.xAxis[0],
				dataMin = xAxis.dataMin,
				dataMax = xAxis.dataMax;

			// If the value isn't parsed directly to a value by the browser's Date.parse method,
			// like YYYY-MM-DD in IE, try parsing it a different way
			if (isNaN(value)) {
				value = inputValue.split('-');
				value = Date.UTC(pInt(value[0]), pInt(value[1]) - 1, pInt(value[2]));
			}

			if (!isNaN(value)) {

				// Correct for timezone offset (#433)
				if (!defaultOptions.global.useUTC) {
					value = value + new Date().getTimezoneOffset() * 60 * 1000;
				}

				// Validate the extremes. If it goes beyound the data min or max, use the
				// actual data extreme (#2438).
				if (isMin) {
					if (value > rangeSelector.maxInput.HCTime) {
						value = UNDEFINED;
					} else if (value < dataMin) {
						value = dataMin;
					}
				} else {
					if (value < rangeSelector.minInput.HCTime) {
						value = UNDEFINED;
					} else if (value > dataMax) {
						value = dataMax;
					}
				}

				// Set the extremes
				if (value !== UNDEFINED) {
					chart.xAxis[0].setExtremes(
						isMin ? value : xAxis.min,
						isMin ? xAxis.max : value,
						UNDEFINED,
						UNDEFINED,
						{ trigger: 'rangeSelectorInput' }
					);
				}
			}
		};
	},

	/**
	 * Render the range selector including the buttons and the inputs. The first time render
	 * is called, the elements are created and positioned. On subsequent calls, they are
	 * moved and updated.
	 * @param {Number} min X axis minimum
	 * @param {Number} max X axis maximum
	 */
	render: function (min, max) {

		var rangeSelector = this,
			chart = rangeSelector.chart,
			renderer = chart.renderer,
			container = chart.container,
			chartOptions = chart.options,
			navButtonOptions = chartOptions.exporting && chartOptions.navigation && chartOptions.navigation.buttonOptions, 
			options = chartOptions.rangeSelector,
			buttons = rangeSelector.buttons,
			lang = defaultOptions.lang,
			div = rangeSelector.div,
			inputGroup = rangeSelector.inputGroup,
			buttonTheme = options.buttonTheme,
			buttonPosition = options.buttonPosition || {},
			inputEnabled = options.inputEnabled,
			states = buttonTheme && buttonTheme.states,
			plotLeft = chart.plotLeft,
			yAlign,
			buttonLeft,
			buttonTop,
			buttonGroup = rangeSelector.group,
			buttonBBox;


		// create the elements
		if (!rangeSelector.rendered) {

			rangeSelector.group = buttonGroup = renderer.g('range-selector-buttons').add();

			rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(buttonPosition.x, plotLeft), pick(buttonPosition.y, chart.plotTop - 35) + 15)
				.css(options.labelStyle)
				.add(buttonGroup);

			// button starting position
			buttonLeft = pick(buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + 5;
			buttonTop = pick(buttonPosition.y, chart.plotTop - 35);

			each(rangeSelector.buttonOptions, function (rangeOptions, i) {
				buttons[i] = renderer.button(
						rangeOptions.text,
						buttonLeft,
						buttonTop,
						function () {
							rangeSelector.clickButton(i);
							rangeSelector.isActive = true;
						},
						buttonTheme,
						states && states.hover,
						states && states.select,
						states && states.disabled
					)
					.css({
						textAlign: 'center'
					})
					.add(buttonGroup);

				// increase button position for the next button
				buttonLeft += buttons[i].width + pick(options.buttonSpacing, 5);

				if (rangeSelector.selected === i) {
					buttons[i].setState(2);
				}
			});

			rangeSelector.updateButtonStates();

			// first create a wrapper outside the container in order to make
			// the inputs work and make export correct
			if (inputEnabled !== false) {
				rangeSelector.div = div = createElement('div', null, {
					position: 'relative',
					height: 0,
					zIndex: 1 // above container
				});

				container.parentNode.insertBefore(div, container);

				// Create the group to keep the inputs
				rangeSelector.inputGroup = inputGroup = renderer.g('input-group')
					.add();
				inputGroup.offset = 0;

				rangeSelector.drawInput('min');
				rangeSelector.drawInput('max');	
			}
		}
		
		if (inputEnabled !== false) {
		
			// Update the alignment to the updated spacing box
			yAlign = chart.plotTop - 45;		
			inputGroup.align(extend({
				y: yAlign,
				width: inputGroup.offset,
				// Detect collision with the exporting buttons
				x: navButtonOptions && (yAlign < (navButtonOptions.y || 0) + navButtonOptions.height - chart.spacing[0]) ? 
					-40 : 0
			}, options.inputPosition), true, chart.spacingBox);

			// Hide if overlapping - inputEnabled is null or undefined
			if (!defined(inputEnabled)) {
				buttonBBox = buttonGroup.getBBox();
				inputGroup[inputGroup.translateX < buttonBBox.x + buttonBBox.width + 10 ? 'hide' : 'show']();
			}
	
			// Set or reset the input values
			rangeSelector.setInputValue('min', min);
			rangeSelector.setInputValue('max', max);
		}

		rangeSelector.rendered = true;
	},

	/**
	 * Destroys allocated elements.
	 */
	destroy: function () {
		var minInput = this.minInput,
			maxInput = this.maxInput,
			chart = this.chart,
			blurInputs = this.blurInputs,
			key;

		removeEvent(chart.container, 'mousedown', blurInputs);
		removeEvent(chart, 'resize', blurInputs);

		// Destroy elements in collections
		destroyObjectProperties(this.buttons);
		
		// Clear input element events
		if (minInput) {
			minInput.onfocus = minInput.onblur = minInput.onchange = null;
		}
		if (maxInput) {
			maxInput.onfocus = maxInput.onblur = maxInput.onchange = null;
		}

		// Destroy HTML and SVG elements
		for (key in this) {
			if (this[key] && key !== 'chart') {
				if (this[key].destroy) { // SVGElement
					this[key].destroy();
				} else if (this[key].nodeType) { // HTML element
					discardElement(this[key]);
				}
			}
			this[key] = null;
		}
	}
};

/**
 * Add logic to normalize the zoomed range in order to preserve the pressed state of range selector buttons
 */
Axis.prototype.toFixedRange = function (pxMin, pxMax, fixedMin, fixedMax) {
	var fixedRange = this.chart && this.chart.fixedRange,
		newMin = pick(fixedMin, this.translate(pxMin, true)),
		newMax = pick(fixedMax, this.translate(pxMax, true)),
		changeRatio = fixedRange && (newMax - newMin) / fixedRange;

	// If the difference between the fixed range and the actual requested range is
	// too great, the user is dragging across an ordinal gap, and we need to release
	// the range selector button.
	if (changeRatio > 0.7 && changeRatio < 1.3) {
		if (fixedMax) {
			newMin = newMax - fixedRange;
		} else {
			newMax = newMin + fixedRange;
		}
	}

	return {
		min: newMin,
		max: newMax
	};
};

// Initialize scroller for stock charts
wrap(Chart.prototype, 'init', function (proceed, options, callback) {
	
	addEvent(this, 'init', function () {
		if (this.options.rangeSelector.enabled) {
			this.rangeSelector = new RangeSelector(this);
		}
	});

	proceed.call(this, options, callback);
	
});


Highcharts.RangeSelector = RangeSelector;

/* ****************************************************************************
 * End Range Selector code													*
 *****************************************************************************/



Chart.prototype.callbacks.push(function (chart) {
	var extremes,
		scroller = chart.scroller,
		rangeSelector = chart.rangeSelector;

	function renderScroller() {
		extremes = chart.xAxis[0].getExtremes();
		scroller.render(extremes.min, extremes.max);
	}

	function renderRangeSelector() {
		extremes = chart.xAxis[0].getExtremes();
		if (!isNaN(extremes.min)) {
			rangeSelector.render(extremes.min, extremes.max);
		}
	}

	function afterSetExtremesHandlerScroller(e) {
		if (e.triggerOp !== 'navigator-drag') {
			scroller.render(e.min, e.max);
		}
	}

	function afterSetExtremesHandlerRangeSelector(e) {
		rangeSelector.render(e.min, e.max);
	}

	function destroyEvents() {
		if (scroller) {
			removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);
		}
		if (rangeSelector) {
			removeEvent(chart, 'resize', renderRangeSelector);
			removeEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);
		}
	}

	// initiate the scroller
	if (scroller) {
		// redraw the scroller on setExtremes
		addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerScroller);

		// redraw the scroller on chart resize or box resize
		wrap(chart, 'drawChartBox', function (proceed) {
			var isDirtyBox = this.isDirtyBox;
			proceed.call(this);
			if (isDirtyBox) {
				renderScroller();
			}
		});

		// do it now
		renderScroller();
	}
	if (rangeSelector) {
		// redraw the scroller on setExtremes
		addEvent(chart.xAxis[0], 'afterSetExtremes', afterSetExtremesHandlerRangeSelector);

		// redraw the scroller chart resize
		addEvent(chart, 'resize', renderRangeSelector);

		// do it now
		renderRangeSelector();
	}

	// Remove resize/afterSetExtremes at chart destroy
	addEvent(chart, 'destroy', destroyEvents);
});
/**
 * A wrapper for Chart with all the default values for a Stock chart
 */
Highcharts.StockChart = function (options, callback) {
	var seriesOptions = options.series, // to increase performance, don't merge the data 
		opposite,

		// Always disable startOnTick:true on the main axis when the navigator is enabled (#1090)
		navigatorEnabled = pick(options.navigator && options.navigator.enabled, true),
		disableStartOnTick = navigatorEnabled ? {
			startOnTick: false,
			endOnTick: false
		} : null,

		lineOptions = {

			marker: {
				enabled: false,
				radius: 2
			},
			// gapSize: 0,
			states: {
				hover: {
					lineWidth: 2
				}
			}
		},
		columnOptions = {
			shadow: false,
			borderWidth: 0
		};

	// apply X axis options to both single and multi y axes
	options.xAxis = map(splat(options.xAxis || {}), function (xAxisOptions) {
		return merge({ // defaults
				minPadding: 0,
				maxPadding: 0,
				ordinal: true,
				title: {
					text: null
				},
				labels: {
					overflow: 'justify'
				},
				showLastLabel: true
			}, xAxisOptions, // user options 
			{ // forced options
				type: 'datetime',
				categories: null
			},
			disableStartOnTick
		);
	});

	// apply Y axis options to both single and multi y axes
	options.yAxis = map(splat(options.yAxis || {}), function (yAxisOptions) {
		opposite = pick(yAxisOptions.opposite, true);
		return merge({ // defaults
			labels: {
				y: -2
			},
			opposite: opposite,
			showLastLabel: false,
			title: {
				text: null
			}
		}, yAxisOptions // user options
		);
	});

	options.series = null;

	options = merge({
		chart: {
			panning: true,
			pinchType: 'x'
		},
		navigator: {
			enabled: true
		},
		scrollbar: {
			enabled: true
		},
		rangeSelector: {
			enabled: true
		},
		title: {
			text: null,
			style: {
				fontSize: '16px'
			}
		},
		tooltip: {
			shared: true,
			crosshairs: true
		},
		legend: {
			enabled: false
		},

		plotOptions: {
			line: lineOptions,
			spline: lineOptions,
			area: lineOptions,
			areaspline: lineOptions,
			arearange: lineOptions,
			areasplinerange: lineOptions,
			column: columnOptions,
			columnrange: columnOptions,
			candlestick: columnOptions,
			ohlc: columnOptions
		}

	},
	options, // user's options

	{ // forced options
		_stock: true, // internal flag
		chart: {
			inverted: false
		}
	});

	options.series = seriesOptions;


	return new Chart(options, callback);
};

// Implement the pinchType option
wrap(Pointer.prototype, 'init', function (proceed, chart, options) {

	var pinchType = options.chart.pinchType || '';
		
	proceed.call(this, chart, options);

	// Pinch status
	this.pinchX = this.pinchHor = pinchType.indexOf('x') !== -1;
	this.pinchY = this.pinchVert = pinchType.indexOf('y') !== -1;
	this.hasZoom = this.hasZoom || this.pinchHor || this.pinchVert;
});

// Override the automatic label alignment so that the first Y axis' labels
// are drawn on top of the grid line, and subsequent axes are drawn outside
wrap(Axis.prototype, 'autoLabelAlign', function (proceed) {
	var chart = this.chart,
		options = this.options,
		panes = chart._labelPanes = chart._labelPanes || {},
		key,
		labelOptions = this.options.labels;
	if (this.chart.options._stock && this.coll === 'yAxis') {
		key = options.top + ',' + options.height;
		if (!panes[key] && labelOptions.enabled) { // do it only for the first Y axis of each pane
			if (labelOptions.x === 15) { // default
				labelOptions.x = 0;
			}
			if (labelOptions.align === undefined) {
				labelOptions.align = 'right';
			}
			panes[key] = 1;
			return 'right';
		}
	}
	return proceed.call(this, [].slice.call(arguments, 1));
});

// Override getPlotLinePath to allow for multipane charts
wrap(Axis.prototype, 'getPlotLinePath', function (proceed, value, lineWidth, old, force, translatedValue) {
	var axis = this,
		series = (this.isLinked && !this.series ? this.linkedParent.series : this.series),
		chart = axis.chart,
		renderer = chart.renderer,
		axisLeft = axis.left,
		axisTop = axis.top,
		x1,
		y1,
		x2,
		y2,
		result = [],
		axes = [], //#3416 need a default array
		axes2,
		uniqueAxes;

	// Ignore in case of color Axis. #3360, #3524
	if (axis.coll === 'colorAxis') {
		return proceed.apply(this, [].slice.call(arguments, 1));
	}

	// Get the related axes based on series
	axes = (axis.isXAxis ? 
		(defined(axis.options.yAxis) ?
			[chart.yAxis[axis.options.yAxis]] : 
			map(series, function (S) { return S.yAxis; })
		) :
		(defined(axis.options.xAxis) ?
			[chart.xAxis[axis.options.xAxis]] : 
			map(series, function (S) { return S.xAxis; })
		)
	);

	// Get the related axes based options.*Axis setting #2810
	axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);
	each(axes2, function (A) {
		if (defined(A.options.id) ? A.options.id.indexOf('navigator') === -1 : true) {
			var a = (A.isXAxis ? 'yAxis' : 'xAxis'),
				rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][0]);	

			if (axis === rax) {
				axes.push(A);
			}
		}
	});


	// Remove duplicates in the axes array. If there are no axes in the axes array,
	// we are adding an axis without data, so we need to populate this with grid
	// lines (#2796).
	uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[0] : chart.xAxis[0]]; //#3742
	each(axes, function (axis2) {
		if (inArray(axis2, uniqueAxes) === -1) {
			uniqueAxes.push(axis2);
		}
	});
	
	translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
	
	if (!isNaN(translatedValue)) {
		if (axis.horiz) {
			each(uniqueAxes, function (axis2) {
				var skip;

				y1 = axis2.pos;
				y2 = y1 + axis2.len;
				x1 = x2 = mathRound(translatedValue + axis.transB);

				if (x1 < axisLeft || x1 > axisLeft + axis.width) { // outside plot area
					if (force) {
						x1 = x2 = mathMin(mathMax(axisLeft, x1), axisLeft + axis.width);
					} else {
						skip = true;
					}
				}
				if (!skip) {
					result.push('M', x1, y1, 'L', x2, y2);
				}
			});
		} else {
			each(uniqueAxes, function (axis2) {
				var skip;

				x1 = axis2.pos;
				x2 = x1 + axis2.len;
				y1 = y2 = mathRound(axisTop + axis.height - translatedValue);

				if (y1 < axisTop || y1 > axisTop + axis.height) { // outside plot area
					if (force) {
						y1 = y2 = mathMin(mathMax(axisTop, y1), axis.top + axis.height);
					} else {
						skip = true;
					}
				}
				if (!skip) {
					result.push('M', x1, y1, 'L', x2, y2);
				}
			});
		}
	}
	if (result.length > 0) {
		return renderer.crispPolyLine(result, lineWidth || 1); 
	} else {
		return null; //#3557 getPlotLinePath in regular Highcharts also returns null
	}
});

// Override getPlotBandPath to allow for multipane charts
Axis.prototype.getPlotBandPath = function (from, to) {		
	var toPath = this.getPlotLinePath(to, null, null, true),
		path = this.getPlotLinePath(from, null, null, true),
		result = [],
		i;

	if (path && toPath) {
		// Go over each subpath
		for (i = 0; i < path.length; i += 6) {
			result.push('M', path[i + 1], path[i + 2], 'L', path[i + 4], path[i + 5], toPath[i + 4], toPath[i + 5], toPath[i + 1], toPath[i + 2]);
		}
	} else { // outside the axis area
		result = null;
	}

	return result;
};

// Function to crisp a line with multiple segments
SVGRenderer.prototype.crispPolyLine = function (points, width) {
	// points format: [M, 0, 0, L, 100, 0]		
	// normalize to a crisp line
	var i;
	for (i = 0; i < points.length; i = i + 6) {
		if (points[i + 1] === points[i + 4]) {
			// Substract due to #1129. Now bottom and left axis gridlines behave the same.
			points[i + 1] = points[i + 4] = mathRound(points[i + 1]) - (width % 2 / 2);
		}
		if (points[i + 2] === points[i + 5]) {
			points[i + 2] = points[i + 5] = mathRound(points[i + 2]) + (width % 2 / 2);
		}
	}
	return points;
};
if (Renderer === Highcharts.VMLRenderer) {
	VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;
}


// Wrapper to hide the label
wrap(Axis.prototype, 'hideCrosshair', function (proceed, i) {
	proceed.call(this, i);

	if (!defined(this.crossLabelArray)) { return; }

	if (defined(i)) {
		if (this.crossLabelArray[i]) { this.crossLabelArray[i].hide(); }
	} else {
		each(this.crossLabelArray, function (crosslabel) {
			crosslabel.hide();
		});
	}
});

// Wrapper to draw the label
wrap(Axis.prototype, 'drawCrosshair', function (proceed, e, point) {
	// Draw the crosshair
	proceed.call(this, e, point);

	// Check if the label has to be drawn
	if (!defined(this.crosshair.label) || !this.crosshair.label.enabled || !defined(point)) { 
		return; 
	}

	var chart = this.chart,
		options = this.options.crosshair.label,		// the label's options
		axis = this.isXAxis ? 'x' : 'y',			// axis name
		horiz = this.horiz,							// axis orientation
		opposite = this.opposite,					// axis position
		left = this.left,							// left position
		top = this.top,								// top position
		crossLabel = this.crossLabel,				// reference to the svgElement
		posx,
		posy,
		crossBox,
		formatOption = options.format,
		formatFormat = '',
		limit;

	// If the label does not exist yet, create it.
	if (!crossLabel) {
		crossLabel = this.crossLabel = chart.renderer.label()			
		.attr({
			align: options.align || (horiz ? 'center' : opposite ? (this.labelAlign === 'right' ? 'right' : 'left') : (this.labelAlign === 'left' ? 'left' : 'center')),
			zIndex: 12,
			height: horiz ? 16 : UNDEFINED,
			fill: options.backgroundColor || (this.series[0] && this.series[0].color) || 'gray',
			padding: pick(options.padding, 2),
			stroke: options.borderColor || null,
			'stroke-width': options.borderWidth || 0
		})
		.css(extend({				
			color: 'white',
			fontWeight: 'normal',
			fontSize: '11px',
			textAlign: 'center'
		}, options.style))
		.add();
	}

	if (horiz) {
		posx = point.plotX + left;
		posy = top + (opposite ? 0 : this.height);
	} else {
		posx = opposite ? this.width + left : 0;
		posy = point.plotY + top;
	}

	// if the crosshair goes out of view (too high or too low, hide it and hide the label)
	if (posy < top || posy > top + this.height) {
		this.hideCrosshair();
		return;
	}

	// TODO: Dynamic date formats like in Series.tooltipHeaderFormat. 
	if (!formatOption && !options.formatter) {
		if (this.isDatetimeAxis) {
			formatFormat = '%b %d, %Y';
		}
		formatOption = '{value' + (formatFormat ? ':' + formatFormat : '') + '}';
	}

	// show the label
	crossLabel.attr({
		text: formatOption ? format(formatOption, {value: point[axis]}) : options.formatter.call(this, point[axis]), 
		x: posx, 
		y: posy, 
		visibility: VISIBLE
	});
	crossBox = crossLabel.getBBox();

	// now it is placed we can correct its position
	if (horiz) {
		if (((this.options.tickPosition === 'inside') && !opposite) ||
			((this.options.tickPosition !== 'inside') && opposite)) {
			posy = crossLabel.y - crossBox.height;
		}	
	} else {
		posy = crossLabel.y - (crossBox.height / 2);
	}

	// check the edges
	if (horiz) {
		limit = {
			left: left - crossBox.x,
			right: left + this.width - crossBox.x
		};
	} else {
		limit = {
			left: this.labelAlign === 'left' ? left : 0,
			right: this.labelAlign === 'right' ? left + this.width : chart.chartWidth
		};
	}

	// left edge
	if (crossLabel.translateX < limit.left) {
		posx += limit.left - crossLabel.translateX;
	}
	// right edge
	if (crossLabel.translateX + crossBox.width >= limit.right) {
		posx -= crossLabel.translateX + crossBox.width - limit.right;
	}

	// show the crosslabel
	crossLabel.attr({x: posx, y: posy, visibility: VISIBLE});
});

/* ****************************************************************************
 * Start value compare logic                                                  *
 *****************************************************************************/
 
var seriesInit = seriesProto.init, 
	seriesProcessData = seriesProto.processData,
	pointTooltipFormatter = Point.prototype.tooltipFormatter;
	
/**
 * Extend series.init by adding a method to modify the y value used for plotting
 * on the y axis. This method is called both from the axis when finding dataMin
 * and dataMax, and from the series.translate method.
 */
seriesProto.init = function () {
	
	// Call base method
	seriesInit.apply(this, arguments);
	
	// Set comparison mode
	this.setCompare(this.options.compare);
};

/**
 * The setCompare method can be called also from the outside after render time
 */
seriesProto.setCompare = function (compare) {

	// Set or unset the modifyValue method
	this.modifyValue = (compare === 'value' || compare === 'percent') ? function (value, point) {
		var compareValue = this.compareValue;
		
		if (value !== UNDEFINED) { // #2601

			// get the modified value
			value = compare === 'value' ? 
				value - compareValue : // compare value
				value = 100 * (value / compareValue) - 100; // compare percent
				
			// record for tooltip etc.
			if (point) {
				point.change = value;
			}
			
		}
		
		return value;
	} : null;

	// Mark dirty
	if (this.chart.hasRendered) {
		this.isDirty = true;
	}

};

/**
 * Extend series.processData by finding the first y value in the plot area,
 * used for comparing the following values 
 */
seriesProto.processData = function () {
	var series = this,
		i = 0,
		processedXData,
		processedYData,
		length;
	
	// call base method
	seriesProcessData.apply(this, arguments);

	if (series.xAxis && series.processedYData) { // not pies
		
		// local variables
		processedXData = series.processedXData;
		processedYData = series.processedYData;
		length = processedYData.length;
		
		// find the first value for comparison
		for (; i < length; i++) {
			if (typeof processedYData[i] === NUMBER && processedXData[i] >= series.xAxis.min) {
				series.compareValue = processedYData[i];
				break;
			}
		}
	}
};

/**
 * Modify series extremes
 */
wrap(seriesProto, 'getExtremes', function (proceed) {
	proceed.apply(this, [].slice.call(arguments, 1));

	if (this.modifyValue) {
		this.dataMax = this.modifyValue(this.dataMax);
		this.dataMin = this.modifyValue(this.dataMin);
	}		
});

/**
 * Add a utility method, setCompare, to the Y axis
 */
Axis.prototype.setCompare = function (compare, redraw) {
	if (!this.isXAxis) {
		each(this.series, function (series) {
			series.setCompare(compare);
		});
		if (pick(redraw, true)) {
			this.chart.redraw();
		}
	}
};

/**
 * Extend the tooltip formatter by adding support for the point.change variable
 * as well as the changeDecimals option
 */
Point.prototype.tooltipFormatter = function (pointFormat) {
	var point = this;
	
	pointFormat = pointFormat.replace(
		'{point.change}',
		(point.change > 0 ? '+' : '') + Highcharts.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, 2))
	); 
	
	return pointTooltipFormatter.apply(this, [pointFormat]);
};

/* ****************************************************************************
 * End value compare logic                                                    *
 *****************************************************************************/


/**
 * Extend the Series prototype to create a separate series clip box. This is related
 * to using multiple panes, and a future pane logic should incorporate this feature (#2754).
 */
wrap(Series.prototype, 'render', function (proceed) {
	// Only do this on stock charts (#2939), and only if the series type handles clipping
	// in the animate method (#2975).
	if (this.chart.options._stock) {

		// First render, initial clip box
		if (!this.clipBox && this.animate && this.animate.toString().indexOf('sharedClip') !== -1) {
			this.clipBox = merge(this.chart.clipBox);
			this.clipBox.width = this.xAxis.len;
			this.clipBox.height = this.yAxis.len;

		// On redrawing, resizing etc, update the clip rectangle
		} else if (this.chart[this.sharedClipKey]) {
			this.chart[this.sharedClipKey].attr({
				width: this.xAxis.len,
				height: this.yAxis.len
			});
		}
	}
	proceed.call(this);
});

// global variables
extend(Highcharts, {
	
	// Constructors
	Color: Color,
	Point: Point,
	Tick: Tick,	
	Renderer: Renderer,
	SVGElement: SVGElement,
	SVGRenderer: SVGRenderer,
	
	// Various
	arrayMin: arrayMin,
	arrayMax: arrayMax,
	charts: charts,
	dateFormat: dateFormat,
	error: error,
	format: format,
	pathAnim: pathAnim,
	getOptions: getOptions,
	hasBidiBug: hasBidiBug,
	isTouchDevice: isTouchDevice,
	setOptions: setOptions,
	addEvent: addEvent,
	removeEvent: removeEvent,
	createElement: createElement,
	discardElement: discardElement,
	css: css,
	each: each,
	map: map,
	merge: merge,
	splat: splat,
	extendClass: extendClass,
	pInt: pInt,
	svg: hasSVG,
	canvas: useCanVG,
	vml: !hasSVG && !useCanVG,
	product: PRODUCT,
	version: VERSION
});

}());
;/**
 * @license Highstock JS v2.1.3 (2015-02-27)
 * Exporting module
 *
 * (c) 2010-2014 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

// JSLint options:
/*global Highcharts, HighchartsAdapter, document, window, Math, setTimeout */

(function (Highcharts) { // encapsulate

// create shortcuts
var Chart = Highcharts.Chart,
	addEvent = Highcharts.addEvent,
	removeEvent = Highcharts.removeEvent,
	fireEvent = HighchartsAdapter.fireEvent,
	createElement = Highcharts.createElement,
	discardElement = Highcharts.discardElement,
	css = Highcharts.css,
	merge = Highcharts.merge,
	each = Highcharts.each,
	extend = Highcharts.extend,
	splat = Highcharts.splat,
	math = Math,
	mathMax = math.max,
	doc = document,
	win = window,
	isTouchDevice = Highcharts.isTouchDevice,
	M = 'M',
	L = 'L',
	DIV = 'div',
	HIDDEN = 'hidden',
	NONE = 'none',
	PREFIX = 'highcharts-',
	ABSOLUTE = 'absolute',
	PX = 'px',
	UNDEFINED,
	symbols = Highcharts.Renderer.prototype.symbols,
	defaultOptions = Highcharts.getOptions(),
	buttonOffset;

	// Add language
	extend(defaultOptions.lang, {
		printChart: 'Print chart',
		downloadPNG: 'Download PNG image',
		downloadJPEG: 'Download JPEG image',
		downloadPDF: 'Download PDF document',
		downloadSVG: 'Download SVG vector image',
		contextButtonTitle: 'Chart context menu'
	});

// Buttons and menus are collected in a separate config option set called 'navigation'.
// This can be extended later to add control buttons like zoom and pan right click menus.
defaultOptions.navigation = {
	menuStyle: {
		border: '1px solid #A0A0A0',
		background: '#FFFFFF',
		padding: '5px 0'
	},
	menuItemStyle: {
		padding: '0 10px',
		background: NONE,
		color: '#303030',
		fontSize: isTouchDevice ? '14px' : '11px'
	},
	menuItemHoverStyle: {
		background: '#4572A5',
		color: '#FFFFFF'
	},

	buttonOptions: {
		symbolFill: '#E0E0E0',
		symbolSize: 14,
		symbolStroke: '#666',
		symbolStrokeWidth: 3,
		symbolX: 12.5,
		symbolY: 10.5,
		align: 'right',
		buttonSpacing: 3,
		height: 22,
		// text: null,
		theme: {
			fill: 'white', // capture hover
			stroke: 'none'
		},
		verticalAlign: 'top',
		width: 24
	}
};



// Add the export related options
defaultOptions.exporting = {
	//enabled: true,
	//filename: 'chart',
	type: 'image/png',
	url: 'http://export.highcharts.com/',
	//width: undefined,
	//scale: 2
	buttons: {
		contextButton: {
			menuClassName: PREFIX + 'contextmenu',
			//x: -10,
			symbol: 'menu',
			_titleKey: 'contextButtonTitle',
			menuItems: [{
				textKey: 'printChart',
				onclick: function () {
					this.print();
				}
			}, {
				separator: true
			}, {
				textKey: 'downloadPNG',
				onclick: function () {
					this.exportChart();
				}
			}, {
				textKey: 'downloadJPEG',
				onclick: function () {
					this.exportChart({
						type: 'image/jpeg'
					});
				}
			}, {
				textKey: 'downloadPDF',
				onclick: function () {
					this.exportChart({
						type: 'application/pdf'
					});
				}
			}, {
				textKey: 'downloadSVG',
				onclick: function () {
					this.exportChart({
						type: 'image/svg+xml'
					});
				}
			}
			// Enable this block to add "View SVG" to the dropdown menu
			/*
			,{

				text: 'View SVG',
				onclick: function () {
					var svg = this.getSVG()
						.replace(/</g, '\n&lt;')
						.replace(/>/g, '&gt;');

					doc.body.innerHTML = '<pre>' + svg + '</pre>';
				}
			} // */
			]
		}
	}
};

// Add the Highcharts.post utility
Highcharts.post = function (url, data, formAttributes) {
	var name,
		form;

	// create the form
	form = createElement('form', merge({
		method: 'post',
		action: url,
		enctype: 'multipart/form-data'
	}, formAttributes), {
		display: NONE
	}, doc.body);

	// add the data
	for (name in data) {
		createElement('input', {
			type: HIDDEN,
			name: name,
			value: data[name]
		}, null, form);
	}

	// submit
	form.submit();

	// clean up
	discardElement(form);
};

extend(Chart.prototype, {

	/**
	 * A collection of regex fixes on the produces SVG to account for expando properties,
	 * browser bugs, VML problems and other. Returns a cleaned SVG.
	 */
	sanitizeSVG: function (svg) {
		return svg
			.replace(/zIndex="[^"]+"/g, '')
			.replace(/isShadow="[^"]+"/g, '')
			.replace(/symbolName="[^"]+"/g, '')
			.replace(/jQuery[0-9]+="[^"]+"/g, '')
			.replace(/url\([^#]+#/g, 'url(#')
			.replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ')
			.replace(/ (NS[0-9]+\:)?href=/g, ' xlink:href=') // #3567
			.replace(/\n/, ' ')
			// Any HTML added to the container after the SVG (#894)
			.replace(/<\/svg>.*?$/, '</svg>') 
			// Batik doesn't support rgba fills and strokes (#3095)
			.replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"')
			
			// An issue with PhantomJS as of 2015-01-11. Revisit with newer versions. (#3649)
			.replace(/(text-shadow:)([^;"]+)([;"])/g, function (s, $1, $2, $3) {
				// Escape commas within rgb and rgba definitions
				$2 = $2.replace(/\([^\)]+\)/g, function (s) {
					return s.replace(/,/g, '|');
				});
				// Keep the first definition
				$2 = $2.split(',')[0];
				// Re-inert commas
				$2 = $2.replace(/\([^\)]+\)/g, function (s) {
					return s.replace(/\|/g, ',');
				});
				s = $1 + $2 + $3;
				return s;
			})
			/* This fails in IE < 8
			.replace(/([0-9]+)\.([0-9]+)/g, function(s1, s2, s3) { // round off to save weight
				return s2 +'.'+ s3[0];
			})*/

			// Replace HTML entities, issue #347
			.replace(/&nbsp;/g, '\u00A0') // no-break space
			.replace(/&shy;/g,  '\u00AD') // soft hyphen

			// IE specific
			.replace(/<IMG /g, '<image ')
			.replace(/height=([^" ]+)/g, 'height="$1"')
			.replace(/width=([^" ]+)/g, 'width="$1"')
			.replace(/hc-svg-href="([^"]+)">/g, 'xlink:href="$1"/>')
			.replace(/id=([^" >]+)/g, 'id="$1"')
			.replace(/class=([^" >]+)/g, 'class="$1"')
			.replace(/ transform /g, ' ')
			.replace(/:(path|rect)/g, '$1')
			.replace(/style="([^"]+)"/g, function (s) {
				return s.toLowerCase();
			});
	},

	/**
	 * Return an SVG representation of the chart
	 *
	 * @param additionalOptions {Object} Additional chart options for the generated SVG representation
	 */
	getSVG: function (additionalOptions) {
		var chart = this,
			chartCopy,
			sandbox,
			svg,
			seriesOptions,
			sourceWidth,
			sourceHeight,
			cssWidth,
			cssHeight,
			options = merge(chart.options, additionalOptions); // copy the options and add extra options

		// IE compatibility hack for generating SVG content that it doesn't really understand
		if (!doc.createElementNS) {
			/*jslint unparam: true*//* allow unused parameter ns in function below */
			doc.createElementNS = function (ns, tagName) {
				return doc.createElement(tagName);
			};
			/*jslint unparam: false*/
		}

		// create a sandbox where a new chart will be generated
		sandbox = createElement(DIV, null, {
			position: ABSOLUTE,
			top: '-9999em',
			width: chart.chartWidth + PX,
			height: chart.chartHeight + PX
		}, doc.body);

		// get the source size
		cssWidth = chart.renderTo.style.width;
		cssHeight = chart.renderTo.style.height;
		sourceWidth = options.exporting.sourceWidth ||
			options.chart.width ||
			(/px$/.test(cssWidth) && parseInt(cssWidth, 10)) ||
			600;
		sourceHeight = options.exporting.sourceHeight ||
			options.chart.height ||
			(/px$/.test(cssHeight) && parseInt(cssHeight, 10)) ||
			400;

		// override some options
		extend(options.chart, {
			animation: false,
			renderTo: sandbox,
			forExport: true,
			width: sourceWidth,
			height: sourceHeight
		});
		options.exporting.enabled = false; // hide buttons in print
		delete options.data; // #3004

		// prepare for replicating the chart
		options.series = [];
		each(chart.series, function (serie) {
			seriesOptions = merge(serie.options, {
				animation: false, // turn off animation
				enableMouseTracking: false,
				showCheckbox: false,
				visible: serie.visible
			});

			if (!seriesOptions.isInternal) { // used for the navigator series that has its own option set
				options.series.push(seriesOptions);
			}
		});

		// Axis options must be merged in one by one, since it may be an array or an object (#2022, #3900)
		if (additionalOptions) {
			each(['xAxis', 'yAxis'], function (axisType) {
				each(splat(additionalOptions[axisType]), function (axisOptions, i) {
					options[axisType][i] = merge(options[axisType][i], axisOptions);
				});
			});
		}

		// generate the chart copy
		chartCopy = new Highcharts.Chart(options, chart.callback);

		// reflect axis extremes in the export
		each(['xAxis', 'yAxis'], function (axisType) {
			each(chart[axisType], function (axis, i) {
				var axisCopy = chartCopy[axisType][i],
					extremes = axis.getExtremes(),
					userMin = extremes.userMin,
					userMax = extremes.userMax;

				if (axisCopy && (userMin !== UNDEFINED || userMax !== UNDEFINED)) {
					axisCopy.setExtremes(userMin, userMax, true, false);
				}
			});
		});

		// get the SVG from the container's innerHTML
		svg = chartCopy.container.innerHTML;

		// free up memory
		options = null;
		chartCopy.destroy();
		discardElement(sandbox);

		// sanitize
		svg = this.sanitizeSVG(svg);

		// IE9 beta bugs with innerHTML. Test again with final IE9.
		svg = svg.replace(/(url\(#highcharts-[0-9]+)&quot;/g, '$1')
			.replace(/&quot;/g, "'");

		return svg;
	},

	getSVGForExport: function (options, chartOptions) {
		var chartExportingOptions = this.options.exporting;

		return this.getSVG(merge(
			{ chart: { borderRadius: 0 } },
			chartExportingOptions.chartOptions,
			chartOptions,
			{
				exporting: {
					sourceWidth: (options && options.sourceWidth) || chartExportingOptions.sourceWidth,
					sourceHeight: (options && options.sourceHeight) || chartExportingOptions.sourceHeight
				}
			}
		));
	},

	/**
	 * Submit the SVG representation of the chart to the server
	 * @param {Object} options Exporting options. Possible members are url, type, width and formAttributes.
	 * @param {Object} chartOptions Additional chart options for the SVG representation of the chart
	 */
	exportChart: function (options, chartOptions) {
		
		var svg = this.getSVGForExport(options, chartOptions);

		// merge the options
		options = merge(this.options.exporting, options);

		// do the post
		Highcharts.post(options.url, {
			filename: options.filename || 'chart',
			type: options.type,
			width: options.width || 0, // IE8 fails to post undefined correctly, so use 0
			scale: options.scale || 2,
			svg: svg
		}, options.formAttributes);

	},

	/**
	 * Print the chart
	 */
	print: function () {

		var chart = this,
			container = chart.container,
			origDisplay = [],
			origParent = container.parentNode,
			body = doc.body,
			childNodes = body.childNodes;

		if (chart.isPrinting) { // block the button while in printing mode
			return;
		}

		chart.isPrinting = true;

		fireEvent(chart, 'beforePrint');

		// hide all body content
		each(childNodes, function (node, i) {
			if (node.nodeType === 1) {
				origDisplay[i] = node.style.display;
				node.style.display = NONE;
			}
		});

		// pull out the chart
		body.appendChild(container);

		// print
		win.focus(); // #1510
		win.print();

		// allow the browser to prepare before reverting
		setTimeout(function () {

			// put the chart back in
			origParent.appendChild(container);

			// restore all body content
			each(childNodes, function (node, i) {
				if (node.nodeType === 1) {
					node.style.display = origDisplay[i];
				}
			});

			chart.isPrinting = false;

			fireEvent(chart, 'afterPrint');

		}, 1000);

	},

	/**
	 * Display a popup menu for choosing the export type
	 *
	 * @param {String} className An identifier for the menu
	 * @param {Array} items A collection with text and onclicks for the items
	 * @param {Number} x The x position of the opener button
	 * @param {Number} y The y position of the opener button
	 * @param {Number} width The width of the opener button
	 * @param {Number} height The height of the opener button
	 */
	contextMenu: function (className, items, x, y, width, height, button) {
		var chart = this,
			navOptions = chart.options.navigation,
			menuItemStyle = navOptions.menuItemStyle,
			chartWidth = chart.chartWidth,
			chartHeight = chart.chartHeight,
			cacheName = 'cache-' + className,
			menu = chart[cacheName],
			menuPadding = mathMax(width, height), // for mouse leave detection
			boxShadow = '3px 3px 10px #888',
			innerMenu,
			hide,
			hideTimer,
			menuStyle,
			docMouseUpHandler = function (e) {
				if (!chart.pointer.inClass(e.target, className)) {
					hide();
				}
			};

		// create the menu only the first time
		if (!menu) {

			// create a HTML element above the SVG
			chart[cacheName] = menu = createElement(DIV, {
				className: className
			}, {
				position: ABSOLUTE,
				zIndex: 1000,
				padding: menuPadding + PX
			}, chart.container);

			innerMenu = createElement(DIV, null,
				extend({
					MozBoxShadow: boxShadow,
					WebkitBoxShadow: boxShadow,
					boxShadow: boxShadow
				}, navOptions.menuStyle), menu);

			// hide on mouse out
			hide = function () {
				css(menu, { display: NONE });
				if (button) {
					button.setState(0);
				}
				chart.openMenu = false;
			};

			// Hide the menu some time after mouse leave (#1357)
			addEvent(menu, 'mouseleave', function () {
				hideTimer = setTimeout(hide, 500);
			});
			addEvent(menu, 'mouseenter', function () {
				clearTimeout(hideTimer);
			});


			// Hide it on clicking or touching outside the menu (#2258, #2335, #2407)
			addEvent(document, 'mouseup', docMouseUpHandler);
			addEvent(chart, 'destroy', function () {
				removeEvent(document, 'mouseup', docMouseUpHandler);
			});


			// create the items
			each(items, function (item) {
				if (item) {
					var element = item.separator ?
						createElement('hr', null, null, innerMenu) :
						createElement(DIV, {
							onmouseover: function () {
								css(this, navOptions.menuItemHoverStyle);
							},
							onmouseout: function () {
								css(this, menuItemStyle);
							},
							onclick: function () {
								hide();
								if (item.onclick) {
									item.onclick.apply(chart, arguments);
								}
							},
							innerHTML: item.text || chart.options.lang[item.textKey]
						}, extend({
							cursor: 'pointer'
						}, menuItemStyle), innerMenu);


					// Keep references to menu divs to be able to destroy them
					chart.exportDivElements.push(element);
				}
			});

			// Keep references to menu and innerMenu div to be able to destroy them
			chart.exportDivElements.push(innerMenu, menu);

			chart.exportMenuWidth = menu.offsetWidth;
			chart.exportMenuHeight = menu.offsetHeight;
		}

		menuStyle = { display: 'block' };

		// if outside right, right align it
		if (x + chart.exportMenuWidth > chartWidth) {
			menuStyle.right = (chartWidth - x - width - menuPadding) + PX;
		} else {
			menuStyle.left = (x - menuPadding) + PX;
		}
		// if outside bottom, bottom align it
		if (y + height + chart.exportMenuHeight > chartHeight && button.alignOptions.verticalAlign !== 'top') {
			menuStyle.bottom = (chartHeight - y - menuPadding)  + PX;
		} else {
			menuStyle.top = (y + height - menuPadding) + PX;
		}

		css(menu, menuStyle);
		chart.openMenu = true;
	},

	/**
	 * Add the export button to the chart
	 */
	addButton: function (options) {
		var chart = this,
			renderer = chart.renderer,
			btnOptions = merge(chart.options.navigation.buttonOptions, options),
			onclick = btnOptions.onclick,
			menuItems = btnOptions.menuItems,
			symbol,
			button,
			symbolAttr = {
				stroke: btnOptions.symbolStroke,
				fill: btnOptions.symbolFill
			},
			symbolSize = btnOptions.symbolSize || 12;
		if (!chart.btnCount) {
			chart.btnCount = 0;
		}

		// Keeps references to the button elements
		if (!chart.exportDivElements) {
			chart.exportDivElements = [];
			chart.exportSVGElements = [];
		}

		if (btnOptions.enabled === false) {
			return;
		}


		var attr = btnOptions.theme,
			states = attr.states,
			hover = states && states.hover,
			select = states && states.select,
			callback;

		delete attr.states;

		if (onclick) {
			callback = function () {
				onclick.apply(chart, arguments);
			};

		} else if (menuItems) {
			callback = function () {
				chart.contextMenu(
					button.menuClassName,
					menuItems,
					button.translateX,
					button.translateY,
					button.width,
					button.height,
					button
				);
				button.setState(2);
			};
		}


		if (btnOptions.text && btnOptions.symbol) {
			attr.paddingLeft = Highcharts.pick(attr.paddingLeft, 25);

		} else if (!btnOptions.text) {
			extend(attr, {
				width: btnOptions.width,
				height: btnOptions.height,
				padding: 0
			});
		}

		button = renderer.button(btnOptions.text, 0, 0, callback, attr, hover, select)
			.attr({
				title: chart.options.lang[btnOptions._titleKey],
				'stroke-linecap': 'round'
			});
		button.menuClassName = options.menuClassName || PREFIX + 'menu-' + chart.btnCount++;

		if (btnOptions.symbol) {
			symbol = renderer.symbol(
					btnOptions.symbol,
					btnOptions.symbolX - (symbolSize / 2),
					btnOptions.symbolY - (symbolSize / 2),
					symbolSize,
					symbolSize
				)
				.attr(extend(symbolAttr, {
					'stroke-width': btnOptions.symbolStrokeWidth || 1,
					zIndex: 1
				})).add(button);
		}

		button.add()
			.align(extend(btnOptions, {
				width: button.width,
				x: Highcharts.pick(btnOptions.x, buttonOffset) // #1654
			}), true, 'spacingBox');

		buttonOffset += (button.width + btnOptions.buttonSpacing) * (btnOptions.align === 'right' ? -1 : 1);

		chart.exportSVGElements.push(button, symbol);

	},

	/**
	 * Destroy the buttons.
	 */
	destroyExport: function (e) {
		var chart = e.target,
			i,
			elem;

		// Destroy the extra buttons added
		for (i = 0; i < chart.exportSVGElements.length; i++) {
			elem = chart.exportSVGElements[i];

			// Destroy and null the svg/vml elements
			if (elem) { // #1822
				elem.onclick = elem.ontouchstart = null;
				chart.exportSVGElements[i] = elem.destroy();
			}
		}

		// Destroy the divs for the menu
		for (i = 0; i < chart.exportDivElements.length; i++) {
			elem = chart.exportDivElements[i];

			// Remove the event handler
			removeEvent(elem, 'mouseleave');

			// Remove inline events
			chart.exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null;

			// Destroy the div by moving to garbage bin
			discardElement(elem);
		}
	}
});


symbols.menu = function (x, y, width, height) {
	var arr = [
		M, x, y + 2.5,
		L, x + width, y + 2.5,
		M, x, y + height / 2 + 0.5,
		L, x + width, y + height / 2 + 0.5,
		M, x, y + height - 1.5,
		L, x + width, y + height - 1.5
	];
	return arr;
};

// Add the buttons on chart load
Chart.prototype.callbacks.push(function (chart) {
	var n,
		exportingOptions = chart.options.exporting,
		buttons = exportingOptions.buttons;

	buttonOffset = 0;

	if (exportingOptions.enabled !== false) {

		for (n in buttons) {
			chart.addButton(buttons[n]);
		}

		// Destroy the export elements at chart destroy
		addEvent(chart, 'destroy', chart.destroyExport);
	}

});


}(Highcharts));
;//! moment.js
//! version : 2.8.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.8.1',
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty('toString')) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty('valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name  + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) {
                return parseTokenOneDigit;
            }
            /* falls through */
        case 'SS':
            if (strict) {
                return parseTokenTwoDigits;
            }
            /* falls through */
        case 'SSS':
            if (strict) {
                return parseTokenThreeDigits;
            }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return config._locale._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = config._locale.monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = config._locale.isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === "boolean") {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i);
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === "boolean") {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== "undefined") {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.add(this._d.getTimezoneOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: deprecate(
                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._d.getTimezoneOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            if (key === undefined) {
                return this._locale._abbr;
            } else {
                this._locale = moment.localeData(key);
                return this;
            }
        },

        lang : deprecate(
            "moment().lang() is deprecated. Use moment().localeData() instead.",
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    this._locale = moment.localeData(key);
                    return this;
                }
            }
        ),

        localeData : function () {
            return this._locale;
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            days = this._days + this._milliseconds / 864e5;
            if (units === 'month' || units === 'year') {
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                days += yearsToDays(this._months / 12);
                switch (units) {
                    case 'week': return days / 7;
                    case 'day': return days;
                    case 'hour': return days * 24;
                    case 'minute': return days * 24 * 60;
                    case 'second': return days * 24 * 60 * 60;
                    case 'millisecond': return days * 24 * 60 * 60 * 1000;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            "toIsoString() is deprecated. Please use toISOString() instead " +
            "(notice the capitals)",
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    'Accessing Moment through the global scope is ' +
                    'deprecated, and will be removed in an upcoming ' +
                    'release.',
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define('moment', function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);
;/**
 * eventsource.js
 * Available under MIT License (MIT)
 * https://github.com/Yaffle/EventSource/
 */

/*jslint indent: 2, vars: true, plusplus: true */
/*global setTimeout, clearTimeout */

(function (global) {
  "use strict";

  function Map() {
    this.data = {};
  }

  Map.prototype = {
    get: function (key) {
      return this.data[key + "~"];
    },
    set: function (key, value) {
      this.data[key + "~"] = value;
    },
    "delete": function (key) {
      delete this.data[key + "~"];
    }
  };

  function EventTarget() {
    this.listeners = new Map();
  }

  function throwError(e) {
    setTimeout(function () {
      throw e;
    }, 0);
  }

  EventTarget.prototype = {
    dispatchEvent: function (event) {
      event.target = this;
      var type = String(event.type);
      var listeners = this.listeners;
      var typeListeners = listeners.get(type);
      if (!typeListeners) {
        return;
      }
      var length = typeListeners.length;
      var i = -1;
      var listener = null;
      while (++i < length) {
        listener = typeListeners[i];
        try {
          listener.call(this, event);
        } catch (e) {
          throwError(e);
        }
      }
    },
    addEventListener: function (type, callback) {
      type = String(type);
      var listeners = this.listeners;
      var typeListeners = listeners.get(type);
      if (!typeListeners) {
        typeListeners = [];
        listeners.set(type, typeListeners);
      }
      var i = typeListeners.length;
      while (--i >= 0) {
        if (typeListeners[i] === callback) {
          return;
        }
      }
      typeListeners.push(callback);
    },
    removeEventListener: function (type, callback) {
      type = String(type);
      var listeners = this.listeners;
      var typeListeners = listeners.get(type);
      if (!typeListeners) {
        return;
      }
      var length = typeListeners.length;
      var filtered = [];
      var i = -1;
      while (++i < length) {
        if (typeListeners[i] !== callback) {
          filtered.push(typeListeners[i]);
        }
      }
      if (filtered.length === 0) {
        listeners["delete"](type);
      } else {
        listeners.set(type, filtered);
      }
    }
  };

  function Event(type) {
    this.type = type;
    this.target = null;
  }

  function MessageEvent(type, options) {
    Event.call(this, type);
    this.data = options.data;
    this.lastEventId = options.lastEventId;
  }

  MessageEvent.prototype = Event.prototype;

  var XHR = global.XMLHttpRequest;
  var XDR = global.XDomainRequest;
  var isCORSSupported = Boolean(XHR && ((new XHR()).withCredentials !== undefined));
  var isXHR = isCORSSupported;
  var Transport = isCORSSupported ? XHR : XDR;
  var WAITING = -1;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSED = 2;
  var AFTER_CR = 3;
  var FIELD_START = 4;
  var FIELD = 5;
  var VALUE_START = 6;
  var VALUE = 7;
  var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;

  var MINIMUM_DURATION = 1000;
  var MAXIMUM_DURATION = 18000000;

  function getDuration(value, def) {
    var n = Number(value) || def;
    return (n < MINIMUM_DURATION ? MINIMUM_DURATION : (n > MAXIMUM_DURATION ? MAXIMUM_DURATION : n));
  }

  function fire(that, f, event) {
    try {
      if (typeof f === "function") {
        f.call(that, event);
      }
    } catch (e) {
      throwError(e);
    }
  }

  function EventSource(url, options) {
    url = String(url);

    var withCredentials = Boolean(isCORSSupported && options && options.withCredentials);
    var initialRetry = getDuration(options ? options.retry : NaN, 1000);
    var heartbeatTimeout = getDuration(options ? options.heartbeatTimeout : NaN, 45000);
    var lastEventId = (options && options.lastEventId && String(options.lastEventId)) || "";
    var that = this;
    var retry = initialRetry;
    var wasActivity = false;
    var xhr = new Transport();
    var timeout = 0;
    var timeout0 = 0;
    var charOffset = 0;
    var currentState = WAITING;
    var dataBuffer = [];
    var lastEventIdBuffer = "";
    var eventTypeBuffer = "";
    var onTimeout = null;

    var state = FIELD_START;
    var field = "";
    var value = "";

    options = null;

    function close() {
      currentState = CLOSED;
      if (xhr !== null) {
        xhr.abort();
        xhr = null;
      }
      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }
      if (timeout0 !== 0) {
        clearTimeout(timeout0);
        timeout0 = 0;
      }
      that.readyState = CLOSED;
    }

    function onProgress(isLoadEnd) {
      var responseText = currentState === OPEN || currentState === CONNECTING ? xhr.responseText || "" : "";
      var event = null;
      var isWrongStatusCodeOrContentType = false;

      if (currentState === CONNECTING) {
        var status = 0;
        var statusText = "";
        var contentType = "";
        if (isXHR) {
          try {
            status = Number(xhr.status || 0);
            statusText = String(xhr.statusText || "");
            contentType = String(xhr.getResponseHeader("Content-Type") || "");
          } catch (error) {
            // https://bugs.webkit.org/show_bug.cgi?id=29121
            status = 0;
            // FF < 14, WebKit
            // https://bugs.webkit.org/show_bug.cgi?id=29658
            // https://bugs.webkit.org/show_bug.cgi?id=77854
          }
        } else {
          status = 200;
          contentType = xhr.contentType;
        }
        if (status === 200 && contentTypeRegExp.test(contentType)) {
          currentState = OPEN;
          wasActivity = true;
          retry = initialRetry;
          that.readyState = OPEN;
          event = new Event("open");
          that.dispatchEvent(event);
          fire(that, that.onopen, event);
          if (currentState === CLOSED) {
            return;
          }
        } else {
          if (status !== 0) {
            var message = "";
            if (status !== 200) {
              message = "EventSource's response has a status " + status + " " + statusText.replace(/\s+/g, " ") + " that is not 200. Aborting the connection.";
            } else {
              message = "EventSource's response has a Content-Type specifying an unsupported type: " + contentType.replace(/\s+/g, " ") + ". Aborting the connection.";
            }
            setTimeout(function () {
              throw new Error(message);
            });
            isWrongStatusCodeOrContentType = true;
          }
        }
      }

      if (currentState === OPEN) {
        if (responseText.length > charOffset) {
          wasActivity = true;
        }
        var i = charOffset - 1;
        var length = responseText.length;
        var c = "\n";
        while (++i < length) {
          c = responseText[i];
          if (state === AFTER_CR && c === "\n") {
            state = FIELD_START;
          } else {
            if (state === AFTER_CR) {
              state = FIELD_START;
            }
            if (c === "\r" || c === "\n") {
              if (field === "data") {
                dataBuffer.push(value);
              } else if (field === "id") {
                lastEventIdBuffer = value;
              } else if (field === "event") {
                eventTypeBuffer = value;
              } else if (field === "retry") {
                initialRetry = getDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === "heartbeatTimeout") {//!
                heartbeatTimeout = getDuration(value, heartbeatTimeout);
                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(onTimeout, heartbeatTimeout);
                }
              }
              value = "";
              field = "";
              if (state === FIELD_START) {
                if (dataBuffer.length !== 0) {
                  lastEventId = lastEventIdBuffer;
                  if (eventTypeBuffer === "") {
                    eventTypeBuffer = "message";
                  }
                  event = new MessageEvent(eventTypeBuffer, {
                    data: dataBuffer.join("\n"),
                    lastEventId: lastEventIdBuffer
                  });
                  that.dispatchEvent(event);
                  if (eventTypeBuffer === "message") {
                    fire(that, that.onmessage, event);
                  }
                  if (currentState === CLOSED) {
                    return;
                  }
                }
                dataBuffer.length = 0;
                eventTypeBuffer = "";
              }
              state = c === "\r" ? AFTER_CR : FIELD_START;
            } else {
              if (state === FIELD_START) {
                state = FIELD;
              }
              if (state === FIELD) {
                if (c === ":") {
                  state = VALUE_START;
                } else {
                  field += c;
                }
              } else if (state === VALUE_START) {
                if (c !== " ") {
                  value += c;
                }
                state = VALUE;
              } else if (state === VALUE) {
                value += c;
              }
            }
          }
        }
        charOffset = length;
      }

      if ((currentState === OPEN || currentState === CONNECTING) &&
          (isLoadEnd || isWrongStatusCodeOrContentType || (charOffset > 1024 * 1024) || (timeout === 0 && !wasActivity))) {
        currentState = WAITING;
        xhr.abort();
        if (timeout !== 0) {
          clearTimeout(timeout);
          timeout = 0;
        }
        if (retry > initialRetry * 16) {
          retry = initialRetry * 16;
        }
        if (retry > MAXIMUM_DURATION) {
          retry = MAXIMUM_DURATION;
        }
        timeout = setTimeout(onTimeout, retry);
        retry = retry * 2 + 1;

        that.readyState = CONNECTING;
        event = new Event("error");
        that.dispatchEvent(event);
        fire(that, that.onerror, event);
      } else {
        if (timeout === 0) {
          wasActivity = false;
          timeout = setTimeout(onTimeout, heartbeatTimeout);
        }
      }
    }

    function onProgress2() {
      onProgress(false);
    }

    function onLoadEnd() {
      onProgress(true);
    }

    if (isXHR) {
      // workaround for Opera issue with "progress" events
      timeout0 = setTimeout(function f() {
        if (xhr.readyState === 3) {
          onProgress2();
        }
        timeout0 = setTimeout(f, 500);
      }, 0);
    }

    onTimeout = function () {
      timeout = 0;
      if (currentState !== WAITING) {
        onProgress(false);
        return;
      }
      // loading indicator in Safari, Chrome < 14, Firefox
      // https://bugzilla.mozilla.org/show_bug.cgi?id=736723
      if (isXHR && (xhr.sendAsBinary !== undefined || xhr.onloadend === undefined) && global.document && global.document.readyState && global.document.readyState !== "complete") {
        timeout = setTimeout(onTimeout, 4);
        return;
      }
      // XDomainRequest#abort removes onprogress, onerror, onload

      xhr.onload = xhr.onerror = onLoadEnd;

      if (isXHR) {
        // improper fix to match Firefox behaviour, but it is better than just ignore abort
        // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
        // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
        // https://code.google.com/p/chromium/issues/detail?id=153570
        xhr.onabort = onLoadEnd;

        // Firefox 3.5 - 3.6 - ? < 9.0
        // onprogress is not fired sometimes or delayed
        xhr.onreadystatechange = onProgress2;
      }

      xhr.onprogress = onProgress2;

      wasActivity = false;
      timeout = setTimeout(onTimeout, heartbeatTimeout);

      charOffset = 0;
      currentState = CONNECTING;
      dataBuffer.length = 0;
      eventTypeBuffer = "";
      lastEventIdBuffer = lastEventId;
      value = "";
      field = "";
      state = FIELD_START;

      var s = url.slice(0, 5);
      if (s !== "data:" && s !== "blob:") {
        s = url + ((url.indexOf("?", 0) === -1 ? "?" : "&") + "lastEventId=" + encodeURIComponent(lastEventId) + "&r=" + String(Math.random() + 1).slice(2));
      } else {
        s = url;
      }
      xhr.open("GET", s, true);

      if (isXHR) {
        // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)
        xhr.withCredentials = withCredentials;

        xhr.responseType = "text";

        // Request header field Cache-Control is not allowed by Access-Control-Allow-Headers.
        // "Cache-control: no-cache" are not honored in Chrome and Firefox
        // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
        //xhr.setRequestHeader("Cache-Control", "no-cache");
        xhr.setRequestHeader("Accept", "text/event-stream");
        // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.
        //xhr.setRequestHeader("Last-Event-ID", lastEventId);
      }

      xhr.send(null);
    };

    EventTarget.call(this);
    this.close = close;
    this.url = url;
    this.readyState = CONNECTING;
    this.withCredentials = withCredentials;

    this.onopen = null;
    this.onmessage = null;
    this.onerror = null;

    onTimeout();
  }

  function F() {
    this.CONNECTING = CONNECTING;
    this.OPEN = OPEN;
    this.CLOSED = CLOSED;
  }
  F.prototype = EventTarget.prototype;

  EventSource.prototype = new F();
  F.call(EventSource);

  if (Transport) {
    // Why replace a native EventSource ?
    // https://bugzilla.mozilla.org/show_bug.cgi?id=444328
    // https://bugzilla.mozilla.org/show_bug.cgi?id=831392
    // https://code.google.com/p/chromium/issues/detail?id=260144
    // https://code.google.com/p/chromium/issues/detail?id=225654
    // ...
    global.NativeEventSource = global.EventSource;
    global.EventSource = EventSource;
  }

}(this));
;// https://github.com/xbsoftware/enjoyhint
// (+ some custom changes for binary.com)

var EnjoyHint = function (_options) {
    var that = this;
    // Some options
    var defaults = {
        onStart: function () {

        },
        onEnd: function () {

        }
    };
    var options = $.extend(defaults, _options);


    var data = [];
    var current_step = 0;

    $body = $('body');

    /********************* PRIVAT METHODS ***************************************/
    var init = function () {
        if ($('.enjoyhint'))
            $('.enjoyhint').remove();
        $("html, body").css({'overflow':'hidden'});
        $(document).on("touchmove",lockTouch);

        $body.enjoyhint({
            onNextClick: function () {
                current_step++;
                stepAction();
            },
            onSkipClick: function () {
                var step_data = data[current_step];
                var $element = $(step_data.selector);
                off(step_data.event);
                $element.off(makeEventName(step_data.event));
                destroyEnjoy();
            }
        });
    };

    var lockTouch = function(e) {
        e.preventDefault();
    };

    var destroyEnjoy = function () {
        $body = $('body');
        $('.enjoyhint').remove();
        $("html, body").css({'overflow':'auto'});
        $("html, body").css({'overflow-x':'hidden'});
        $(document).off("touchmove", lockTouch);

    };

    that.clear = function(){
        //Remove userClass and set default text
        $(".enjoyhint_next_btn").removeClass(that.nextUserClass);
        $(".enjoyhint_next_btn").text("Next");
        $(".enjoyhint_skip_btn").removeClass(that.skipUserClass);
        $(".enjoyhint_skip_btn").text("Skip");
    }

    var $body = $('body');
    var stepAction = function () {
        if (data && data[current_step]) {
            $(".enjoyhint").removeClass("enjoyhint-step-"+current_step);
            $(".enjoyhint").addClass("enjoyhint-step-"+(current_step+1));
            var step_data = data[current_step];
            if (step_data.onBeforeStart && typeof step_data.onBeforeStart === 'function') {
                step_data.onBeforeStart();
            }
            var timeout = step_data.timeout || 0;
            setTimeout(function () {
                if (!step_data.selector) {
                    for (var prop in step_data) {
                        if (step_data.hasOwnProperty(prop) && prop.split(" ")[1]) {
                            step_data.selector = prop.split(" ")[1];
                            step_data.event = prop.split(" ")[0];
                            if (prop.split(" ")[0] == 'next' || prop.split(" ")[0] == 'auto' || prop.split(" ")[0] == 'custom') {
                                step_data.event_type = prop.split(" ")[0];
                            }
                            step_data.description = step_data[prop];
                        }
                    }
                }
                setTimeout(function(){
                    that.clear();
                }, 250);
                $(document.body).scrollTo(step_data.selector, step_data.scrollAnimationSpeed || 250, {offset: -100});
                setTimeout(function () {
                    var $element = $(step_data.selector);
                    var event = makeEventName(step_data.event);

                    $body.enjoyhint('show');
                    $body.enjoyhint('hide_next');
                    var $event_element = $element;
                    if (step_data.event_selector) {
                        $event_element = $(step_data.event_selector);
                    }
                    if (!step_data.event_type && step_data.event == "key"){
                        $element.keydown(function( event ) {
                            if ( event.which == step_data.keyCode ) {
                                current_step++;
                                stepAction();
                            }
                        });
                    }
                    if (step_data.showNext == true){
                        $body.enjoyhint('show_next');
                    }
                    if (step_data.showSkip == true){
                        $body.enjoyhint('show_skip');
                    }else{
                        $body.enjoyhint('hide_skip');
                    }
                    if (step_data.showSkip == true){

                    }


                    if (step_data.nextButton){
                        $(".enjoyhint_next_btn").addClass(step_data.nextButton.className || "");
                        $(".enjoyhint_next_btn").html(step_data.nextButton.html || "Next");
                        that.nextUserClass = step_data.nextButton.className
                    }

                    if (step_data.skipButton){
                        $(".enjoyhint_skip_btn").addClass(step_data.skipButton.className || "");
                        $(".enjoyhint_skip_btn").html(step_data.skipButton.html || "Skip");
                        that.skipUserClass = step_data.skipButton.className
                    }

                    if (step_data.event_type) {
                        switch (step_data.event_type) {
                            case 'auto':
                                $element[step_data.event]();
                                switch (step_data.event) {
                                    case 'click':
                                        break;
                                }
                                current_step++;
                                stepAction();
                                return;
                                break;
                            case 'custom':
                                on(step_data.event, function () {
                                    current_step++;
                                    off(step_data.event);
                                    stepAction();
                                });
                                break;
                            case 'next':
                                $body.enjoyhint('show_next');
                                break;

                        }

                    } else {
                        $event_element.on(event, function (e) {
                            if (step_data.keyCode && e.keyCode != step_data.keyCode) {
                                return;
                            }
                            current_step++;
                            $(this).off(event);

                            stepAction();
                        });

                    }
                    var max_habarites = Math.max($element.outerWidth(), $element.outerHeight());
                    var radius = step_data.radius  || Math.round(max_habarites / 2) + 5;
                    var offset = $element.offset();
                    var w = $element.outerWidth();
                    var h = $element.outerHeight();
                    var shape_margin = (step_data.margin !== undefined) ? step_data.margin : 10;
                    var coords = {
                        x: offset.left + Math.round(w / 2) ,
                        y: offset.top + Math.round(h / 2)  - $(document).scrollTop()
                    };
                    var shape_data = {
                        center_x: coords.x,
                        center_y: coords.y,
                        text: step_data.description,
                        top: step_data.top,
                        bottom: step_data.bottom,
                        left: step_data.left,
                        right: step_data.right,
                        margin: step_data.margin,
                        scroll: step_data.scroll
                    };

                    if (step_data.shape && step_data.shape == 'circle') {
                        shape_data.shape = 'circle';
                        shape_data.radius = radius;
                    } else {
                        shape_data.radius = 0;
                        shape_data.width = w + shape_margin;
                        shape_data.height = h + shape_margin;
                    }
                    $body.enjoyhint('render_label_with_shape', shape_data);
                }, step_data.scrollAnimationSpeed + 20 || 270);
            }, timeout);
        } else {
            $body.enjoyhint('hide');
            options.onEnd();
            destroyEnjoy();
        }

    };

    var makeEventName = function (name, is_custom) {
        return name + (is_custom ? 'custom' : '') + '.enjoy_hint';
    };

    var on = function (event_name, callback) {
        $body.on(makeEventName(event_name, true), callback);
    };
    var off = function (event_name) {
        $body.off(makeEventName(event_name, true));
    };

    /********************* PUBLIC METHODS ***************************************/
    that.runScript = function () {
        current_step = 0;
        options.onStart();
        stepAction();
    };

    that.resumeScript = function () {
        stepAction();
    };

    that.getCurrentStep = function () {
        return current_step;
    };


    that.trigger = function (event_name) {
        $body.trigger(makeEventName(event_name, true));
    };

    that.setScript = function (_data) {
        if (_data) {
            data = _data;
        }
    };

    //support deprecated API methods
    that.set = function (_data) {
        that.setScript(_data);
    };

    that.setSteps = function (_data) {
        that.setScript(_data);
    };

    that.run = function () {
        that.runScript();
    };

    that.resume = function () {
        that.resumeScript();
    };


    init();
};
;CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    this.beginPath();
    this.moveTo(x + r, y);
    this.arcTo(x + w, y, x + w, y + h, r);
    this.arcTo(x + w, y + h, x, y + h, r);
    this.arcTo(x, y + h, x, y, r);
    this.arcTo(x, y, x + w, y, r);
    this.closePath();
    return this;
};

(function ($) {
    var methods = {
        init: function (options) {
            //console.log(options,'-------------');
            return this.each(function () {
                var defaults = {
                    onNextClick: function () {
                    },
                    onSkipClick: function () {
                    },
                    animation_time: 800
                };


                this.enjoyhint_obj = {};
                var that = this.enjoyhint_obj;
                var $that = $(this);
                var $body = $('body');
                that.options = jQuery.extend(defaults, options);

                //general classes
                that.gcl = {
                    chooser: 'enjoyhint'
                };

                // classes
                that.cl = {
                    enjoy_hint: 'enjoyhint',
                    hide: 'enjoyhint_hide',
                    disable_events_element: 'enjoyhint_disable_events',
                    btn: 'enjoyhint_btn',
                    skip_btn: 'enjoyhint_skip_btn',
                    close_btn: 'enjoyhint_close_btn',
                    next_btn: 'enjoyhint_next_btn',
                    main_canvas: 'enjoyhint_canvas',
                    main_svg: 'enjoyhint_svg',
                    svg_wrapper: 'enjoyhint_svg_wrapper',
                    svg_transparent: 'enjoyhint_svg_transparent',
                    kinetic_container: 'kinetic_container'
                };
                function makeSVG(tag, attrs) {
                    var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                    for (var k in attrs)
                        el.setAttribute(k, attrs[k]);
                    return el;
                }

                // =======================================================================
                // ========================---- enjoyhint ----==============================
                // =======================================================================
                that.canvas_size = {
                    w: $(window).width()*1.4,
                    h: $(window).height()*1.4
                };
                var canvas_id = "enj_canvas";

                that.enjoyhint = $('<div>', {'class': that.cl.enjoy_hint + ' ' + that.cl.svg_transparent}).appendTo($that);
                that.enjoyhint_svg_wrapper = $('<div>', {'class': that.cl.svg_wrapper + ' ' + that.cl.svg_transparent}).appendTo(that.enjoyhint);
                that.$stage_container = $('<div id="' + that.cl.kinetic_container + '">').appendTo(that.enjoyhint);
                that.$canvas = $('<canvas id="' + canvas_id + '" width="' + that.canvas_size.w + '" height="' + that.canvas_size.h + '" class="' + that.cl.main_canvas + '">').appendTo(that.enjoyhint);
                that.$svg = $('<svg width="' + that.canvas_size.w + '" height="' + that.canvas_size.h + '" class="' + that.cl.main_canvas + ' ' + that.cl.main_svg + '">').appendTo(that.enjoyhint_svg_wrapper);
                var defs = $(makeSVG('defs'));
                var marker = $(makeSVG('marker', {id: "arrowMarker", viewBox: "0 0 36 21", refX: "21", refY: "10", markerUnits: "strokeWidth", orient: "auto", markerWidth: "16", markerHeight: "12"}));
                var polilyne = $(makeSVG('path', {style: "fill:none; stroke:rgb(255,255,255); stroke-width:2", d: "M0,0 c30,11 30,9 0,20"}));
                defs.append(marker.append(polilyne)).appendTo(that.$svg);
                that.kinetic_stage = new Kinetic.Stage({
                    container: that.cl.kinetic_container,
                    width: that.canvas_size.w,
                    height: that.canvas_size.h
                });
                //console.log(that.enjoyhint);

                that.layer = new Kinetic.Layer();
                that.rect = new Kinetic.Rect({
//          x: 0,
//          y: 0,
                    fill: 'rgba(0,0,0,0.6)',
                    width: that.canvas_size.w,
                    height: that.canvas_size.h
                });

                var $top_dis_events = $('<div>', {'class': that.cl.disable_events_element}).appendTo(that.enjoyhint);
                var $bottom_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);
                var $left_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);
                var $right_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);

                that.$skip_btn = $('<div>', {'class': that.cl.skip_btn}).appendTo(that.enjoyhint).html('Skip').click(function (e) {
                    that.hide();
                    that.options.onSkipClick();
                });
                that.$next_btn = $('<div>', {'class': that.cl.next_btn}).appendTo(that.enjoyhint).html('Next').click(function (e) {
                    that.options.onNextClick();
                });

                that.$close_btn = $('<div>', {'class': that.cl.close_btn}).appendTo(that.enjoyhint).html('').click(function (e){
                    that.hide();
                    that.options.onSkipClick();
                });

                that.$canvas.mousedown(function (e) {
                    //console.log('cl')
                    $('canvas').css({left: '4000px'});

                    var BottomElement = document.elementFromPoint(e.clientX, e.clientY);
                    //console.log(BottomElement.tagName)
                    $('canvas').css({left: '0px'});

                    $(BottomElement).click();
//          that.$canvas.show();
                    return false;
                });


                var circle_r = 0;
                var shape_init_shift = 130;
                that.shape = new Kinetic.Shape({
                    radius: circle_r,
                    center_x: -shape_init_shift,
                    center_y: -shape_init_shift,
                    width: 0,
                    height: 0,
                    sceneFunc: function (context) {
                        var ctx = this.getContext("2d")._context;
                        var pos = this.pos;
                        var def_comp = ctx.globalCompositeOperation;
                        ctx.globalCompositeOperation = 'destination-out';
                        ctx.beginPath();

                        var x = this.attrs.center_x - Math.round(this.attrs.width / 2);
                        var y = this.attrs.center_y - Math.round(this.attrs.height / 2);
                        ctx.roundRect(x, y, this.attrs.width, this.attrs.height, this.attrs.radius);
                        ctx.fillStyle = "red";
                        ctx.fill();

                        ctx.globalCompositeOperation = def_comp;
                    }
                });
                that.shape.radius = circle_r;
                that.layer.add(that.rect);
                that.layer.add(that.shape);
                that.kinetic_stage.add(that.layer);

                var enjoyhint_elements = [
                    that.enjoyhint,
                    $top_dis_events,
                    $bottom_dis_events,
                    $left_dis_events,
                    $right_dis_events
                ];

                that.show = function () {
                    that.enjoyhint.removeClass(that.cl.hide);
                };

                that.hide = function () {
                    that.enjoyhint.addClass(that.cl.hide);
                    var tween = new Kinetic.Tween({
                        node: that.shape,
                        duration: 0.002,
                        center_x: -shape_init_shift,
                        center_y: -shape_init_shift
                    });
                    tween.play();
                };

                that.hide();

                that.hideNextBtn = function () {
                    that.$next_btn.addClass(that.cl.hide);
                    that.nextBtn = "hide";
                };
                that.showNextBtn = function () {
                    that.$next_btn.removeClass(that.cl.hide);
                    that.nextBtn = "show";
                };

                that.hideSkipBtn = function () {
                    that.$skip_btn.addClass(that.cl.hide);
                };
                that.showSkipBtn = function () {
                    that.$skip_btn.removeClass(that.cl.hide);
                };





                that.renderCircle = function (data) {
                    var r = data.r || 0;
                    var x = data.x || 0;
                    var y = data.y || 0;

                    var tween = new Kinetic.Tween({
                        node: that.shape,
                        duration: 0.2,
                        center_x: x,
                        center_y: y,
                        width: r * 2,
                        height: r * 2,
                        radius: r
                    });
                    tween.play();

                    var left = x - r;
                    var right = x + r;
                    var top = y - r;
                    var bottom = y + r;
                    var margin = 20;
                    return {
                        x: x,
                        y: y,
                        left: left,
                        right: right,
                        top: top,
                        bottom: bottom,
                        conn: {
                            left: {
                                x: left - margin,
                                y: y
                            },
                            right: {
                                x: right + margin,
                                y: y
                            },
                            top: {
                                x: x,
                                y: top - margin
                            },
                            bottom: {
                                x: x,
                                y: bottom + margin
                            }
                        }
                    };

                };


                that.renderRect = function (data) {
                    var r = data.r || 0;
                    var x = data.x || 0;
                    var y = data.y || 0;
                    var w = data.w || 0;
                    var h = data.h || 0;
                    var margin = 20;
                    var tween = new Kinetic.Tween({
                        node: that.shape,
                        duration: 0.2,
                        center_x: x,
                        center_y: y,
                        width: w,
                        height: h,
                        radius: r
                    });
                    tween.play();
                    var half_w = Math.round(w / 2);
                    var half_h = Math.round(h / 2);
                    var left = x - half_w;
                    var right = x + half_w;
                    var top = y - half_h;
                    var bottom = y + half_h;
                    return {
                        x: x,
                        y: y,
                        left: left,
                        right: right,
                        top: top,
                        bottom: bottom,
                        conn: {
                            left: {
                                x: left - margin,
                                y: y
                            },
                            right: {
                                x: right + margin,
                                y: y
                            },
                            top: {
                                x: x,
                                y: top - margin
                            },
                            bottom: {
                                x: x,
                                y: bottom + margin
                            }
                        }
                    };

                };
                that.renderLabel = function (data) {
                    var x = data.x || 0;
                    var y = data.y || 0;
                    var text = data.text || 0;

                    var label = that.getLabelElement({
                        x: x,
                        y: y,
                        text: data.text
                    });
                    var label_w = label.width();
                    var label_h = label.height();
                    var label_left = label.offset().left;
                    var label_right = label.offset().left + label_w;
                    var label_top = label.offset().top - $(document).scrollTop();;
                    var label_bottom = label.offset().top + label_h;

                    var margin = 10;
                    var conn_left = {
                        x: label_left - margin,
                        y: label_top + Math.round(label_h / 2)
                    };
                    var conn_right = {
                        x: label_right + margin,
                        y: label_top + Math.round(label_h / 2)
                    };
                    var conn_top = {
                        x: label_left + Math.round(label_w / 2),
                        y: label_top - margin
                    };
                    var conn_bottom = {
                        x: label_left + Math.round(label_w / 2),
                        y: label_bottom + margin
                    };
                    label.detach();
                    setTimeout(function () {
                        $('#enjoyhint_label').remove();
                        label.appendTo(that.enjoyhint);

                    }, that.options.animation_time / 2);
                    return {
                        label: label,
                        left: label_left,
                        right: label_right,
                        top: label_top,
                        bottom: label_bottom,
                        conn: {
                            left: conn_left,
                            right: conn_right,
                            top: conn_top,
                            bottom: conn_bottom
                        }

                    };
                };
                that.renderArrow = function (data) {
                    var x_from = data.x_from || 0;
                    var y_from = data.y_from || 0;
                    var x_to = data.x_to || 0;
                    var y_to = data.y_to || 0;
                    var by_top_side = data.by_top_side;
                    var control_point_x = 0;
                    var control_point_y = 0;
                    if (by_top_side) {
                        if (y_from >= y_to) {
                            control_point_y = y_to;
                            control_point_x = x_from;
                        } else {
                            control_point_y = y_from;
                            control_point_x = x_to;
                        }
                    } else {
                        if (y_from >= y_to) {
                            control_point_y = y_from;
                            control_point_x = x_to;
                        } else {
                            control_point_y = y_to;
                            control_point_x = x_from;
                        }
                    }

                    var text = data.text || '';
                    that.enjoyhint.addClass(that.cl.svg_transparent);
                    setTimeout(function () {
                        $('#enjoyhint_arrpw_line').remove();
                        var d = 'M' + x_from + ',' + y_from + ' Q' + control_point_x + ',' + control_point_y + ' ' + x_to + ',' + y_to;
                        that.$svg.append(makeSVG('path', {style: "fill:none; stroke:rgb(255,255,255); stroke-width:3", 'marker-end': "url(#arrowMarker)", d: d, id: 'enjoyhint_arrpw_line'}));
                        that.enjoyhint.removeClass(that.cl.svg_transparent);

                    }, that.options.animation_time / 2);
                };


                that.getLabelElement = function (data) {
                    return $('<div>', {"class": 'enjoy_hint_label', id: 'enjoyhint_label'})
                        .css({
                            'top': data.y + 'px',
                            'left': data.x + 'px'
                        })
                        .html(data.text).appendTo(that.enjoyhint);

                };


                that.disableEventsNearRect = function (rect) {
                    $top_dis_events.css({
                        top: '0',
                        left: '0'
                    }).height(rect.top);
                    $bottom_dis_events.css({
                        top: rect.bottom + 'px',
                        left: '0'
                    });
                    $left_dis_events.css({
                        top: '0',
                        left: 0 + 'px'
                    }).width(rect.left);
                    $right_dis_events.css({
                        top: '0',
                        left: rect.right + 'px'
                    });
                };


                that.renderLabelWithShape = function (data) {
                    var shape_type = data.shape || 'rect';
                    var shape_data = {};


                    var half_w = 0;
                    var half_h = 0;

                    var shape_offsets = {
                        top: data.top || 0,
                        bottom: data.bottom || 0,
                        left: data.left || 0,
                        right: data.right || 0
                    };

                    switch (shape_type) {
                        case 'circle':
                            half_w = half_h = data.radius;
                            var sides_pos = {
                                top: data.center_y - half_h + shape_offsets.top,
                                bottom: data.center_y + half_h - shape_offsets.bottom,
                                left: data.center_x - half_w + shape_offsets.left,
                                right: data.center_x + half_w - shape_offsets.right
                            };
                            var width = sides_pos.right - sides_pos.left;
                            var height = sides_pos.bottom - sides_pos.top;
                            data.radius = Math.round(Math.min(width, height) / 2);
                            //new half habarites
                            half_w = half_h = Math.round(data.radius / 2);

                            var new_half_w = Math.round(width / 2);
                            var new_half_h = Math.round(height / 2);
                            //new center_x and center_y
                            data.center_x = sides_pos.left + new_half_w;
                            data.center_y = sides_pos.top + new_half_h;

                            shape_data = that.renderCircle({
                                x: data.center_x,
                                y: data.center_y,
                                r: data.radius
                            });

                            break;
                        case 'rect':
                            half_w = Math.round(data.width / 2);
                            half_h = Math.round(data.height / 2);

                            var sides_pos = {
                                top: data.center_y - half_h + shape_offsets.top,
                                bottom: data.center_y + half_h - shape_offsets.bottom,
                                left: data.center_x - half_w + shape_offsets.left,
                                right: data.center_x + half_w - shape_offsets.right
                            };
                            data.width = sides_pos.right - sides_pos.left;
                            data.height = sides_pos.bottom - sides_pos.top;

                            half_w = Math.round(data.width / 2);
                            half_h = Math.round(data.height / 2);
                            //new center_x and center_y
                            data.center_x = sides_pos.left + half_w;
                            data.center_y = sides_pos.top + half_h;
                            shape_data = that.renderRect({
                                x: data.center_x,
                                y: data.center_y,
                                w: data.width,
                                h: data.height,
                                r: data.radius,
                            });
                            break;
                    }


                    var body_size = {
                        w: that.enjoyhint.width(),
                        h: that.enjoyhint.height()
                    };
                    //temp label used for detect label width and height
                    var label = that.getLabelElement({
                        x: 0,
                        y: 0,
                        text: data.text
                    });
                    var label_width = label.outerWidth();
                    var label_height = label.outerHeight();
                    label.remove();
                    var top_offset = data.center_y - half_h;
                    var bottom_offset = body_size.h - (data.center_y + half_h);
                    var left_offset = data.center_x - half_w;
                    var right_offset = body_size.w - (data.center_x + half_w);

                    var label_hor_side = (body_size.w - data.center_x) < data.center_x ? 'left' : 'right';
                    var label_ver_side = (body_size.h - data.center_y) < data.center_y ? 'top' : 'bottom';
                    var label_shift = 150;
                    var label_margin = 40;
                    var label_shift_with_label_width = label_shift + label_width + label_margin;
                    var label_shift_with_label_height = label_shift + label_height + label_margin;
                    var label_hor_offset = half_w + label_shift;
                    var label_ver_offset = half_h + label_shift;

                    var label_x = (label_hor_side == 'left') ? data.center_x - label_hor_offset - label_width : data.center_x + label_hor_offset;
                    var label_y = (label_ver_side == 'top') ? data.center_y - label_ver_offset - label_height : data.center_y + label_ver_offset;
                    if (top_offset < label_shift_with_label_height && bottom_offset < label_shift_with_label_height) {
                        label_y = data.center_y + label_margin;
                    }
                    if (left_offset < label_shift_with_label_width && right_offset < label_shift_with_label_width) {
                        label_x = data.center_x;
                    }

                    var label_data = that.renderLabel({
                        x: label_x,
                        y: label_y,
                        text: data.text
                    });

                    that.$next_btn.css({
                        left: label_x,
                        top: label_y + label_height + 15
                    });
                    var left_skip = label_x + that.$next_btn.width() + 10;
                    //console.log(that.nextBtn);
                    if (that.nextBtn == "hide"){
                        left_skip = label_x;
                    }

                    that.$skip_btn.css({
                        left: left_skip,
                        top: label_y + label_height + 15
                    });
                    that.$close_btn.css({
                        right : 10,
                        top: 10
                    });


                    that.disableEventsNearRect({
                        top: shape_data.top,
                        bottom: shape_data.bottom,
                        left: shape_data.left,
                        right: shape_data.right
                    });


                    var x_to = 0;
                    var y_to = 0;
                    var arrow_side = false;
                    var conn_label_side = 'left';
                    var conn_circle_side = 'left';

                    var is_center = (label_data.left <= shape_data.x && label_data.right >= shape_data.x);
                    var is_left = (label_data.right < shape_data.x);
                    var is_right = (label_data.left > shape_data.x);

                    var is_abs_left = (label_data.right < shape_data.left);
                    var is_abs_right = (label_data.left > shape_data.right);

                    var is_top = (label_data.bottom < shape_data.top);
                    var is_bottom = (label_data.top > shape_data.bottom);
                    var is_mid = (label_data.bottom >= shape_data.y && label_data.top <= shape_data.y);
                    var is_mid_top = (label_data.bottom <= shape_data.y && !is_top);
                    var is_mid_bottom = (label_data.top >= shape_data.y && !is_bottom);


                    function setArrowData(l_s, c_s, a_s) {
                        conn_label_side = l_s;
                        conn_circle_side = c_s;
                        arrow_side = a_s;
                    }

                    function sideStatements(top_s, mid_top_s, mid_s, mid_bottom_s, bottom_s) {
                        var statement = [];
                        if (is_top) {
                            statement = top_s;
                        } else if (is_mid_top) {
                            statement = mid_top_s;
                        } else if (is_mid) {
                            statement = mid_s;
                        } else if (is_mid_bottom) {
                            statement = mid_bottom_s;
                        } else {//bottom
                            statement = bottom_s;
                        }
                        if (!statement) {
                            return;
                        } else {
                            setArrowData(statement[0], statement[1], statement[2]);
                        }
                    }


                    if (is_center) {
                        if (is_top) {
                            setArrowData('bottom', 'top', 'top');
                        } else if (is_bottom) {
                            setArrowData('top', 'bottom', 'bottom');
                        } else {
                            return;
                        }
                    } else if (is_left) {
                        sideStatements(
                            ['right', 'top', 'top'],//top
                            ['bottom', 'left', 'bottom'],//mid_top
                            ['right', 'left', 'top'],//mid
                            ['top', 'left', 'top'],//mid_bot
                            ['right', 'bottom', 'bottom']//bot
                        );
                    } else {//right
                        sideStatements(
                            ['left', 'top', 'top'],//top
                            ['bottom', 'right', 'bottom'],//mid_top
                            ['left', 'right', 'top'],//mid
                            ['top', 'right', 'top'],//mid_bot
                            ['left', 'bottom', 'bottom']//bot
                        );
                    }

                    var label_conn_coordinates = label_data.conn[conn_label_side];
                    var circle_conn_coordinates = shape_data.conn[conn_circle_side];
                    var by_top_side = (arrow_side == 'top') ? true : false;
                    that.renderArrow({
                        x_from: label_conn_coordinates.x,
                        y_from: label_conn_coordinates.y,
                        x_to: circle_conn_coordinates.x,
                        y_to: circle_conn_coordinates.y,
                        by_top_side: by_top_side
                    });

                };

                that.clear = function () {
                    that.ctx.clearRect(0, 0, 3000, 2000);
                };

                return this;
            });
        },

        set: function (val) {
            this.each(function () {
                this.enjoyhint_obj.setValue(val);
            });
            return this;
        },

        show: function () {
            this.each(function () {
                this.enjoyhint_obj.show();
            });
            return this;
        },

        hide: function () {
            this.each(function () {
                this.enjoyhint_obj.hide();
            });
            return this;
        },

        hide_next: function () {
            this.each(function () {
                this.enjoyhint_obj.hideNextBtn();
            });
            return this;
        },

        show_next: function () {
            this.each(function () {
                this.enjoyhint_obj.showNextBtn();
            });
            return this;
        },

        hide_skip: function () {
            this.each(function () {
                this.enjoyhint_obj.hideSkipBtn();
            });
            return this;
        },

        show_skip: function () {
            this.each(function () {
                this.enjoyhint_obj.showSkipBtn();
            });
            return this;
        },

        render_circle: function (x, y, r) {
            this.each(function () {
                this.enjoyhint_obj.renderCircle(x, y, r);
            });
            return this;
        },

        render_label: function (x, y, r) {
            this.each(function () {
                this.enjoyhint_obj.renderLabel(x, y, r);
            });
            return this;
        },

        render_label_with_shape: function (data) {
            this.each(function () {
                this.enjoyhint_obj.renderLabelWithShape(data);
            });
            return this;
        },

        clear: function () {
            this.each(function () {
                this.enjoyhint_obj.clear();
            });
            return this;
        },

        close: function (val) {
            this.each(function () {
                this.enjoyhint_obj.closePopdown();
            });
            return this;
        }
    };

    $.fn.enjoyhint = function (method) {
        //console.log(method);
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on $.numinput');
        }
        return this;
    };
})(window.jQuery);

;/*! KineticJS v5.2.0 2015-01-22 http://lavrton.github.io/KineticJS/ by Eric Rowell @ericdrowell, Anton Lavrenov @lavrton - MIT License https://github.com/lavrton/KineticJS/wiki/License*/
var Kinetic={};!function(a){var b=Math.PI/180;Kinetic={version:"5.2.0",stages:[],idCounter:0,ids:{},names:{},shapes:{},listenClickTap:!1,inDblClickWindow:!1,enableTrace:!1,traceArrMax:100,dblClickWindow:400,pixelRatio:void 0,dragDistance:0,angleDeg:!0,showWarnings:!0,Filters:{},Node:function(a){this._init(a)},Shape:function(a){this.__init(a)},Container:function(a){this.__init(a)},Stage:function(a){this.___init(a)},BaseLayer:function(a){this.___init(a)},Layer:function(a){this.____init(a)},FastLayer:function(a){this.____init(a)},Group:function(a){this.___init(a)},isDragging:function(){var a=Kinetic.DD;return a?a.isDragging:!1},isDragReady:function(){var a=Kinetic.DD;return a?!!a.node:!1},_addId:function(a,b){void 0!==b&&(this.ids[b]=a)},_removeId:function(a){void 0!==a&&delete this.ids[a]},_addName:function(a,b){if(void 0!==b)for(var c=b.split(/\s/g),d=0;d<c.length;d++){var e=c[d];e&&(void 0===this.names[e]&&(this.names[e]=[]),this.names[e].push(a))}},_removeName:function(a,b){if(void 0!==a){var c=this.names[a];if(void 0!==c){for(var d=0;d<c.length;d++){var e=c[d];e._id===b&&c.splice(d,1)}0===c.length&&delete this.names[a]}}},getAngle:function(a){return this.angleDeg?a*b:a},_parseUA:function(a){var b=a.toLowerCase(),c=/(chrome)[ \/]([\w.]+)/.exec(b)||/(webkit)[ \/]([\w.]+)/.exec(b)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(b)||/(msie) ([\w.]+)/.exec(b)||b.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(b)||[],d=!!a.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i),e=!!a.match(/IEMobile/i);return{browser:c[1]||"",version:c[2]||"0",mobile:d,ieMobile:e}},UA:void 0},Kinetic.UA=Kinetic._parseUA(a.navigator&&a.navigator.userAgent||"")}(this),function(a,b){if("object"==typeof exports){var c=b();if(global.window===global)Kinetic.document=global.document,Kinetic.window=global;else{var d=require("canvas"),e=require("jsdom").jsdom;Kinetic.document=e("<!DOCTYPE html><html><head></head><body></body></html>"),Kinetic.window=Kinetic.document.createWindow(),Kinetic.window.Image=d.Image,Kinetic._nodeCanvas=d}return Kinetic.root=a,void(module.exports=c)}"function"==typeof define&&define.amd&&define(b),Kinetic.document=document,Kinetic.window=window,Kinetic.root=a}(this,function(){return Kinetic}),function(){Kinetic.Collection=function(){var a=[].slice.call(arguments),b=a.length,c=0;for(this.length=b;b>c;c++)this[c]=a[c];return this},Kinetic.Collection.prototype=[],Kinetic.Collection.prototype.each=function(a){for(var b=0;b<this.length;b++)a(this[b],b)},Kinetic.Collection.prototype.toArray=function(){var a,b=[],c=this.length;for(a=0;c>a;a++)b.push(this[a]);return b},Kinetic.Collection.toCollection=function(a){var b,c=new Kinetic.Collection,d=a.length;for(b=0;d>b;b++)c.push(a[b]);return c},Kinetic.Collection._mapMethod=function(a){Kinetic.Collection.prototype[a]=function(){var b,c=this.length,d=[].slice.call(arguments);for(b=0;c>b;b++)this[b][a].apply(this[b],d);return this}},Kinetic.Collection.mapMethods=function(a){var b=a.prototype;for(var c in b)Kinetic.Collection._mapMethod(c)},Kinetic.Transform=function(a){this.m=a&&a.slice()||[1,0,0,1,0,0]},Kinetic.Transform.prototype={copy:function(){return new Kinetic.Transform(this.m)},point:function(a){var b=this.m;return{x:b[0]*a.x+b[2]*a.y+b[4],y:b[1]*a.x+b[3]*a.y+b[5]}},translate:function(a,b){return this.m[4]+=this.m[0]*a+this.m[2]*b,this.m[5]+=this.m[1]*a+this.m[3]*b,this},scale:function(a,b){return this.m[0]*=a,this.m[1]*=a,this.m[2]*=b,this.m[3]*=b,this},rotate:function(a){var b=Math.cos(a),c=Math.sin(a),d=this.m[0]*b+this.m[2]*c,e=this.m[1]*b+this.m[3]*c,f=this.m[0]*-c+this.m[2]*b,g=this.m[1]*-c+this.m[3]*b;return this.m[0]=d,this.m[1]=e,this.m[2]=f,this.m[3]=g,this},getTranslation:function(){return{x:this.m[4],y:this.m[5]}},skew:function(a,b){var c=this.m[0]+this.m[2]*b,d=this.m[1]+this.m[3]*b,e=this.m[2]+this.m[0]*a,f=this.m[3]+this.m[1]*a;return this.m[0]=c,this.m[1]=d,this.m[2]=e,this.m[3]=f,this},multiply:function(a){var b=this.m[0]*a.m[0]+this.m[2]*a.m[1],c=this.m[1]*a.m[0]+this.m[3]*a.m[1],d=this.m[0]*a.m[2]+this.m[2]*a.m[3],e=this.m[1]*a.m[2]+this.m[3]*a.m[3],f=this.m[0]*a.m[4]+this.m[2]*a.m[5]+this.m[4],g=this.m[1]*a.m[4]+this.m[3]*a.m[5]+this.m[5];return this.m[0]=b,this.m[1]=c,this.m[2]=d,this.m[3]=e,this.m[4]=f,this.m[5]=g,this},invert:function(){var a=1/(this.m[0]*this.m[3]-this.m[1]*this.m[2]),b=this.m[3]*a,c=-this.m[1]*a,d=-this.m[2]*a,e=this.m[0]*a,f=a*(this.m[2]*this.m[5]-this.m[3]*this.m[4]),g=a*(this.m[1]*this.m[4]-this.m[0]*this.m[5]);return this.m[0]=b,this.m[1]=c,this.m[2]=d,this.m[3]=e,this.m[4]=f,this.m[5]=g,this},getMatrix:function(){return this.m},setAbsolutePosition:function(a,b){var c=this.m[0],d=this.m[1],e=this.m[2],f=this.m[3],g=this.m[4],h=this.m[5],i=(c*(b-h)-d*(a-g))/(c*f-d*e),j=(a-g-e*i)/c;return this.translate(j,i)}};var a="2d",b="[object Array]",c="[object Number]",d="[object String]",e=Math.PI/180,f=180/Math.PI,g="#",h="",i="0",j="Kinetic warning: ",k="Kinetic error: ",l="rgb(",m={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},n=/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;Kinetic.Util={_isElement:function(a){return!(!a||1!=a.nodeType)},_isFunction:function(a){return!!(a&&a.constructor&&a.call&&a.apply)},_isObject:function(a){return!!a&&a.constructor==Object},_isArray:function(a){return Object.prototype.toString.call(a)==b},_isNumber:function(a){return Object.prototype.toString.call(a)==c},_isString:function(a){return Object.prototype.toString.call(a)==d},_throttle:function(a,b,c){var d,e,f,g=null,h=0,i=c||{},j=function(){h=i.leading===!1?0:(new Date).getTime(),g=null,f=a.apply(d,e),d=e=null};return function(){var c=(new Date).getTime();h||i.leading!==!1||(h=c);var k=b-(c-h);return d=this,e=arguments,0>=k?(clearTimeout(g),g=null,h=c,f=a.apply(d,e),d=e=null):g||i.trailing===!1||(g=setTimeout(j,k)),f}},_hasMethods:function(a){var b,c=[];for(b in a)this._isFunction(a[b])&&c.push(b);return c.length>0},createCanvasElement:function(){var a=Kinetic.document.createElement("canvas");try{a.style=a.style||{}}catch(b){}return a},isBrowser:function(){return"object"!=typeof exports},_isInDocument:function(a){for(;a=a.parentNode;)if(a==Kinetic.document)return!0;return!1},_simplifyArray:function(a){var b,c,d=[],e=a.length,f=Kinetic.Util;for(b=0;e>b;b++)c=a[b],f._isNumber(c)?c=Math.round(1e3*c)/1e3:f._isString(c)||(c=c.toString()),d.push(c);return d},_getImage:function(b,c){var d,e;if(b)if(this._isElement(b))c(b);else if(this._isString(b))d=new Kinetic.window.Image,d.onload=function(){c(d)},d.src=b;else if(b.data){e=Kinetic.Util.createCanvasElement(),e.width=b.width,e.height=b.height;var f=e.getContext(a);f.putImageData(b,0,0),this._getImage(e.toDataURL(),c)}else c(null);else c(null)},_getRGBAString:function(a){var b=a.red||0,c=a.green||0,d=a.blue||0,e=a.alpha||1;return["rgba(",b,",",c,",",d,",",e,")"].join(h)},_rgbToHex:function(a,b,c){return((1<<24)+(a<<16)+(b<<8)+c).toString(16).slice(1)},_hexToRgb:function(a){a=a.replace(g,h);var b=parseInt(a,16);return{r:b>>16&255,g:b>>8&255,b:255&b}},getRandomColor:function(){for(var a=(16777215*Math.random()<<0).toString(16);a.length<6;)a=i+a;return g+a},get:function(a,b){return void 0===a?b:a},getRGB:function(a){var b;return a in m?(b=m[a],{r:b[0],g:b[1],b:b[2]}):a[0]===g?this._hexToRgb(a.substring(1)):a.substr(0,4)===l?(b=n.exec(a.replace(/ /g,"")),{r:parseInt(b[1],10),g:parseInt(b[2],10),b:parseInt(b[3],10)}):{r:0,g:0,b:0}},_merge:function(a,b){var c=this._clone(b);for(var d in a)c[d]=this._isObject(a[d])?this._merge(a[d],c[d]):a[d];return c},cloneObject:function(a){var b={};for(var c in a)b[c]=this._isObject(a[c])?this.cloneObject(a[c]):this._isArray(a[c])?this.cloneArray(a[c]):a[c];return b},cloneArray:function(a){return a.slice(0)},_degToRad:function(a){return a*e},_radToDeg:function(a){return a*f},_capitalize:function(a){return a.charAt(0).toUpperCase()+a.slice(1)},error:function(a){throw new Error(k+a)},warn:function(a){Kinetic.root.console&&console.warn&&Kinetic.showWarnings&&console.warn(j+a)},extend:function(a,b){function c(){this.constructor=a}c.prototype=b.prototype;var d=a.prototype;a.prototype=new c;for(var e in d)d.hasOwnProperty(e)&&(a.prototype[e]=d[e]);a.__super__=b.prototype},addMethods:function(a,b){var c;for(c in b)a.prototype[c]=b[c]},_getControlPoints:function(a,b,c,d,e,f,g){var h=Math.sqrt(Math.pow(c-a,2)+Math.pow(d-b,2)),i=Math.sqrt(Math.pow(e-c,2)+Math.pow(f-d,2)),j=g*h/(h+i),k=g*i/(h+i),l=c-j*(e-a),m=d-j*(f-b),n=c+k*(e-a),o=d+k*(f-b);return[l,m,n,o]},_expandPoints:function(a,b){var c,d,e=a.length,f=[];for(c=2;e-2>c;c+=2)d=Kinetic.Util._getControlPoints(a[c-2],a[c-1],a[c],a[c+1],a[c+2],a[c+3],b),f.push(d[0]),f.push(d[1]),f.push(a[c]),f.push(a[c+1]),f.push(d[2]),f.push(d[3]);return f},_removeLastLetter:function(a){return a.substring(0,a.length-1)}}}(),function(){var a=Kinetic.Util.createCanvasElement(),b=a.getContext("2d"),c=Kinetic.UA.mobile?function(){var a=window.devicePixelRatio||1,c=b.webkitBackingStorePixelRatio||b.mozBackingStorePixelRatio||b.msBackingStorePixelRatio||b.oBackingStorePixelRatio||b.backingStorePixelRatio||1;return a/c}():1;Kinetic.Canvas=function(a){this.init(a)},Kinetic.Canvas.prototype={init:function(a){var b=a||{},d=b.pixelRatio||Kinetic.pixelRatio||c;this.pixelRatio=d,this._canvas=Kinetic.Util.createCanvasElement(),this._canvas.style.padding=0,this._canvas.style.margin=0,this._canvas.style.border=0,this._canvas.style.background="transparent",this._canvas.style.position="absolute",this._canvas.style.top=0,this._canvas.style.left=0},getContext:function(){return this.context},getPixelRatio:function(){return this.pixelRatio},setPixelRatio:function(a){this.pixelRatio=a,this.setSize(this.getWidth(),this.getHeight())},setWidth:function(a){this.width=this._canvas.width=a*this.pixelRatio,this._canvas.style.width=a+"px"},setHeight:function(a){this.height=this._canvas.height=a*this.pixelRatio,this._canvas.style.height=a+"px"},getWidth:function(){return this.width},getHeight:function(){return this.height},setSize:function(a,b){this.setWidth(a),this.setHeight(b)},toDataURL:function(a,b){try{return this._canvas.toDataURL(a,b)}catch(c){try{return this._canvas.toDataURL()}catch(d){return Kinetic.Util.warn("Unable to get data URL. "+d.message),""}}}},Kinetic.SceneCanvas=function(a){var b=a||{},c=b.width||0,d=b.height||0;Kinetic.Canvas.call(this,b),this.context=new Kinetic.SceneContext(this),this.setSize(c,d)},Kinetic.SceneCanvas.prototype={setWidth:function(a){var b=this.pixelRatio,c=this.getContext()._context;Kinetic.Canvas.prototype.setWidth.call(this,a),c.scale(b,b)},setHeight:function(a){var b=this.pixelRatio,c=this.getContext()._context;Kinetic.Canvas.prototype.setHeight.call(this,a),c.scale(b,b)}},Kinetic.Util.extend(Kinetic.SceneCanvas,Kinetic.Canvas),Kinetic.HitCanvas=function(a){var b=a||{},c=b.width||0,d=b.height||0;Kinetic.Canvas.call(this,b),this.context=new Kinetic.HitContext(this),this.setSize(c,d),this.hitCanvas=!0},Kinetic.Util.extend(Kinetic.HitCanvas,Kinetic.Canvas)}(),function(){var a=",",b="(",c=")",d="([",e="])",f=";",g="()",h="=",i=["arc","arcTo","beginPath","bezierCurveTo","clearRect","clip","closePath","createLinearGradient","createPattern","createRadialGradient","drawImage","fill","fillText","getImageData","createImageData","lineTo","moveTo","putImageData","quadraticCurveTo","rect","restore","rotate","save","scale","setLineDash","setTransform","stroke","strokeText","transform","translate"];Kinetic.Context=function(a){this.init(a)},Kinetic.Context.prototype={init:function(a){this.canvas=a,this._context=a._canvas.getContext("2d"),Kinetic.enableTrace&&(this.traceArr=[],this._enableTrace())},fillShape:function(a){a.getFillEnabled()&&this._fill(a)},strokeShape:function(a){a.getStrokeEnabled()&&this._stroke(a)},fillStrokeShape:function(a){var b=a.getFillEnabled();b&&this._fill(a),a.getStrokeEnabled()&&this._stroke(a)},getTrace:function(i){var j,k,l,m,n=this.traceArr,o=n.length,p="";for(j=0;o>j;j++)k=n[j],l=k.method,l?(m=k.args,p+=l,p+=i?g:Kinetic.Util._isArray(m[0])?d+m.join(a)+e:b+m.join(a)+c):(p+=k.property,i||(p+=h+k.val)),p+=f;return p},clearTrace:function(){this.traceArr=[]},_trace:function(a){var b,c=this.traceArr;c.push(a),b=c.length,b>=Kinetic.traceArrMax&&c.shift()},reset:function(){var a=this.getCanvas().getPixelRatio();this.setTransform(1*a,0,0,1*a,0,0)},getCanvas:function(){return this.canvas},clear:function(a){var b=this.getCanvas();a?this.clearRect(a.x||0,a.y||0,a.width||0,a.height||0):this.clearRect(0,0,b.getWidth(),b.getHeight())},_applyLineCap:function(a){var b=a.getLineCap();b&&this.setAttr("lineCap",b)},_applyOpacity:function(a){var b=a.getAbsoluteOpacity();1!==b&&this.setAttr("globalAlpha",b)},_applyLineJoin:function(a){var b=a.getLineJoin();b&&this.setAttr("lineJoin",b)},setAttr:function(a,b){this._context[a]=b},arc:function(){var a=arguments;this._context.arc(a[0],a[1],a[2],a[3],a[4],a[5])},beginPath:function(){this._context.beginPath()},bezierCurveTo:function(){var a=arguments;this._context.bezierCurveTo(a[0],a[1],a[2],a[3],a[4],a[5])},clearRect:function(){var a=arguments;this._context.clearRect(a[0],a[1],a[2],a[3])},clip:function(){this._context.clip()},closePath:function(){this._context.closePath()},createImageData:function(){var a=arguments;return 2===a.length?this._context.createImageData(a[0],a[1]):1===a.length?this._context.createImageData(a[0]):void 0},createLinearGradient:function(){var a=arguments;return this._context.createLinearGradient(a[0],a[1],a[2],a[3])},createPattern:function(){var a=arguments;return this._context.createPattern(a[0],a[1])},createRadialGradient:function(){var a=arguments;return this._context.createRadialGradient(a[0],a[1],a[2],a[3],a[4],a[5])},drawImage:function(){var a=arguments,b=this._context;3===a.length?b.drawImage(a[0],a[1],a[2]):5===a.length?b.drawImage(a[0],a[1],a[2],a[3],a[4]):9===a.length&&b.drawImage(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8])},fill:function(){this._context.fill()},fillText:function(){var a=arguments;this._context.fillText(a[0],a[1],a[2])},getImageData:function(){var a=arguments;return this._context.getImageData(a[0],a[1],a[2],a[3])},lineTo:function(){var a=arguments;this._context.lineTo(a[0],a[1])},moveTo:function(){var a=arguments;this._context.moveTo(a[0],a[1])},rect:function(){var a=arguments;this._context.rect(a[0],a[1],a[2],a[3])},putImageData:function(){var a=arguments;this._context.putImageData(a[0],a[1],a[2])},quadraticCurveTo:function(){var a=arguments;this._context.quadraticCurveTo(a[0],a[1],a[2],a[3])},restore:function(){this._context.restore()},rotate:function(){var a=arguments;this._context.rotate(a[0])},save:function(){this._context.save()},scale:function(){var a=arguments;this._context.scale(a[0],a[1])},setLineDash:function(){var a=arguments,b=this._context;this._context.setLineDash?b.setLineDash(a[0]):"mozDash"in b?b.mozDash=a[0]:"webkitLineDash"in b&&(b.webkitLineDash=a[0])},setTransform:function(){var a=arguments;this._context.setTransform(a[0],a[1],a[2],a[3],a[4],a[5])},stroke:function(){this._context.stroke()},strokeText:function(){var a=arguments;this._context.strokeText(a[0],a[1],a[2])},transform:function(){var a=arguments;this._context.transform(a[0],a[1],a[2],a[3],a[4],a[5])},translate:function(){var a=arguments;this._context.translate(a[0],a[1])},_enableTrace:function(){var a,b,c=this,d=i.length,e=Kinetic.Util._simplifyArray,f=this.setAttr,g=function(a){var d,f=c[a];c[a]=function(){return b=e(Array.prototype.slice.call(arguments,0)),d=f.apply(c,arguments),c._trace({method:a,args:b}),d}};for(a=0;d>a;a++)g(i[a]);c.setAttr=function(){f.apply(c,arguments),c._trace({property:arguments[0],val:arguments[1]})}}},Kinetic.SceneContext=function(a){Kinetic.Context.call(this,a)},Kinetic.SceneContext.prototype={_fillColor:function(a){var b=a.fill()||Kinetic.Util._getRGBAString({red:a.fillRed(),green:a.fillGreen(),blue:a.fillBlue(),alpha:a.fillAlpha()});this.setAttr("fillStyle",b),a._fillFunc(this)},_fillPattern:function(a){var b=a.getFillPatternImage(),c=a.getFillPatternX(),d=a.getFillPatternY(),e=a.getFillPatternScale(),f=Kinetic.getAngle(a.getFillPatternRotation()),g=a.getFillPatternOffset(),h=a.getFillPatternRepeat();(c||d)&&this.translate(c||0,d||0),f&&this.rotate(f),e&&this.scale(e.x,e.y),g&&this.translate(-1*g.x,-1*g.y),this.setAttr("fillStyle",this.createPattern(b,h||"repeat")),this.fill()},_fillLinearGradient:function(a){var b=a.getFillLinearGradientStartPoint(),c=a.getFillLinearGradientEndPoint(),d=a.getFillLinearGradientColorStops(),e=this.createLinearGradient(b.x,b.y,c.x,c.y);if(d){for(var f=0;f<d.length;f+=2)e.addColorStop(d[f],d[f+1]);this.setAttr("fillStyle",e),this.fill()}},_fillRadialGradient:function(a){for(var b=a.getFillRadialGradientStartPoint(),c=a.getFillRadialGradientEndPoint(),d=a.getFillRadialGradientStartRadius(),e=a.getFillRadialGradientEndRadius(),f=a.getFillRadialGradientColorStops(),g=this.createRadialGradient(b.x,b.y,d,c.x,c.y,e),h=0;h<f.length;h+=2)g.addColorStop(f[h],f[h+1]);this.setAttr("fillStyle",g),this.fill()},_fill:function(a){var b=a.fill()||a.fillRed()||a.fillGreen()||a.fillBlue(),c=a.getFillPatternImage(),d=a.getFillLinearGradientColorStops(),e=a.getFillRadialGradientColorStops(),f=a.getFillPriority();b&&"color"===f?this._fillColor(a):c&&"pattern"===f?this._fillPattern(a):d&&"linear-gradient"===f?this._fillLinearGradient(a):e&&"radial-gradient"===f?this._fillRadialGradient(a):b?this._fillColor(a):c?this._fillPattern(a):d?this._fillLinearGradient(a):e&&this._fillRadialGradient(a)},_stroke:function(a){var b=a.dash(),c=a.getStrokeScaleEnabled();a.hasStroke()&&(c||(this.save(),this.setTransform(1,0,0,1,0,0)),this._applyLineCap(a),b&&a.dashEnabled()&&this.setLineDash(b),this.setAttr("lineWidth",a.strokeWidth()),this.setAttr("strokeStyle",a.stroke()||Kinetic.Util._getRGBAString({red:a.strokeRed(),green:a.strokeGreen(),blue:a.strokeBlue(),alpha:a.strokeAlpha()})),a._strokeFunc(this),c||this.restore())},_applyShadow:function(a){var b=Kinetic.Util,c=a.getAbsoluteOpacity(),d=b.get(a.getShadowColor(),"black"),e=b.get(a.getShadowBlur(),5),f=b.get(a.getShadowOpacity(),1),g=b.get(a.getShadowOffset(),{x:0,y:0});f&&this.setAttr("globalAlpha",f*c),this.setAttr("shadowColor",d),this.setAttr("shadowBlur",e),this.setAttr("shadowOffsetX",g.x),this.setAttr("shadowOffsetY",g.y)}},Kinetic.Util.extend(Kinetic.SceneContext,Kinetic.Context),Kinetic.HitContext=function(a){Kinetic.Context.call(this,a)},Kinetic.HitContext.prototype={_fill:function(a){this.save(),this.setAttr("fillStyle",a.colorKey),a._fillFuncHit(this),this.restore()},_stroke:function(a){a.hasStroke()&&(this._applyLineCap(a),this.setAttr("lineWidth",a.strokeWidth()),this.setAttr("strokeStyle",a.colorKey),a._strokeFuncHit(this))}},Kinetic.Util.extend(Kinetic.HitContext,Kinetic.Context)}(),function(){var a="get",b="set";Kinetic.Factory={addGetterSetter:function(a,b,c,d,e){this.addGetter(a,b,c),this.addSetter(a,b,d,e),this.addOverloadedGetterSetter(a,b)},addGetter:function(b,c,d){var e=a+Kinetic.Util._capitalize(c);b.prototype[e]=function(){var a=this.attrs[c];return void 0===a?d:a}},addSetter:function(a,c,d,e){var f=b+Kinetic.Util._capitalize(c);a.prototype[f]=function(a){return d&&(a=d.call(this,a)),this._setAttr(c,a),e&&e.call(this),this}},addComponentsGetterSetter:function(c,d,e,f,g){var h,i,j=e.length,k=Kinetic.Util._capitalize,l=a+k(d),m=b+k(d);c.prototype[l]=function(){var a={};for(h=0;j>h;h++)i=e[h],a[i]=this.getAttr(d+k(i));return a},c.prototype[m]=function(a){var b,c=this.attrs[d];f&&(a=f.call(this,a));for(b in a)this._setAttr(d+k(b),a[b]);return this._fireChangeEvent(d,c,a),g&&g.call(this),this},this.addOverloadedGetterSetter(c,d)},addOverloadedGetterSetter:function(c,d){var e=Kinetic.Util._capitalize(d),f=b+e,g=a+e;c.prototype[d]=function(){return arguments.length?(this[f](arguments[0]),this):this[g]()}},backCompat:function(a,b){var c;for(c in b)a.prototype[c]=a.prototype[b[c]]},afterSetFilter:function(){this._filterUpToDate=!1}},Kinetic.Validators={RGBComponent:function(a){return a>255?255:0>a?0:Math.round(a)},alphaComponent:function(a){return a>1?1:1e-4>a?1e-4:a}}}(),function(){var a="absoluteOpacity",b="absoluteTransform",c="Change",d="children",e=".",f="",g="get",h="id",i="kinetic",j="listening",k="mouseenter",l="mouseleave",m="name",n="set",o="Shape",p=" ",q="stage",r="transform",s="Stage",t="visible",u=["id"],v=["xChange.kinetic","yChange.kinetic","scaleXChange.kinetic","scaleYChange.kinetic","skewXChange.kinetic","skewYChange.kinetic","rotationChange.kinetic","offsetXChange.kinetic","offsetYChange.kinetic","transformsEnabledChange.kinetic"].join(p);Kinetic.Util.addMethods(Kinetic.Node,{_init:function(c){var d=this;this._id=Kinetic.idCounter++,this.eventListeners={},this.attrs={},this._cache={},this._filterUpToDate=!1,this.setAttrs(c),this.on(v,function(){this._clearCache(r),d._clearSelfAndDescendantCache(b)}),this.on("visibleChange.kinetic",function(){d._clearSelfAndDescendantCache(t)}),this.on("listeningChange.kinetic",function(){d._clearSelfAndDescendantCache(j)}),this.on("opacityChange.kinetic",function(){d._clearSelfAndDescendantCache(a)})},_clearCache:function(a){a?delete this._cache[a]:this._cache={}},_getCache:function(a,b){var c=this._cache[a];return void 0===c&&(this._cache[a]=b.call(this)),this._cache[a]},_clearSelfAndDescendantCache:function(a){this._clearCache(a),this.children&&this.getChildren().each(function(b){b._clearSelfAndDescendantCache(a)})},clearCache:function(){return delete this._cache.canvas,this._filterUpToDate=!1,this},cache:function(a){var b=a||{},c=b.x||0,d=b.y||0,e=b.width||this.width(),f=b.height||this.height(),g=b.drawBorder||!1;if(0===e||0===f)return void Kinetic.Util.warn("Width or height of caching configuration equals 0. Cache is ignored.");var h=new Kinetic.SceneCanvas({pixelRatio:1,width:e,height:f}),i=new Kinetic.SceneCanvas({pixelRatio:1,width:e,height:f}),j=new Kinetic.HitCanvas({width:e,height:f}),k=h.getContext(),l=j.getContext();return j.isCache=!0,this.clearCache(),k.save(),l.save(),g&&(k.save(),k.beginPath(),k.rect(0,0,e,f),k.closePath(),k.setAttr("strokeStyle","red"),k.setAttr("lineWidth",5),k.stroke(),k.restore()),k.translate(-1*c,-1*d),l.translate(-1*c,-1*d),"Shape"===this.nodeType&&(k.translate(-1*this.x(),-1*this.y()),l.translate(-1*this.x(),-1*this.y())),this.drawScene(h,this),this.drawHit(j,this),k.restore(),l.restore(),this._cache.canvas={scene:h,filter:i,hit:j},this},_drawCachedSceneCanvas:function(a){a.save(),this.getLayer()._applyTransform(this,a),a._applyOpacity(this),a.drawImage(this._getCachedSceneCanvas()._canvas,0,0),a.restore()},_getCachedSceneCanvas:function(){var a,b,c,d,e=this.filters(),f=this._cache.canvas,g=f.scene,h=f.filter,i=h.getContext();if(e){if(!this._filterUpToDate){try{for(a=e.length,i.clear(),i.drawImage(g._canvas,0,0),b=i.getImageData(0,0,h.getWidth(),h.getHeight()),c=0;a>c;c++)d=e[c],d.call(this,b),i.putImageData(b,0,0)}catch(j){Kinetic.Util.warn("Unable to apply filter. "+j.message)}this._filterUpToDate=!0}return h}return g},_drawCachedHitCanvas:function(a){var b=this._cache.canvas,c=b.hit;a.save(),this.getLayer()._applyTransform(this,a),a.drawImage(c._canvas,0,0),a.restore()},on:function(a,b){var c,d,g,h,i,j=a.split(p),k=j.length;for(c=0;k>c;c++)d=j[c],g=d.split(e),h=g[0],i=g[1]||f,this.eventListeners[h]||(this.eventListeners[h]=[]),this.eventListeners[h].push({name:i,handler:b});return this},off:function(a){var b,c,d,f,g,h,i=(a||"").split(p),j=i.length;if(!a)for(c in this.eventListeners)this._off(c);for(b=0;j>b;b++)if(d=i[b],f=d.split(e),g=f[0],h=f[1],g)this.eventListeners[g]&&this._off(g,h);else for(c in this.eventListeners)this._off(c,h);return this},dispatchEvent:function(a){var b={target:this,type:a.type,evt:a};this.fire(a.type,b)},addEventListener:function(a,b){this.on(a,function(a){b.call(this,a.evt)})},removeEventListener:function(a){this.off(a)},remove:function(){var c=this.getParent();return c&&c.children&&(c.children.splice(this.index,1),c._setChildrenIndices(),delete this.parent),this._clearSelfAndDescendantCache(q),this._clearSelfAndDescendantCache(b),this._clearSelfAndDescendantCache(t),this._clearSelfAndDescendantCache(j),this._clearSelfAndDescendantCache(a),this},destroy:function(){Kinetic._removeId(this.getId()),Kinetic._removeName(this.getName(),this._id),this.remove()},getAttr:function(a){var b=g+Kinetic.Util._capitalize(a);return Kinetic.Util._isFunction(this[b])?this[b]():this.attrs[a]},getAncestors:function(){for(var a=this.getParent(),b=new Kinetic.Collection;a;)b.push(a),a=a.getParent();return b},getAttrs:function(){return this.attrs||{}},setAttrs:function(a){var b,c;if(a)for(b in a)b===d||a[b]instanceof Kinetic.Node||(c=n+Kinetic.Util._capitalize(b),Kinetic.Util._isFunction(this[c])?this[c](a[b]):this._setAttr(b,a[b]));return this},isListening:function(){return this._getCache(j,this._isListening)},_isListening:function(){var a=this.getListening(),b=this.getParent();return"inherit"===a?b?b.isListening():!0:a},isVisible:function(){return this._getCache(t,this._isVisible)},_isVisible:function(){var a=this.getVisible(),b=this.getParent();return"inherit"===a?b?b.isVisible():!0:a},shouldDrawHit:function(a){var b=this.getLayer();return a&&a.isCache||b&&b.hitGraphEnabled()&&this.isListening()&&this.isVisible()},show:function(){return this.setVisible(!0),this},hide:function(){return this.setVisible(!1),this},getZIndex:function(){return this.index||0},getAbsoluteZIndex:function(){function a(i){for(b=[],c=i.length,d=0;c>d;d++)e=i[d],h++,e.nodeType!==o&&(b=b.concat(e.getChildren().toArray())),e._id===g._id&&(d=c);b.length>0&&b[0].getDepth()<=f&&a(b)}var b,c,d,e,f=this.getDepth(),g=this,h=0;return g.nodeType!==s&&a(g.getStage().getChildren()),h},getDepth:function(){for(var a=0,b=this.parent;b;)a++,b=b.parent;return a},setPosition:function(a){return this.setX(a.x),this.setY(a.y),this},getPosition:function(){return{x:this.getX(),y:this.getY()}},getAbsolutePosition:function(){var a=this.getAbsoluteTransform().getMatrix(),b=new Kinetic.Transform,c=this.offset();return b.m=a.slice(),b.translate(c.x,c.y),b.getTranslation()},setAbsolutePosition:function(a){var b,c=this._clearTransform();return this.attrs.x=c.x,this.attrs.y=c.y,delete c.x,delete c.y,b=this.getAbsoluteTransform(),b.invert(),b.translate(a.x,a.y),a={x:this.attrs.x+b.getTranslation().x,y:this.attrs.y+b.getTranslation().y},this.setPosition({x:a.x,y:a.y}),this._setTransform(c),this},_setTransform:function(a){var c;for(c in a)this.attrs[c]=a[c];this._clearCache(r),this._clearSelfAndDescendantCache(b)},_clearTransform:function(){var a={x:this.getX(),y:this.getY(),rotation:this.getRotation(),scaleX:this.getScaleX(),scaleY:this.getScaleY(),offsetX:this.getOffsetX(),offsetY:this.getOffsetY(),skewX:this.getSkewX(),skewY:this.getSkewY()};return this.attrs.x=0,this.attrs.y=0,this.attrs.rotation=0,this.attrs.scaleX=1,this.attrs.scaleY=1,this.attrs.offsetX=0,this.attrs.offsetY=0,this.attrs.skewX=0,this.attrs.skewY=0,this._clearCache(r),this._clearSelfAndDescendantCache(b),a},move:function(a){var b=a.x,c=a.y,d=this.getX(),e=this.getY();return void 0!==b&&(d+=b),void 0!==c&&(e+=c),this.setPosition({x:d,y:e}),this},_eachAncestorReverse:function(a,b){var c,d,e=[],f=this.getParent();if(b&&b._id===this._id)return a(this),!0;for(e.unshift(this);f&&(!b||f._id!==b._id);)e.unshift(f),f=f.parent;for(c=e.length,d=0;c>d;d++)a(e[d])},rotate:function(a){return this.setRotation(this.getRotation()+a),this},moveToTop:function(){if(!this.parent)return void Kinetic.Util.warn("Node has no parent. moveToTop function is ignored.");var a=this.index;return this.parent.children.splice(a,1),this.parent.children.push(this),this.parent._setChildrenIndices(),!0},moveUp:function(){if(!this.parent)return void Kinetic.Util.warn("Node has no parent. moveUp function is ignored.");var a=this.index,b=this.parent.getChildren().length;return b-1>a?(this.parent.children.splice(a,1),this.parent.children.splice(a+1,0,this),this.parent._setChildrenIndices(),!0):!1},moveDown:function(){if(!this.parent)return void Kinetic.Util.warn("Node has no parent. moveDown function is ignored.");var a=this.index;return a>0?(this.parent.children.splice(a,1),this.parent.children.splice(a-1,0,this),this.parent._setChildrenIndices(),!0):!1},moveToBottom:function(){if(!this.parent)return void Kinetic.Util.warn("Node has no parent. moveToBottom function is ignored.");var a=this.index;return a>0?(this.parent.children.splice(a,1),this.parent.children.unshift(this),this.parent._setChildrenIndices(),!0):!1},setZIndex:function(a){if(!this.parent)return void Kinetic.Util.warn("Node has no parent. zIndex parameter is ignored.");var b=this.index;return this.parent.children.splice(b,1),this.parent.children.splice(a,0,this),this.parent._setChildrenIndices(),this},getAbsoluteOpacity:function(){return this._getCache(a,this._getAbsoluteOpacity)},_getAbsoluteOpacity:function(){var a=this.getOpacity();return this.getParent()&&(a*=this.getParent().getAbsoluteOpacity()),a},moveTo:function(a){return this.getParent()!==a&&(this.remove(),a.add(this)),this},toObject:function(){var a,b,c,d,e=Kinetic.Util,f={},g=this.getAttrs();f.attrs={};for(a in g)b=g[a],e._isFunction(b)||e._isElement(b)||e._isObject(b)&&e._hasMethods(b)||(c=this[a],delete g[a],d=c?c.call(this):null,g[a]=b,d!==b&&(f.attrs[a]=b));return f.className=this.getClassName(),f},toJSON:function(){return JSON.stringify(this.toObject())},getParent:function(){return this.parent},getLayer:function(){var a=this.getParent();return a?a.getLayer():null},getStage:function(){return this._getCache(q,this._getStage)},_getStage:function(){var a=this.getParent();return a?a.getStage():void 0},fire:function(a,b,c){return c?this._fireAndBubble(a,b||{}):this._fire(a,b||{}),this},getAbsoluteTransform:function(a){return a?this._getAbsoluteTransform(a):this._getCache(b,this._getAbsoluteTransform)},_getAbsoluteTransform:function(a){var b,c,d=new Kinetic.Transform;return this._eachAncestorReverse(function(a){b=a.transformsEnabled(),c=a.getTransform(),"all"===b?d.multiply(c):"position"===b&&d.translate(a.x(),a.y())},a),d},getTransform:function(){return this._getCache(r,this._getTransform)},_getTransform:function(){var a=new Kinetic.Transform,b=this.getX(),c=this.getY(),d=Kinetic.getAngle(this.getRotation()),e=this.getScaleX(),f=this.getScaleY(),g=this.getSkewX(),h=this.getSkewY(),i=this.getOffsetX(),j=this.getOffsetY();return(0!==b||0!==c)&&a.translate(b,c),0!==d&&a.rotate(d),(0!==g||0!==h)&&a.skew(g,h),(1!==e||1!==f)&&a.scale(e,f),(0!==i||0!==j)&&a.translate(-1*i,-1*j),a},clone:function(a){var b,c,d,e,f,g=this.getClassName(),h=Kinetic.Util.cloneObject(this.attrs);for(var j in u){var k=u[j];delete h[k]}for(b in a)h[b]=a[b];var l=new Kinetic[g](h);for(b in this.eventListeners)for(c=this.eventListeners[b],d=c.length,e=0;d>e;e++)f=c[e],f.name.indexOf(i)<0&&(l.eventListeners[b]||(l.eventListeners[b]=[]),l.eventListeners[b].push(f));return l},toDataURL:function(a){a=a||{};var b=a.mimeType||null,c=a.quality||null,d=this.getStage(),e=a.x||0,f=a.y||0,g=new Kinetic.SceneCanvas({width:a.width||this.getWidth()||(d?d.getWidth():0),height:a.height||this.getHeight()||(d?d.getHeight():0),pixelRatio:1}),h=g.getContext();return h.save(),(e||f)&&h.translate(-1*e,-1*f),this.drawScene(g),h.restore(),g.toDataURL(b,c)},toImage:function(a){Kinetic.Util._getImage(this.toDataURL(a),function(b){a.callback(b)})},setSize:function(a){return this.setWidth(a.width),this.setHeight(a.height),this},getSize:function(){return{width:this.getWidth(),height:this.getHeight()}},getWidth:function(){return this.attrs.width||0},getHeight:function(){return this.attrs.height||0},getClassName:function(){return this.className||this.nodeType},getType:function(){return this.nodeType},getDragDistance:function(){return void 0!==this.attrs.dragDistance?this.attrs.dragDistance:this.parent?this.parent.getDragDistance():Kinetic.dragDistance
},_get:function(a){return this.className===a||this.nodeType===a?[this]:[]},_off:function(a,b){var c,d,e=this.eventListeners[a];for(c=0;c<e.length;c++)if(d=e[c].name,!("kinetic"===d&&"kinetic"!==b||b&&d!==b)){if(e.splice(c,1),0===e.length){delete this.eventListeners[a];break}c--}},_fireChangeEvent:function(a,b,d){this._fire(a+c,{oldVal:b,newVal:d})},setId:function(a){var b=this.getId();return Kinetic._removeId(b),Kinetic._addId(this,a),this._setAttr(h,a),this},setName:function(a){var b=this.getName();return Kinetic._removeName(b,this._id),Kinetic._addName(this,a),this._setAttr(m,a),this},setAttr:function(a,b){var c=n+Kinetic.Util._capitalize(a),d=this[c];return Kinetic.Util._isFunction(d)?d.call(this,b):this._setAttr(a,b),this},_setAttr:function(a,b){var c;void 0!==b&&(c=this.attrs[a],this.attrs[a]=b,this._fireChangeEvent(a,c,b))},_setComponentAttr:function(a,b,c){var d;void 0!==c&&(d=this.attrs[a],d||(this.attrs[a]=this.getAttr(a)),this.attrs[a][b]=c,this._fireChangeEvent(a,d,c))},_fireAndBubble:function(a,b,c){var d=!0;if(b&&this.nodeType===o&&(b.target=this),a===k&&c&&(this._id===c._id||this.isAncestorOf&&this.isAncestorOf(c))?d=!1:a===l&&c&&(this._id===c._id||this.isAncestorOf&&this.isAncestorOf(c))&&(d=!1),d){this._fire(a,b);var e=(a===k||a===l)&&(c&&c.isAncestorOf&&c.isAncestorOf(this)||!(!c||!c.isAncestorOf));b&&!b.cancelBubble&&this.parent&&this.parent.isListening()&&!e&&(c&&c.parent?this._fireAndBubble.call(this.parent,a,b,c.parent):this._fireAndBubble.call(this.parent,a,b))}},_fire:function(a,b){var c,d=this.eventListeners[a];if(b.type=a,d)for(c=0;c<d.length;c++)d[c].handler.call(this,b)},draw:function(){return this.drawScene(),this.drawHit(),this}}),Kinetic.Node.create=function(a,b){return this._createNode(JSON.parse(a),b)},Kinetic.Node._createNode=function(a,b){var c,d,e,f=Kinetic.Node.prototype.getClassName.call(a),g=a.children;if(b&&(a.attrs.container=b),c=new Kinetic[f](a.attrs),g)for(d=g.length,e=0;d>e;e++)c.add(this._createNode(g[e]));return c},Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"position"),Kinetic.Factory.addGetterSetter(Kinetic.Node,"x",0),Kinetic.Factory.addGetterSetter(Kinetic.Node,"y",0),Kinetic.Factory.addGetterSetter(Kinetic.Node,"opacity",1),Kinetic.Factory.addGetter(Kinetic.Node,"name"),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"name"),Kinetic.Factory.addGetter(Kinetic.Node,"id"),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"id"),Kinetic.Factory.addGetterSetter(Kinetic.Node,"rotation",0),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node,"scale",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Node,"scaleX",1),Kinetic.Factory.addGetterSetter(Kinetic.Node,"scaleY",1),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node,"skew",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Node,"skewX",0),Kinetic.Factory.addGetterSetter(Kinetic.Node,"skewY",0),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Node,"offset",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Node,"offsetX",0),Kinetic.Factory.addGetterSetter(Kinetic.Node,"offsetY",0),Kinetic.Factory.addSetter(Kinetic.Node,"dragDistance"),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"dragDistance"),Kinetic.Factory.addSetter(Kinetic.Node,"width",0),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"width"),Kinetic.Factory.addSetter(Kinetic.Node,"height",0),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"height"),Kinetic.Factory.addGetterSetter(Kinetic.Node,"listening","inherit"),Kinetic.Factory.addGetterSetter(Kinetic.Node,"filters",void 0,function(a){return this._filterUpToDate=!1,a}),Kinetic.Factory.addGetterSetter(Kinetic.Node,"visible","inherit"),Kinetic.Factory.addGetterSetter(Kinetic.Node,"transformsEnabled","all"),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"size"),Kinetic.Factory.backCompat(Kinetic.Node,{rotateDeg:"rotate",setRotationDeg:"setRotation",getRotationDeg:"getRotation"}),Kinetic.Collection.mapMethods(Kinetic.Node)}(),function(){Kinetic.Filters.Grayscale=function(a){var b,c,d=a.data,e=d.length;for(b=0;e>b;b+=4)c=.34*d[b]+.5*d[b+1]+.16*d[b+2],d[b]=c,d[b+1]=c,d[b+2]=c}}(),function(){Kinetic.Filters.Brighten=function(a){var b,c=255*this.brightness(),d=a.data,e=d.length;for(b=0;e>b;b+=4)d[b]+=c,d[b+1]+=c,d[b+2]+=c},Kinetic.Factory.addGetterSetter(Kinetic.Node,"brightness",0,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.Invert=function(a){var b,c=a.data,d=c.length;for(b=0;d>b;b+=4)c[b]=255-c[b],c[b+1]=255-c[b+1],c[b+2]=255-c[b+2]}}(),function(){function a(){this.r=0,this.g=0,this.b=0,this.a=0,this.next=null}function b(b,e){var f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D=b.data,E=b.width,F=b.height,G=e+e+1,H=E-1,I=F-1,J=e+1,K=J*(J+1)/2,L=new a,M=null,N=L,O=null,P=null,Q=c[e],R=d[e];for(h=1;G>h;h++)N=N.next=new a,h==J&&(M=N);for(N.next=L,l=k=0,g=0;F>g;g++){for(u=v=w=x=m=n=o=p=0,q=J*(y=D[k]),r=J*(z=D[k+1]),s=J*(A=D[k+2]),t=J*(B=D[k+3]),m+=K*y,n+=K*z,o+=K*A,p+=K*B,N=L,h=0;J>h;h++)N.r=y,N.g=z,N.b=A,N.a=B,N=N.next;for(h=1;J>h;h++)i=k+((h>H?H:h)<<2),m+=(N.r=y=D[i])*(C=J-h),n+=(N.g=z=D[i+1])*C,o+=(N.b=A=D[i+2])*C,p+=(N.a=B=D[i+3])*C,u+=y,v+=z,w+=A,x+=B,N=N.next;for(O=L,P=M,f=0;E>f;f++)D[k+3]=B=p*Q>>R,0!==B?(B=255/B,D[k]=(m*Q>>R)*B,D[k+1]=(n*Q>>R)*B,D[k+2]=(o*Q>>R)*B):D[k]=D[k+1]=D[k+2]=0,m-=q,n-=r,o-=s,p-=t,q-=O.r,r-=O.g,s-=O.b,t-=O.a,i=l+((i=f+e+1)<H?i:H)<<2,u+=O.r=D[i],v+=O.g=D[i+1],w+=O.b=D[i+2],x+=O.a=D[i+3],m+=u,n+=v,o+=w,p+=x,O=O.next,q+=y=P.r,r+=z=P.g,s+=A=P.b,t+=B=P.a,u-=y,v-=z,w-=A,x-=B,P=P.next,k+=4;l+=E}for(f=0;E>f;f++){for(v=w=x=u=n=o=p=m=0,k=f<<2,q=J*(y=D[k]),r=J*(z=D[k+1]),s=J*(A=D[k+2]),t=J*(B=D[k+3]),m+=K*y,n+=K*z,o+=K*A,p+=K*B,N=L,h=0;J>h;h++)N.r=y,N.g=z,N.b=A,N.a=B,N=N.next;for(j=E,h=1;e>=h;h++)k=j+f<<2,m+=(N.r=y=D[k])*(C=J-h),n+=(N.g=z=D[k+1])*C,o+=(N.b=A=D[k+2])*C,p+=(N.a=B=D[k+3])*C,u+=y,v+=z,w+=A,x+=B,N=N.next,I>h&&(j+=E);for(k=f,O=L,P=M,g=0;F>g;g++)i=k<<2,D[i+3]=B=p*Q>>R,B>0?(B=255/B,D[i]=(m*Q>>R)*B,D[i+1]=(n*Q>>R)*B,D[i+2]=(o*Q>>R)*B):D[i]=D[i+1]=D[i+2]=0,m-=q,n-=r,o-=s,p-=t,q-=O.r,r-=O.g,s-=O.b,t-=O.a,i=f+((i=g+J)<I?i:I)*E<<2,m+=u+=O.r=D[i],n+=v+=O.g=D[i+1],o+=w+=O.b=D[i+2],p+=x+=O.a=D[i+3],O=O.next,q+=y=P.r,r+=z=P.g,s+=A=P.b,t+=B=P.a,u-=y,v-=z,w-=A,x-=B,P=P.next,k+=E}}var c=[512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,289,287,285,282,280,278,275,273,271,269,267,265,263,261,259],d=[9,11,12,13,13,14,14,15,15,15,15,16,16,16,16,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24];Kinetic.Filters.Blur=function(a){var c=Math.round(this.blurRadius());c>0&&b(a,c)},Kinetic.Factory.addGetterSetter(Kinetic.Node,"blurRadius",0,null,Kinetic.Factory.afterSetFilter)}(),function(){function a(a,b,c){var d=4*(c*a.width+b),e=[];return e.push(a.data[d++],a.data[d++],a.data[d++],a.data[d++]),e}function b(a,b){return Math.sqrt(Math.pow(a[0]-b[0],2)+Math.pow(a[1]-b[1],2)+Math.pow(a[2]-b[2],2))}function c(a){for(var b=[0,0,0],c=0;c<a.length;c++)b[0]+=a[c][0],b[1]+=a[c][1],b[2]+=a[c][2];return b[0]/=a.length,b[1]/=a.length,b[2]/=a.length,b}function d(d,e){var f=a(d,0,0),g=a(d,d.width-1,0),h=a(d,0,d.height-1),i=a(d,d.width-1,d.height-1),j=e||10;if(b(f,g)<j&&b(g,i)<j&&b(i,h)<j&&b(h,f)<j){for(var k=c([g,f,i,h]),l=[],m=0;m<d.width*d.height;m++){var n=b(k,[d.data[4*m],d.data[4*m+1],d.data[4*m+2]]);l[m]=j>n?0:255}return l}}function e(a,b){for(var c=0;c<a.width*a.height;c++)a.data[4*c+3]=b[c]}function f(a,b,c){for(var d=[1,1,1,1,0,1,1,1,1],e=Math.round(Math.sqrt(d.length)),f=Math.floor(e/2),g=[],h=0;c>h;h++)for(var i=0;b>i;i++){for(var j=h*b+i,k=0,l=0;e>l;l++)for(var m=0;e>m;m++){var n=h+l-f,o=i+m-f;if(n>=0&&c>n&&o>=0&&b>o){var p=n*b+o,q=d[l*e+m];k+=a[p]*q}}g[j]=2040===k?255:0}return g}function g(a,b,c){for(var d=[1,1,1,1,1,1,1,1,1],e=Math.round(Math.sqrt(d.length)),f=Math.floor(e/2),g=[],h=0;c>h;h++)for(var i=0;b>i;i++){for(var j=h*b+i,k=0,l=0;e>l;l++)for(var m=0;e>m;m++){var n=h+l-f,o=i+m-f;if(n>=0&&c>n&&o>=0&&b>o){var p=n*b+o,q=d[l*e+m];k+=a[p]*q}}g[j]=k>=1020?255:0}return g}function h(a,b,c){for(var d=[1/9,1/9,1/9,1/9,1/9,1/9,1/9,1/9,1/9],e=Math.round(Math.sqrt(d.length)),f=Math.floor(e/2),g=[],h=0;c>h;h++)for(var i=0;b>i;i++){for(var j=h*b+i,k=0,l=0;e>l;l++)for(var m=0;e>m;m++){var n=h+l-f,o=i+m-f;if(n>=0&&c>n&&o>=0&&b>o){var p=n*b+o,q=d[l*e+m];k+=a[p]*q}}g[j]=k}return g}Kinetic.Filters.Mask=function(a){var b=this.threshold(),c=d(a,b);return c&&(c=f(c,a.width,a.height),c=g(c,a.width,a.height),c=h(c,a.width,a.height),e(a,c)),a},Kinetic.Factory.addGetterSetter(Kinetic.Node,"threshold",0,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.RGB=function(a){var b,c,d=a.data,e=d.length,f=this.red(),g=this.green(),h=this.blue();for(b=0;e>b;b+=4)c=(.34*d[b]+.5*d[b+1]+.16*d[b+2])/255,d[b]=c*f,d[b+1]=c*g,d[b+2]=c*h,d[b+3]=d[b+3]},Kinetic.Factory.addGetterSetter(Kinetic.Node,"red",0,function(a){return this._filterUpToDate=!1,a>255?255:0>a?0:Math.round(a)}),Kinetic.Factory.addGetterSetter(Kinetic.Node,"green",0,function(a){return this._filterUpToDate=!1,a>255?255:0>a?0:Math.round(a)}),Kinetic.Factory.addGetterSetter(Kinetic.Node,"blue",0,Kinetic.Validators.RGBComponent,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.HSV=function(a){var b,c,d,e,f,g=a.data,h=g.length,i=Math.pow(2,this.value()),j=Math.pow(2,this.saturation()),k=Math.abs(this.hue()+360)%360,l=i*j*Math.cos(k*Math.PI/180),m=i*j*Math.sin(k*Math.PI/180),n=.299*i+.701*l+.167*m,o=.587*i-.587*l+.33*m,p=.114*i-.114*l-.497*m,q=.299*i-.299*l-.328*m,r=.587*i+.413*l+.035*m,s=.114*i-.114*l+.293*m,t=.299*i-.3*l+1.25*m,u=.587*i-.586*l-1.05*m,v=.114*i+.886*l-.2*m;for(b=0;h>b;b+=4)c=g[b+0],d=g[b+1],e=g[b+2],f=g[b+3],g[b+0]=n*c+o*d+p*e,g[b+1]=q*c+r*d+s*e,g[b+2]=t*c+u*d+v*e,g[b+3]=f},Kinetic.Factory.addGetterSetter(Kinetic.Node,"hue",0,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"saturation",0,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"value",0,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Factory.addGetterSetter(Kinetic.Node,"hue",0,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"saturation",0,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"luminance",0,null,Kinetic.Factory.afterSetFilter),Kinetic.Filters.HSL=function(a){var b,c,d,e,f,g=a.data,h=g.length,i=1,j=Math.pow(2,this.saturation()),k=Math.abs(this.hue()+360)%360,l=127*this.luminance(),m=i*j*Math.cos(k*Math.PI/180),n=i*j*Math.sin(k*Math.PI/180),o=.299*i+.701*m+.167*n,p=.587*i-.587*m+.33*n,q=.114*i-.114*m-.497*n,r=.299*i-.299*m-.328*n,s=.587*i+.413*m+.035*n,t=.114*i-.114*m+.293*n,u=.299*i-.3*m+1.25*n,v=.587*i-.586*m-1.05*n,w=.114*i+.886*m-.2*n;for(b=0;h>b;b+=4)c=g[b+0],d=g[b+1],e=g[b+2],f=g[b+3],g[b+0]=o*c+p*d+q*e+l,g[b+1]=r*c+s*d+t*e+l,g[b+2]=u*c+v*d+w*e+l,g[b+3]=f}}(),function(){Kinetic.Filters.Emboss=function(a){var b=10*this.embossStrength(),c=255*this.embossWhiteLevel(),d=this.embossDirection(),e=this.embossBlend(),f=0,g=0,h=a.data,i=a.width,j=a.height,k=4*i,l=j;switch(d){case"top-left":f=-1,g=-1;break;case"top":f=-1,g=0;break;case"top-right":f=-1,g=1;break;case"right":f=0,g=1;break;case"bottom-right":f=1,g=1;break;case"bottom":f=1,g=0;break;case"bottom-left":f=1,g=-1;break;case"left":f=0,g=-1}do{var m=(l-1)*k,n=f;1>l+n&&(n=0),l+n>j&&(n=0);var o=(l-1+n)*i*4,p=i;do{var q=m+4*(p-1),r=g;1>p+r&&(r=0),p+r>i&&(r=0);var s=o+4*(p-1+r),t=h[q]-h[s],u=h[q+1]-h[s+1],v=h[q+2]-h[s+2],w=t,x=w>0?w:-w,y=u>0?u:-u,z=v>0?v:-v;if(y>x&&(w=u),z>x&&(w=v),w*=b,e){var A=h[q]+w,B=h[q+1]+w,C=h[q+2]+w;h[q]=A>255?255:0>A?0:A,h[q+1]=B>255?255:0>B?0:B,h[q+2]=C>255?255:0>C?0:C}else{var D=c-w;0>D?D=0:D>255&&(D=255),h[q]=h[q+1]=h[q+2]=D}}while(--p)}while(--l)},Kinetic.Factory.addGetterSetter(Kinetic.Node,"embossStrength",.5,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"embossWhiteLevel",.5,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"embossDirection","top-left",null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"embossBlend",!1,null,Kinetic.Factory.afterSetFilter)}(),function(){function a(a,b,c,d,e){var f,g=c-b,h=e-d;return 0===g?d+h/2:0===h?d:(f=(a-b)/g,f=h*f+d)}Kinetic.Filters.Enhance=function(b){var c,d,e,f,g=b.data,h=g.length,i=g[0],j=i,k=g[1],l=k,m=g[2],n=m,o=this.enhance();if(0!==o){for(f=0;h>f;f+=4)c=g[f+0],i>c?i=c:c>j&&(j=c),d=g[f+1],k>d?k=d:d>l&&(l=d),e=g[f+2],m>e?m=e:e>n&&(n=e);j===i&&(j=255,i=0),l===k&&(l=255,k=0),n===m&&(n=255,m=0);var p,q,r,s,t,u,v,w,x;for(o>0?(q=j+o*(255-j),r=i-o*(i-0),t=l+o*(255-l),u=k-o*(k-0),w=n+o*(255-n),x=m-o*(m-0)):(p=.5*(j+i),q=j+o*(j-p),r=i+o*(i-p),s=.5*(l+k),t=l+o*(l-s),u=k+o*(k-s),v=.5*(n+m),w=n+o*(n-v),x=m+o*(m-v)),f=0;h>f;f+=4)g[f+0]=a(g[f+0],i,j,r,q),g[f+1]=a(g[f+1],k,l,u,t),g[f+2]=a(g[f+2],m,n,x,w)}},Kinetic.Factory.addGetterSetter(Kinetic.Node,"enhance",0,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.Posterize=function(a){var b,c=Math.round(254*this.levels())+1,d=a.data,e=d.length,f=255/c;for(b=0;e>b;b+=1)d[b]=Math.floor(d[b]/f)*f},Kinetic.Factory.addGetterSetter(Kinetic.Node,"levels",.5,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.Noise=function(a){var b,c=255*this.noise(),d=a.data,e=d.length,f=c/2;for(b=0;e>b;b+=4)d[b+0]+=f-2*f*Math.random(),d[b+1]+=f-2*f*Math.random(),d[b+2]+=f-2*f*Math.random()},Kinetic.Factory.addGetterSetter(Kinetic.Node,"noise",.2,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.Pixelate=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p=Math.ceil(this.pixelSize()),q=a.width,r=a.height,s=Math.ceil(q/p),t=Math.ceil(r/p);for(a=a.data,m=0;s>m;m+=1)for(n=0;t>n;n+=1){for(e=0,f=0,g=0,h=0,i=m*p,j=i+p,k=n*p,l=k+p,o=0,b=i;j>b;b+=1)if(!(b>=q))for(c=k;l>c;c+=1)c>=r||(d=4*(q*c+b),e+=a[d+0],f+=a[d+1],g+=a[d+2],h+=a[d+3],o+=1);for(e/=o,f/=o,g/=o,b=i;j>b;b+=1)if(!(b>=q))for(c=k;l>c;c+=1)c>=r||(d=4*(q*c+b),a[d+0]=e,a[d+1]=f,a[d+2]=g,a[d+3]=h)}},Kinetic.Factory.addGetterSetter(Kinetic.Node,"pixelSize",8,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.Threshold=function(a){var b,c=255*this.threshold(),d=a.data,e=d.length;for(b=0;e>b;b+=1)d[b]=d[b]<c?0:255},Kinetic.Factory.addGetterSetter(Kinetic.Node,"threshold",.5,null,Kinetic.Factory.afterSetFilter)}(),function(){Kinetic.Filters.Sepia=function(a){var b,c,d,e,f,g,h,i,j,k=a.data,l=a.width,m=a.height,n=4*l;do{b=(m-1)*n,c=l;do d=b+4*(c-1),e=k[d],f=k[d+1],g=k[d+2],h=.393*e+.769*f+.189*g,i=.349*e+.686*f+.168*g,j=.272*e+.534*f+.131*g,k[d]=h>255?255:h,k[d+1]=i>255?255:i,k[d+2]=j>255?255:j,k[d+3]=k[d+3];while(--c)}while(--m)}}(),function(){Kinetic.Filters.Solarize=function(a){var b=a.data,c=a.width,d=a.height,e=4*c,f=d;do{var g=(f-1)*e,h=c;do{var i=g+4*(h-1),j=b[i],k=b[i+1],l=b[i+2];j>127&&(j=255-j),k>127&&(k=255-k),l>127&&(l=255-l),b[i]=j,b[i+1]=k,b[i+2]=l}while(--h)}while(--f)}}(),function(){var a=function(a,b,c){var d,e,f,g,h=a.data,i=b.data,j=a.width,k=a.height,l=c.polarCenterX||j/2,m=c.polarCenterY||k/2,n=0,o=0,p=0,q=0,r=Math.sqrt(l*l+m*m);e=j-l,f=k-m,g=Math.sqrt(e*e+f*f),r=g>r?g:r;var s,t,u,v,w=k,x=j,y=360/x*Math.PI/180;for(t=0;x>t;t+=1)for(u=Math.sin(t*y),v=Math.cos(t*y),s=0;w>s;s+=1)e=Math.floor(l+r*s/w*v),f=Math.floor(m+r*s/w*u),d=4*(f*j+e),n=h[d+0],o=h[d+1],p=h[d+2],q=h[d+3],d=4*(t+s*j),i[d+0]=n,i[d+1]=o,i[d+2]=p,i[d+3]=q},b=function(a,b,c){var d,e,f,g,h,i,j=a.data,k=b.data,l=a.width,m=a.height,n=c.polarCenterX||l/2,o=c.polarCenterY||m/2,p=0,q=0,r=0,s=0,t=Math.sqrt(n*n+o*o);e=l-n,f=m-o,i=Math.sqrt(e*e+f*f),t=i>t?i:t;var u,v,w,x,y=m,z=l,A=c.polarRotation||0;for(e=0;l>e;e+=1)for(f=0;m>f;f+=1)g=e-n,h=f-o,u=Math.sqrt(g*g+h*h)*y/t,v=(180*Math.atan2(h,g)/Math.PI+360+A)%360,v=v*z/360,w=Math.floor(v),x=Math.floor(u),d=4*(x*l+w),p=j[d+0],q=j[d+1],r=j[d+2],s=j[d+3],d=4*(f*l+e),k[d+0]=p,k[d+1]=q,k[d+2]=r,k[d+3]=s},c=Kinetic.Util.createCanvasElement();Kinetic.Filters.Kaleidoscope=function(d){var e,f,g,h,i,j,k,l,m,n,o=d.width,p=d.height,q=Math.round(this.kaleidoscopePower()),r=Math.round(this.kaleidoscopeAngle()),s=Math.floor(o*(r%360)/360);if(!(1>q)){c.width=o,c.height=p;var t=c.getContext("2d").getImageData(0,0,o,p);a(d,t,{polarCenterX:o/2,polarCenterY:p/2});for(var u=o/Math.pow(2,q);8>=u;)u=2*u,q-=1;u=Math.ceil(u);var v=u,w=0,x=v,y=1;for(s+u>o&&(w=v,x=0,y=-1),f=0;p>f;f+=1)for(e=w;e!==x;e+=y)g=Math.round(e+s)%o,m=4*(o*f+g),i=t.data[m+0],j=t.data[m+1],k=t.data[m+2],l=t.data[m+3],n=4*(o*f+e),t.data[n+0]=i,t.data[n+1]=j,t.data[n+2]=k,t.data[n+3]=l;for(f=0;p>f;f+=1)for(v=Math.floor(u),h=0;q>h;h+=1){for(e=0;v+1>e;e+=1)m=4*(o*f+e),i=t.data[m+0],j=t.data[m+1],k=t.data[m+2],l=t.data[m+3],n=4*(o*f+2*v-e-1),t.data[n+0]=i,t.data[n+1]=j,t.data[n+2]=k,t.data[n+3]=l;v*=2}b(t,d,{polarRotation:0})}},Kinetic.Factory.addGetterSetter(Kinetic.Node,"kaleidoscopePower",2,null,Kinetic.Factory.afterSetFilter),Kinetic.Factory.addGetterSetter(Kinetic.Node,"kaleidoscopeAngle",0,null,Kinetic.Factory.afterSetFilter)}(),function(){function a(a){setTimeout(a,1e3/60)}function b(){return e.apply(Kinetic.root,arguments)}var c=500,d=function(){return Kinetic.root.performance&&Kinetic.root.performance.now?function(){return Kinetic.root.performance.now()}:function(){return(new Date).getTime()}}(),e=function(){return Kinetic.root.requestAnimationFrame||Kinetic.root.webkitRequestAnimationFrame||Kinetic.root.mozRequestAnimationFrame||Kinetic.root.oRequestAnimationFrame||Kinetic.root.msRequestAnimationFrame||a}();Kinetic.Animation=function(a,b){var c=Kinetic.Animation;this.func=a,this.setLayers(b),this.id=c.animIdCounter++,this.frame={time:0,timeDiff:0,lastTime:d()}},Kinetic.Animation.prototype={setLayers:function(a){var b=[];b=a?a.length>0?a:[a]:[],this.layers=b},getLayers:function(){return this.layers},addLayer:function(a){var b,c,d=this.layers;if(d){for(b=d.length,c=0;b>c;c++)if(d[c]._id===a._id)return!1}else this.layers=[];return this.layers.push(a),!0},isRunning:function(){var a,b=Kinetic.Animation,c=b.animations,d=c.length;for(a=0;d>a;a++)if(c[a].id===this.id)return!0;return!1},start:function(){var a=Kinetic.Animation;this.stop(),this.frame.timeDiff=0,this.frame.lastTime=d(),a._addAnimation(this)},stop:function(){Kinetic.Animation._removeAnimation(this)},_updateFrameObject:function(a){this.frame.timeDiff=a-this.frame.lastTime,this.frame.lastTime=a,this.frame.time+=this.frame.timeDiff,this.frame.frameRate=1e3/this.frame.timeDiff}},Kinetic.Animation.animations=[],Kinetic.Animation.animIdCounter=0,Kinetic.Animation.animRunning=!1,Kinetic.Animation._addAnimation=function(a){this.animations.push(a),this._handleAnimation()},Kinetic.Animation._removeAnimation=function(a){var b,c=a.id,d=this.animations,e=d.length;for(b=0;e>b;b++)if(d[b].id===c){this.animations.splice(b,1);break}},Kinetic.Animation._runFrames=function(){var a,b,c,e,f,g,h,i,j,k={},l=this.animations;for(e=0;e<l.length;e++)if(a=l[e],b=a.layers,c=a.func,a._updateFrameObject(d()),g=b.length,j=c?c.call(a,a.frame)!==!1:!0)for(f=0;g>f;f++)h=b[f],void 0!==h._id&&(k[h._id]=h);for(i in k)k[i].draw()},Kinetic.Animation._animationLoop=function(){var a=Kinetic.Animation;a.animations.length?(b(a._animationLoop),a._runFrames()):a.animRunning=!1},Kinetic.Animation._handleAnimation=function(){var a=this;this.animRunning||(this.animRunning=!0,a._animationLoop())};var f=Kinetic.Node.prototype.moveTo;Kinetic.Node.prototype.moveTo=function(a){f.call(this,a)},Kinetic.BaseLayer.prototype.batchDraw=function(){var a=this,b=Kinetic.Animation;this.batchAnim||(this.batchAnim=new b(function(){a.lastBatchDrawTime&&d()-a.lastBatchDrawTime>c&&a.batchAnim.stop()},this)),this.lastBatchDrawTime=d(),this.batchAnim.isRunning()||(this.draw(),this.batchAnim.start())},Kinetic.Stage.prototype.batchDraw=function(){this.getChildren().each(function(a){a.batchDraw()})}}(this),function(){var a={node:1,duration:1,easing:1,onFinish:1,yoyo:1},b=1,c=2,d=3,e=0;Kinetic.Tween=function(b){var c,d,g=this,h=b.node,i=h._id,j=b.easing||Kinetic.Easings.Linear,k=!!b.yoyo;c="undefined"==typeof b.duration?1:0===b.duration?.001:b.duration,this.node=h,this._id=e++,this.anim=new Kinetic.Animation(function(){g.tween.onEnterFrame()},h.getLayer()||(h instanceof Kinetic.Stage?h.getLayers():null)),this.tween=new f(d,function(a){g._tweenFunc(a)},j,0,1,1e3*c,k),this._addListeners(),Kinetic.Tween.attrs[i]||(Kinetic.Tween.attrs[i]={}),Kinetic.Tween.attrs[i][this._id]||(Kinetic.Tween.attrs[i][this._id]={}),Kinetic.Tween.tweens[i]||(Kinetic.Tween.tweens[i]={});for(d in b)void 0===a[d]&&this._addAttr(d,b[d]);this.reset(),this.onFinish=b.onFinish,this.onReset=b.onReset},Kinetic.Tween.attrs={},Kinetic.Tween.tweens={},Kinetic.Tween.prototype={_addAttr:function(a,b){var c,d,e,f,g,h=this.node,i=h._id;if(e=Kinetic.Tween.tweens[i][a],e&&delete Kinetic.Tween.attrs[i][e][a],c=h.getAttr(a),Kinetic.Util._isArray(b))for(d=[],g=b.length,f=0;g>f;f++)d.push(b[f]-c[f]);else d=b-c;Kinetic.Tween.attrs[i][this._id][a]={start:c,diff:d},Kinetic.Tween.tweens[i][a]=this._id},_tweenFunc:function(a){var b,c,d,e,f,g,h,i=this.node,j=Kinetic.Tween.attrs[i._id][this._id];for(b in j){if(c=j[b],d=c.start,e=c.diff,Kinetic.Util._isArray(d))for(f=[],h=d.length,g=0;h>g;g++)f.push(d[g]+e[g]*a);else f=d+e*a;i.setAttr(b,f)}},_addListeners:function(){var a=this;this.tween.onPlay=function(){a.anim.start()},this.tween.onReverse=function(){a.anim.start()},this.tween.onPause=function(){a.anim.stop()},this.tween.onFinish=function(){a.onFinish&&a.onFinish()},this.tween.onReset=function(){a.onReset&&a.onReset()}},play:function(){return this.tween.play(),this},reverse:function(){return this.tween.reverse(),this},reset:function(){return this.tween.reset(),this},seek:function(a){return this.tween.seek(1e3*a),this},pause:function(){return this.tween.pause(),this},finish:function(){return this.tween.finish(),this},destroy:function(){var a,b=this.node._id,c=this._id,d=Kinetic.Tween.tweens[b];this.pause();for(a in d)delete Kinetic.Tween.tweens[b][a];delete Kinetic.Tween.attrs[b][c]}};var f=function(a,b,c,d,e,f,g){this.prop=a,this.propFunc=b,this.begin=d,this._pos=d,this.duration=f,this._change=0,this.prevPos=0,this.yoyo=g,this._time=0,this._position=0,this._startTime=0,this._finish=0,this.func=c,this._change=e-this.begin,this.pause()};f.prototype={fire:function(a){var b=this[a];b&&b()},setTime:function(a){a>this.duration?this.yoyo?(this._time=this.duration,this.reverse()):this.finish():0>a?this.yoyo?(this._time=0,this.play()):this.reset():(this._time=a,this.update())},getTime:function(){return this._time},setPosition:function(a){this.prevPos=this._pos,this.propFunc(a),this._pos=a},getPosition:function(a){return void 0===a&&(a=this._time),this.func(a,this.begin,this._change,this.duration)},play:function(){this.state=c,this._startTime=this.getTimer()-this._time,this.onEnterFrame(),this.fire("onPlay")},reverse:function(){this.state=d,this._time=this.duration-this._time,this._startTime=this.getTimer()-this._time,this.onEnterFrame(),this.fire("onReverse")},seek:function(a){this.pause(),this._time=a,this.update(),this.fire("onSeek")},reset:function(){this.pause(),this._time=0,this.update(),this.fire("onReset")},finish:function(){this.pause(),this._time=this.duration,this.update(),this.fire("onFinish")},update:function(){this.setPosition(this.getPosition(this._time))},onEnterFrame:function(){var a=this.getTimer()-this._startTime;this.state===c?this.setTime(a):this.state===d&&this.setTime(this.duration-a)},pause:function(){this.state=b,this.fire("onPause")},getTimer:function(){return(new Date).getTime()}},Kinetic.Easings={BackEaseIn:function(a,b,c,d){var e=1.70158;return c*(a/=d)*a*((e+1)*a-e)+b},BackEaseOut:function(a,b,c,d){var e=1.70158;return c*((a=a/d-1)*a*((e+1)*a+e)+1)+b},BackEaseInOut:function(a,b,c,d){var e=1.70158;return(a/=d/2)<1?c/2*a*a*(((e*=1.525)+1)*a-e)+b:c/2*((a-=2)*a*(((e*=1.525)+1)*a+e)+2)+b},ElasticEaseIn:function(a,b,c,d,e,f){var g=0;return 0===a?b:1==(a/=d)?b+c:(f||(f=.3*d),!e||e<Math.abs(c)?(e=c,g=f/4):g=f/(2*Math.PI)*Math.asin(c/e),-(e*Math.pow(2,10*(a-=1))*Math.sin(2*(a*d-g)*Math.PI/f))+b)},ElasticEaseOut:function(a,b,c,d,e,f){var g=0;return 0===a?b:1==(a/=d)?b+c:(f||(f=.3*d),!e||e<Math.abs(c)?(e=c,g=f/4):g=f/(2*Math.PI)*Math.asin(c/e),e*Math.pow(2,-10*a)*Math.sin(2*(a*d-g)*Math.PI/f)+c+b)},ElasticEaseInOut:function(a,b,c,d,e,f){var g=0;return 0===a?b:2==(a/=d/2)?b+c:(f||(f=.3*d*1.5),!e||e<Math.abs(c)?(e=c,g=f/4):g=f/(2*Math.PI)*Math.asin(c/e),1>a?-.5*e*Math.pow(2,10*(a-=1))*Math.sin(2*(a*d-g)*Math.PI/f)+b:e*Math.pow(2,-10*(a-=1))*Math.sin(2*(a*d-g)*Math.PI/f)*.5+c+b)},BounceEaseOut:function(a,b,c,d){return(a/=d)<1/2.75?7.5625*c*a*a+b:2/2.75>a?c*(7.5625*(a-=1.5/2.75)*a+.75)+b:2.5/2.75>a?c*(7.5625*(a-=2.25/2.75)*a+.9375)+b:c*(7.5625*(a-=2.625/2.75)*a+.984375)+b},BounceEaseIn:function(a,b,c,d){return c-Kinetic.Easings.BounceEaseOut(d-a,0,c,d)+b},BounceEaseInOut:function(a,b,c,d){return d/2>a?.5*Kinetic.Easings.BounceEaseIn(2*a,0,c,d)+b:.5*Kinetic.Easings.BounceEaseOut(2*a-d,0,c,d)+.5*c+b},EaseIn:function(a,b,c,d){return c*(a/=d)*a+b},EaseOut:function(a,b,c,d){return-c*(a/=d)*(a-2)+b},EaseInOut:function(a,b,c,d){return(a/=d/2)<1?c/2*a*a+b:-c/2*(--a*(a-2)-1)+b},StrongEaseIn:function(a,b,c,d){return c*(a/=d)*a*a*a*a+b},StrongEaseOut:function(a,b,c,d){return c*((a=a/d-1)*a*a*a*a+1)+b},StrongEaseInOut:function(a,b,c,d){return(a/=d/2)<1?c/2*a*a*a*a*a+b:c/2*((a-=2)*a*a*a*a+2)+b},Linear:function(a,b,c,d){return c*a/d+b}}}(),function(){Kinetic.DD={anim:new Kinetic.Animation(function(){var a=this.dirty;return this.dirty=!1,a}),isDragging:!1,justDragged:!1,offset:{x:0,y:0},node:null,_drag:function(a){var b=Kinetic.DD,c=b.node;if(c){if(!b.isDragging){var d=c.getStage().getPointerPosition(),e=c.dragDistance(),f=Math.max(Math.abs(d.x-b.startPointerPos.x),Math.abs(d.y-b.startPointerPos.y));if(e>f)return}c._setDragPosition(a),b.isDragging||(b.isDragging=!0,c.fire("dragstart",{type:"dragstart",target:c,evt:a},!0)),c.fire("dragmove",{type:"dragmove",target:c,evt:a},!0)}},_endDragBefore:function(a){var b,c,d=Kinetic.DD,e=d.node;e&&(b=e.nodeType,c=e.getLayer(),d.anim.stop(),d.isDragging&&(d.isDragging=!1,d.justDragged=!0,Kinetic.listenClickTap=!1,a&&(a.dragEndNode=e)),delete d.node,(c||e).draw())},_endDragAfter:function(a){a=a||{};var b=a.dragEndNode;a&&b&&b.fire("dragend",{type:"dragend",target:b,evt:a},!0)}},Kinetic.Node.prototype.startDrag=function(){var a=Kinetic.DD,b=this.getStage(),c=this.getLayer(),d=b.getPointerPosition(),e=this.getAbsolutePosition();d&&(a.node&&a.node.stopDrag(),a.node=this,a.startPointerPos=d,a.offset.x=d.x-e.x,a.offset.y=d.y-e.y,a.anim.setLayers(c||this.getLayers()),a.anim.start(),this._setDragPosition())},Kinetic.Node.prototype._setDragPosition=function(a){var b=Kinetic.DD,c=this.getStage().getPointerPosition(),d=this.getDragBoundFunc();if(c){var e={x:c.x-b.offset.x,y:c.y-b.offset.y};void 0!==d&&(e=d.call(this,e,a)),this.setAbsolutePosition(e),this._lastPos&&this._lastPos.x===e.x&&this._lastPos.y===e.y||(b.anim.dirty=!0),this._lastPos=e}},Kinetic.Node.prototype.stopDrag=function(){var a=Kinetic.DD,b={};a._endDragBefore(b),a._endDragAfter(b)},Kinetic.Node.prototype.setDraggable=function(a){this._setAttr("draggable",a),this._dragChange()};var a=Kinetic.Node.prototype.destroy;Kinetic.Node.prototype.destroy=function(){var b=Kinetic.DD;b.node&&b.node._id===this._id&&this.stopDrag(),a.call(this)},Kinetic.Node.prototype.isDragging=function(){var a=Kinetic.DD;return!(!a.node||a.node._id!==this._id||!a.isDragging)},Kinetic.Node.prototype._listenDrag=function(){var a=this;this._dragCleanup(),"Stage"===this.getClassName()?this.on("contentMousedown.kinetic contentTouchstart.kinetic",function(b){Kinetic.DD.node||a.startDrag(b)}):this.on("mousedown.kinetic touchstart.kinetic",function(b){1!==b.evt.button&&2!==b.evt.button&&(Kinetic.DD.node||a.startDrag(b))})},Kinetic.Node.prototype._dragChange=function(){if(this.attrs.draggable)this._listenDrag();else{this._dragCleanup();var a=this.getStage(),b=Kinetic.DD;a&&b.node&&b.node._id===this._id&&b.node.stopDrag()}},Kinetic.Node.prototype._dragCleanup=function(){"Stage"===this.getClassName()?(this.off("contentMousedown.kinetic"),this.off("contentTouchstart.kinetic")):(this.off("mousedown.kinetic"),this.off("touchstart.kinetic"))},Kinetic.Factory.addGetterSetter(Kinetic.Node,"dragBoundFunc"),Kinetic.Factory.addGetter(Kinetic.Node,"draggable",!1),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Node,"draggable");var b=Kinetic.document.documentElement;b.addEventListener("mouseup",Kinetic.DD._endDragBefore,!0),b.addEventListener("touchend",Kinetic.DD._endDragBefore,!0),b.addEventListener("mouseup",Kinetic.DD._endDragAfter,!1),b.addEventListener("touchend",Kinetic.DD._endDragAfter,!1)}(),function(){Kinetic.Util.addMethods(Kinetic.Container,{__init:function(a){this.children=new Kinetic.Collection,Kinetic.Node.call(this,a)},getChildren:function(a){if(a){var b=new Kinetic.Collection;return this.children.each(function(c){a(c)&&b.push(c)}),b}return this.children},hasChildren:function(){return this.getChildren().length>0},removeChildren:function(){for(var a,b=Kinetic.Collection.toCollection(this.children),c=0;c<b.length;c++)a=b[c],delete a.parent,a.index=0,a.hasChildren()&&a.removeChildren(),a.remove();return b=null,this.children=new Kinetic.Collection,this},destroyChildren:function(){for(var a,b=Kinetic.Collection.toCollection(this.children),c=0;c<b.length;c++)a=b[c],delete a.parent,a.index=0,a.destroy();return b=null,this.children=new Kinetic.Collection,this},add:function(a){if(arguments.length>1){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a.getParent())return a.moveTo(this),this;var c=this.children;return this._validateAdd(a),a.index=c.length,a.parent=this,c.push(a),this._fire("add",{child:a}),a.isDragging()&&Kinetic.DD.anim.setLayers(a.getLayer()),this},destroy:function(){this.hasChildren()&&this.destroyChildren(),Kinetic.Node.prototype.destroy.call(this)},find:function(a){var b,c,d,e,f,g,h,i=[],j=a.replace(/ /g,"").split(","),k=j.length;for(b=0;k>b;b++)if(d=j[b],"#"===d.charAt(0))f=this._getNodeById(d.slice(1)),f&&i.push(f);else if("."===d.charAt(0))e=this._getNodesByName(d.slice(1)),i=i.concat(e);else for(g=this.getChildren(),h=g.length,c=0;h>c;c++)i=i.concat(g[c]._get(d));return Kinetic.Collection.toCollection(i)},_getNodeById:function(a){var b=Kinetic.ids[a];return void 0!==b&&this.isAncestorOf(b)?b:null},_getNodesByName:function(a){var b=Kinetic.names[a]||[];return this._getDescendants(b)},_get:function(a){for(var b=Kinetic.Node.prototype._get.call(this,a),c=this.getChildren(),d=c.length,e=0;d>e;e++)b=b.concat(c[e]._get(a));return b},toObject:function(){var a=Kinetic.Node.prototype.toObject.call(this);
a.children=[];for(var b=this.getChildren(),c=b.length,d=0;c>d;d++){var e=b[d];a.children.push(e.toObject())}return a},_getDescendants:function(a){for(var b=[],c=a.length,d=0;c>d;d++){var e=a[d];this.isAncestorOf(e)&&b.push(e)}return b},isAncestorOf:function(a){for(var b=a.getParent();b;){if(b._id===this._id)return!0;b=b.getParent()}return!1},clone:function(a){var b=Kinetic.Node.prototype.clone.call(this,a);return this.getChildren().each(function(a){b.add(a.clone())}),b},getAllIntersections:function(a){var b=[];return this.find("Shape").each(function(c){c.isVisible()&&c.intersects(a)&&b.push(c)}),b},_setChildrenIndices:function(){this.children.each(function(a,b){a.index=b})},drawScene:function(a,b){var c=this.getLayer(),d=a||c&&c.getCanvas(),e=d&&d.getContext(),f=this._cache.canvas,g=f&&f.scene;return this.isVisible()&&(g?this._drawCachedSceneCanvas(e):this._drawChildren(d,"drawScene",b)),this},drawHit:function(a,b){var c=this.getLayer(),d=a||c&&c.hitCanvas,e=d&&d.getContext(),f=this._cache.canvas,g=f&&f.hit;return this.shouldDrawHit(d)&&(c&&c.clearHitCache(),g?this._drawCachedHitCanvas(e):this._drawChildren(d,"drawHit",b)),this},_drawChildren:function(a,b,c){var d,e,f=this.getLayer(),g=a&&a.getContext(),h=this.getClipWidth(),i=this.getClipHeight(),j=h&&i;j&&f&&(d=this.getClipX(),e=this.getClipY(),g.save(),f._applyTransform(this,g),g.beginPath(),g.rect(d,e,h,i),g.clip(),g.reset()),this.children.each(function(d){d[b](a,c)}),j&&g.restore()},shouldDrawHit:function(a){var b=this.getLayer(),c=Kinetic.DD,d=c&&Kinetic.isDragging()&&-1!==Kinetic.DD.anim.getLayers().indexOf(b);return a&&a.isCache||b&&b.hitGraphEnabled()&&this.isVisible()&&!d}}),Kinetic.Util.extend(Kinetic.Container,Kinetic.Node),Kinetic.Container.prototype.get=Kinetic.Container.prototype.find,Kinetic.Factory.addComponentsGetterSetter(Kinetic.Container,"clip",["x","y","width","height"]),Kinetic.Factory.addGetterSetter(Kinetic.Container,"clipX"),Kinetic.Factory.addGetterSetter(Kinetic.Container,"clipY"),Kinetic.Factory.addGetterSetter(Kinetic.Container,"clipWidth"),Kinetic.Factory.addGetterSetter(Kinetic.Container,"clipHeight"),Kinetic.Collection.mapMethods(Kinetic.Container)}(),function(){function a(a){a.fill()}function b(a){a.stroke()}function c(a){a.fill()}function d(a){a.stroke()}function e(){this._clearCache(f)}var f="hasShadow";Kinetic.Util.addMethods(Kinetic.Shape,{__init:function(f){this.nodeType="Shape",this._fillFunc=a,this._strokeFunc=b,this._fillFuncHit=c,this._strokeFuncHit=d;for(var g,h=Kinetic.shapes;;)if(g=Kinetic.Util.getRandomColor(),g&&!(g in h))break;this.colorKey=g,h[g]=this,Kinetic.Node.call(this,f),this.on("shadowColorChange.kinetic shadowBlurChange.kinetic shadowOffsetChange.kinetic shadowOpacityChange.kinetic shadowEnabledChange.kinetic",e)},hasChildren:function(){return!1},getChildren:function(){return[]},getContext:function(){return this.getLayer().getContext()},getCanvas:function(){return this.getLayer().getCanvas()},hasShadow:function(){return this._getCache(f,this._hasShadow)},_hasShadow:function(){return this.getShadowEnabled()&&0!==this.getShadowOpacity()&&!!(this.getShadowColor()||this.getShadowBlur()||this.getShadowOffsetX()||this.getShadowOffsetY())},hasFill:function(){return!!(this.getFill()||this.getFillPatternImage()||this.getFillLinearGradientColorStops()||this.getFillRadialGradientColorStops())},hasStroke:function(){return!!(this.stroke()||this.strokeRed()||this.strokeGreen()||this.strokeBlue())},intersects:function(a){var b,c=this.getStage(),d=c.bufferHitCanvas;return d.getContext().clear(),this.drawScene(d),b=d.context.getImageData(Math.round(a.x),Math.round(a.y),1,1).data,b[3]>0},destroy:function(){Kinetic.Node.prototype.destroy.call(this),delete Kinetic.shapes[this.colorKey]},_useBufferCanvas:function(){return(this.hasShadow()||1!==this.getAbsoluteOpacity())&&this.hasFill()&&this.hasStroke()&&this.getStage()},drawScene:function(a,b){var c,d,e,f=this.getLayer(),g=a||f.getCanvas(),h=g.getContext(),i=this._cache.canvas,j=this.sceneFunc(),k=this.hasShadow();if(this.isVisible())if(i)this._drawCachedSceneCanvas(h);else if(j){if(h.save(),this._useBufferCanvas()){if(c=this.getStage(),d=c.bufferCanvas,e=d.getContext(),e.clear(),e.save(),e._applyLineJoin(this),f)f._applyTransform(this,e,b);else{var l=this.getAbsoluteTransform(b).getMatrix();h.transform(l[0],l[1],l[2],l[3],l[4],l[5])}j.call(this,e),e.restore(),k&&!g.hitCanvas&&(h.save(),h._applyShadow(this),h.drawImage(d._canvas,0,0),h.restore()),h._applyOpacity(this),h.drawImage(d._canvas,0,0)}else{if(h._applyLineJoin(this),f)f._applyTransform(this,h,b);else{var m=this.getAbsoluteTransform(b).getMatrix();h.transform(m[0],m[1],m[2],m[3],m[4],m[5])}k&&!g.hitCanvas&&(h.save(),h._applyShadow(this),j.call(this,h),h.restore()),h._applyOpacity(this),j.call(this,h)}h.restore()}return this},drawHit:function(a,b){var c=this.getLayer(),d=a||c.hitCanvas,e=d.getContext(),f=this.hitFunc()||this.sceneFunc(),g=this._cache.canvas,h=g&&g.hit;if(this.shouldDrawHit(d))if(c&&c.clearHitCache(),h)this._drawCachedHitCanvas(e);else if(f){if(e.save(),e._applyLineJoin(this),c)c._applyTransform(this,e,b);else{var i=this.getAbsoluteTransform(b).getMatrix();e.transform(i[0],i[1],i[2],i[3],i[4],i[5])}f.call(this,e),e.restore()}return this},drawHitFromCache:function(a){var b,c,d,e,f,g,h,i,j=a||0,k=this._cache.canvas,l=this._getCachedSceneCanvas(),m=l.getContext(),n=k.hit,o=n.getContext(),p=l.getWidth(),q=l.getHeight();o.clear();try{for(b=m.getImageData(0,0,p,q),c=b.data,d=o.getImageData(0,0,p,q),e=d.data,f=c.length,g=Kinetic.Util._hexToRgb(this.colorKey),h=0;f>h;h+=4)i=c[h+3],i>j&&(e[h]=g.r,e[h+1]=g.g,e[h+2]=g.b,e[h+3]=255);o.putImageData(d,0,0)}catch(r){Kinetic.Util.warn("Unable to draw hit graph from cached scene canvas. "+r.message)}return this}}),Kinetic.Util.extend(Kinetic.Shape,Kinetic.Node),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"stroke"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeRed",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeGreen",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeBlue",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeAlpha",1,Kinetic.Validators.alphaComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeWidth",2),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"lineJoin"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"lineCap"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"sceneFunc"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"hitFunc"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"dash"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowColor"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowRed",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowGreen",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowBlue",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowAlpha",1,Kinetic.Validators.alphaComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowBlur"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowOpacity"),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"shadowOffset",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowOffsetX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowOffsetY",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternImage"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fill"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRed",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillGreen",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillBlue",0,Kinetic.Validators.RGBComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillAlpha",1,Kinetic.Validators.alphaComponent),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternY",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillLinearGradientColorStops"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientStartRadius",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientEndRadius",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientColorStops"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternRepeat","repeat"),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillEnabled",!0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeEnabled",!0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"shadowEnabled",!0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"dashEnabled",!0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"strokeScaleEnabled",!0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPriority","color"),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"fillPatternOffset",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternOffsetX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternOffsetY",0),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"fillPatternScale",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternScaleX",1),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternScaleY",1),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"fillLinearGradientStartPoint",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillLinearGradientStartPointX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillLinearGradientStartPointY",0),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"fillLinearGradientEndPoint",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillLinearGradientEndPointX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillLinearGradientEndPointY",0),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"fillRadialGradientStartPoint",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientStartPointX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientStartPointY",0),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Shape,"fillRadialGradientEndPoint",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientEndPointX",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillRadialGradientEndPointY",0),Kinetic.Factory.addGetterSetter(Kinetic.Shape,"fillPatternRotation",0),Kinetic.Factory.backCompat(Kinetic.Shape,{dashArray:"dash",getDashArray:"getDash",setDashArray:"getDash",drawFunc:"sceneFunc",getDrawFunc:"getSceneFunc",setDrawFunc:"setSceneFunc",drawHitFunc:"hitFunc",getDrawHitFunc:"getHitFunc",setDrawHitFunc:"setHitFunc"}),Kinetic.Collection.mapMethods(Kinetic.Shape)}(),function(){function a(a,b){a.content.addEventListener(b,function(c){a[L+b](c)},!1)}var b="Stage",c="string",d="px",e="mouseout",f="mouseleave",g="mouseover",h="mouseenter",i="mousemove",j="mousedown",k="mouseup",l="click",m="dblclick",n="touchstart",o="touchend",p="tap",q="dbltap",r="touchmove",s="DOMMouseScroll",t="mousewheel",u="wheel",v="contentMouseout",w="contentMouseover",x="contentMousemove",y="contentMousedown",z="contentMouseup",A="contentClick",B="contentDblclick",C="contentTouchstart",D="contentTouchend",E="contentDbltap",F="contentTouchmove",G="div",H="relative",I="inline-block",J="kineticjs-content",K=" ",L="_",M="container",N="",O=[j,i,k,e,n,r,o,g,s,t,u],P=O.length;Kinetic.Util.addMethods(Kinetic.Stage,{___init:function(a){this.nodeType=b,Kinetic.Container.call(this,a),this._id=Kinetic.idCounter++,this._buildDOM(),this._bindContentEvents(),this._enableNestedTransforms=!1,Kinetic.stages.push(this)},_validateAdd:function(a){"Layer"!==a.getType()&&Kinetic.Util.error("You may only add layers to the stage.")},setContainer:function(a){if(typeof a===c){var b=a;if(a=Kinetic.document.getElementById(a),!a)throw"Can not find container in document with id "+b}return this._setAttr(M,a),this},shouldDrawHit:function(){return!0},draw:function(){return Kinetic.Node.prototype.draw.call(this),this},setHeight:function(a){return Kinetic.Node.prototype.setHeight.call(this,a),this._resizeDOM(),this},setWidth:function(a){return Kinetic.Node.prototype.setWidth.call(this,a),this._resizeDOM(),this},clear:function(){var a,b=this.children,c=b.length;for(a=0;c>a;a++)b[a].clear();return this},clone:function(a){return a||(a={}),a.container=Kinetic.document.createElement(G),Kinetic.Container.prototype.clone.call(this,a)},destroy:function(){var a=this.content;Kinetic.Container.prototype.destroy.call(this),a&&Kinetic.Util._isInDocument(a)&&this.getContainer().removeChild(a);var b=Kinetic.stages.indexOf(this);b>-1&&Kinetic.stages.splice(b,1)},getPointerPosition:function(){return this.pointerPos},getStage:function(){return this},getContent:function(){return this.content},toDataURL:function(a){function b(e){var f=i[e],j=f.toDataURL(),k=new Kinetic.window.Image;k.onload=function(){h.drawImage(k,0,0),e<i.length-1?b(e+1):a.callback(g.toDataURL(c,d))},k.src=j}a=a||{};var c=a.mimeType||null,d=a.quality||null,e=a.x||0,f=a.y||0,g=new Kinetic.SceneCanvas({width:a.width||this.getWidth(),height:a.height||this.getHeight(),pixelRatio:1}),h=g.getContext()._context,i=this.children;(e||f)&&h.translate(-1*e,-1*f),b(0)},toImage:function(a){var b=a.callback;a.callback=function(a){Kinetic.Util._getImage(a,function(a){b(a)})},this.toDataURL(a)},getIntersection:function(a){var b,c,d=this.getChildren(),e=d.length,f=e-1;for(b=f;b>=0;b--)if(c=d[b].getIntersection(a))return c;return null},_resizeDOM:function(){if(this.content){var a,b,c=this.getWidth(),e=this.getHeight(),f=this.getChildren(),g=f.length;for(this.content.style.width=c+d,this.content.style.height=e+d,this.bufferCanvas.setSize(c,e),this.bufferHitCanvas.setSize(c,e),a=0;g>a;a++)b=f[a],b.setSize(c,e),b.draw()}},add:function(a){if(!(arguments.length>1))return Kinetic.Container.prototype.add.call(this,a),a._setCanvasSize(this.width(),this.height()),a.draw(),this.content.appendChild(a.canvas._canvas),this;for(var b=0;b<arguments.length;b++)this.add(arguments[b])},getParent:function(){return null},getLayer:function(){return null},getLayers:function(){return this.getChildren()},_bindContentEvents:function(){for(var b=0;P>b;b++)a(this,O[b])},_mouseover:function(a){Kinetic.UA.mobile||(this._setPointerPosition(a),this._fire(w,{evt:a}))},_mouseout:function(a){if(!Kinetic.UA.mobile){this._setPointerPosition(a);var b=this.targetShape;b&&!Kinetic.isDragging()&&(b._fireAndBubble(e,{evt:a}),b._fireAndBubble(f,{evt:a}),this.targetShape=null),this.pointerPos=void 0,this._fire(v,{evt:a})}},_mousemove:function(a){if(Kinetic.UA.ieMobile)return this._touchmove(a);if(("undefined"==typeof a.webkitMovementX&&"undefined"==typeof a.webkitMovementY||0!==a.webkitMovementY||0!==a.webkitMovementX)&&!Kinetic.UA.mobile){this._setPointerPosition(a);var b,c=Kinetic.DD;Kinetic.isDragging()||(b=this.getIntersection(this.getPointerPosition()),b&&b.isListening()?Kinetic.isDragging()||this.targetShape&&this.targetShape._id===b._id?b._fireAndBubble(i,{evt:a}):(this.targetShape&&(this.targetShape._fireAndBubble(e,{evt:a},b),this.targetShape._fireAndBubble(f,{evt:a},b)),b._fireAndBubble(g,{evt:a},this.targetShape),b._fireAndBubble(h,{evt:a},this.targetShape),this.targetShape=b):this.targetShape&&!Kinetic.isDragging()&&(this.targetShape._fireAndBubble(e,{evt:a}),this.targetShape._fireAndBubble(f,{evt:a}),this.targetShape=null),this._fire(x,{evt:a})),c&&c._drag(a),a.preventDefault&&a.preventDefault()}},_mousedown:function(a){if(Kinetic.UA.ieMobile)return this._touchstart(a);if(!Kinetic.UA.mobile){this._setPointerPosition(a);var b=this.getIntersection(this.getPointerPosition());Kinetic.listenClickTap=!0,b&&b.isListening()&&(this.clickStartShape=b,b._fireAndBubble(j,{evt:a})),this._fire(y,{evt:a})}a.preventDefault&&a.preventDefault()},_mouseup:function(a){if(Kinetic.UA.ieMobile)return this._touchend(a);if(!Kinetic.UA.mobile){this._setPointerPosition(a);var b=this.getIntersection(this.getPointerPosition()),c=this.clickStartShape,d=!1,e=Kinetic.DD;Kinetic.inDblClickWindow?(d=!0,Kinetic.inDblClickWindow=!1):e&&e.justDragged?e&&(e.justDragged=!1):Kinetic.inDblClickWindow=!0,setTimeout(function(){Kinetic.inDblClickWindow=!1},Kinetic.dblClickWindow),b&&b.isListening()&&(b._fireAndBubble(k,{evt:a}),Kinetic.listenClickTap&&c&&c._id===b._id&&(b._fireAndBubble(l,{evt:a}),d&&b._fireAndBubble(m,{evt:a}))),this._fire(z,{evt:a}),Kinetic.listenClickTap&&(this._fire(A,{evt:a}),d&&this._fire(B,{evt:a})),Kinetic.listenClickTap=!1}a.preventDefault&&a.preventDefault()},_touchstart:function(a){this._setPointerPosition(a);var b=this.getIntersection(this.getPointerPosition());Kinetic.listenClickTap=!0,b&&b.isListening()&&(this.tapStartShape=b,b._fireAndBubble(n,{evt:a}),b.isListening()&&a.preventDefault&&a.preventDefault()),this._fire(C,{evt:a})},_touchend:function(a){this._setPointerPosition(a);var b=this.getIntersection(this.getPointerPosition()),c=!1;Kinetic.inDblClickWindow?(c=!0,Kinetic.inDblClickWindow=!1):Kinetic.inDblClickWindow=!0,setTimeout(function(){Kinetic.inDblClickWindow=!1},Kinetic.dblClickWindow),b&&b.isListening()&&(b._fireAndBubble(o,{evt:a}),Kinetic.listenClickTap&&b._id===this.tapStartShape._id&&(b._fireAndBubble(p,{evt:a}),c&&b._fireAndBubble(q,{evt:a})),b.isListening()&&a.preventDefault&&a.preventDefault()),Kinetic.listenClickTap&&(this._fire(D,{evt:a}),c&&this._fire(E,{evt:a})),Kinetic.listenClickTap=!1},_touchmove:function(a){this._setPointerPosition(a);var b,c=Kinetic.DD;Kinetic.isDragging()||(b=this.getIntersection(this.getPointerPosition()),b&&b.isListening()&&(b._fireAndBubble(r,{evt:a}),b.isListening()&&a.preventDefault&&a.preventDefault()),this._fire(F,{evt:a})),c&&(c._drag(a),Kinetic.isDragging()&&a.preventDefault())},_DOMMouseScroll:function(a){this._mousewheel(a)},_mousewheel:function(a){this._setPointerPosition(a);var b=this.getIntersection(this.getPointerPosition());b&&b.isListening()&&b._fireAndBubble(t,{evt:a})},_wheel:function(a){this._mousewheel(a)},_setPointerPosition:function(a){var b,c=this._getContentPosition(),d=a.offsetX,e=a.clientX,f=null,g=null;a=a?a:window.event,void 0!==a.touches?a.touches.length>0&&(b=a.touches[0],f=b.clientX-c.left,g=b.clientY-c.top):void 0!==d?(f=d,g=a.offsetY):"mozilla"===Kinetic.UA.browser?(f=a.layerX,g=a.layerY):void 0!==e&&c&&(f=e-c.left,g=a.clientY-c.top),null!==f&&null!==g&&(this.pointerPos={x:f,y:g})},_getContentPosition:function(){var a=this.content.getBoundingClientRect?this.content.getBoundingClientRect():{top:0,left:0};return{top:a.top,left:a.left}},_buildDOM:function(){var a=this.getContainer();if(!a){if(Kinetic.Util.isBrowser())throw"Stage has no container. A container is required.";a=Kinetic.document.createElement(G)}a.innerHTML=N,this.content=Kinetic.document.createElement(G),this.content.style.position=H,this.content.style.display=I,this.content.className=J,this.content.setAttribute("role","presentation"),a.appendChild(this.content),this.bufferCanvas=new Kinetic.SceneCanvas({pixelRatio:1}),this.bufferHitCanvas=new Kinetic.HitCanvas,this._resizeDOM()},_onContent:function(a,b){var c,d,e=a.split(K),f=e.length;for(c=0;f>c;c++)d=e[c],this.content.addEventListener(d,b,!1)},cache:function(){Kinetic.Util.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.")},clearCache:function(){}}),Kinetic.Util.extend(Kinetic.Stage,Kinetic.Container),Kinetic.Factory.addGetter(Kinetic.Stage,"container"),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Stage,"container")}(),function(){Kinetic.Util.addMethods(Kinetic.BaseLayer,{___init:function(a){this.nodeType="Layer",Kinetic.Container.call(this,a)},createPNGStream:function(){return this.canvas._canvas.createPNGStream()},getCanvas:function(){return this.canvas},getHitCanvas:function(){return this.hitCanvas},getContext:function(){return this.getCanvas().getContext()},clear:function(a){return this.getContext().clear(a),this.getHitCanvas().getContext().clear(a),this},clearHitCache:function(){this._hitImageData=void 0},setZIndex:function(a){Kinetic.Node.prototype.setZIndex.call(this,a);var b=this.getStage();return b&&(b.content.removeChild(this.getCanvas()._canvas),a<b.getChildren().length-1?b.content.insertBefore(this.getCanvas()._canvas,b.getChildren()[a+1].getCanvas()._canvas):b.content.appendChild(this.getCanvas()._canvas)),this},moveToTop:function(){Kinetic.Node.prototype.moveToTop.call(this);var a=this.getStage();a&&(a.content.removeChild(this.getCanvas()._canvas),a.content.appendChild(this.getCanvas()._canvas))},moveUp:function(){if(Kinetic.Node.prototype.moveUp.call(this)){var a=this.getStage();a&&(a.content.removeChild(this.getCanvas()._canvas),this.index<a.getChildren().length-1?a.content.insertBefore(this.getCanvas()._canvas,a.getChildren()[this.index+1].getCanvas()._canvas):a.content.appendChild(this.getCanvas()._canvas))}},moveDown:function(){if(Kinetic.Node.prototype.moveDown.call(this)){var a=this.getStage();if(a){var b=a.getChildren();a.content.removeChild(this.getCanvas()._canvas),a.content.insertBefore(this.getCanvas()._canvas,b[this.index+1].getCanvas()._canvas)}}},moveToBottom:function(){if(Kinetic.Node.prototype.moveToBottom.call(this)){var a=this.getStage();if(a){var b=a.getChildren();a.content.removeChild(this.getCanvas()._canvas),a.content.insertBefore(this.getCanvas()._canvas,b[1].getCanvas()._canvas)}}},getLayer:function(){return this},remove:function(){var a=this.getCanvas()._canvas;return Kinetic.Node.prototype.remove.call(this),a&&a.parentNode&&Kinetic.Util._isInDocument(a)&&a.parentNode.removeChild(a),this},getStage:function(){return this.parent},setSize:function(a,b){this.canvas.setSize(a,b)},getWidth:function(){return this.parent?this.parent.getWidth():void 0},setWidth:function(){Kinetic.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.')},getHeight:function(){return this.parent?this.parent.getHeight():void 0},setHeight:function(){Kinetic.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.')}}),Kinetic.Util.extend(Kinetic.BaseLayer,Kinetic.Container),Kinetic.Factory.addGetterSetter(Kinetic.BaseLayer,"clearBeforeDraw",!0),Kinetic.Collection.mapMethods(Kinetic.BaseLayer)}(),function(){var a="#",b="beforeDraw",c="draw",d=[{x:0,y:0},{x:-1,y:0},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1}],e=d.length;Kinetic.Util.addMethods(Kinetic.Layer,{____init:function(a){this.nodeType="Layer",this.canvas=new Kinetic.SceneCanvas,this.hitCanvas=new Kinetic.HitCanvas,Kinetic.BaseLayer.call(this,a)},_setCanvasSize:function(a,b){this.canvas.setSize(a,b),this.hitCanvas.setSize(a,b)},_validateAdd:function(a){var b=a.getType();"Group"!==b&&"Shape"!==b&&Kinetic.Util.error("You may only add groups and shapes to a layer.")},getIntersection:function(a){var b,c,f,g;if(!this.hitGraphEnabled()||!this.isVisible())return null;for(var h=1,i=!1;;){for(c=0;e>c;c++){if(f=d[c],b=this._getIntersection({x:a.x+f.x*h,y:a.y+f.y*h}),g=b.shape)return g;b.antialiased&&(i=!0)}if(!i)return;h+=1}},_getImageData:function(a,b){var c=this.hitCanvas.width||1,d=this.hitCanvas.height||1,e=Math.round(b)*c+Math.round(a);return this._hitImageData||(this._hitImageData=this.hitCanvas.context.getImageData(0,0,c,d)),[this._hitImageData.data[4*e+0],this._hitImageData.data[4*e+1],this._hitImageData.data[4*e+2],this._hitImageData.data[4*e+3]]},_getIntersection:function(b){var c,d,e=this.hitCanvas.context.getImageData(b.x,b.y,1,1).data,f=e[3];return 255===f?(c=Kinetic.Util._rgbToHex(e[0],e[1],e[2]),d=Kinetic.shapes[a+c],{shape:d}):f>0?{antialiased:!0}:{}},drawScene:function(a,d){var e=this.getLayer(),f=a||e&&e.getCanvas();return this._fire(b,{node:this}),this.getClearBeforeDraw()&&f.getContext().clear(),Kinetic.Container.prototype.drawScene.call(this,f,d),this._fire(c,{node:this}),this},_applyTransform:function(a,b,c){var d=a.getAbsoluteTransform(c).getMatrix();b.transform(d[0],d[1],d[2],d[3],d[4],d[5])},drawHit:function(a,b){var c=this.getLayer(),d=a||c&&c.hitCanvas;return c&&c.getClearBeforeDraw()&&c.getHitCanvas().getContext().clear(),Kinetic.Container.prototype.drawHit.call(this,d,b),this.imageData=null,this},clear:function(a){return this.getContext().clear(a),this.getHitCanvas().getContext().clear(a),this.imageData=null,this},setVisible:function(a){return Kinetic.Node.prototype.setVisible.call(this,a),a?(this.getCanvas()._canvas.style.display="block",this.hitCanvas._canvas.style.display="block"):(this.getCanvas()._canvas.style.display="none",this.hitCanvas._canvas.style.display="none"),this},enableHitGraph:function(){return this.setHitGraphEnabled(!0),this},disableHitGraph:function(){return this.setHitGraphEnabled(!1),this},setSize:function(a,b){Kinetic.BaseLayer.prototype.setSize.call(this,a,b),this.hitCanvas.setSize(a,b)}}),Kinetic.Util.extend(Kinetic.Layer,Kinetic.BaseLayer),Kinetic.Factory.addGetterSetter(Kinetic.Layer,"hitGraphEnabled",!0),Kinetic.Collection.mapMethods(Kinetic.Layer)}(),function(){Kinetic.Util.addMethods(Kinetic.FastLayer,{____init:function(a){this.nodeType="Layer",this.canvas=new Kinetic.SceneCanvas,Kinetic.BaseLayer.call(this,a)},_validateAdd:function(a){var b=a.getType();"Shape"!==b&&Kinetic.Util.error("You may only add shapes to a fast layer.")},_setCanvasSize:function(a,b){this.canvas.setSize(a,b)},hitGraphEnabled:function(){return!1},getIntersection:function(){return null},drawScene:function(a){var b=this.getLayer(),c=a||b&&b.getCanvas();return this.getClearBeforeDraw()&&c.getContext().clear(),Kinetic.Container.prototype.drawScene.call(this,c),this},_applyTransform:function(a,b,c){if(!c||c._id!==this._id){var d=a.getTransform().getMatrix();b.transform(d[0],d[1],d[2],d[3],d[4],d[5])}},draw:function(){return this.drawScene(),this},clear:function(a){return this.getContext().clear(a),this},setVisible:function(a){return Kinetic.Node.prototype.setVisible.call(this,a),this.getCanvas()._canvas.style.display=a?"block":"none",this}}),Kinetic.Util.extend(Kinetic.FastLayer,Kinetic.BaseLayer),Kinetic.Collection.mapMethods(Kinetic.FastLayer)}(),function(){Kinetic.Util.addMethods(Kinetic.Group,{___init:function(a){this.nodeType="Group",Kinetic.Container.call(this,a)},_validateAdd:function(a){var b=a.getType();"Group"!==b&&"Shape"!==b&&Kinetic.Util.error("You may only add groups and shapes to groups.")}}),Kinetic.Util.extend(Kinetic.Group,Kinetic.Container),Kinetic.Collection.mapMethods(Kinetic.Group)}(),function(){Kinetic.Rect=function(a){this.___init(a)},Kinetic.Rect.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Rect",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b=this.getCornerRadius(),c=this.getWidth(),d=this.getHeight();a.beginPath(),b?(a.moveTo(b,0),a.lineTo(c-b,0),a.arc(c-b,b,b,3*Math.PI/2,0,!1),a.lineTo(c,d-b),a.arc(c-b,d-b,b,0,Math.PI/2,!1),a.lineTo(b,d),a.arc(b,d-b,b,Math.PI/2,Math.PI,!1),a.lineTo(0,b),a.arc(b,b,b,Math.PI,3*Math.PI/2,!1)):a.rect(0,0,c,d),a.closePath(),a.fillStrokeShape(this)}},Kinetic.Util.extend(Kinetic.Rect,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Rect,"cornerRadius",0),Kinetic.Collection.mapMethods(Kinetic.Rect)}(),function(){var a=2*Math.PI-1e-4,b="Circle";Kinetic.Circle=function(a){this.___init(a)},Kinetic.Circle.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className=b,this.sceneFunc(this._sceneFunc)},_sceneFunc:function(b){b.beginPath(),b.arc(0,0,this.getRadius(),0,a,!1),b.closePath(),b.fillStrokeShape(this)},getWidth:function(){return 2*this.getRadius()},getHeight:function(){return 2*this.getRadius()},setWidth:function(a){Kinetic.Node.prototype.setWidth.call(this,a),this.radius()!==a/2&&this.setRadius(a/2)},setHeight:function(a){Kinetic.Node.prototype.setHeight.call(this,a),this.radius()!==a/2&&this.setRadius(a/2)},setRadius:function(a){this._setAttr("radius",a),this.setWidth(2*a),this.setHeight(2*a)}},Kinetic.Util.extend(Kinetic.Circle,Kinetic.Shape),Kinetic.Factory.addGetter(Kinetic.Circle,"radius",0),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Circle,"radius"),Kinetic.Collection.mapMethods(Kinetic.Circle)}(),function(){var a=2*Math.PI-1e-4,b="Ellipse";Kinetic.Ellipse=function(a){this.___init(a)},Kinetic.Ellipse.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className=b,this.sceneFunc(this._sceneFunc)},_sceneFunc:function(b){var c=this.getRadiusX(),d=this.getRadiusY();b.beginPath(),b.save(),c!==d&&b.scale(1,d/c),b.arc(0,0,c,0,a,!1),b.restore(),b.closePath(),b.fillStrokeShape(this)},getWidth:function(){return 2*this.getRadiusX()},getHeight:function(){return 2*this.getRadiusY()},setWidth:function(a){Kinetic.Node.prototype.setWidth.call(this,a),this.setRadius({x:a/2})},setHeight:function(a){Kinetic.Node.prototype.setHeight.call(this,a),this.setRadius({y:a/2})}},Kinetic.Util.extend(Kinetic.Ellipse,Kinetic.Shape),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Ellipse,"radius",["x","y"]),Kinetic.Factory.addGetterSetter(Kinetic.Ellipse,"radiusX",0),Kinetic.Factory.addGetterSetter(Kinetic.Ellipse,"radiusY",0),Kinetic.Collection.mapMethods(Kinetic.Ellipse)}(),function(){var a=2*Math.PI-1e-4;Kinetic.Ring=function(a){this.___init(a)},Kinetic.Ring.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Ring",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(b){b.beginPath(),b.arc(0,0,this.getInnerRadius(),0,a,!1),b.moveTo(this.getOuterRadius(),0),b.arc(0,0,this.getOuterRadius(),a,0,!0),b.closePath(),b.fillStrokeShape(this)},getWidth:function(){return 2*this.getOuterRadius()},getHeight:function(){return 2*this.getOuterRadius()},setWidth:function(a){Kinetic.Node.prototype.setWidth.call(this,a),this.outerRadius()!==a/2&&this.setOuterRadius(a/2)},setHeight:function(a){Kinetic.Node.prototype.setHeight.call(this,a),this.outerRadius()!==a/2&&this.setOuterRadius(a/2)},setOuterRadius:function(a){this._setAttr("outerRadius",a),this.setWidth(2*a),this.setHeight(2*a)}},Kinetic.Util.extend(Kinetic.Ring,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Ring,"innerRadius",0),Kinetic.Factory.addGetter(Kinetic.Ring,"outerRadius",0),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Ring,"outerRadius"),Kinetic.Collection.mapMethods(Kinetic.Ring)}(),function(){Kinetic.Wedge=function(a){this.___init(a)},Kinetic.Wedge.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Wedge",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){a.beginPath(),a.arc(0,0,this.getRadius(),0,Kinetic.getAngle(this.getAngle()),this.getClockwise()),a.lineTo(0,0),a.closePath(),a.fillStrokeShape(this)}},Kinetic.Util.extend(Kinetic.Wedge,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Wedge,"radius",0),Kinetic.Factory.addGetterSetter(Kinetic.Wedge,"angle",0),Kinetic.Factory.addGetterSetter(Kinetic.Wedge,"clockwise",!1),Kinetic.Factory.backCompat(Kinetic.Wedge,{angleDeg:"angle",getAngleDeg:"getAngle",setAngleDeg:"setAngle"}),Kinetic.Collection.mapMethods(Kinetic.Wedge)}(),function(){Kinetic.Arc=function(a){this.___init(a)},Kinetic.Arc.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Arc",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b=Kinetic.getAngle(this.angle()),c=this.clockwise();a.beginPath(),a.arc(0,0,this.getOuterRadius(),0,b,c),a.arc(0,0,this.getInnerRadius(),b,0,!c),a.closePath(),a.fillStrokeShape(this)}},Kinetic.Util.extend(Kinetic.Arc,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Arc,"innerRadius",0),Kinetic.Factory.addGetterSetter(Kinetic.Arc,"outerRadius",0),Kinetic.Factory.addGetterSetter(Kinetic.Arc,"angle",0),Kinetic.Factory.addGetterSetter(Kinetic.Arc,"clockwise",!1),Kinetic.Collection.mapMethods(Kinetic.Arc)}(),function(){var a="Image";Kinetic.Image=function(a){this.___init(a)},Kinetic.Image.prototype={___init:function(b){Kinetic.Shape.call(this,b),this.className=a,this.sceneFunc(this._sceneFunc),this.hitFunc(this._hitFunc)},_useBufferCanvas:function(){return(this.hasShadow()||1!==this.getAbsoluteOpacity())&&this.hasStroke()&&this.getStage()},_sceneFunc:function(a){var b,c,d,e=this.getWidth(),f=this.getHeight(),g=this.getImage();g&&(b=this.getCropWidth(),c=this.getCropHeight(),d=b&&c?[g,this.getCropX(),this.getCropY(),b,c,0,0,e,f]:[g,0,0,e,f]),(this.hasFill()||this.hasStroke()||this.hasShadow())&&(a.beginPath(),a.rect(0,0,e,f),a.closePath(),a.fillStrokeShape(this)),g&&a.drawImage.apply(a,d)
},_hitFunc:function(a){var b=this.getWidth(),c=this.getHeight();a.beginPath(),a.rect(0,0,b,c),a.closePath(),a.fillStrokeShape(this)},getWidth:function(){var a=this.getImage();return this.attrs.width||(a?a.width:0)},getHeight:function(){var a=this.getImage();return this.attrs.height||(a?a.height:0)}},Kinetic.Util.extend(Kinetic.Image,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Image,"image"),Kinetic.Factory.addComponentsGetterSetter(Kinetic.Image,"crop",["x","y","width","height"]),Kinetic.Factory.addGetterSetter(Kinetic.Image,"cropX",0),Kinetic.Factory.addGetterSetter(Kinetic.Image,"cropY",0),Kinetic.Factory.addGetterSetter(Kinetic.Image,"cropWidth",0),Kinetic.Factory.addGetterSetter(Kinetic.Image,"cropHeight",0),Kinetic.Collection.mapMethods(Kinetic.Image)}(),function(){function a(a){a.fillText(this.partialText,0,0)}function b(a){a.strokeText(this.partialText,0,0)}var c="auto",d="center",e="Change.kinetic",f="2d",g="-",h="",i="left",j="text",k="Text",l="middle",m="normal",n="px ",o=" ",p="right",q="word",r="char",s="none",t=["fontFamily","fontSize","fontStyle","fontVariant","padding","align","lineHeight","text","width","height","wrap"],u=t.length,v=Kinetic.Util.createCanvasElement().getContext(f);Kinetic.Text=function(a){this.___init(a)},Kinetic.Text.prototype={___init:function(d){d=d||{},d.fill=d.fill||"black",void 0===d.width&&(d.width=c),void 0===d.height&&(d.height=c),Kinetic.Shape.call(this,d),this._fillFunc=a,this._strokeFunc=b,this.className=k;for(var f=0;u>f;f++)this.on(t[f]+e,this._setTextData);this._setTextData(),this.sceneFunc(this._sceneFunc),this.hitFunc(this._hitFunc)},_sceneFunc:function(a){var b,c=this.getPadding(),e=this.getTextHeight(),f=this.getLineHeight()*e,g=this.textArr,h=g.length,j=this.getWidth();for(a.setAttr("font",this._getContextFont()),a.setAttr("textBaseline",l),a.setAttr("textAlign",i),a.save(),a.translate(c,0),a.translate(0,c+e/2),b=0;h>b;b++){var k=g[b],m=k.text,n=k.width;a.save(),this.getAlign()===p?a.translate(j-n-2*c,0):this.getAlign()===d&&a.translate((j-n-2*c)/2,0),this.partialText=m,a.fillStrokeShape(this),a.restore(),a.translate(0,f)}a.restore()},_hitFunc:function(a){var b=this.getWidth(),c=this.getHeight();a.beginPath(),a.rect(0,0,b,c),a.closePath(),a.fillStrokeShape(this)},setText:function(a){var b=Kinetic.Util._isString(a)?a:a.toString();return this._setAttr(j,b),this},getWidth:function(){return this.attrs.width===c?this.getTextWidth()+2*this.getPadding():this.attrs.width},getHeight:function(){return this.attrs.height===c?this.getTextHeight()*this.textArr.length*this.getLineHeight()+2*this.getPadding():this.attrs.height},getTextWidth:function(){return this.textWidth},getTextHeight:function(){return this.textHeight},_getTextSize:function(a){var b,c=v,d=this.getFontSize();return c.save(),c.font=this._getContextFont(),b=c.measureText(a),c.restore(),{width:b.width,height:parseInt(d,10)}},_getContextFont:function(){return this.getFontStyle()+o+this.getFontVariant()+o+this.getFontSize()+n+this.getFontFamily()},_addTextLine:function(a,b){return this.textArr.push({text:a,width:b})},_getTextWidth:function(a){return v.measureText(a).width},_setTextData:function(){var a=this.getText().split("\n"),b=+this.getFontSize(),d=0,e=this.getLineHeight()*b,f=this.attrs.width,h=this.attrs.height,i=f!==c,j=h!==c,k=this.getPadding(),l=f-2*k,m=h-2*k,n=0,p=this.getWrap(),q=p!==s,t=p!==r&&q;this.textArr=[],v.save(),v.font=this._getContextFont();for(var u=0,w=a.length;w>u;++u){var x=a[u],y=this._getTextWidth(x);if(i&&y>l)for(;x.length>0;){for(var z=0,A=x.length,B="",C=0;A>z;){var D=z+A>>>1,E=x.slice(0,D+1),F=this._getTextWidth(E);l>=F?(z=D+1,B=E,C=F):A=D}if(!B)break;if(t){var G=Math.max(B.lastIndexOf(o),B.lastIndexOf(g))+1;G>0&&(z=G,B=B.slice(0,z),C=this._getTextWidth(B))}if(this._addTextLine(B,C),d=Math.max(d,C),n+=e,!q||j&&n+e>m)break;if(x=x.slice(z),x.length>0&&(y=this._getTextWidth(x),l>=y)){this._addTextLine(x,y),n+=e,d=Math.max(d,y);break}}else this._addTextLine(x,y),n+=e,d=Math.max(d,y);if(j&&n+e>m)break}v.restore(),this.textHeight=b,this.textWidth=d}},Kinetic.Util.extend(Kinetic.Text,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Text,"fontFamily","Arial"),Kinetic.Factory.addGetterSetter(Kinetic.Text,"fontSize",12),Kinetic.Factory.addGetterSetter(Kinetic.Text,"fontStyle",m),Kinetic.Factory.addGetterSetter(Kinetic.Text,"fontVariant",m),Kinetic.Factory.addGetterSetter(Kinetic.Text,"padding",0),Kinetic.Factory.addGetterSetter(Kinetic.Text,"align",i),Kinetic.Factory.addGetterSetter(Kinetic.Text,"lineHeight",1),Kinetic.Factory.addGetterSetter(Kinetic.Text,"wrap",q),Kinetic.Factory.addGetter(Kinetic.Text,"text",h),Kinetic.Factory.addOverloadedGetterSetter(Kinetic.Text,"text"),Kinetic.Collection.mapMethods(Kinetic.Text)}(),function(){Kinetic.Line=function(a){this.___init(a)},Kinetic.Line.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Line",this.on("pointsChange.kinetic tensionChange.kinetic closedChange.kinetic",function(){this._clearCache("tensionPoints")}),this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b,c,d,e=this.getPoints(),f=e.length,g=this.getTension(),h=this.getClosed();if(f){if(a.beginPath(),a.moveTo(e[0],e[1]),0!==g&&f>4){for(b=this.getTensionPoints(),c=b.length,d=h?0:4,h||a.quadraticCurveTo(b[0],b[1],b[2],b[3]);c-2>d;)a.bezierCurveTo(b[d++],b[d++],b[d++],b[d++],b[d++],b[d++]);h||a.quadraticCurveTo(b[c-2],b[c-1],e[f-2],e[f-1])}else for(d=2;f>d;d+=2)a.lineTo(e[d],e[d+1]);h?(a.closePath(),a.fillStrokeShape(this)):a.strokeShape(this)}},getTensionPoints:function(){return this._getCache("tensionPoints",this._getTensionPoints)},_getTensionPoints:function(){return this.getClosed()?this._getTensionPointsClosed():Kinetic.Util._expandPoints(this.getPoints(),this.getTension())},_getTensionPointsClosed:function(){var a=this.getPoints(),b=a.length,c=this.getTension(),d=Kinetic.Util,e=d._getControlPoints(a[b-2],a[b-1],a[0],a[1],a[2],a[3],c),f=d._getControlPoints(a[b-4],a[b-3],a[b-2],a[b-1],a[0],a[1],c),g=Kinetic.Util._expandPoints(a,c),h=[e[2],e[3]].concat(g).concat([f[0],f[1],a[b-2],a[b-1],f[2],f[3],e[0],e[1],a[0],a[1]]);return h}},Kinetic.Util.extend(Kinetic.Line,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Line,"closed",!1),Kinetic.Factory.addGetterSetter(Kinetic.Line,"tension",0),Kinetic.Factory.addGetterSetter(Kinetic.Line,"points",[]),Kinetic.Collection.mapMethods(Kinetic.Line)}(),function(){Kinetic.Sprite=function(a){this.___init(a)},Kinetic.Sprite.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Sprite",this._updated=!0;var b=this;this.anim=new Kinetic.Animation(function(){var a=b._updated;return b._updated=!1,a}),this.on("animationChange.kinetic",function(){this.frameIndex(0)}),this.on("frameIndexChange.kinetic",function(){this._updated=!0}),this.on("frameRateChange.kinetic",function(){this.anim.isRunning()&&(clearInterval(this.interval),this._setInterval())}),this.sceneFunc(this._sceneFunc),this.hitFunc(this._hitFunc)},_sceneFunc:function(a){var b=this.getAnimation(),c=this.frameIndex(),d=4*c,e=this.getAnimations()[b],f=this.frameOffsets(),g=e[d+0],h=e[d+1],i=e[d+2],j=e[d+3],k=this.getImage();if(k)if(f){var l=f[b],m=2*c;a.drawImage(k,g,h,i,j,l[m+0],l[m+1],i,j)}else a.drawImage(k,g,h,i,j,0,0,i,j)},_hitFunc:function(a){var b=this.getAnimation(),c=this.frameIndex(),d=4*c,e=this.getAnimations()[b],f=this.frameOffsets(),g=e[d+2],h=e[d+3];if(a.beginPath(),f){var i=f[b],j=2*c;a.rect(i[j+0],i[j+1],g,h)}else a.rect(0,0,g,h);a.closePath(),a.fillShape(this)},_useBufferCanvas:function(){return(this.hasShadow()||1!==this.getAbsoluteOpacity())&&this.hasStroke()},_setInterval:function(){var a=this;this.interval=setInterval(function(){a._updateIndex()},1e3/this.getFrameRate())},start:function(){var a=this.getLayer();this.anim.setLayers(a),this._setInterval(),this.anim.start()},stop:function(){this.anim.stop(),clearInterval(this.interval)},isRunning:function(){return this.anim.isRunning()},_updateIndex:function(){var a=this.frameIndex(),b=this.getAnimation(),c=this.getAnimations(),d=c[b],e=d.length/4;this.frameIndex(e-1>a?a+1:0)}},Kinetic.Util.extend(Kinetic.Sprite,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Sprite,"animation"),Kinetic.Factory.addGetterSetter(Kinetic.Sprite,"animations"),Kinetic.Factory.addGetterSetter(Kinetic.Sprite,"frameOffsets"),Kinetic.Factory.addGetterSetter(Kinetic.Sprite,"image"),Kinetic.Factory.addGetterSetter(Kinetic.Sprite,"frameIndex",0),Kinetic.Factory.addGetterSetter(Kinetic.Sprite,"frameRate",17),Kinetic.Factory.backCompat(Kinetic.Sprite,{index:"frameIndex",getIndex:"getFrameIndex",setIndex:"setFrameIndex"}),Kinetic.Collection.mapMethods(Kinetic.Sprite)}(),function(){Kinetic.Path=function(a){this.___init(a)},Kinetic.Path.prototype={___init:function(a){this.dataArray=[];var b=this;Kinetic.Shape.call(this,a),this.className="Path",this.dataArray=Kinetic.Path.parsePathData(this.getData()),this.on("dataChange.kinetic",function(){b.dataArray=Kinetic.Path.parsePathData(this.getData())}),this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b=this.dataArray,c=!1;a.beginPath();for(var d=0;d<b.length;d++){var e=b[d].command,f=b[d].points;switch(e){case"L":a.lineTo(f[0],f[1]);break;case"M":a.moveTo(f[0],f[1]);break;case"C":a.bezierCurveTo(f[0],f[1],f[2],f[3],f[4],f[5]);break;case"Q":a.quadraticCurveTo(f[0],f[1],f[2],f[3]);break;case"A":var g=f[0],h=f[1],i=f[2],j=f[3],k=f[4],l=f[5],m=f[6],n=f[7],o=i>j?i:j,p=i>j?1:i/j,q=i>j?j/i:1;a.translate(g,h),a.rotate(m),a.scale(p,q),a.arc(0,0,o,k,k+l,1-n),a.scale(1/p,1/q),a.rotate(-m),a.translate(-g,-h);break;case"z":a.closePath(),c=!0}}c?a.fillStrokeShape(this):a.strokeShape(this)}},Kinetic.Util.extend(Kinetic.Path,Kinetic.Shape),Kinetic.Path.getLineLength=function(a,b,c,d){return Math.sqrt((c-a)*(c-a)+(d-b)*(d-b))},Kinetic.Path.getPointOnLine=function(a,b,c,d,e,f,g){void 0===f&&(f=b),void 0===g&&(g=c);var h=(e-c)/(d-b+1e-8),i=Math.sqrt(a*a/(1+h*h));b>d&&(i*=-1);var j,k=h*i;if(d===b)j={x:f,y:g+k};else if((g-c)/(f-b+1e-8)===h)j={x:f+i,y:g+k};else{var l,m,n=this.getLineLength(b,c,d,e);if(1e-8>n)return void 0;var o=(f-b)*(d-b)+(g-c)*(e-c);o/=n*n,l=b+o*(d-b),m=c+o*(e-c);var p=this.getLineLength(f,g,l,m),q=Math.sqrt(a*a-p*p);i=Math.sqrt(q*q/(1+h*h)),b>d&&(i*=-1),k=h*i,j={x:l+i,y:m+k}}return j},Kinetic.Path.getPointOnCubicBezier=function(a,b,c,d,e,f,g,h,i){function j(a){return a*a*a}function k(a){return 3*a*a*(1-a)}function l(a){return 3*a*(1-a)*(1-a)}function m(a){return(1-a)*(1-a)*(1-a)}var n=h*j(a)+f*k(a)+d*l(a)+b*m(a),o=i*j(a)+g*k(a)+e*l(a)+c*m(a);return{x:n,y:o}},Kinetic.Path.getPointOnQuadraticBezier=function(a,b,c,d,e,f,g){function h(a){return a*a}function i(a){return 2*a*(1-a)}function j(a){return(1-a)*(1-a)}var k=f*h(a)+d*i(a)+b*j(a),l=g*h(a)+e*i(a)+c*j(a);return{x:k,y:l}},Kinetic.Path.getPointOnEllipticalArc=function(a,b,c,d,e,f){var g=Math.cos(f),h=Math.sin(f),i={x:c*Math.cos(e),y:d*Math.sin(e)};return{x:a+(i.x*g-i.y*h),y:b+(i.x*h+i.y*g)}},Kinetic.Path.parsePathData=function(a){if(!a)return[];var b=a,c=["m","M","l","L","v","V","h","H","z","Z","c","C","q","Q","t","T","s","S","a","A"];b=b.replace(new RegExp(" ","g"),",");for(var d=0;d<c.length;d++)b=b.replace(new RegExp(c[d],"g"),"|"+c[d]);var e=b.split("|"),f=[],g=0,h=0;for(d=1;d<e.length;d++){var i=e[d],j=i.charAt(0);i=i.slice(1),i=i.replace(new RegExp(",-","g"),"-"),i=i.replace(new RegExp("-","g"),",-"),i=i.replace(new RegExp("e,-","g"),"e-");var k=i.split(",");k.length>0&&""===k[0]&&k.shift();for(var l=0;l<k.length;l++)k[l]=parseFloat(k[l]);for(;k.length>0&&!isNaN(k[0]);){var m,n,o,p,q,r,s,t,u,v,w=null,x=[],y=g,z=h;switch(j){case"l":g+=k.shift(),h+=k.shift(),w="L",x.push(g,h);break;case"L":g=k.shift(),h=k.shift(),x.push(g,h);break;case"m":var A=k.shift(),B=k.shift();if(g+=A,h+=B,w="M",f.length>2&&"z"===f[f.length-1].command)for(var C=f.length-2;C>=0;C--)if("M"===f[C].command){g=f[C].points[0]+A,h=f[C].points[1]+B;break}x.push(g,h),j="l";break;case"M":g=k.shift(),h=k.shift(),w="M",x.push(g,h),j="L";break;case"h":g+=k.shift(),w="L",x.push(g,h);break;case"H":g=k.shift(),w="L",x.push(g,h);break;case"v":h+=k.shift(),w="L",x.push(g,h);break;case"V":h=k.shift(),w="L",x.push(g,h);break;case"C":x.push(k.shift(),k.shift(),k.shift(),k.shift()),g=k.shift(),h=k.shift(),x.push(g,h);break;case"c":x.push(g+k.shift(),h+k.shift(),g+k.shift(),h+k.shift()),g+=k.shift(),h+=k.shift(),w="C",x.push(g,h);break;case"S":n=g,o=h,m=f[f.length-1],"C"===m.command&&(n=g+(g-m.points[2]),o=h+(h-m.points[3])),x.push(n,o,k.shift(),k.shift()),g=k.shift(),h=k.shift(),w="C",x.push(g,h);break;case"s":n=g,o=h,m=f[f.length-1],"C"===m.command&&(n=g+(g-m.points[2]),o=h+(h-m.points[3])),x.push(n,o,g+k.shift(),h+k.shift()),g+=k.shift(),h+=k.shift(),w="C",x.push(g,h);break;case"Q":x.push(k.shift(),k.shift()),g=k.shift(),h=k.shift(),x.push(g,h);break;case"q":x.push(g+k.shift(),h+k.shift()),g+=k.shift(),h+=k.shift(),w="Q",x.push(g,h);break;case"T":n=g,o=h,m=f[f.length-1],"Q"===m.command&&(n=g+(g-m.points[0]),o=h+(h-m.points[1])),g=k.shift(),h=k.shift(),w="Q",x.push(n,o,g,h);break;case"t":n=g,o=h,m=f[f.length-1],"Q"===m.command&&(n=g+(g-m.points[0]),o=h+(h-m.points[1])),g+=k.shift(),h+=k.shift(),w="Q",x.push(n,o,g,h);break;case"A":p=k.shift(),q=k.shift(),r=k.shift(),s=k.shift(),t=k.shift(),u=g,v=h,g=k.shift(),h=k.shift(),w="A",x=this.convertEndpointToCenterParameterization(u,v,g,h,s,t,p,q,r);break;case"a":p=k.shift(),q=k.shift(),r=k.shift(),s=k.shift(),t=k.shift(),u=g,v=h,g+=k.shift(),h+=k.shift(),w="A",x=this.convertEndpointToCenterParameterization(u,v,g,h,s,t,p,q,r)}f.push({command:w||j,points:x,start:{x:y,y:z},pathLength:this.calcLength(y,z,w||j,x)})}("z"===j||"Z"===j)&&f.push({command:"z",points:[],start:void 0,pathLength:0})}return f},Kinetic.Path.calcLength=function(a,b,c,d){var e,f,g,h,i=Kinetic.Path;switch(c){case"L":return i.getLineLength(a,b,d[0],d[1]);case"C":for(e=0,f=i.getPointOnCubicBezier(0,a,b,d[0],d[1],d[2],d[3],d[4],d[5]),h=.01;1>=h;h+=.01)g=i.getPointOnCubicBezier(h,a,b,d[0],d[1],d[2],d[3],d[4],d[5]),e+=i.getLineLength(f.x,f.y,g.x,g.y),f=g;return e;case"Q":for(e=0,f=i.getPointOnQuadraticBezier(0,a,b,d[0],d[1],d[2],d[3]),h=.01;1>=h;h+=.01)g=i.getPointOnQuadraticBezier(h,a,b,d[0],d[1],d[2],d[3]),e+=i.getLineLength(f.x,f.y,g.x,g.y),f=g;return e;case"A":e=0;var j=d[4],k=d[5],l=d[4]+k,m=Math.PI/180;if(Math.abs(j-l)<m&&(m=Math.abs(j-l)),f=i.getPointOnEllipticalArc(d[0],d[1],d[2],d[3],j,0),0>k)for(h=j-m;h>l;h-=m)g=i.getPointOnEllipticalArc(d[0],d[1],d[2],d[3],h,0),e+=i.getLineLength(f.x,f.y,g.x,g.y),f=g;else for(h=j+m;l>h;h+=m)g=i.getPointOnEllipticalArc(d[0],d[1],d[2],d[3],h,0),e+=i.getLineLength(f.x,f.y,g.x,g.y),f=g;return g=i.getPointOnEllipticalArc(d[0],d[1],d[2],d[3],l,0),e+=i.getLineLength(f.x,f.y,g.x,g.y)}return 0},Kinetic.Path.convertEndpointToCenterParameterization=function(a,b,c,d,e,f,g,h,i){var j=i*(Math.PI/180),k=Math.cos(j)*(a-c)/2+Math.sin(j)*(b-d)/2,l=-1*Math.sin(j)*(a-c)/2+Math.cos(j)*(b-d)/2,m=k*k/(g*g)+l*l/(h*h);m>1&&(g*=Math.sqrt(m),h*=Math.sqrt(m));var n=Math.sqrt((g*g*h*h-g*g*l*l-h*h*k*k)/(g*g*l*l+h*h*k*k));e===f&&(n*=-1),isNaN(n)&&(n=0);var o=n*g*l/h,p=n*-h*k/g,q=(a+c)/2+Math.cos(j)*o-Math.sin(j)*p,r=(b+d)/2+Math.sin(j)*o+Math.cos(j)*p,s=function(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1])},t=function(a,b){return(a[0]*b[0]+a[1]*b[1])/(s(a)*s(b))},u=function(a,b){return(a[0]*b[1]<a[1]*b[0]?-1:1)*Math.acos(t(a,b))},v=u([1,0],[(k-o)/g,(l-p)/h]),w=[(k-o)/g,(l-p)/h],x=[(-1*k-o)/g,(-1*l-p)/h],y=u(w,x);return t(w,x)<=-1&&(y=Math.PI),t(w,x)>=1&&(y=0),0===f&&y>0&&(y-=2*Math.PI),1===f&&0>y&&(y+=2*Math.PI),[q,r,g,h,v,y,j,f]},Kinetic.Factory.addGetterSetter(Kinetic.Path,"data"),Kinetic.Collection.mapMethods(Kinetic.Path)}(),function(){function a(a){a.fillText(this.partialText,0,0)}function b(a){a.strokeText(this.partialText,0,0)}var c="",d="normal";Kinetic.TextPath=function(a){this.___init(a)},Kinetic.TextPath.prototype={___init:function(c){var d=this;this.dummyCanvas=Kinetic.Util.createCanvasElement(),this.dataArray=[],Kinetic.Shape.call(this,c),this._fillFunc=a,this._strokeFunc=b,this._fillFuncHit=a,this._strokeFuncHit=b,this.className="TextPath",this.dataArray=Kinetic.Path.parsePathData(this.attrs.data),this.on("dataChange.kinetic",function(){d.dataArray=Kinetic.Path.parsePathData(this.attrs.data)}),this.on("textChange.kinetic textStroke.kinetic textStrokeWidth.kinetic",d._setTextData),d._setTextData(),this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){a.setAttr("font",this._getContextFont()),a.setAttr("textBaseline","middle"),a.setAttr("textAlign","left"),a.save();for(var b=this.glyphInfo,c=0;c<b.length;c++){a.save();var d=b[c].p0;a.translate(d.x,d.y),a.rotate(b[c].rotation),this.partialText=b[c].text,a.fillStrokeShape(this),a.restore()}a.restore()},getTextWidth:function(){return this.textWidth},getTextHeight:function(){return this.textHeight},setText:function(a){Kinetic.Text.prototype.setText.call(this,a)},_getTextSize:function(a){var b=this.dummyCanvas,c=b.getContext("2d");c.save(),c.font=this._getContextFont();var d=c.measureText(a);return c.restore(),{width:d.width,height:parseInt(this.attrs.fontSize,10)}},_setTextData:function(){var a=this,b=this._getTextSize(this.attrs.text);this.textWidth=b.width,this.textHeight=b.height,this.glyphInfo=[];for(var c,d,e,f=this.attrs.text.split(""),g=-1,h=0,i=function(){h=0;for(var b=a.dataArray,d=g+1;d<b.length;d++){if(b[d].pathLength>0)return g=d,b[d];"M"==b[d].command&&(c={x:b[d].points[0],y:b[d].points[1]})}return{}},j=function(b){var f=a._getTextSize(b).width,g=0,j=0;for(d=void 0;Math.abs(f-g)/f>.01&&25>j;){j++;for(var k=g;void 0===e;)e=i(),e&&k+e.pathLength<f&&(k+=e.pathLength,e=void 0);if(e==={}||void 0===c)return void 0;var l=!1;switch(e.command){case"L":Kinetic.Path.getLineLength(c.x,c.y,e.points[0],e.points[1])>f?d=Kinetic.Path.getPointOnLine(f,c.x,c.y,e.points[0],e.points[1],c.x,c.y):e=void 0;break;case"A":var m=e.points[4],n=e.points[5],o=e.points[4]+n;0===h?h=m+1e-8:f>g?h+=Math.PI/180*n/Math.abs(n):h-=Math.PI/360*n/Math.abs(n),(0>n&&o>h||n>=0&&h>o)&&(h=o,l=!0),d=Kinetic.Path.getPointOnEllipticalArc(e.points[0],e.points[1],e.points[2],e.points[3],h,e.points[6]);break;case"C":0===h?h=f>e.pathLength?1e-8:f/e.pathLength:f>g?h+=(f-g)/e.pathLength:h-=(g-f)/e.pathLength,h>1&&(h=1,l=!0),d=Kinetic.Path.getPointOnCubicBezier(h,e.start.x,e.start.y,e.points[0],e.points[1],e.points[2],e.points[3],e.points[4],e.points[5]);break;case"Q":0===h?h=f/e.pathLength:f>g?h+=(f-g)/e.pathLength:h-=(g-f)/e.pathLength,h>1&&(h=1,l=!0),d=Kinetic.Path.getPointOnQuadraticBezier(h,e.start.x,e.start.y,e.points[0],e.points[1],e.points[2],e.points[3])}void 0!==d&&(g=Kinetic.Path.getLineLength(c.x,c.y,d.x,d.y)),l&&(l=!1,e=void 0)}},k=0;k<f.length&&(j(f[k]),void 0!==c&&void 0!==d);k++){var l=Kinetic.Path.getLineLength(c.x,c.y,d.x,d.y),m=0,n=Kinetic.Path.getPointOnLine(m+l/2,c.x,c.y,d.x,d.y),o=Math.atan2(d.y-c.y,d.x-c.x);this.glyphInfo.push({transposeX:n.x,transposeY:n.y,text:f[k],rotation:o,p0:c,p1:d}),c=d}}},Kinetic.TextPath.prototype._getContextFont=Kinetic.Text.prototype._getContextFont,Kinetic.Util.extend(Kinetic.TextPath,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.TextPath,"fontFamily","Arial"),Kinetic.Factory.addGetterSetter(Kinetic.TextPath,"fontSize",12),Kinetic.Factory.addGetterSetter(Kinetic.TextPath,"fontStyle",d),Kinetic.Factory.addGetterSetter(Kinetic.TextPath,"fontVariant",d),Kinetic.Factory.addGetter(Kinetic.TextPath,"text",c),Kinetic.Collection.mapMethods(Kinetic.TextPath)}(),function(){Kinetic.RegularPolygon=function(a){this.___init(a)},Kinetic.RegularPolygon.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="RegularPolygon",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b,c,d,e=this.attrs.sides,f=this.attrs.radius;for(a.beginPath(),a.moveTo(0,0-f),b=1;e>b;b++)c=f*Math.sin(2*b*Math.PI/e),d=-1*f*Math.cos(2*b*Math.PI/e),a.lineTo(c,d);a.closePath(),a.fillStrokeShape(this)}},Kinetic.Util.extend(Kinetic.RegularPolygon,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.RegularPolygon,"radius",0),Kinetic.Factory.addGetterSetter(Kinetic.RegularPolygon,"sides",0),Kinetic.Collection.mapMethods(Kinetic.RegularPolygon)}(),function(){Kinetic.Star=function(a){this.___init(a)},Kinetic.Star.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Star",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b=this.innerRadius(),c=this.outerRadius(),d=this.numPoints();a.beginPath(),a.moveTo(0,0-c);for(var e=1;2*d>e;e++){var f=e%2===0?c:b,g=f*Math.sin(e*Math.PI/d),h=-1*f*Math.cos(e*Math.PI/d);a.lineTo(g,h)}a.closePath(),a.fillStrokeShape(this)}},Kinetic.Util.extend(Kinetic.Star,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Star,"numPoints",5),Kinetic.Factory.addGetterSetter(Kinetic.Star,"innerRadius",0),Kinetic.Factory.addGetterSetter(Kinetic.Star,"outerRadius",0),Kinetic.Collection.mapMethods(Kinetic.Star)}(),function(){var a=["fontFamily","fontSize","fontStyle","padding","lineHeight","text"],b="Change.kinetic",c="none",d="up",e="right",f="down",g="left",h="Label",i=a.length;Kinetic.Label=function(a){this.____init(a)},Kinetic.Label.prototype={____init:function(a){var b=this;Kinetic.Group.call(this,a),this.className=h,this.on("add.kinetic",function(a){b._addListeners(a.child),b._sync()})},getText:function(){return this.find("Text")[0]},getTag:function(){return this.find("Tag")[0]},_addListeners:function(c){var d,e=this,f=function(){e._sync()};for(d=0;i>d;d++)c.on(a[d]+b,f)},getWidth:function(){return this.getText().getWidth()},getHeight:function(){return this.getText().getHeight()},_sync:function(){var a,b,c,h,i,j,k,l=this.getText(),m=this.getTag();if(l&&m){switch(a=l.getWidth(),b=l.getHeight(),c=m.getPointerDirection(),h=m.getPointerWidth(),k=m.getPointerHeight(),i=0,j=0,c){case d:i=a/2,j=-1*k;break;case e:i=a+h,j=b/2;break;case f:i=a/2,j=b+k;break;case g:i=-1*h,j=b/2}m.setAttrs({x:-1*i,y:-1*j,width:a,height:b}),l.setAttrs({x:-1*i,y:-1*j})}}},Kinetic.Util.extend(Kinetic.Label,Kinetic.Group),Kinetic.Collection.mapMethods(Kinetic.Label),Kinetic.Tag=function(a){this.___init(a)},Kinetic.Tag.prototype={___init:function(a){Kinetic.Shape.call(this,a),this.className="Tag",this.sceneFunc(this._sceneFunc)},_sceneFunc:function(a){var b=this.getWidth(),c=this.getHeight(),h=this.getPointerDirection(),i=this.getPointerWidth(),j=this.getPointerHeight(),k=this.getCornerRadius();a.beginPath(),a.moveTo(0,0),h===d&&(a.lineTo((b-i)/2,0),a.lineTo(b/2,-1*j),a.lineTo((b+i)/2,0)),k?(a.lineTo(b-k,0),a.arc(b-k,k,k,3*Math.PI/2,0,!1)):a.lineTo(b,0),h===e&&(a.lineTo(b,(c-j)/2),a.lineTo(b+i,c/2),a.lineTo(b,(c+j)/2)),k?(a.lineTo(b,c-k),a.arc(b-k,c-k,k,0,Math.PI/2,!1)):a.lineTo(b,c),h===f&&(a.lineTo((b+i)/2,c),a.lineTo(b/2,c+j),a.lineTo((b-i)/2,c)),k?(a.lineTo(k,c),a.arc(k,c-k,k,Math.PI/2,Math.PI,!1)):a.lineTo(0,c),h===g&&(a.lineTo(0,(c+j)/2),a.lineTo(-1*i,c/2),a.lineTo(0,(c-j)/2)),k&&(a.lineTo(0,k),a.arc(k,k,k,Math.PI,3*Math.PI/2,!1)),a.closePath(),a.fillStrokeShape(this)}},Kinetic.Util.extend(Kinetic.Tag,Kinetic.Shape),Kinetic.Factory.addGetterSetter(Kinetic.Tag,"pointerDirection",c),Kinetic.Factory.addGetterSetter(Kinetic.Tag,"pointerWidth",0),Kinetic.Factory.addGetterSetter(Kinetic.Tag,"pointerHeight",0),Kinetic.Factory.addGetterSetter(Kinetic.Tag,"cornerRadius",0),Kinetic.Collection.mapMethods(Kinetic.Tag)}(),function(){Kinetic.Arrow=function(a){this.____init(a)},Kinetic.Arrow.prototype={____init:function(a){Kinetic.Line.call(this,a),this.className="Arrow"},_sceneFunc:function(a){var b=2*Math.PI,c=this.points(),d=c.length,e=c[d-2]-c[d-4],f=c[d-1]-c[d-3],g=(Math.atan2(f,e)+b)%b,h=this.pointerLength(),i=this.pointerWidth();a.save(),a.beginPath(),a.translate(c[d-2],c[d-1]),a.rotate(g),a.moveTo(0,0),a.lineTo(-h,i/2),a.lineTo(-h,-i/2),a.closePath(),a.restore(),this.pointerAtBeginning()&&(a.save(),a.translate(c[0],c[1]),e=c[2]-c[0],f=c[3]-c[1],a.rotate((Math.atan2(-f,-e)+b)%b),a.moveTo(0,0),a.lineTo(-10,6),a.lineTo(-10,-6),a.closePath(),a.restore()),a.fillStrokeShape(this),Kinetic.Line.prototype._sceneFunc.apply(this,arguments)}},Kinetic.Util.extend(Kinetic.Arrow,Kinetic.Line),Kinetic.Factory.addGetterSetter(Kinetic.Arrow,"pointerLength",10),Kinetic.Factory.addGetterSetter(Kinetic.Arrow,"pointerWidth",10),Kinetic.Factory.addGetterSetter(Kinetic.Arrow,"pointerAtBeginning",!1),Kinetic.Collection.mapMethods(Kinetic.Arrow)}();;/**
 * Copyright (c) 2007-2014 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT
 * @author Ariel Flesler
 * @version 1.4.14
 */
;(function(k){'use strict';k(['jquery'],function($){var j=$.scrollTo=function(a,b,c){return $(window).scrollTo(a,b,c)};j.defaults={axis:'xy',duration:0,limit:!0};j.window=function(a){return $(window)._scrollable()};$.fn._scrollable=function(){return this.map(function(){var a=this,isWin=!a.nodeName||$.inArray(a.nodeName.toLowerCase(),['iframe','#document','html','body'])!=-1;if(!isWin)return a;var b=(a.contentWindow||a).document||a.ownerDocument||a;return/webkit/i.test(navigator.userAgent)||b.compatMode=='BackCompat'?b.body:b.documentElement})};$.fn.scrollTo=function(f,g,h){if(typeof g=='object'){h=g;g=0}if(typeof h=='function')h={onAfter:h};if(f=='max')f=9e9;h=$.extend({},j.defaults,h);g=g||h.duration;h.queue=h.queue&&h.axis.length>1;if(h.queue)g/=2;h.offset=both(h.offset);h.over=both(h.over);return this._scrollable().each(function(){if(f==null)return;var d=this,$elem=$(d),targ=f,toff,attr={},win=$elem.is('html,body');switch(typeof targ){case'number':case'string':if(/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)){targ=both(targ);break}targ=win?$(targ):$(targ,this);if(!targ.length)return;case'object':if(targ.is||targ.style)toff=(targ=$(targ)).offset()}var e=$.isFunction(h.offset)&&h.offset(d,targ)||h.offset;$.each(h.axis.split(''),function(i,a){var b=a=='x'?'Left':'Top',pos=b.toLowerCase(),key='scroll'+b,old=d[key],max=j.max(d,a);if(toff){attr[key]=toff[pos]+(win?0:old-$elem.offset()[pos]);if(h.margin){attr[key]-=parseInt(targ.css('margin'+b))||0;attr[key]-=parseInt(targ.css('border'+b+'Width'))||0}attr[key]+=e[pos]||0;if(h.over[pos])attr[key]+=targ[a=='x'?'width':'height']()*h.over[pos]}else{var c=targ[pos];attr[key]=c.slice&&c.slice(-1)=='%'?parseFloat(c)/100*max:c}if(h.limit&&/^\d+$/.test(attr[key]))attr[key]=attr[key]<=0?0:Math.min(attr[key],max);if(!i&&h.queue){if(old!=attr[key])animate(h.onAfterFirst);delete attr[key]}});animate(h.onAfter);function animate(a){$elem.animate(attr,g,h.easing,a&&function(){a.call(this,targ,h)})}}).end()};j.max=function(a,b){var c=b=='x'?'Width':'Height',scroll='scroll'+c;if(!$(a).is('html,body'))return a[scroll]-$(a)[c.toLowerCase()]();var d='client'+c,html=a.ownerDocument.documentElement,body=a.ownerDocument.body;return Math.max(html[scroll],body[scroll])-Math.min(html[d],body[d])};function both(a){return $.isFunction(a)||$.isPlainObject(a)?a:{top:a,left:a}}return j})}(typeof define==='function'&&define.amd?define:function(a,b){if(typeof module!=='undefined'&&module.exports){module.exports=b(require('jquery'))}else{b(jQuery)}}));;/**
 * A small plugin for getting the CSV of a rendered chart
 */
/*global Highcharts, document */
(function (Highcharts) {

    'use strict';

    var each = Highcharts.each,
        downloadAttrSupported = document.createElement('a').download !== undefined;


    Highcharts.Chart.prototype.getCSV = function () {
        var columns = [],
            line,
            csv = '',
            row,
            col,
            maxRows,
            options = (this.options.exporting || {}).csv || {},

            // Options
            dateFormat = options.dateFormat || '%Y-%m-%d %H:%M:%S',
            itemDelimiter = options.itemDelimiter || ';', // use ';' for direct import to Excel
            lineDelimiter = options.lineDelimiter || '\n'; // '\n' isn't working with the js csv data extraction


        each(this.series, function (series) {
            if (series.options.includeInCSVExport !== false) {
                if (series.xAxis) {
                    var xData = series.xData.slice(),
                        xTitle = 'X values';
                    if (series.xAxis.isDatetimeAxis) {
                        xData = Highcharts.map(xData, function (x) {
                            return Highcharts.dateFormat(dateFormat, x);
                        });
                        xTitle = 'DateTime';
                    } else if (series.xAxis.categories) {
                        xData = Highcharts.map(xData, function (x) {
                            return Highcharts.pick(series.xAxis.categories[x], x);
                        });
                        xTitle = 'Category';
                    }
                    columns.push(xData);
                    columns[columns.length - 1].unshift(xTitle);
                }
                columns.push(series.yData.slice());
                columns[columns.length - 1].unshift(series.name);
            }
        });

        // Transform the columns to CSV
        maxRows = Math.max.apply(this, Highcharts.map(columns, function (col) { return col.length; }));
        for (row = 0; row < maxRows; row = row + 1) {
            line = [];
            for (col = 0; col < columns.length; col = col + 1) {
                line.push(columns[col][row]);
            }
            csv += line.join(itemDelimiter) + lineDelimiter;
        }

        return csv;
    };

    // Add "Download CSV" to the exporting menu. Use download attribute if supported, else
    // run a simple PHP script that returns a file. The source code for the PHP script can be viewed at
    // https://raw.github.com/highslide-software/highcharts.com/master/studies/csv-export/csv.php
    if (Highcharts.getOptions().exporting) {
        Highcharts.getOptions().exporting.buttons.contextButton.menuItems.push({
            text: Highcharts.getOptions().lang.downloadCSV || 'Save as CSV',
            onclick: function () {
                var a;

                // Download attribute supported
                if (downloadAttrSupported) {
                    // Client side extraction
                    a = document.createElement('a');
                    a.href        = 'data:attachment/csv,' + this.getCSV().replace(/\n/g, '%0A');
                    a.target      = '_blank';
                    a.download    = (this.title ? this.title.textStr.replace(/ /g, '-').toLowerCase() : 'chart') + '.csv';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();

                // Fall back to server side handling
                } else {
                    Highcharts.post('http://www.highcharts.com/studies/csv-export/csv.php', {
                        csv: this.getCSV()
                    });
                }

            }
        });
    }
}(Highcharts));
;// jQuery.XDomainRequest.js
// Author: Jason Moon - @JSONMOON
// IE8+
(function($){

if (!$.support.cors && $.ajaxTransport && window.XDomainRequest) {
  var httpRegEx = /^https?:\/\//i;
  var getOrPostRegEx = /^get|post$/i;
  var sameSchemeRegEx = new RegExp('^'+location.protocol, 'i');
  var htmlRegEx = /text\/html/i;
  var jsonRegEx = /\/json/i;
  var xmlRegEx = /\/xml/i;
  
  // ajaxTransport exists in jQuery 1.5+
  $.ajaxTransport('* text html xml json', function(options, userOptions, jqXHR){
    // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page
    if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(options.url) && sameSchemeRegEx.test(options.url)) {
      var xdr = null;
      var userType = (userOptions.dataType||'').toLowerCase();
      return {
        send: function(headers, complete){
          xdr = new XDomainRequest();
          if (/^\d+$/.test(userOptions.timeout)) {
            xdr.timeout = userOptions.timeout;
          }
          xdr.ontimeout = function(){
            complete(500, 'timeout');
          };
          xdr.onload = function(){
            var allResponseHeaders = 'Content-Length: ' + xdr.responseText.length + '\r\nContent-Type: ' + xdr.contentType;
            var status = {
              code: 200,
              message: 'success'
            };
            var responses = {
              text: xdr.responseText
            };
            try {
              if (userType === 'html' || htmlRegEx.test(xdr.contentType)) {
                responses.html = xdr.responseText;
              } else if (userType === 'json' || (userType !== 'text' && jsonRegEx.test(xdr.contentType))) {
                try {
                  responses.json = $.parseJSON(xdr.responseText);
                } catch(e) {
                  status.code = 500;
                  status.message = 'parseerror';
                  //throw 'Invalid JSON: ' + xdr.responseText;
                }
              } else if (userType === 'xml' || (userType !== 'text' && xmlRegEx.test(xdr.contentType))) {
                var doc = new ActiveXObject('Microsoft.XMLDOM');
                doc.async = false;
                try {
                  doc.loadXML(xdr.responseText);
                } catch(e) {
                  doc = undefined;
                }
                if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
                  status.code = 500;
                  status.message = 'parseerror';
                  throw 'Invalid XML: ' + xdr.responseText;
                }
                responses.xml = doc;
              }
            } catch(parseMessage) {
              throw parseMessage;
            } finally {
              complete(status.code, status.message, responses, allResponseHeaders);
            }
          };
          // set an empty handler for 'onprogress' so requests don't get aborted
          xdr.onprogress = function(){};
          xdr.onerror = function(){
            complete(500, 'error', {
              text: xdr.responseText
            });
          };
          var postData = '';
          if (userOptions.data) {
            postData = ($.type(userOptions.data) === 'string') ? userOptions.data : $.param(userOptions.data);
          }
          xdr.open(options.type, options.url);
          xdr.send(postData);
        },
        abort: function(){
          if (xdr) {
            xdr.abort();
          }
        }
      };
    }
  });
}

})(jQuery);;/**
 * Copyright (c) 2007-2012 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * @author Ariel Flesler
 * @version 1.4.3.1
 */
;(function($){var h=$.scrollTo=function(a,b,c){$(window).scrollTo(a,b,c)};h.defaults={axis:'xy',duration:parseFloat($.fn.jquery)>=1.3?0:1,limit:true};h.window=function(a){return $(window)._scrollable()};$.fn._scrollable=function(){return this.map(function(){var a=this,isWin=!a.nodeName||$.inArray(a.nodeName.toLowerCase(),['iframe','#document','html','body'])!=-1;if(!isWin)return a;var b=(a.contentWindow||a).document||a.ownerDocument||a;return/webkit/i.test(navigator.userAgent)||b.compatMode=='BackCompat'?b.body:b.documentElement})};$.fn.scrollTo=function(e,f,g){if(typeof f=='object'){g=f;f=0}if(typeof g=='function')g={onAfter:g};if(e=='max')e=9e9;g=$.extend({},h.defaults,g);f=f||g.duration;g.queue=g.queue&&g.axis.length>1;if(g.queue)f/=2;g.offset=both(g.offset);g.over=both(g.over);return this._scrollable().each(function(){if(e==null)return;var d=this,$elem=$(d),targ=e,toff,attr={},win=$elem.is('html,body');switch(typeof targ){case'number':case'string':if(/^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(targ)){targ=both(targ);break}targ=$(targ,this);if(!targ.length)return;case'object':if(targ.is||targ.style)toff=(targ=$(targ)).offset()}$.each(g.axis.split(''),function(i,a){var b=a=='x'?'Left':'Top',pos=b.toLowerCase(),key='scroll'+b,old=d[key],max=h.max(d,a);if(toff){attr[key]=toff[pos]+(win?0:old-$elem.offset()[pos]);if(g.margin){attr[key]-=parseInt(targ.css('margin'+b))||0;attr[key]-=parseInt(targ.css('border'+b+'Width'))||0}attr[key]+=g.offset[pos]||0;if(g.over[pos])attr[key]+=targ[a=='x'?'width':'height']()*g.over[pos]}else{var c=targ[pos];attr[key]=c.slice&&c.slice(-1)=='%'?parseFloat(c)/100*max:c}if(g.limit&&/^\d+$/.test(attr[key]))attr[key]=attr[key]<=0?0:Math.min(attr[key],max);if(!i&&g.queue){if(old!=attr[key])animate(g.onAfterFirst);delete attr[key]}});animate(g.onAfter);function animate(a){$elem.animate(attr,f,g.easing,a&&function(){a.call(this,e,g)})}}).end()};h.max=function(a,b){var c=b=='x'?'Width':'Height',scroll='scroll'+c;if(!$(a).is('html,body'))return a[scroll]-$(a)[c.toLowerCase()]();var d='client'+c,html=a.ownerDocument.documentElement,body=a.ownerDocument.body;return Math.max(html[scroll],body[scroll])-Math.min(html[d],body[d])};function both(a){return typeof a=='object'?a:{top:a,left:a}}})(jQuery);;/*
 * simplyScroll 2 - a scroll-tastic jQuery plugin
 *
 * http://logicbox.net/jquery/simplyscroll/
 *
 * Copyright (c) 2009-2012 Will Kelly - http://logicbox.net
 *
 * Dual licensed under the MIT and GPL licenses.
 *
 * Version: 2.0.5 Last revised: 10/05/2012
 *
 */
(function(c,j,i){c.fn.simplyScroll=function(a){return this.each(function(){new c.simplyScroll(this,a)})};var h={customClass:"simply-scroll",frameRate:24,speed:1,orientation:"horizontal",auto:!0,autoMode:"loop",manualMode:"end",direction:"forwards",pauseOnHover:!0,pauseOnTouch:!0,pauseButton:!1,startOnLoad:!1};c.simplyScroll=function(a,b){var g=this;this.o=c.extend({},h,b||{});this.isAuto=!1!==this.o.auto&&null!==this.o.autoMode.match(/^loop|bounce$/);this.isRTL=(this.isHorizontal=null!==this.o.orientation.match(/^horizontal|vertical$/)&&
this.o.orientation==h.orientation)&&"rtl"==c("html").attr("dir");this.isForwards=!this.isAuto||this.isAuto&&(null!==this.o.direction.match(/^forwards|backwards$/)&&this.o.direction==h.direction)&&!this.isRTL;this.isLoop=this.isAuto&&"loop"==this.o.autoMode||!this.isAuto&&"loop"==this.o.manualMode;this.events=(this.supportsTouch="createTouch"in document)?{start:"touchstart MozTouchDown",move:"touchmove MozTouchMove",end:"touchend touchcancel MozTouchRelease"}:{start:"mouseenter",end:"mouseleave"};
this.$list=c(a);var d=this.$list.children();this.$list.addClass("simply-scroll-list").wrap('<div class="simply-scroll-clip"></div>').parent().wrap('<div class="'+this.o.customClass+' simply-scroll-container"></div>');this.isAuto?this.o.pauseButton&&(this.$list.parent().parent().prepend('<div class="simply-scroll-btn simply-scroll-btn-pause"></div>'),this.o.pauseOnHover=!1):this.$list.parent().parent().prepend('<div class="simply-scroll-forward"></div>').prepend('<div class="simply-scroll-back"></div>');
if(1<d.length){var f=!1,e=0;this.isHorizontal?(d.each(function(){e=e+c(this).outerWidth(true)}),f=d.eq(0).outerWidth(!0)*d.length!==e):(d.each(function(){e=e+c(this).outerHeight(true)}),f=d.eq(0).outerHeight(!0)*d.length!==e);f&&(this.$list=this.$list.wrap("<div></div>").parent().addClass("simply-scroll-list"),this.isHorizontal?this.$list.children().css({"float":"left",width:e+"px"}):this.$list.children().css({height:e+"px"}))}this.o.startOnLoad?c(j).load(function(){g.init()}):this.init()};c.simplyScroll.fn=
c.simplyScroll.prototype={};c.simplyScroll.fn.extend=c.simplyScroll.extend=c.extend;c.simplyScroll.fn.extend({init:function(){this.$items=this.$list.children();this.$clip=this.$list.parent();this.$container=this.$clip.parent();this.$btnBack=c(".simply-scroll-back",this.$container);this.$btnForward=c(".simply-scroll-forward",this.$container);this.isHorizontal?(this.itemMax=this.$items.eq(0).outerWidth(!0),this.clipMax=this.$clip.width(),this.dimension="width",this.moveBackClass="simply-scroll-btn-left",
this.moveForwardClass="simply-scroll-btn-right",this.scrollPos="Left"):(this.itemMax=this.$items.eq(0).outerHeight(!0),this.clipMax=this.$clip.height(),this.dimension="height",this.moveBackClass="simply-scroll-btn-up",this.moveForwardClass="simply-scroll-btn-down",this.scrollPos="Top");this.posMin=0;this.posMax=this.$items.length*this.itemMax;var a=Math.ceil(this.clipMax/this.itemMax);if(this.isAuto&&"loop"==this.o.autoMode)this.$list.css(this.dimension,this.posMax+this.itemMax*a+"px"),this.posMax+=
this.clipMax-this.o.speed,this.isForwards?(this.$items.slice(0,a).clone(!0).appendTo(this.$list),this.resetPosition=0):(this.$items.slice(-a).clone(!0).prependTo(this.$list),this.resetPosition=this.$items.length*this.itemMax,this.isRTL&&(this.$clip[0].dir="ltr",this.$items.css("float","right")));else if(!this.isAuto&&"loop"==this.o.manualMode){this.posMax+=this.itemMax*a;this.$list.css(this.dimension,this.posMax+this.itemMax*a+"px");this.posMax+=this.clipMax-this.o.speed;this.$items.slice(0,a).clone(!0).appendTo(this.$list);
this.$items.slice(-a).clone(!0).prependTo(this.$list);this.resetPositionForwards=this.resetPosition=a*this.itemMax;this.resetPositionBackwards=this.$items.length*this.itemMax;var b=this;this.$btnBack.bind(this.events.start,function(){b.isForwards=false;b.resetPosition=b.resetPositionBackwards});this.$btnForward.bind(this.events.start,function(){b.isForwards=true;b.resetPosition=b.resetPositionForwards})}else this.$list.css(this.dimension,this.posMax+"px"),this.isForwards?this.resetPosition=0:(this.resetPosition=
this.$items.length*this.itemMax,this.isRTL&&(this.$clip[0].dir="ltr",this.$items.css("float","right")));this.resetPos();this.interval=null;this.intervalDelay=Math.floor(1E3/this.o.frameRate);if(this.isAuto||"end"!=this.o.manualMode)for(;0!==this.itemMax%this.o.speed;)if(this.o.speed--,0===this.o.speed){this.o.speed=1;break}b=this;this.trigger=null;this.funcMoveBack=function(a){a!==i&&a.preventDefault();b.trigger=!b.isAuto&&b.o.manualMode=="end"?this:null;b.isAuto?b.isForwards?b.moveBack():b.moveForward():
b.moveBack()};this.funcMoveForward=function(a){a!==i&&a.preventDefault();b.trigger=!b.isAuto&&b.o.manualMode=="end"?this:null;b.isAuto?b.isForwards?b.moveForward():b.moveBack():b.moveForward()};this.funcMovePause=function(){b.movePause()};this.funcMoveStop=function(){b.moveStop()};this.funcMoveResume=function(){b.moveResume()};if(this.isAuto){this.paused=!1;var g=function(){if(b.paused===false){b.paused=true;b.funcMovePause()}else{b.paused=false;b.funcMoveResume()}return b.paused};this.supportsTouch&&
this.$items.find("a").length&&(this.supportsTouch=!1);if(this.isAuto&&this.o.pauseOnHover&&!this.supportsTouch)this.$clip.bind(this.events.start,this.funcMovePause).bind(this.events.end,this.funcMoveResume);else if(this.isAuto&&this.o.pauseOnTouch&&!this.o.pauseButton&&this.supportsTouch){var d,f;this.$clip.bind(this.events.start,function(a){g();var c=a.originalEvent.touches[0];d=b.isHorizontal?c.pageX:c.pageY;f=b.$clip[0]["scroll"+b.scrollPos];a.stopPropagation();a.preventDefault()}).bind(this.events.move,
function(a){a.stopPropagation();a.preventDefault();a=a.originalEvent.touches[0];a=d-(b.isHorizontal?a.pageX:a.pageY)+f;if(a<0)a=0;else if(a>b.posMax)a=b.posMax;b.$clip[0]["scroll"+b.scrollPos]=a;b.funcMovePause();b.paused=true})}else this.o.pauseButton&&(this.$btnPause=c(".simply-scroll-btn-pause",this.$container).bind("click",function(a){a.preventDefault();g()?c(this).addClass("active"):c(this).removeClass("active")}));this.funcMoveForward()}else this.$btnBack.addClass("simply-scroll-btn "+this.moveBackClass).bind(this.events.start,
this.funcMoveBack).bind(this.events.end,this.funcMoveStop),this.$btnForward.addClass("simply-scroll-btn "+this.moveForwardClass).bind(this.events.start,this.funcMoveForward).bind(this.events.end,this.funcMoveStop),"end"==this.o.manualMode&&(!this.isRTL?this.$btnBack.addClass("disabled"):this.$btnForward.addClass("disabled"))},moveForward:function(){var a=this;this.movement="forward";null!==this.trigger&&this.$btnBack.removeClass("disabled");a.interval=setInterval(function(){a.$clip[0]["scroll"+a.scrollPos]<
a.posMax-a.clipMax?a.$clip[0]["scroll"+a.scrollPos]+=a.o.speed:a.isLoop?a.resetPos():a.moveStop(a.movement)},a.intervalDelay)},moveBack:function(){var a=this;this.movement="back";null!==this.trigger&&this.$btnForward.removeClass("disabled");a.interval=setInterval(function(){a.$clip[0]["scroll"+a.scrollPos]>a.posMin?a.$clip[0]["scroll"+a.scrollPos]-=a.o.speed:a.isLoop?a.resetPos():a.moveStop(a.movement)},a.intervalDelay)},movePause:function(){clearInterval(this.interval)},moveStop:function(a){this.movePause();
null!==this.trigger&&("undefined"!==typeof a&&c(this.trigger).addClass("disabled"),this.trigger=null);this.isAuto&&"bounce"==this.o.autoMode&&("forward"==a?this.moveBack():this.moveForward())},moveResume:function(){"forward"==this.movement?this.moveForward():this.moveBack()},resetPos:function(){this.$clip[0]["scroll"+this.scrollPos]=this.resetPosition}})})(jQuery,window);;/*
* Slides, A Slideshow Plugin for jQuery
* Intructions: http://slidesjs.com
* By: Nathan Searles, http://nathansearles.com
* Version: 1.2.0
* Updated: February 5th, 2013
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
(function(a){a.fn.slides=function(b){return b=a.extend({},a.fn.slides.option,b),this.each(function(){function w(g,h,i){if(!p&&o){switch(p=!0,b.animationStart(n+1),g){case"next":l=n,k=n+1,k=e===k?0:k,r=2*f,g=2*-f,n=k;break;case"prev":l=n,k=n-1,k=-1===k?e-1:k,r=0,g=0,n=k;break;case"pagination":k=parseInt(i,10),l=a("."+b.paginationClass+" li."+b.currentClass+" a",c).attr("href").match("[^#/]+$"),k>l?(r=2*f,g=2*-f):(r=0,g=0),n=k}"fade"===h?b.crossfade?d.children(":eq("+k+")",c).css({zIndex:10}).fadeIn(b.fadeSpeed,b.fadeEasing,function(){b.autoHeight?d.animate({height:d.children(":eq("+k+")",c).outerHeight()},b.autoHeightSpeed,function(){d.children(":eq("+l+")",c).css({display:"none",zIndex:0}),d.children(":eq("+k+")",c).css({zIndex:0}),b.animationComplete(k+1),p=!1}):(d.children(":eq("+l+")",c).css({display:"none",zIndex:0}),d.children(":eq("+k+")",c).css({zIndex:0}),b.animationComplete(k+1),p=!1)}):d.children(":eq("+l+")",c).fadeOut(b.fadeSpeed,b.fadeEasing,function(){b.autoHeight?d.animate({height:d.children(":eq("+k+")",c).outerHeight()},b.autoHeightSpeed,function(){d.children(":eq("+k+")",c).fadeIn(b.fadeSpeed,b.fadeEasing)}):d.children(":eq("+k+")",c).fadeIn(b.fadeSpeed,b.fadeEasing,function(){}),b.animationComplete(k+1),p=!1}):(d.children(":eq("+k+")").css({left:r,display:"block"}),b.autoHeight?d.animate({left:g,height:d.children(":eq("+k+")").outerHeight()},b.slideSpeed,b.slideEasing,function(){d.css({left:-f}),d.children(":eq("+k+")").css({left:f,zIndex:5}),d.children(":eq("+l+")").css({left:f,display:"none",zIndex:0}),b.animationComplete(k+1),p=!1}):d.animate({left:g},b.slideSpeed,b.slideEasing,function(){d.css({left:-f}),d.children(":eq("+k+")").css({left:f,zIndex:5}),d.children(":eq("+l+")").css({left:f,display:"none",zIndex:0}),b.animationComplete(k+1),p=!1})),b.pagination&&(a("."+b.paginationClass+" li."+b.currentClass,c).removeClass(b.currentClass),a("."+b.paginationClass+" li:eq("+k+")",c).addClass(b.currentClass))}}function x(){clearInterval(c.data("interval"))}function y(){b.pause?(clearTimeout(c.data("pause")),clearInterval(c.data("interval")),u=setTimeout(function(){clearTimeout(c.data("pause")),v=setInterval(function(){w("next",i)},b.play),c.data("interval",v)},b.pause),c.data("pause",u)):x()}a("."+b.container,a(this)).children().wrapAll('<div class="slides_control"/>');var o,p,q,r,t,u,v,c=a(this),d=a(".slides_control",c),e=d.children().size(),f=d.children().outerWidth(),g=d.children().outerHeight(),h=b.start-1,i=0>b.effect.indexOf(",")?b.effect:b.effect.replace(" ","").split(",")[0],j=0>b.effect.indexOf(",")?i:b.effect.replace(" ","").split(",")[1],k=0,l=0,m=0,n=0;if(2>e)return a("."+b.container,a(this)).fadeIn(b.fadeSpeed,b.fadeEasing,function(){o=!0,b.slidesLoaded()}),a("."+b.next+", ."+b.prev).fadeOut(0),!1;if(!(2>e)){if(0>h&&(h=0),h>e&&(h=e-1),b.start&&(n=h),b.randomize&&d.randomize(),a("."+b.container,c).css({overflow:"hidden",position:"relative"}),d.children().css({position:"absolute",top:0,left:d.children().outerWidth(),zIndex:0,display:"none"}),d.css({position:"relative",width:3*f,height:g,left:-f}),a("."+b.container,c).css({display:"block"}),b.autoHeight&&(d.children().css({height:"auto"}),d.animate({height:d.children(":eq("+h+")").outerHeight()},b.autoHeightSpeed)),b.preload&&d.find("img:eq("+h+")").length){a("."+b.container,c).css({background:"url("+b.preloadImage+") no-repeat 50% 50%"});var z=d.find("img:eq("+h+")").attr("src")+"?"+(new Date).getTime();t="slides_control"!=a("img",c).parent().attr("class")?d.children(":eq(0)")[0].tagName.toLowerCase():d.find("img:eq("+h+")"),d.find("img:eq("+h+")").attr("src",z).load(function(){d.find(t+":eq("+h+")").fadeIn(b.fadeSpeed,b.fadeEasing,function(){a(this).css({zIndex:5}),a("."+b.container,c).css({background:""}),o=!0,b.slidesLoaded()})})}else d.children(":eq("+h+")").fadeIn(b.fadeSpeed,b.fadeEasing,function(){o=!0,b.slidesLoaded()});b.bigTarget&&(d.children().css({cursor:"pointer"}),d.children().on("click",function(){return w("next",i),!1})),b.hoverPause&&b.play&&(d.bind("mouseover",function(){x()}),d.bind("mouseleave",function(){y()})),b.generateNextPrev&&(a("."+b.container,c).after('<a href="#" class="'+b.prev+'">Prev</a>'),a("."+b.prev,c).after('<a href="#" class="'+b.next+'">Next</a>')),a("."+b.next,c).on("click",function(a){a.preventDefault(),b.play&&y(),w("next",i)}),a("."+b.prev,c).on("click",function(a){a.preventDefault(),b.play&&y(),w("prev",i)}),b.generatePagination?(b.prependPagination?c.prepend("<ul class="+b.paginationClass+"></ul>"):c.append("<ul class="+b.paginationClass+"></ul>"),d.children().each(function(){a("."+b.paginationClass,c).append('<li><a href="#'+m+'">'+(m+1)+"</a></li>"),m++})):a("."+b.paginationClass+" li a",c).each(function(){a(this).attr("href","#"+m),m++}),a("."+b.paginationClass+" li:eq("+h+")",c).addClass(b.currentClass),a("."+b.paginationClass+" li a",c).on("click",function(){return b.play&&y(),q=a(this).attr("href").match("[^#/]+$"),n!=q&&w("pagination",j,q),!1}),a("a.link",c).on("click",function(){return b.play&&y(),q=a(this).attr("href").match("[^#/]+$")-1,n!=q&&w("pagination",j,q),!1}),b.play&&(v=setInterval(function(){w("next",i)},b.play),c.data("interval",v))}})},a.fn.slides.option={preload:!1,preloadImage:"/img/loading.gif",container:"slides_container",generateNextPrev:!1,next:"next",prev:"prev",pagination:!0,generatePagination:!0,prependPagination:!1,paginationClass:"pagination",currentClass:"current",fadeSpeed:350,fadeEasing:"",slideSpeed:350,slideEasing:"",start:1,effect:"slide",crossfade:!1,randomize:!1,play:0,pause:0,hoverPause:!1,autoHeight:!1,autoHeightSpeed:350,bigTarget:!1,animationStart:function(){},animationComplete:function(){},slidesLoaded:function(){}},a.fn.randomize=function(b){function c(){return Math.round(Math.random())-.5}return a(this).each(function(){var d=a(this),e=d.children(),f=e.length;if(f>1){e.hide();var g=[];for(i=0;f>i;i++)g[g.length]=i;g=g.sort(c),a.each(g,function(a,c){var f=e.eq(c),g=f.clone(!0);g.show().appendTo(d),void 0!==b&&b(f,g),f.remove()})}})}})(jQuery);
;/*
 * jQuery UI Timepicker
 *
 * Copyright 2010-2013, Francois Gelinas
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://fgelinas.com/code/timepicker
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.position.js (only if position settings are used)
 *
 * Change version 0.1.0 - moved the t-rex up here
 *
                                                  ____
       ___                                      .-~. /_"-._
      `-._~-.                                  / /_ "~o\  :Y
          \  \                                / : \~x.  ` ')
           ]  Y                              /  |  Y< ~-.__j
          /   !                        _.--~T : l  l<  /.-~
         /   /                 ____.--~ .   ` l /~\ \<|Y
        /   /             .-~~"        /| .    ',-~\ \L|
       /   /             /     .^   \ Y~Y \.^>/l_   "--'
      /   Y           .-"(  .  l__  j_j l_/ /~_.-~    .
     Y    l          /    \  )    ~~~." / `/"~ / \.__/l_
     |     \     _.-"      ~-{__     l  :  l._Z~-.___.--~
     |      ~---~           /   ~~"---\_  ' __[>
     l  .                _.^   ___     _>-y~
      \  \     .      .-~   .-~   ~>--"  /
       \  ~---"            /     ./  _.-'
        "-.,_____.,_  _.--~\     _.-~
                    ~~     (   _}       -Row
                           `. ~(
                             )  \
                            /,`--'~\--'~\
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                             ->T-Rex<-
*/

(function ($) {

    $.extend($.ui, { timepicker: { version: "0.3.3"} });

    var PROP_NAME = 'timepicker',
        tpuuid = new Date().getTime();

    /* Time picker manager.
    Use the singleton instance of this class, $.timepicker, to interact with the time picker.
    Settings for (groups of) time pickers are maintained in an instance object,
    allowing multiple different settings on the same page. */

    function Timepicker() {
        this.debug = true; // Change this to true to start debugging
        this._curInst = null; // The current instance in use
        this._disabledInputs = []; // List of time picker inputs that have been disabled
        this._timepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._dialogClass = 'ui-timepicker-dialog'; // The name of the dialog marker class
        this._mainDivId = 'ui-timepicker-div'; // The ID of the main timepicker division
        this._inlineClass = 'ui-timepicker-inline'; // The name of the inline marker class
        this._currentClass = 'ui-timepicker-current'; // The name of the current hour / minutes marker class
        this._dayOverClass = 'ui-timepicker-days-cell-over'; // The name of the day hover marker class

        this.regional = []; // Available regional settings, indexed by language code
        this.regional[''] = { // Default regional settings
            hourText: 'Hour',           // Display text for hours section
            minuteText: 'Minute',       // Display text for minutes link
            amPmText: ['AM', 'PM'],     // Display text for AM PM
            closeButtonText: 'Done',        // Text for the confirmation button (ok button)
            nowButtonText: 'Now',           // Text for the now button
            deselectButtonText: 'Deselect'  // Text for the deselect button
        };
        this._defaults = { // Global defaults for all the time picker instances
            showOn: 'focus',    // 'focus' for popup on focus,
                                // 'button' for trigger button, or 'both' for either (not yet implemented)
            button: null,                   // 'button' element that will trigger the timepicker
            showAnim: 'fadeIn',             // Name of jQuery animation for popup
            showOptions: {},                // Options for enhanced animations
            appendText: '',                 // Display text following the input box, e.g. showing the format

            beforeShow: null,               // Define a callback function executed before the timepicker is shown
            onSelect: null,                 // Define a callback function when a hour / minutes is selected
            onClose: null,                  // Define a callback function when the timepicker is closed

            timeSeparator: ':',             // The character to use to separate hours and minutes.
            periodSeparator: ' ',           // The character to use to separate the time from the time period.
            showPeriod: false,              // Define whether or not to show AM/PM with selected time
            showPeriodLabels: true,         // Show the AM/PM labels on the left of the time picker
            showLeadingZero: true,          // Define whether or not to show a leading zero for hours < 10. [true/false]
            showMinutesLeadingZero: true,   // Define whether or not to show a leading zero for minutes < 10.
            altField: '',                   // Selector for an alternate field to store selected time into
            defaultTime: 'now',             // Used as default time when input field is empty or for inline timePicker
                                            // (set to 'now' for the current time, '' for no highlighted time)
            myPosition: 'left top',         // Position of the dialog relative to the input.
                                            // see the position utility for more info : http://jqueryui.com/demos/position/
            atPosition: 'left bottom',      // Position of the input element to match
                                            // Note : if the position utility is not loaded, the timepicker will attach left top to left bottom
            //NEW: 2011-02-03
            onHourShow: null,			    // callback for enabling / disabling on selectable hours  ex : function(hour) { return true; }
            onMinuteShow: null,             // callback for enabling / disabling on time selection  ex : function(hour,minute) { return true; }

            hours: {
                starts: 0,                  // first displayed hour
                ends: 23                    // last displayed hour
            },
            minutes: {
                starts: 0,                  // first displayed minute
                ends: 55,                   // last displayed minute
                interval: 5,                // interval of displayed minutes
                manual: []                  // optional extra manual entries for minutes
            },
            rows: 4,                        // number of rows for the input tables, minimum 2, makes more sense if you use multiple of 2
            // 2011-08-05 0.2.4
            showHours: true,                // display the hours section of the dialog
            showMinutes: true,              // display the minute section of the dialog
            optionalMinutes: false,         // optionally parse inputs of whole hours with minutes omitted

            // buttons
            showCloseButton: false,         // shows an OK button to confirm the edit
            showNowButton: false,           // Shows the 'now' button
            showDeselectButton: false,       // Shows the deselect time button
            
            maxTime: {
                hour: null,
                minute: null
            },
            minTime: {
                hour: null,
                minute: null
            }
			
        };
        $.extend(this._defaults, this.regional['']);

        this.tpDiv = $('<div id="' + this._mainDivId + '" class="ui-timepicker ui-widget ui-helper-clearfix ui-corner-all " style="display: none"></div>');
    }

    $.extend(Timepicker.prototype, {
        /* Class name added to elements to indicate already configured with a time picker. */
        markerClassName: 'hasTimepicker',

        /* Debug logging (if enabled). */
        log: function () {
            if (this.debug)
                console.log.apply('', arguments);
        },

        _widgetTimepicker: function () {
            return this.tpDiv;
        },

        /* Override the default settings for all instances of the time picker.
        @param  settings  object - the new settings to use as defaults (anonymous object)
        @return the manager object */
        setDefaults: function (settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the time picker to a jQuery selection.
        @param  target    element - the target input field or division or span
        @param  settings  object - the new settings to use for this time picker instance (anonymous) */
        _attachTimepicker: function (target, settings) {
            // check for settings on the control itself - in namespace 'time:'
            var inlineSettings = null;
            for (var attrName in this._defaults) {
                var attrValue = target.getAttribute('time:' + attrName);
                if (attrValue) {
                    inlineSettings = inlineSettings || {};
                    try {
                        inlineSettings[attrName] = eval(attrValue);
                    } catch (err) {
                        inlineSettings[attrName] = attrValue;
                    }
                }
            }
            var nodeName = target.nodeName.toLowerCase();
            var inline = (nodeName == 'div' || nodeName == 'span');

            if (!target.id) {
                this.uuid += 1;
                target.id = 'tp' + this.uuid;
            }
            var inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {}, inlineSettings || {});
            if (nodeName == 'input') {
                this._connectTimepicker(target, inst);
                // init inst.hours and inst.minutes from the input value
                this._setTimeFromField(inst);
            } else if (inline) {
                this._inlineTimepicker(target, inst);
            }


        },

        /* Create a new instance object. */
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
            return {
                id: id, input: target, // associated target
                inline: inline, // is timepicker inline or not :
                tpDiv: (!inline ? this.tpDiv : // presentation div
                    $('<div class="' + this._inlineClass + ' ui-timepicker ui-widget  ui-helper-clearfix"></div>'))
            };
        },

        /* Attach the time picker to an input field. */
        _connectTimepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) { return; }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).
                keydown(this._doKeyDown).
                keyup(this._doKeyUp).
                bind("setData.timepicker", function (event, key, value) {
                    inst.settings[key] = value;
                }).
                bind("getData.timepicker", function (event, key) {
                    return this._get(inst, key);
                });
            $.data(target, PROP_NAME, inst);
        },

        /* Handle keystrokes. */
        _doKeyDown: function (event) {
            var inst = $.timepicker._getInst(event.target);
            var handled = true;
            inst._keyEvent = true;
            if ($.timepicker._timepickerShowing) {
                switch (event.keyCode) {
                    case 9: $.timepicker._hideTimepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13:
                        $.timepicker._updateSelectedValue(inst);
                        $.timepicker._hideTimepicker();

						return false; // don't submit the form
						break; // select the value on enter
                    case 27: $.timepicker._hideTimepicker();
                        break; // hide on escape
                    default: handled = false;
                }
            }
            else if (event.keyCode == 36 && event.ctrlKey) { // display the time picker on ctrl+home
                $.timepicker._showTimepicker(this);
            }
            else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Update selected time on keyUp */
        /* Added verion 0.0.5 */
        _doKeyUp: function (event) {
            var inst = $.timepicker._getInst(event.target);
            $.timepicker._setTimeFromField(inst);
            $.timepicker._updateTimepicker(inst);
        },

        /* Make attachments based on settings. */
        _attachments: function (input, inst) {
            var appendText = this._get(inst, 'appendText');
            var isRTL = this._get(inst, 'isRTL');
            if (inst.append) { inst.append.remove(); }
            if (appendText) {
                inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
                input[isRTL ? 'before' : 'after'](inst.append);
            }
            input.unbind('focus.timepicker', this._showTimepicker);
            input.unbind('click.timepicker', this._adjustZIndex);

            if (inst.trigger) { inst.trigger.remove(); }

            var showOn = this._get(inst, 'showOn');
            if (showOn == 'focus' || showOn == 'both') { // pop-up time picker when in the marked field
                input.bind("focus.timepicker", this._showTimepicker);
                input.bind("click.timepicker", this._adjustZIndex);
            }
            if (showOn == 'button' || showOn == 'both') { // pop-up time picker when 'button' element is clicked
                var button = this._get(inst, 'button');

                // Add button if button element is not set
                if(button == null) {
                    button = $('<button class="ui-timepicker-trigger" type="button">...</button>');
                    input.after(button);
                }

                $(button).bind("click.timepicker", function () {
                    if ($.timepicker._timepickerShowing && $.timepicker._lastInput == input[0]) {
                        $.timepicker._hideTimepicker();
                    } else if (!inst.input.is(':disabled')) {
                        $.timepicker._showTimepicker(input[0]);
                    }
                    return false;
                });

            }
        },


        /* Attach an inline time picker to a div. */
        _inlineTimepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName))
                return;
            divSpan.addClass(this.markerClassName).append(inst.tpDiv).
                bind("setData.timepicker", function(event, key, value){
                    inst.settings[key] = value;
                }).bind("getData.timepicker", function(event, key){
                    return this._get(inst, key);
                });
            $.data(target, PROP_NAME, inst);

            this._setTimeFromField(inst);
            this._updateTimepicker(inst);
            inst.tpDiv.show();
        },

        _adjustZIndex: function(input) {
            input = input.target || input;
            var inst = $.timepicker._getInst(input);
            inst.tpDiv.css('zIndex', $.timepicker._getZIndex(input) +1);
        },

        /* Pop-up the time picker for a given input field.
        @param  input  element - the input field attached to the time picker or
        event - if triggered by focus */
        _showTimepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() != 'input') { input = $('input', input.parentNode)[0]; } // find from button/image trigger

            if ($.timepicker._isDisabledTimepicker(input) || $.timepicker._lastInput == input) { return; } // already here

            // fix v 0.0.8 - close current timepicker before showing another one
            $.timepicker._hideTimepicker();

            var inst = $.timepicker._getInst(input);
            if ($.timepicker._curInst && $.timepicker._curInst != inst) {
                $.timepicker._curInst.tpDiv.stop(true, true);
            }
            var beforeShow = $.timepicker._get(inst, 'beforeShow');
            extendRemove(inst.settings, (beforeShow ? beforeShow.apply(input, [input, inst]) : {}));
            inst.lastVal = null;
            $.timepicker._lastInput = input;

            $.timepicker._setTimeFromField(inst);

            // calculate default position
            if ($.timepicker._inDialog) { input.value = ''; } // hide cursor
            if (!$.timepicker._pos) { // position below input
                $.timepicker._pos = $.timepicker._findPos(input);
                $.timepicker._pos[1] += input.offsetHeight; // add the height
            }
            var isFixed = false;
            $(input).parents().each(function () {
                isFixed |= $(this).css('position') == 'fixed';
                return !isFixed;
            });

            var offset = { left: $.timepicker._pos[0], top: $.timepicker._pos[1] };

            $.timepicker._pos = null;
            // determine sizing offscreen
            inst.tpDiv.css({ position: 'absolute', display: 'block', top: '-1000px' });
            $.timepicker._updateTimepicker(inst);


            // position with the ui position utility, if loaded
            if ( ( ! inst.inline )  && ( typeof $.ui.position == 'object' ) ) {
                inst.tpDiv.position({
                    of: inst.input,
                    my: $.timepicker._get( inst, 'myPosition' ),
                    at: $.timepicker._get( inst, 'atPosition' ),
                    // offset: $( "#offset" ).val(),
                    // using: using,
                    collision: 'flip'
                });
                var offset = inst.tpDiv.offset();
                $.timepicker._pos = [offset.top, offset.left];
            }


            // reset clicked state
            inst._hoursClicked = false;
            inst._minutesClicked = false;

            // fix width for dynamic number of time pickers
            // and adjust position before showing
            offset = $.timepicker._checkOffset(inst, offset, isFixed);
            inst.tpDiv.css({ position: ($.timepicker._inDialog && $.blockUI ?
			    'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
                left: offset.left + 'px', top: offset.top + 'px'
            });
            if ( ! inst.inline ) {
                var showAnim = $.timepicker._get(inst, 'showAnim');
                var duration = $.timepicker._get(inst, 'duration');

                var postProcess = function () {
                    $.timepicker._timepickerShowing = true;
                    var borders = $.timepicker._getBorders(inst.tpDiv);
                    inst.tpDiv.find('iframe.ui-timepicker-cover'). // IE6- only
					css({ left: -borders[0], top: -borders[1],
					    width: inst.tpDiv.outerWidth(), height: inst.tpDiv.outerHeight()
					});
                };

                // Fixed the zIndex problem for real (I hope) - FG - v 0.2.9
                $.timepicker._adjustZIndex(input);
                //inst.tpDiv.css('zIndex', $.timepicker._getZIndex(input) +1);

                if ($.effects && $.effects[showAnim]) {
                    inst.tpDiv.show(showAnim, $.timepicker._get(inst, 'showOptions'), duration, postProcess);
                }
                else {
                    inst.tpDiv.show((showAnim ? duration : null), postProcess);
                }
                if (!showAnim || !duration) { postProcess(); }
                if (inst.input.is(':visible') && !inst.input.is(':disabled')) { inst.input.focus(); }
                $.timepicker._curInst = inst;
            }
        },

        // This is an enhanced copy of the zIndex function of UI core 1.8.?? For backward compatibility.
        // Enhancement returns maximum zindex value discovered while traversing parent elements,
        // rather than the first zindex value found. Ensures the timepicker popup will be in front,
        // even in funky scenarios like non-jq dialog containers with large fixed zindex values and
        // nested zindex-influenced elements of their own.
        _getZIndex: function (target) {
            var elem = $(target);
            var maxValue = 0;
            var position, value;
            while (elem.length && elem[0] !== document) {
                position = elem.css("position");
                if (position === "absolute" || position === "relative" || position === "fixed") {
                    value = parseInt(elem.css("zIndex"), 10);
                    if (!isNaN(value) && value !== 0) {
                        if (value > maxValue) { maxValue = value; }
                    }
                }
                elem = elem.parent();
            }

            return maxValue;
        },

        /* Refresh the time picker
           @param   target  element - The target input field or inline container element. */
        _refreshTimepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateTimepicker(inst);
            }
        },


        /* Generate the time picker content. */
        _updateTimepicker: function (inst) {
            inst.tpDiv.empty().append(this._generateHTML(inst));
            this._rebindDialogEvents(inst);

        },

        _rebindDialogEvents: function (inst) {
            var borders = $.timepicker._getBorders(inst.tpDiv),
                self = this;
            inst.tpDiv
			.find('iframe.ui-timepicker-cover') // IE6- only
				.css({ left: -borders[0], top: -borders[1],
				    width: inst.tpDiv.outerWidth(), height: inst.tpDiv.outerHeight()
				})
			.end()
            // after the picker html is appended bind the click & double click events (faster in IE this way
            // then letting the browser interpret the inline events)
            // the binding for the minute cells also exists in _updateMinuteDisplay
            .find('.ui-timepicker-minute-cell')
                .unbind()
                .bind("click", { fromDoubleClick:false }, $.proxy($.timepicker.selectMinutes, this))
                .bind("dblclick", { fromDoubleClick:true }, $.proxy($.timepicker.selectMinutes, this))
            .end()
            .find('.ui-timepicker-hour-cell')
                .unbind()
                .bind("click", { fromDoubleClick:false }, $.proxy($.timepicker.selectHours, this))
                .bind("dblclick", { fromDoubleClick:true }, $.proxy($.timepicker.selectHours, this))
            .end()
			.find('.ui-timepicker td a')
                .unbind()
				.bind('mouseout', function () {
				    $(this).removeClass('ui-state-hover');
				    if (this.className.indexOf('ui-timepicker-prev') != -1) $(this).removeClass('ui-timepicker-prev-hover');
				    if (this.className.indexOf('ui-timepicker-next') != -1) $(this).removeClass('ui-timepicker-next-hover');
				})
				.bind('mouseover', function () {
				    if ( ! self._isDisabledTimepicker(inst.inline ? inst.tpDiv.parent()[0] : inst.input[0])) {
				        $(this).parents('.ui-timepicker-calendar').find('a').removeClass('ui-state-hover');
				        $(this).addClass('ui-state-hover');
				        if (this.className.indexOf('ui-timepicker-prev') != -1) $(this).addClass('ui-timepicker-prev-hover');
				        if (this.className.indexOf('ui-timepicker-next') != -1) $(this).addClass('ui-timepicker-next-hover');
				    }
				})
			.end()
			.find('.' + this._dayOverClass + ' a')
				.trigger('mouseover')
			.end()
            .find('.ui-timepicker-now').bind("click", function(e) {
                    $.timepicker.selectNow(e);
            }).end()
            .find('.ui-timepicker-deselect').bind("click",function(e) {
                    $.timepicker.deselectTime(e);
            }).end()
            .find('.ui-timepicker-close').bind("click",function(e) {
                    $.timepicker._hideTimepicker();
            }).end();
        },

        /* Generate the HTML for the current state of the time picker. */
        _generateHTML: function (inst) {

            var h, m, row, col, html, hoursHtml, minutesHtml = '',
                showPeriod = (this._get(inst, 'showPeriod') == true),
                showPeriodLabels = (this._get(inst, 'showPeriodLabels') == true),
                showLeadingZero = (this._get(inst, 'showLeadingZero') == true),
                showHours = (this._get(inst, 'showHours') == true),
                showMinutes = (this._get(inst, 'showMinutes') == true),
                amPmText = this._get(inst, 'amPmText'),
                rows = this._get(inst, 'rows'),
                amRows = 0,
                pmRows = 0,
                amItems = 0,
                pmItems = 0,
                amFirstRow = 0,
                pmFirstRow = 0,
                hours = Array(),
                hours_options = this._get(inst, 'hours'),
                hoursPerRow = null,
                hourCounter = 0,
                hourLabel = this._get(inst, 'hourText'),
                showCloseButton = this._get(inst, 'showCloseButton'),
                closeButtonText = this._get(inst, 'closeButtonText'),
                showNowButton = this._get(inst, 'showNowButton'),
                nowButtonText = this._get(inst, 'nowButtonText'),
                showDeselectButton = this._get(inst, 'showDeselectButton'),
                deselectButtonText = this._get(inst, 'deselectButtonText'),
                showButtonPanel = showCloseButton || showNowButton || showDeselectButton;



            // prepare all hours and minutes, makes it easier to distribute by rows
            for (h = hours_options.starts; h <= hours_options.ends; h++) {
                hours.push (h);
            }
            hoursPerRow = Math.ceil(hours.length / rows); // always round up

            if (showPeriodLabels) {
                for (hourCounter = 0; hourCounter < hours.length; hourCounter++) {
                    if (hours[hourCounter] < 12) {
                        amItems++;
                    }
                    else {
                        pmItems++;
                    }
                }
                hourCounter = 0;

                amRows = Math.floor(amItems / hours.length * rows);
                pmRows = Math.floor(pmItems / hours.length * rows);

                // assign the extra row to the period that is more densely populated
                if (rows != amRows + pmRows) {
                    // Make sure: AM Has Items and either PM Does Not, AM has no rows yet, or AM is more dense
                    if (amItems && (!pmItems || !amRows || (pmRows && amItems / amRows >= pmItems / pmRows))) {
                        amRows++;
                    } else {
                        pmRows++;
                    }
                }
                amFirstRow = Math.min(amRows, 1);
                pmFirstRow = amRows + 1;

                if (amRows == 0) {
                    hoursPerRow = Math.ceil(pmItems / pmRows);
                } else if (pmRows == 0) {
                    hoursPerRow = Math.ceil(amItems / amRows);
                } else {
                    hoursPerRow = Math.ceil(Math.max(amItems / amRows, pmItems / pmRows));
                }
            }


            html = '<table class="ui-timepicker-table ui-widget-content ui-corner-all"><tr>';

            if (showHours) {

                html += '<td class="ui-timepicker-hours">' +
                        '<div class="ui-timepicker-title ui-widget-header ui-helper-clearfix ui-corner-all">' +
                        hourLabel +
                        '</div>' +
                        '<table class="ui-timepicker">';

                for (row = 1; row <= rows; row++) {
                    html += '<tr>';
                    // AM
                    if (row == amFirstRow && showPeriodLabels) {
                        html += '<th rowspan="' + amRows.toString() + '" class="periods" scope="row">' + amPmText[0] + '</th>';
                    }
                    // PM
                    if (row == pmFirstRow && showPeriodLabels) {
                        html += '<th rowspan="' + pmRows.toString() + '" class="periods" scope="row">' + amPmText[1] + '</th>';
                    }
                    for (col = 1; col <= hoursPerRow; col++) {
                        if (showPeriodLabels && row < pmFirstRow && hours[hourCounter] >= 12) {
                            html += this._generateHTMLHourCell(inst, undefined, showPeriod, showLeadingZero);
                        } else {
                            html += this._generateHTMLHourCell(inst, hours[hourCounter], showPeriod, showLeadingZero);
                            hourCounter++;
                        }
                    }
                    html += '</tr>';
                }
                html += '</table>' + // Close the hours cells table
                        '</td>'; // Close the Hour td
            }

            if (showMinutes) {
                html += '<td class="ui-timepicker-minutes">';
                html += this._generateHTMLMinutes(inst);
                html += '</td>';
            }

            html += '</tr>';


            if (showButtonPanel) {
                var buttonPanel = '<tr><td colspan="3"><div class="ui-timepicker-buttonpane ui-widget-content">';
                if (showNowButton) {
                    buttonPanel += '<button type="button" class="ui-timepicker-now ui-state-default ui-corner-all" '
                                   + ' data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" >'
                                   + nowButtonText + '</button>';
                }
                if (showDeselectButton) {
                    buttonPanel += '<button type="button" class="ui-timepicker-deselect ui-state-default ui-corner-all" '
                                   + ' data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" >'
                                   + deselectButtonText + '</button>';
                }
                if (showCloseButton) {
                    buttonPanel += '<button type="button" class="ui-timepicker-close ui-state-default ui-corner-all" '
                                   + ' data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" >'
                                   + closeButtonText + '</button>';
                }

                html += buttonPanel + '</div></td></tr>';
            }
            html += '</table>';

            return html;
        },

        /* Special function that update the minutes selection in currently visible timepicker
         * called on hour selection when onMinuteShow is defined  */
        _updateMinuteDisplay: function (inst) {
            var newHtml = this._generateHTMLMinutes(inst);
            inst.tpDiv.find('td.ui-timepicker-minutes').html(newHtml);
            this._rebindDialogEvents(inst);
                // after the picker html is appended bind the click & double click events (faster in IE this way
                // then letting the browser interpret the inline events)
                // yes I know, duplicate code, sorry
/*                .find('.ui-timepicker-minute-cell')
                    .bind("click", { fromDoubleClick:false }, $.proxy($.timepicker.selectMinutes, this))
                    .bind("dblclick", { fromDoubleClick:true }, $.proxy($.timepicker.selectMinutes, this));
*/

        },

        /*
         * Generate the minutes table
         * This is separated from the _generateHTML function because is can be called separately (when hours changes)
         */
        _generateHTMLMinutes: function (inst) {

            var m, row, html = '',
                rows = this._get(inst, 'rows'),
                minutes = Array(),
                minutes_options = this._get(inst, 'minutes'),
                minutesPerRow = null,
                minuteCounter = 0,
                showMinutesLeadingZero = (this._get(inst, 'showMinutesLeadingZero') == true),
                onMinuteShow = this._get(inst, 'onMinuteShow'),
                minuteLabel = this._get(inst, 'minuteText');

            if ( ! minutes_options.starts) {
                minutes_options.starts = 0;
            }
            if ( ! minutes_options.ends) {
                minutes_options.ends = 59;
            }
            if ( ! minutes_options.manual) {
                minutes_options.manual = [];
            }
            for (m = minutes_options.starts; m <= minutes_options.ends; m += minutes_options.interval) {
                minutes.push(m);
            }
            for (i = 0; i < minutes_options.manual.length;i++) {
                var currMin = minutes_options.manual[i];

                // Validate & filter duplicates of manual minute input
                if (typeof currMin != 'number' || currMin < 0 || currMin > 59 || $.inArray(currMin, minutes) >= 0) {
                    continue;
                }
                minutes.push(currMin);
            }

            // Sort to get correct order after adding manual minutes
            // Use compare function to sort by number, instead of string (default)
            minutes.sort(function(a, b) {
                return a-b;
            });

            minutesPerRow = Math.round(minutes.length / rows + 0.49); // always round up

            /*
             * The minutes table
             */
            // if currently selected minute is not enabled, we have a problem and need to select a new minute.
            if (onMinuteShow &&
                (onMinuteShow.apply((inst.input ? inst.input[0] : null), [inst.hours , inst.minutes]) == false) ) {
                // loop minutes and select first available
                for (minuteCounter = 0; minuteCounter < minutes.length; minuteCounter += 1) {
                    m = minutes[minuteCounter];
                    if (onMinuteShow.apply((inst.input ? inst.input[0] : null), [inst.hours, m])) {
                        inst.minutes = m;
                        break;
                    }
                }
            }



            html += '<div class="ui-timepicker-title ui-widget-header ui-helper-clearfix ui-corner-all">' +
                    minuteLabel +
                    '</div>' +
                    '<table class="ui-timepicker">';

            minuteCounter = 0;
            for (row = 1; row <= rows; row++) {
                html += '<tr>';
                while (minuteCounter < row * minutesPerRow) {
                    var m = minutes[minuteCounter];
                    var displayText = '';
                    if (m !== undefined ) {
                        displayText = (m < 10) && showMinutesLeadingZero ? "0" + m.toString() : m.toString();
                    }
                    html += this._generateHTMLMinuteCell(inst, m, displayText);
                    minuteCounter++;
                }
                html += '</tr>';
            }

            html += '</table>';

            return html;
        },

        /* Generate the content of a "Hour" cell */
        _generateHTMLHourCell: function (inst, hour, showPeriod, showLeadingZero) {

            var displayHour = hour;
            if ((hour > 12) && showPeriod) {
                displayHour = hour - 12;
            }
            if ((displayHour == 0) && showPeriod) {
                displayHour = 12;
            }
            if ((displayHour < 10) && showLeadingZero) {
                displayHour = '0' + displayHour;
            }

            var html = "";
            var enabled = true;
            var onHourShow = this._get(inst, 'onHourShow');		//custom callback
            var maxTime = this._get(inst, 'maxTime');
            var minTime = this._get(inst, 'minTime');

            if (hour == undefined) {
                html = '<td><span class="ui-state-default ui-state-disabled">&nbsp;</span></td>';
                return html;
            }

            if (onHourShow) {
            	enabled = onHourShow.apply((inst.input ? inst.input[0] : null), [hour]);
            }
			
            if (enabled) {
                if ( !isNaN(parseInt(maxTime.hour)) && hour > maxTime.hour ) enabled = false;
                if ( !isNaN(parseInt(minTime.hour)) && hour < minTime.hour ) enabled = false;
            }
			
            if (enabled) {
                html = '<td class="ui-timepicker-hour-cell" data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" data-hour="' + hour.toString() + '">' +
                   '<a class="ui-state-default ' +
                   (hour == inst.hours ? 'ui-state-active' : '') +
                   '">' +
                   displayHour.toString() +
                   '</a></td>';
            }
            else {
            	html =
            		'<td>' +
		                '<span class="ui-state-default ui-state-disabled ' +
		                (hour == inst.hours ? ' ui-state-active ' : ' ') +
		                '">' +
		                displayHour.toString() +
		                '</span>' +
		            '</td>';
            }
            return html;
        },

        /* Generate the content of a "Hour" cell */
        _generateHTMLMinuteCell: function (inst, minute, displayText) {
             var html = "";
             var enabled = true;
             var hour = inst.hours;
             var onMinuteShow = this._get(inst, 'onMinuteShow');		//custom callback
             var maxTime = this._get(inst, 'maxTime');
             var minTime = this._get(inst, 'minTime');

             if (onMinuteShow) {
            	 //NEW: 2011-02-03  we should give the hour as a parameter as well!
             	enabled = onMinuteShow.apply((inst.input ? inst.input[0] : null), [inst.hours,minute]);		//trigger callback
             }

             if (minute == undefined) {
                 html = '<td><span class="ui-state-default ui-state-disabled">&nbsp;</span></td>';
                 return html;
             }

            if (enabled && hour !== null) {
                if ( !isNaN(parseInt(maxTime.hour)) && !isNaN(parseInt(maxTime.minute)) && hour >= maxTime.hour && minute > maxTime.minute ) enabled = false;
                if ( !isNaN(parseInt(minTime.hour)) && !isNaN(parseInt(minTime.minute)) && hour <= minTime.hour && minute < minTime.minute ) enabled = false;
            }
			
             if (enabled) {
	             html = '<td class="ui-timepicker-minute-cell" data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" data-minute="' + minute.toString() + '" >' +
	                   '<a class="ui-state-default ' +
	                   (minute == inst.minutes ? 'ui-state-active' : '') +
	                   '" >' +
	                   displayText +
	                   '</a></td>';
             }
             else {

            	html = '<td>' +
	                 '<span class="ui-state-default ui-state-disabled" >' +
	                 	displayText +
	                 '</span>' +
                 '</td>';
             }
             return html;
        },


        /* Detach a timepicker from its control.
           @param  target    element - the target input field or division or span */
        _destroyTimepicker: function(target) {
            var $target = $(target);
            var inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            $.removeData(target, PROP_NAME);
            if (nodeName == 'input') {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName)
                    .unbind('focus.timepicker', this._showTimepicker)
                    .unbind('click.timepicker', this._adjustZIndex);
            } else if (nodeName == 'div' || nodeName == 'span')
                $target.removeClass(this.markerClassName).empty();
        },

        /* Enable the date picker to a jQuery selection.
           @param  target    element - the target input field or division or span */
        _enableTimepicker: function(target) {
            var $target = $(target),
                target_id = $target.attr('id'),
                inst = $.data(target, PROP_NAME);

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            if (nodeName == 'input') {
                target.disabled = false;
                var button = this._get(inst, 'button');
                $(button).removeClass('ui-state-disabled').disabled = false;
                inst.trigger.filter('button').
                    each(function() { this.disabled = false; }).end();
            }
            else if (nodeName == 'div' || nodeName == 'span') {
                var inline = $target.children('.' + this._inlineClass);
                inline.children().removeClass('ui-state-disabled');
                inline.find('button').each(
                    function() { this.disabled = false }
                )
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) { return (value == target_id ? null : value); }); // delete entry
        },

        /* Disable the time picker to a jQuery selection.
           @param  target    element - the target input field or division or span */
        _disableTimepicker: function(target) {
            var $target = $(target);
            var inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            if (nodeName == 'input') {
                var button = this._get(inst, 'button');

                $(button).addClass('ui-state-disabled').disabled = true;
                target.disabled = true;

                inst.trigger.filter('button').
                    each(function() { this.disabled = true; }).end();

            }
            else if (nodeName == 'div' || nodeName == 'span') {
                var inline = $target.children('.' + this._inlineClass);
                inline.children().addClass('ui-state-disabled');
                inline.find('button').each(
                    function() { this.disabled = true }
                )

            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) { return (value == target ? null : value); }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = $target.attr('id');
        },

        /* Is the first field in a jQuery collection disabled as a timepicker?
        @param  target_id element - the target input field or division or span
        @return boolean - true if disabled, false if enabled */
        _isDisabledTimepicker: function (target_id) {
            if ( ! target_id) { return false; }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] == target_id) { return true; }
            }
            return false;
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function (inst, offset, isFixed) {
            var tpWidth = inst.tpDiv.outerWidth();
            var tpHeight = inst.tpDiv.outerHeight();
            var inputWidth = inst.input ? inst.input.outerWidth() : 0;
            var inputHeight = inst.input ? inst.input.outerHeight() : 0;
            var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
            var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

            offset.left -= (this._get(inst, 'isRTL') ? (tpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // now check if timepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + tpWidth > viewWidth && viewWidth > tpWidth) ?
			Math.abs(offset.left + tpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + tpHeight > viewHeight && viewHeight > tpHeight) ?
			Math.abs(tpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function (obj) {
            var inst = this._getInst(obj);
            var isRTL = this._get(inst, 'isRTL');
            while (obj && (obj.type == 'hidden' || obj.nodeType != 1)) {
                obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
            }
            var position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Retrieve the size of left and top borders for an element.
        @param  elem  (jQuery object) the element of interest
        @return  (number[2]) the left and top borders */
        _getBorders: function (elem) {
            var convert = function (value) {
                return { thin: 1, medium: 2, thick: 3}[value] || value;
            };
            return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
        },


        /* Close time picker if clicked elsewhere. */
        _checkExternalClick: function (event) {
            if (!$.timepicker._curInst) { return; }
            var $target = $(event.target);
            if ($target[0].id != $.timepicker._mainDivId &&
				$target.parents('#' + $.timepicker._mainDivId).length == 0 &&
				!$target.hasClass($.timepicker.markerClassName) &&
				!$target.hasClass($.timepicker._triggerClass) &&
				$.timepicker._timepickerShowing && !($.timepicker._inDialog && $.blockUI))
                $.timepicker._hideTimepicker();
        },

        /* Hide the time picker from view.
        @param  input  element - the input field attached to the time picker */
        _hideTimepicker: function (input) {
            var inst = this._curInst;
            if (!inst || (input && inst != $.data(input, PROP_NAME))) { return; }
            if (this._timepickerShowing) {
                var showAnim = this._get(inst, 'showAnim');
                var duration = this._get(inst, 'duration');
                var postProcess = function () {
                    $.timepicker._tidyDialog(inst);
                    this._curInst = null;
                };
                if ($.effects && $.effects[showAnim]) {
                    inst.tpDiv.hide(showAnim, $.timepicker._get(inst, 'showOptions'), duration, postProcess);
                }
                else {
                    inst.tpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					    (showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
                }
                if (!showAnim) { postProcess(); }

                this._timepickerShowing = false;

                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
                    if ($.blockUI) {
                        $.unblockUI();
                        $('body').append(this.tpDiv);
                    }
                }
                this._inDialog = false;

                var onClose = this._get(inst, 'onClose');
                 if (onClose) {
                     onClose.apply(
                         (inst.input ? inst.input[0] : null),
 					    [(inst.input ? inst.input.val() : ''), inst]);  // trigger custom callback
                 }

            }
        },



        /* Tidy up after a dialog display. */
        _tidyDialog: function (inst) {
            inst.tpDiv.removeClass(this._dialogClass).unbind('.ui-timepicker');
        },

        /* Retrieve the instance data for the target control.
        @param  target  element - the target input field or division or span
        @return  object - the associated instance data
        @throws  error if a jQuery problem getting data */
        _getInst: function (target) {
            try {
                return $.data(target, PROP_NAME);
            }
            catch (err) {
                throw 'Missing instance data for this timepicker';
            }
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function (inst, name) {
            return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
        },

        /* Parse existing time and initialise time picker. */
        _setTimeFromField: function (inst) {
            if (inst.input.val() == inst.lastVal) { return; }
            var defaultTime = this._get(inst, 'defaultTime');

            var timeToParse = defaultTime == 'now' ? this._getCurrentTimeRounded(inst) : defaultTime;
            if ((inst.inline == false) && (inst.input.val() != '')) { timeToParse = inst.input.val() }

            if (timeToParse instanceof Date) {
                inst.hours = timeToParse.getHours();
                inst.minutes = timeToParse.getMinutes();
            } else {
                var timeVal = inst.lastVal = timeToParse;
                if (timeToParse == '') {
                    inst.hours = -1;
                    inst.minutes = -1;
                } else {
                    var time = this.parseTime(inst, timeVal);
                    inst.hours = time.hours;
                    inst.minutes = time.minutes;
                }
            }


            $.timepicker._updateTimepicker(inst);
        },

        /* Update or retrieve the settings for an existing time picker.
           @param  target  element - the target input field or division or span
           @param  name    object - the new settings to update or
                           string - the name of the setting to change or retrieve,
                           when retrieving also 'all' for all instance settings or
                           'defaults' for all global defaults
           @param  value   any - the new value for the setting
                       (omit if above is an object or to retrieve a value) */
        _optionTimepicker: function(target, name, value) {
            var inst = this._getInst(target);
            if (arguments.length == 2 && typeof name == 'string') {
                return (name == 'defaults' ? $.extend({}, $.timepicker._defaults) :
                    (inst ? (name == 'all' ? $.extend({}, inst.settings) :
                    this._get(inst, name)) : null));
            }
            var settings = name || {};
            if (typeof name == 'string') {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                extendRemove(inst.settings, settings);
                if (this._curInst == inst) {
                    this._hideTimepicker();
                	this._updateTimepicker(inst);
                }
                if (inst.inline) {
                    this._updateTimepicker(inst);
                }
            }
        },


        /* Set the time for a jQuery selection.
	    @param  target  element - the target input field or division or span
	    @param  time    String - the new time */
	    _setTimeTimepicker: function(target, time, noChange) {
		    var inst = this._getInst(target);
		    if (inst) {
			    this._setTime(inst, time, noChange);
    			this._updateTimepicker(inst);
	    		this._updateAlternate(inst, time);
		    }
	    },

        /* Set the time directly. */
        _setTime: function(inst, time, noChange) {
            var origHours = inst.hours;
            var origMinutes = inst.minutes;
            if (time instanceof Date) {
                inst.hours = time.getHours();
                inst.minutes = time.getMinutes();
            } else {
                var time = this.parseTime(inst, time);
                inst.hours = time.hours;
                inst.minutes = time.minutes;
            }

            if ((origHours != inst.hours || origMinutes != inst.minutes) && !noChange) {
                inst.input.trigger('change');
            }
            this._updateTimepicker(inst);
            this._updateSelectedValue(inst);
        },

        /* Return the current time, ready to be parsed, rounded to the closest minute by interval */
        _getCurrentTimeRounded: function (inst) {
            var currentTime = new Date(),
                currentMinutes = currentTime.getMinutes(),
                minutes_options = this._get(inst, 'minutes'),
                // round to closest interval
                adjustedMinutes = Math.round(currentMinutes / minutes_options.interval) * minutes_options.interval;
            currentTime.setMinutes(adjustedMinutes);
            return currentTime;
        },

        /*
        * Parse a time string into hours and minutes
        */
        parseTime: function (inst, timeVal) {
            var retVal = new Object();
            retVal.hours = -1;
            retVal.minutes = -1;

            if(!timeVal)
                return '';

            var timeSeparator = this._get(inst, 'timeSeparator'),
                amPmText = this._get(inst, 'amPmText'),
                showHours = this._get(inst, 'showHours'),
                showMinutes = this._get(inst, 'showMinutes'),
                optionalMinutes = this._get(inst, 'optionalMinutes'),
                showPeriod = (this._get(inst, 'showPeriod') == true),
                p = timeVal.indexOf(timeSeparator);

            // check if time separator found
            if (p != -1) {
                retVal.hours = parseInt(timeVal.substr(0, p), 10);
                retVal.minutes = parseInt(timeVal.substr(p + 1), 10);
            }
            // check for hours only
            else if ( (showHours) && ( !showMinutes || optionalMinutes ) ) {
                retVal.hours = parseInt(timeVal, 10);
            }
            // check for minutes only
            else if ( ( ! showHours) && (showMinutes) ) {
                retVal.minutes = parseInt(timeVal, 10);
            }

            if (showHours) {
                var timeValUpper = timeVal.toUpperCase();
                if ((retVal.hours < 12) && (showPeriod) && (timeValUpper.indexOf(amPmText[1].toUpperCase()) != -1)) {
                    retVal.hours += 12;
                }
                // fix for 12 AM
                if ((retVal.hours == 12) && (showPeriod) && (timeValUpper.indexOf(amPmText[0].toUpperCase()) != -1)) {
                    retVal.hours = 0;
                }
            }

            return retVal;
        },

        selectNow: function(event) {
            var id = $(event.target).attr("data-timepicker-instance-id"),
                $target = $(id),
                inst = this._getInst($target[0]);
            //if (!inst || (input && inst != $.data(input, PROP_NAME))) { return; }
            var currentTime = new Date();
            inst.hours = currentTime.getHours();
            inst.minutes = currentTime.getMinutes();
            this._updateSelectedValue(inst);
            this._updateTimepicker(inst);
            this._hideTimepicker();
        },

        deselectTime: function(event) {
            var id = $(event.target).attr("data-timepicker-instance-id"),
                $target = $(id),
                inst = this._getInst($target[0]);
            inst.hours = -1;
            inst.minutes = -1;
            this._updateSelectedValue(inst);
            this._hideTimepicker();
        },


        selectHours: function (event) {
            var $td = $(event.currentTarget),
                id = $td.attr("data-timepicker-instance-id"),
                newHours = parseInt($td.attr("data-hour")),
                fromDoubleClick = event.data.fromDoubleClick,
                $target = $(id),
                inst = this._getInst($target[0]),
                showMinutes = (this._get(inst, 'showMinutes') == true);

            // don't select if disabled
            if ( $.timepicker._isDisabledTimepicker($target.attr('id')) ) { return false }

            $td.parents('.ui-timepicker-hours:first').find('a').removeClass('ui-state-active');
            $td.children('a').addClass('ui-state-active');
            inst.hours = newHours;

            // added for onMinuteShow callback
            var onMinuteShow = this._get(inst, 'onMinuteShow'),
                maxTime = this._get(inst, 'maxTime'),
                minTime = this._get(inst, 'minTime');
            if (onMinuteShow || maxTime.minute || minTime.minute) {
                // this will trigger a callback on selected hour to make sure selected minute is allowed. 
                this._updateMinuteDisplay(inst);
            }

            this._updateSelectedValue(inst);

            inst._hoursClicked = true;
            if ((inst._minutesClicked) || (fromDoubleClick) || (showMinutes == false)) {
                $.timepicker._hideTimepicker();
            }
            // return false because if used inline, prevent the url to change to a hashtag
            return false;
        },

        selectMinutes: function (event) {
            var $td = $(event.currentTarget),
                id = $td.attr("data-timepicker-instance-id"),
                newMinutes = parseInt($td.attr("data-minute")),
                fromDoubleClick = event.data.fromDoubleClick,
                $target = $(id),
                inst = this._getInst($target[0]),
                showHours = (this._get(inst, 'showHours') == true);

            // don't select if disabled
            if ( $.timepicker._isDisabledTimepicker($target.attr('id')) ) { return false }

            $td.parents('.ui-timepicker-minutes:first').find('a').removeClass('ui-state-active');
            $td.children('a').addClass('ui-state-active');

            inst.minutes = newMinutes;
            this._updateSelectedValue(inst);

            inst._minutesClicked = true;
            if ((inst._hoursClicked) || (fromDoubleClick) || (showHours == false)) {
                $.timepicker._hideTimepicker();
                // return false because if used inline, prevent the url to change to a hashtag
                return false;
            }

            // return false because if used inline, prevent the url to change to a hashtag
            return false;
        },

        _updateSelectedValue: function (inst) {
            var newTime = this._getParsedTime(inst);
            if (inst.input) {
                inst.input.val(newTime);
                inst.input.trigger('change');
            }
            var onSelect = this._get(inst, 'onSelect');
            if (onSelect) { onSelect.apply((inst.input ? inst.input[0] : null), [newTime, inst]); } // trigger custom callback
            this._updateAlternate(inst, newTime);
            return newTime;
        },

        /* this function process selected time and return it parsed according to instance options */
        _getParsedTime: function(inst) {

            if (inst.hours == -1 && inst.minutes == -1) {
                return '';
            }

            // default to 0 AM if hours is not valid
            if ((inst.hours < inst.hours.starts) || (inst.hours > inst.hours.ends )) { inst.hours = 0; }
            // default to 0 minutes if minute is not valid
            if ((inst.minutes < inst.minutes.starts) || (inst.minutes > inst.minutes.ends)) { inst.minutes = 0; }

            var period = "",
                showPeriod = (this._get(inst, 'showPeriod') == true),
                showLeadingZero = (this._get(inst, 'showLeadingZero') == true),
                showHours = (this._get(inst, 'showHours') == true),
                showMinutes = (this._get(inst, 'showMinutes') == true),
                optionalMinutes = (this._get(inst, 'optionalMinutes') == true),
                amPmText = this._get(inst, 'amPmText'),
                selectedHours = inst.hours ? inst.hours : 0,
                selectedMinutes = inst.minutes ? inst.minutes : 0,
                displayHours = selectedHours ? selectedHours : 0,
                parsedTime = '';

            // fix some display problem when hours or minutes are not selected yet
            if (displayHours == -1) { displayHours = 0 }
            if (selectedMinutes == -1) { selectedMinutes = 0 }

            if (showPeriod) {
                if (inst.hours == 0) {
                    displayHours = 12;
                }
                if (inst.hours < 12) {
                    period = amPmText[0];
                }
                else {
                    period = amPmText[1];
                    if (displayHours > 12) {
                        displayHours -= 12;
                    }
                }
            }

            var h = displayHours.toString();
            if (showLeadingZero && (displayHours < 10)) { h = '0' + h; }

            var m = selectedMinutes.toString();
            if (selectedMinutes < 10) { m = '0' + m; }

            if (showHours) {
                parsedTime += h;
            }
            if (showHours && showMinutes && (!optionalMinutes || m != 0)) {
                parsedTime += this._get(inst, 'timeSeparator');
            }
            if (showMinutes && (!optionalMinutes || m != 0)) {
                parsedTime += m;
            }
            if (showHours) {
                if (period.length > 0) { parsedTime += this._get(inst, 'periodSeparator') + period; }
            }

            return parsedTime;
        },

        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function(inst, newTime) {
            var altField = this._get(inst, 'altField');
            if (altField) { // update alternate field too
                $(altField).each(function(i,e) {
                    $(e).val(newTime);
                });
            }
        },

        _getTimeAsDateTimepicker: function(input) {
            var inst = this._getInst(input);
            if (inst.hours == -1 && inst.minutes == -1) {
                return '';
            }

            // default to 0 AM if hours is not valid
            if ((inst.hours < inst.hours.starts) || (inst.hours > inst.hours.ends )) { inst.hours = 0; }
            // default to 0 minutes if minute is not valid
            if ((inst.minutes < inst.minutes.starts) || (inst.minutes > inst.minutes.ends)) { inst.minutes = 0; }

            return new Date(0, 0, 0, inst.hours, inst.minutes, 0);
        },
        /* This might look unused but it's called by the $.fn.timepicker function with param getTime */
        /* added v 0.2.3 - gitHub issue #5 - Thanks edanuff */
        _getTimeTimepicker : function(input) {
            var inst = this._getInst(input);
            return this._getParsedTime(inst);
        },
        _getHourTimepicker: function(input) {
            var inst = this._getInst(input);
            if ( inst == undefined) { return -1; }
            return inst.hours;
        },
        _getMinuteTimepicker: function(input) {
            var inst= this._getInst(input);
            if ( inst == undefined) { return -1; }
            return inst.minutes;
        }

    });



    /* Invoke the timepicker functionality.
    @param  options  string - a command, optionally followed by additional parameters or
    Object - settings for attaching new timepicker functionality
    @return  jQuery object */
    $.fn.timepicker = function (options) {
        /* Initialise the time picker. */
        if (!$.timepicker.initialized) {
            $(document).mousedown($.timepicker._checkExternalClick);
            $.timepicker.initialized = true;
        }

         /* Append timepicker main container to body if not exist. */
        if ($("#"+$.timepicker._mainDivId).length === 0) {
            $('body').append($.timepicker.tpDiv);
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options == 'string' && (options == 'getTime' || options == 'getTimeAsDate' || options == 'getHour' || options == 'getMinute' ))
            return $.timepicker['_' + options + 'Timepicker'].
			    apply($.timepicker, [this[0]].concat(otherArgs));
        if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
            return $.timepicker['_' + options + 'Timepicker'].
                apply($.timepicker, [this[0]].concat(otherArgs));
        return this.each(function () {
            typeof options == 'string' ?
			$.timepicker['_' + options + 'Timepicker'].
				apply($.timepicker, [this].concat(otherArgs)) :
			$.timepicker._attachTimepicker(this, options);
        });
    };

    /* jQuery extend now ignores nulls! */
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props)
            if (props[name] == null || props[name] == undefined)
                target[name] = props[name];
        return target;
    };

    $.timepicker = new Timepicker(); // singleton instance
    $.timepicker.initialized = false;
    $.timepicker.uuid = new Date().getTime();
    $.timepicker.version = "0.3.3";

    // Workaround for #4055
    // Add another global to avoid noConflict issues with inline event handlers
    window['TP_jQuery_' + tpuuid] = $;

})(jQuery);
;/*! jQuery UI - v1.11.0 - 2014-08-11
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, draggable.js, datepicker.js, tabs.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
/*!
 * jQuery UI Core 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */


// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.11.0",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	scrollParent: function() {
		var position = this.css( "position" ),
			excludeStaticParent = position === "absolute",
			scrollParent = this.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return (/(auto|scroll)/).test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: (function() {
		var uuid = 0;

		return function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			});
		};
	})(),

	removeUniqueId: function() {
		return this.each(function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	disableSelection: (function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.bind( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
		};
	})(),

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};


/*!
 * jQuery UI Widget 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */


var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

var widget = $.widget;


/*!
 * jQuery UI Mouse 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */


var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

var mouse = $.widget("ui.mouse", {
	version: "1.11.0",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown." + this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click." + this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("." + this.widgetName);
		if ( this._mouseMoveDelegate ) {
			this.document
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};

		this.document
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);

		// Iframe mouseup check - mouseup occurred in another document
		} else if ( !event.which ) {
			return this._mouseUp( event );
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		this.document
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		mouseHandled = false;
		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});


/*!
 * jQuery UI Draggable 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */


$.widget("ui.draggable", $.ui.mouse, {
	version: "1.11.0",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var document = this.document[ 0 ],
			o = this.options;

		// support: IE9
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {
			// Support: IE9+
			// If the <body> is blurred, IE will switch windows, see #9520
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {
				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth + "px", height: this.offsetHeight + "px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// The interaction is over; whether or not the click resulted in a drag, focus the element
		this.element.focus();

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this._removeHandleClassName();
		$( this.options.handle || this.element ).addClass( "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this.element.find( ".ui-draggable-handle" )
			.addBack()
			.removeClass( "ui-draggable-handle" );
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[ 0 ], [ event ])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if (!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relative_container = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );
		//The absolute position has to be recalculated after plugins
		if (type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function( event, ui, inst ) {

		var o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $( this ).sortable( "instance" );
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function( event, ui, inst ) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var uiSortable = $.extend( {}, ui, {
			item: inst.element
		});

		$.each(inst.sortables, function() {
			if (this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if (this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if (inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function( event, ui, inst ) {

		var that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if (this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function() {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}

			if (innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if (!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if (this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if (this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if (this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( i.scrollParent[ 0 ] !== i.document[ 0 ] && i.scrollParent[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			document = i.document[ 0 ];

		if ( i.scrollParent[ 0 ] !== document && i.scrollParent[ 0 ].tagName !== "HTML" ) {
			if (!o.axis || o.axis !== "x") {
				if ((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if (!o.axis || o.axis !== "y") {
				if ((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== "x") {
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== "y") {
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

var draggable = $.ui.draggable;


/*!
 * jQuery UI Datepicker 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */


$.extend($.ui, { datepicker: { version: "1.11.0" } });

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {
		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {
			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.regional.en = $.extend( true, {}, this.regional[ "" ]);
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		datepicker_extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, "datepicker", inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, "datepicker", inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], "datepicker", inst);
		}
		datepicker_extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], "datepicker", inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, "datepicker");
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, "datepicker");
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			datepicker_extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		datepicker_extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a");

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, "datepicker"))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? dpDiv.parent()[0] : datepicker_instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.11.0";

var datepicker = $.datepicker;


/*!
 * jQuery UI Tabs 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 */


var tabs = $.widget( "ui.tabs", {
	version: "1.11.0",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: (function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			// support: IE7
			// IE7 doesn't normalize the href property when set via script (#9317)
			anchor = anchor.cloneNode( false );

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	})(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		});
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr({
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

/*!
 * jQuery UI Accordion 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 */


var accordion = $.widget( "ui.accordion", {
	version: "1.11.4",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;
		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// ARIA
			.attr( "role", "tablist" );

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}

		this._processPanels();
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +
				"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +
				"ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
			options.active = false;
			this.active = $();
		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );
		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
				options.active = false;
				this.active = $();
			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}
		// was active, active panel still exists
		} else {
			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		var prevHeaders = this.headers,
			prevPanels = this.panels;

		this.headers = this.element.find( this.options.header )
			.addClass( "ui-accordion-header ui-state-default ui-corner-all" );

		this.panels = this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.filter( ":not(.ui-accordion-content-active)" )
			.hide();

		// Avoid memory leaks (#10056)
		if ( prevPanels ) {
			this._off( prevHeaders.not( this.headers ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
			.removeClass( "ui-corner-all" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this.headers
			.attr( "role", "tab" )
			.each(function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-hidden": "false"
				});
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-hidden": "true"
		});
		toHide.prev().attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr({
				"tabIndex": -1,
				"aria-expanded": "false"
			});
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			boxSizing = toShow.css( "box-sizing" ),
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						if ( boxSizing === "content-box" ) {
							adjust += fx.now;
						}
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
});

}));;/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as anonymous module.
		define(['jquery'], factory);
	} else {
		// Browser globals.
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function decode(s) {
		if (config.raw) {
			return s;
		}
		try {
			// If we can't decode the cookie, ignore it, it's unusable.
			return decodeURIComponent(s.replace(pluses, ' '));
		} catch(e) {}
	}

	function decodeAndParse(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		s = decode(s);

		try {
			// If we can't parse the cookie, ignore it, it's unusable.
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	var config = $.cookie = function (key, value, options) {

		// Write
		if (value !== undefined) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setDate(t.getDate() + days);
			}

			value = config.json ? JSON.stringify(value) : String(value);

			return (document.cookie = [
				config.raw ? key : encodeURIComponent(key),
				'=',
				config.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				result = decodeAndParse(cookie);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = decodeAndParse(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) !== undefined) {
			// Must not alter options, thus extending a fresh object...
			$.cookie(key, '', $.extend({}, options, { expires: -1 }));
			return true;
		}
		return false;
	};

}));
;/**
*
* jquery.sparkline.js
*
* v@VERSION@
* (c) Splunk, Inc
* Contact: Gareth Watts (gareth@splunk.com)
* http://omnipotent.net/jquery.sparkline/
*
* Generates inline sparkline charts from data supplied either to the method
* or inline in HTML
*
* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag
* (Firefox 2.0+, Safari, Opera, etc)
*
* License: New BSD License
*
* Copyright (c) 2012, Splunk Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright notice,
*       this list of conditions and the following disclaimer in the documentation
*       and/or other materials provided with the distribution.
*     * Neither the name of Splunk Inc nor the names of its contributors may
*       be used to endorse or promote products derived from this software without
*       specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*
* Usage:
*  $(selector).sparkline(values, options)
*
* If values is undefined or set to 'html' then the data values are read from the specified tag:
*   <p>Sparkline: <span class="sparkline">1,4,6,6,8,5,3,5</span></p>
*   $('.sparkline').sparkline();
* There must be no spaces in the enclosed data set
*
* Otherwise values must be an array of numbers or null values
*    <p>Sparkline: <span id="sparkline1">This text replaced if the browser is compatible</span></p>
*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])
*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])
*
* Values can also be specified in an HTML comment, or as a values attribute:
*    <p>Sparkline: <span class="sparkline"><!--1,4,6,6,8,5,3,5 --></span></p>
*    <p>Sparkline: <span class="sparkline" values="1,4,6,6,8,5,3,5"></span></p>
*    $('.sparkline').sparkline();
*
* For line charts, x values can also be specified:
*   <p>Sparkline: <span class="sparkline">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>
*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])
*
* By default, options should be passed in as the second argument to the sparkline function:
*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})
*
* Options can also be set by passing them on the tag itself.  This feature is disabled by default though
* as there's a slight performance overhead:
*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})
*   <p>Sparkline: <span class="sparkline" sparkType="bar" sparkBarColor="red">loading</span></p>
* Prefix all options supplied as tag attribute with "spark" (configurable by setting tagOptionsPrefix)
*
* Supported options:
*   lineColor - Color of the line used for the chart
*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart
*   width - Width of the chart - Defaults to 3 times the number of values in pixels
*   height - Height of the chart - Defaults to the height of the containing element
*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied
*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied
*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax
*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied
*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied
*   composite - If true then don't erase any existing chart attached to the tag, but draw
*           another chart over the top - Note that width and height are ignored if an
*           existing chart is detected.
*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'
*   enableTagOptions - Whether to check tags for sparkline options
*   tagOptionsPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'
*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a
*           hidden dom element, avoding a browser reflow
*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,
*       making the plugin perform much like it did in 1.x
*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)
*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled
*       defaults to false (highlights enabled)
*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase
*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body
*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied
*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis
*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis
*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip
*       callback is given arguments of (sparkline, options, fields)
*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title
*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)
*       to control the format of the tooltip
*   tooltipPrefix - A string to prepend to each field displayed in a tooltip
*   tooltipSuffix - A string to append to each field displayed in a tooltip
*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)
*   tooltipValueLookups - An object or range map to map field values to tooltip strings
*       (eg. to map -1 to "Lost", 0 to "Draw", and 1 to "Win")
*   numberFormatter - Optional callback for formatting numbers in tooltips
*   numberDigitGroupSep - Character to use for group separator in numbers "1,234" - Defaults to ","
*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to "."
*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3
*
* There are 7 types of sparkline, selected by supplying a "type" option of 'line' (default),
* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'
*    line - Line chart.  Options:
*       spotColor - Set to '' to not end each line in a circular spot
*       minSpotColor - If set, color of spot at minimum value
*       maxSpotColor - If set, color of spot at maximum value
*       spotRadius - Radius in pixels
*       lineWidth - Width of line in pixels
*       normalRangeMin
*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the "normal"
*                      or expected range of values
*       normalRangeColor - Color to use for the above bar
*       drawNormalOnTop - Draw the normal range above the chart fill color if true
*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart
*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable
*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable
*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map
*
*   bar - Bar chart.  Options:
*       barColor - Color of bars for postive values
*       negBarColor - Color of bars for negative values
*       zeroColor - Color of bars with zero values
*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely
*       barWidth - Width of bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*       barSpacing - Gap between bars in pixels
*       zeroAxis - Centers the y-axis around zero if true
*
*   tristate - Charts values of win (>0), lose (<0) or draw (=0)
*       posBarColor - Color of win values
*       negBarColor - Color of lose values
*       zeroBarColor - Color of draw values
*       barWidth - Width of bars in pixels
*       barSpacing - Gap between bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*
*   discrete - Options:
*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height
*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor
*       thresholdColor
*
*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...
*       options:
*       targetColor - The color of the vertical target marker
*       targetWidth - The width of the target marker in pixels
*       performanceColor - The color of the performance measure horizontal bar
*       rangeColors - Colors to use for each qualitative range background color
*
*   pie - Pie chart. Options:
*       sliceColors - An array of colors to use for pie slices
*       offset - Angle in degrees to offset the first slice - Try -90 or +90
*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)
*       borderColor - Color to use for the pie chart border - Defaults to #000
*
*   box - Box plot. Options:
*       raw - Set to true to supply pre-computed plot points as values
*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier
*             When set to false you can supply any number of values and the box plot will
*             be computed for you.  Default is false.
*       showOutliers - Set to true (default) to display outliers as circles
*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5
*       boxLineColor - Outline color of the box
*       boxFillColor - Fill color for the box
*       whiskerColor - Line color used for whiskers
*       outlierLineColor - Outline color of outlier circles
*       outlierFillColor - Fill color of the outlier circles
*       spotRadius - Radius of outlier circles
*       medianColor - Line color of the median line
*       target - Draw a target cross hair at the supplied value (default undefined)
*
*
*
*   Examples:
*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });
*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });
*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):
*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });
*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });
*   $('#pie').sparkline([1,1,2], { type:'pie' });
*/

/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */

(function(document, Math, undefined) { // performance/minified-size optimization
(function(factory) {
    if(typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (jQuery && !jQuery.fn.sparkline) {
        factory(jQuery);
    }
}
(function($) {
    'use strict';

    var UNSET_OPTION = {},
        getDefaults, createClass, SPFormat, clipval, quartile, normalizeValue, normalizeValues,
        remove, isNumber, all, sum, addCSS, ensureArray, formatNumber, RangeMap,
        MouseHandler, Tooltip, barHighlightMixin,
        line, bar, tristate, discrete, bullet, pie, box, defaultStyles, initStyles,
        VShape, VCanvas_base, VCanvas_canvas, VCanvas_vml, pending, shapeCount = 0;


    /**
     * Default configuration settings
     */
    getDefaults = function () {
        return {
            // Settings common to most/all chart types
            common: {
                type: 'line',
                lineColor: '#00f',
                fillColor: '#cdf',
                defaultPixelsPerValue: 3,
                width: 'auto',
                height: 'auto',
                composite: false,
                tagValuesAttribute: 'values',
                tagOptionsPrefix: 'spark',
                enableTagOptions: false,
                enableHighlight: true,
                highlightLighten: 1.4,
                tooltipSkipNull: true,
                tooltipPrefix: '',
                tooltipSuffix: '',
                disableHiddenCheck: false,
                numberFormatter: false,
                numberDigitGroupCount: 3,
                numberDigitGroupSep: ',',
                numberDecimalMark: '.',
                disableTooltips: false,
                disableInteraction: false
            },
            // Defaults for line charts
            line: {
                spotColor: '#f80',
                highlightSpotColor: '#5f5',
                highlightLineColor: '#f22',
                spotRadius: 1.5,
                minSpotColor: '#f80',
                maxSpotColor: '#f80',
                lineWidth: 1,
                normalRangeMin: undefined,
                normalRangeMax: undefined,
                normalRangeColor: '#ccc',
                drawNormalOnTop: false,
                chartRangeMin: undefined,
                chartRangeMax: undefined,
                chartRangeMinX: undefined,
                chartRangeMaxX: undefined,
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
            },
            // Defaults for bar charts
            bar: {
                barColor: '#3366cc',
                negBarColor: '#f44',
                stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00',
                    '#dd4477', '#0099c6', '#990099'],
                zeroColor: undefined,
                nullColor: undefined,
                zeroAxis: true,
                barWidth: 4,
                barSpacing: 1,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: false,
                colorMap: undefined,
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
            },
            // Defaults for tristate charts
            tristate: {
                barWidth: 4,
                barSpacing: 1,
                posBarColor: '#6f6',
                negBarColor: '#f44',
                zeroBarColor: '#999',
                colorMap: {},
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
                tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }
            },
            // Defaults for discrete charts
            discrete: {
                lineHeight: 'auto',
                thresholdColor: undefined,
                thresholdValue: 0,
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                chartRangeClip: false,
                tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')
            },
            // Defaults for bullet charts
            bullet: {
                targetColor: '#f33',
                targetWidth: 3, // width of the target bar in pixels
                performanceColor: '#33f',
                rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],
                base: undefined, // set this to a number to change the base start number
                tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),
                tooltipValueLookups: { fields: {r: 'Range', p: 'Performance', t: 'Target'} }
            },
            // Defaults for pie charts
            pie: {
                offset: 0,
                sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00',
                    '#dd4477', '#0099c6', '#990099'],
                borderWidth: 0,
                borderColor: '#000',
                tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
            },
            // Defaults for box plots
            box: {
                raw: false,
                boxLineColor: '#000',
                boxFillColor: '#cdf',
                whiskerColor: '#000',
                outlierLineColor: '#333',
                outlierFillColor: '#fff',
                medianColor: '#f00',
                showOutliers: true,
                outlierIQR: 1.5,
                spotRadius: 1.5,
                target: undefined,
                targetColor: '#4a2',
                chartRangeMax: undefined,
                chartRangeMin: undefined,
                tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),
                tooltipFormatFieldlistKey: 'field',
                tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',
                    uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',
                    lw: 'Left Whisker', rw: 'Right Whisker'} }
            }
        };
    };

    // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname
    defaultStyles = '.jqstooltip { ' +
            'position: absolute;' +
            'left: 0px;' +
            'top: 0px;' +
            'visibility: hidden;' +
            'background: rgb(0, 0, 0) transparent;' +
            'background-color: rgba(0,0,0,0.6);' +
            'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' +
            '-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";' +
            'color: white;' +
            'font: 10px arial, san serif;' +
            'text-align: left;' +
            'white-space: nowrap;' +
            'padding: 5px;' +
            'border: 1px solid white;' +
            'box-sizing: content-box;' +
            'z-index: 10000;' +
            '}' +
            '.jqsfield { ' +
            'color: white;' +
            'font: 10px arial, san serif;' +
            'text-align: left;' +
            '}';


    /**
     * Utilities
     */

    createClass = function (/* [baseclass, [mixin, ...]], definition */) {
        var Class, args;
        Class = function () {
            this.init.apply(this, arguments);
        };
        if (arguments.length > 1) {
            if (arguments[0]) {
                Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);
                Class._super = arguments[0].prototype;
            } else {
                Class.prototype = arguments[arguments.length - 1];
            }
            if (arguments.length > 2) {
                args = Array.prototype.slice.call(arguments, 1, -1);
                args.unshift(Class.prototype);
                $.extend.apply($, args);
            }
        } else {
            Class.prototype = arguments[0];
        }
        Class.prototype.cls = Class;
        return Class;
    };

    /**
     * Wraps a format string for tooltips
     * {{x}}
     * {{x.2}
     * {{x:months}}
     */
    $.SPFormatClass = SPFormat = createClass({
        fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
        precre: /(\w+)\.(\d+)/,

        init: function (format, fclass) {
            this.format = format;
            this.fclass = fclass;
        },

        render: function (fieldset, lookups, options) {
            var self = this,
                fields = fieldset,
                match, token, lookupkey, fieldvalue, prec;
            return this.format.replace(this.fre, function () {
                var lookup;
                token = arguments[1];
                lookupkey = arguments[3];
                match = self.precre.exec(token);
                if (match) {
                    prec = match[2];
                    token = match[1];
                } else {
                    prec = false;
                }
                fieldvalue = fields[token];
                if (fieldvalue === undefined) {
                    return '';
                }
                if (lookupkey && lookups && lookups[lookupkey]) {
                    lookup = lookups[lookupkey];
                    if (lookup.get) { // RangeMap
                        return lookups[lookupkey].get(fieldvalue) || fieldvalue;
                    } else {
                        return lookups[lookupkey][fieldvalue] || fieldvalue;
                    }
                }
                if (isNumber(fieldvalue)) {
                    if (options.get('numberFormatter')) {
                        fieldvalue = options.get('numberFormatter')(fieldvalue);
                    } else {
                        fieldvalue = formatNumber(fieldvalue, prec,
                            options.get('numberDigitGroupCount'),
                            options.get('numberDigitGroupSep'),
                            options.get('numberDecimalMark'));
                    }
                }
                return fieldvalue;
            });
        }
    });

    // convience method to avoid needing the new operator
    $.spformat = function(format, fclass) {
        return new SPFormat(format, fclass);
    };

    clipval = function (val, min, max) {
        if (val < min) {
            return min;
        }
        if (val > max) {
            return max;
        }
        return val;
    };

    quartile = function (values, q) {
        var vl;
        if (q === 2) {
            vl = Math.floor(values.length / 2);
            return values.length % 2 ? values[vl] : (values[vl-1] + values[vl]) / 2;
        } else {
            if (values.length % 2 ) { // odd
                vl = (values.length * q + q) / 4;
                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl-1];
            } else { //even
                vl = (values.length * q + 2) / 4;
                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 :  values[vl-1];

            }
        }
    };

    normalizeValue = function (val) {
        var nf;
        switch (val) {
            case 'undefined':
                val = undefined;
                break;
            case 'null':
                val = null;
                break;
            case 'true':
                val = true;
                break;
            case 'false':
                val = false;
                break;
            default:
                nf = parseFloat(val);
                if (val == nf) {
                    val = nf;
                }
        }
        return val;
    };

    normalizeValues = function (vals) {
        var i, result = [];
        for (i = vals.length; i--;) {
            result[i] = normalizeValue(vals[i]);
        }
        return result;
    };

    remove = function (vals, filter) {
        var i, vl, result = [];
        for (i = 0, vl = vals.length; i < vl; i++) {
            if (vals[i] !== filter) {
                result.push(vals[i]);
            }
        }
        return result;
    };

    isNumber = function (num) {
        return !isNaN(parseFloat(num)) && isFinite(num);
    };

    formatNumber = function (num, prec, groupsize, groupsep, decsep) {
        var p, i;
        num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');
        p = (p = $.inArray('.', num)) < 0 ? num.length : p;
        if (p < num.length) {
            num[p] = decsep;
        }
        for (i = p - groupsize; i > 0; i -= groupsize) {
            num.splice(i, 0, groupsep);
        }
        return num.join('');
    };

    // determine if all values of an array match a value
    // returns true if the array is empty
    all = function (val, arr, ignoreNull) {
        var i;
        for (i = arr.length; i--; ) {
            if (ignoreNull && arr[i] === null) continue;
            if (arr[i] !== val) {
                return false;
            }
        }
        return true;
    };

    // sums the numeric values in an array, ignoring other values
    sum = function (vals) {
        var total = 0, i;
        for (i = vals.length; i--;) {
            total += typeof vals[i] === 'number' ? vals[i] : 0;
        }
        return total;
    };

    ensureArray = function (val) {
        return $.isArray(val) ? val : [val];
    };

    // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/
    addCSS = function(css) {
        var tag, iefail;
        if (document.createStyleSheet) {
            try {
                document.createStyleSheet().cssText = css;
                return;
            } catch (e) {
                // IE <= 9 maxes out at 31 stylesheets; inject into page instead.
                iefail = true;
            }
        }
        tag = document.createElement('style');
        tag.type = 'text/css';
        document.getElementsByTagName('head')[0].appendChild(tag);
        if (iefail) {
            document.styleSheets[document.styleSheets.length - 1].cssText = css;
        } else {
            tag[(typeof document.body.style.WebkitAppearance == 'string') /* webkit only */ ? 'innerText' : 'innerHTML'] = css;
        }
    };


    // Provide a cross-browser interface to a few simple drawing primitives
    $.fn.simpledraw = function (width, height, useExisting, interact) {
        var target, mhandler;
        if (useExisting && (target = this.data('_jqs_vcanvas'))) {
            return target;
        }

        if ($.fn.sparkline.canvas === false) {
            // We've already determined that neither Canvas nor VML are available
            return false;

        } else if ($.fn.sparkline.canvas === undefined) {
            // No function defined yet -- need to see if we support Canvas or VML
            var el = document.createElement('canvas');
            if (!!(el.getContext && el.getContext('2d'))) {
                // Canvas is available
                $.fn.sparkline.canvas = function(width, height, target, interact) {
                    return new VCanvas_canvas(width, height, target, interact);
                };
            } else if (document.namespaces && !document.namespaces.v) {
                // VML is available
                document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');
                $.fn.sparkline.canvas = function(width, height, target, interact) {
                    return new VCanvas_vml(width, height, target);
                };
            } else {
                // Neither Canvas nor VML are available
                $.fn.sparkline.canvas = false;
                return false;
            }
        }

        if (width === undefined) {
            width = $(this).innerWidth();
        }
        if (height === undefined) {
            height = $(this).innerHeight();
        }

        target = $.fn.sparkline.canvas(width, height, this, interact);

        mhandler = $(this).data('_jqs_mhandler');
        if (mhandler) {
            mhandler.registerCanvas(target);
        }
        return target;
    };

    $.fn.cleardraw = function () {
        var target = this.data('_jqs_vcanvas');
        if (target) {
            target.reset();
        }
    };


    $.RangeMapClass = RangeMap = createClass({
        init: function (map) {
            var key, range, rangelist = [];
            for (key in map) {
                if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {
                    range = key.split(':');
                    range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);
                    range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);
                    range[2] = map[key];
                    rangelist.push(range);
                }
            }
            this.map = map;
            this.rangelist = rangelist || false;
        },

        get: function (value) {
            var rangelist = this.rangelist,
                i, range, result;
            if ((result = this.map[value]) !== undefined) {
                return result;
            }
            if (rangelist) {
                for (i = rangelist.length; i--;) {
                    range = rangelist[i];
                    if (range[0] <= value && range[1] >= value) {
                        return range[2];
                    }
                }
            }
            return undefined;
        }
    });

    // Convenience function
    $.range_map = function(map) {
        return new RangeMap(map);
    };


    MouseHandler = createClass({
        init: function (el, options) {
            var $el = $(el);
            this.$el = $el;
            this.options = options;
            this.currentPageX = 0;
            this.currentPageY = 0;
            this.el = el;
            this.splist = [];
            this.tooltip = null;
            this.over = false;
            this.displayTooltips = !options.get('disableTooltips');
            this.highlightEnabled = !options.get('disableHighlight');
        },

        registerSparkline: function (sp) {
            this.splist.push(sp);
            if (this.over) {
                this.updateDisplay();
            }
        },

        registerCanvas: function (canvas) {
            var $canvas = $(canvas.canvas);
            this.canvas = canvas;
            this.$canvas = $canvas;
            $canvas.mouseenter($.proxy(this.mouseenter, this));
            $canvas.mouseleave($.proxy(this.mouseleave, this));
            $canvas.click($.proxy(this.mouseclick, this));
        },

        reset: function (removeTooltip) {
            this.splist = [];
            if (this.tooltip && removeTooltip) {
                this.tooltip.remove();
                this.tooltip = undefined;
            }
        },

        mouseclick: function (e) {
            var clickEvent = $.Event('sparklineClick');
            clickEvent.originalEvent = e;
            clickEvent.sparklines = this.splist;
            this.$el.trigger(clickEvent);
        },

        mouseenter: function (e) {
            $(document.body).unbind('mousemove.jqs');
            $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));
            this.over = true;
            this.currentPageX = e.pageX;
            this.currentPageY = e.pageY;
            this.currentEl = e.target;
            if (!this.tooltip && this.displayTooltips) {
                this.tooltip = new Tooltip(this.options);
                this.tooltip.updatePosition(e.pageX, e.pageY);
            }
            this.updateDisplay();
        },

        mouseleave: function () {
            $(document.body).unbind('mousemove.jqs');
            var splist = this.splist,
                 spcount = splist.length,
                 needsRefresh = false,
                 sp, i;
            this.over = false;
            this.currentEl = null;

            if (this.tooltip) {
                this.tooltip.remove();
                this.tooltip = null;
            }

            for (i = 0; i < spcount; i++) {
                sp = splist[i];
                if (sp.clearRegionHighlight()) {
                    needsRefresh = true;
                }
            }

            if (needsRefresh) {
                this.canvas.render();
            }
        },

        mousemove: function (e) {
            this.currentPageX = e.pageX;
            this.currentPageY = e.pageY;
            this.currentEl = e.target;
            if (this.tooltip) {
                this.tooltip.updatePosition(e.pageX, e.pageY);
            }
            this.updateDisplay();
        },

        updateDisplay: function () {
            var splist = this.splist,
                 spcount = splist.length,
                 needsRefresh = false,
                 offset = this.$canvas.offset(),
                 localX = this.currentPageX - offset.left,
                 localY = this.currentPageY - offset.top,
                 tooltiphtml, sp, i, result, changeEvent;
            if (!this.over) {
                return;
            }
            for (i = 0; i < spcount; i++) {
                sp = splist[i];
                result = sp.setRegionHighlight(this.currentEl, localX, localY);
                if (result) {
                    needsRefresh = true;
                }
            }
            if (needsRefresh) {
                changeEvent = $.Event('sparklineRegionChange');
                changeEvent.sparklines = this.splist;
                this.$el.trigger(changeEvent);
                if (this.tooltip) {
                    tooltiphtml = '';
                    for (i = 0; i < spcount; i++) {
                        sp = splist[i];
                        tooltiphtml += sp.getCurrentRegionTooltip();
                    }
                    this.tooltip.setContent(tooltiphtml);
                }
                if (!this.disableHighlight) {
                    this.canvas.render();
                }
            }
            if (result === null) {
                this.mouseleave();
            }
        }
    });


    Tooltip = createClass({
        sizeStyle: 'position: static !important;' +
            'display: block !important;' +
            'visibility: hidden !important;' +
            'float: left !important;',

        init: function (options) {
            var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),
                sizetipStyle = this.sizeStyle,
                offset;
            this.container = options.get('tooltipContainer') || document.body;
            this.tooltipOffsetX = options.get('tooltipOffsetX', 10);
            this.tooltipOffsetY = options.get('tooltipOffsetY', 12);
            // remove any previous lingering tooltip
            $('#jqssizetip').remove();
            $('#jqstooltip').remove();
            this.sizetip = $('<div/>', {
                id: 'jqssizetip',
                style: sizetipStyle,
                'class': tooltipClassname
            });
            this.tooltip = $('<div/>', {
                id: 'jqstooltip',
                'class': tooltipClassname
            }).appendTo(this.container);
            // account for the container's location
            offset = this.tooltip.offset();
            this.offsetLeft = offset.left;
            this.offsetTop = offset.top;
            this.hidden = true;
            $(window).unbind('resize.jqs scroll.jqs');
            $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));
            this.updateWindowDims();
        },

        updateWindowDims: function () {
            this.scrollTop = $(window).scrollTop();
            this.scrollLeft = $(window).scrollLeft();
            this.scrollRight = this.scrollLeft + $(window).width();
            this.updatePosition();
        },

        getSize: function (content) {
            this.sizetip.html(content).appendTo(this.container);
            this.width = this.sizetip.width() + 1;
            this.height = this.sizetip.height();
            this.sizetip.remove();
        },

        setContent: function (content) {
            if (!content) {
                this.tooltip.css('visibility', 'hidden');
                this.hidden = true;
                return;
            }
            this.getSize(content);
            this.tooltip.html(content)
                .css({
                    'width': this.width,
                    'height': this.height,
                    'visibility': 'visible'
                });
            if (this.hidden) {
                this.hidden = false;
                this.updatePosition();
            }
        },

        updatePosition: function (x, y) {
            if (x === undefined) {
                if (this.mousex === undefined) {
                    return;
                }
                x = this.mousex - this.offsetLeft;
                y = this.mousey - this.offsetTop;

            } else {
                this.mousex = x = x - this.offsetLeft;
                this.mousey = y = y - this.offsetTop;
            }
            if (!this.height || !this.width || this.hidden) {
                return;
            }

            y -= this.height + this.tooltipOffsetY;
            x += this.tooltipOffsetX;

            if (y < this.scrollTop) {
                y = this.scrollTop;
            }
            if (x < this.scrollLeft) {
                x = this.scrollLeft;
            } else if (x + this.width > this.scrollRight) {
                x = this.scrollRight - this.width;
            }

            this.tooltip.css({
                'left': x,
                'top': y
            });
        },

        remove: function () {
            this.tooltip.remove();
            this.sizetip.remove();
            this.sizetip = this.tooltip = undefined;
            $(window).unbind('resize.jqs scroll.jqs');
        }
    });


    initStyles = function() {
        addCSS(defaultStyles);
    };

    $(initStyles);

    pending = [];
    $.fn.sparkline = function (userValues, userOptions) {
        return this.each(function () {
            var options = new $.fn.sparkline.options(this, userOptions),
                 $this = $(this),
                 render, i;
            render = function () {
                var values, width, height, tmp, mhandler, sp, vals;
                if (userValues === 'html' || userValues === undefined) {
                    vals = this.getAttribute(options.get('tagValuesAttribute'));
                    if (vals === undefined || vals === null) {
                        vals = $this.html();
                    }
                    values = vals.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, '').split(',');
                } else {
                    values = userValues;
                }

                width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');
                if (options.get('height') === 'auto') {
                    if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {
                        // must be a better way to get the line height
                        tmp = document.createElement('span');
                        tmp.innerHTML = 'a';
                        $this.html(tmp);
                        height = $(tmp).innerHeight() || $(tmp).height();
                        $(tmp).remove();
                        tmp = null;
                    }
                } else {
                    height = options.get('height');
                }

                if (!options.get('disableInteraction')) {
                    mhandler = $.data(this, '_jqs_mhandler');
                    if (!mhandler) {
                        mhandler = new MouseHandler(this, options);
                        $.data(this, '_jqs_mhandler', mhandler);
                    } else if (!options.get('composite')) {
                        mhandler.reset();
                    }
                } else {
                    mhandler = false;
                }

                if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {
                    if (!$.data(this, '_jqs_errnotify')) {
                        alert('Attempted to attach a composite sparkline to an element with no existing sparkline');
                        $.data(this, '_jqs_errnotify', true);
                    }
                    return;
                }

                sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);

                sp.render();

                if (mhandler) {
                    mhandler.registerSparkline(sp);
                }
            };
            if (($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden')) || !$(this).parents('body').length) {
                if (!options.get('composite') && $.data(this, '_jqs_pending')) {
                    // remove any existing references to the element
                    for (i = pending.length; i; i--) {
                        if (pending[i - 1][0] == this) {
                            pending.splice(i - 1, 1);
                        }
                    }
                }
                pending.push([this, render]);
                $.data(this, '_jqs_pending', true);
            } else {
                render.call(this);
            }
        });
    };

    $.fn.sparkline.defaults = getDefaults();


    $.sparkline_display_visible = function () {
        var el, i, pl;
        var done = [];
        for (i = 0, pl = pending.length; i < pl; i++) {
            el = pending[i][0];
            if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {
                pending[i][1].call(el);
                $.data(pending[i][0], '_jqs_pending', false);
                done.push(i);
            } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {
                // element has been inserted and removed from the DOM
                // If it was not yet inserted into the dom then the .data request
                // will return true.
                // removing from the dom causes the data to be removed.
                $.data(pending[i][0], '_jqs_pending', false);
                done.push(i);
            }
        }
        for (i = done.length; i; i--) {
            pending.splice(done[i - 1], 1);
        }
    };


    /**
     * User option handler
     */
    $.fn.sparkline.options = createClass({
        init: function (tag, userOptions) {
            var extendedOptions, defaults, base, tagOptionType;
            this.userOptions = userOptions = userOptions || {};
            this.tag = tag;
            this.tagValCache = {};
            defaults = $.fn.sparkline.defaults;
            base = defaults.common;
            this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);

            tagOptionType = this.getTagSetting('type');
            if (tagOptionType === UNSET_OPTION) {
                extendedOptions = defaults[userOptions.type || base.type];
            } else {
                extendedOptions = defaults[tagOptionType];
            }
            this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);
        },


        getTagSetting: function (key) {
            var prefix = this.tagOptionsPrefix,
                val, i, pairs, keyval;
            if (prefix === false || prefix === undefined) {
                return UNSET_OPTION;
            }
            if (this.tagValCache.hasOwnProperty(key)) {
                val = this.tagValCache.key;
            } else {
                val = this.tag.getAttribute(prefix + key);
                if (val === undefined || val === null) {
                    val = UNSET_OPTION;
                } else if (val.substr(0, 1) === '[') {
                    val = val.substr(1, val.length - 2).split(',');
                    for (i = val.length; i--;) {
                        val[i] = normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g, ''));
                    }
                } else if (val.substr(0, 1) === '{') {
                    pairs = val.substr(1, val.length - 2).split(',');
                    val = {};
                    for (i = pairs.length; i--;) {
                        keyval = pairs[i].split(':', 2);
                        val[keyval[0].replace(/(^\s*)|(\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g, ''));
                    }
                } else {
                    val = normalizeValue(val);
                }
                this.tagValCache.key = val;
            }
            return val;
        },

        get: function (key, defaultval) {
            var tagOption = this.getTagSetting(key),
                result;
            if (tagOption !== UNSET_OPTION) {
                return tagOption;
            }
            return (result = this.mergedOptions[key]) === undefined ? defaultval : result;
        }
    });


    $.fn.sparkline._base = createClass({
        disabled: false,

        init: function (el, values, options, width, height) {
            this.el = el;
            this.$el = $(el);
            this.values = values;
            this.options = options;
            this.width = width;
            this.height = height;
            this.currentRegion = undefined;
        },

        /**
         * Setup the canvas
         */
        initTarget: function () {
            var interactive = !this.options.get('disableInteraction');
            if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {
                this.disabled = true;
            } else {
                this.canvasWidth = this.target.pixelWidth;
                this.canvasHeight = this.target.pixelHeight;
            }
        },

        /**
         * Actually render the chart to the canvas
         */
        render: function () {
            if (this.disabled) {
                this.el.innerHTML = '';
                return false;
            }
            return true;
        },

        /**
         * Return a region id for a given x/y co-ordinate
         */
        getRegion: function (x, y) {
        },

        /**
         * Highlight an item based on the moused-over x,y co-ordinate
         */
        setRegionHighlight: function (el, x, y) {
            var currentRegion = this.currentRegion,
                highlightEnabled = !this.options.get('disableHighlight'),
                newRegion;
            if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {
                return null;
            }
            newRegion = this.getRegion(el, x, y);
            if (currentRegion !== newRegion) {
                if (currentRegion !== undefined && highlightEnabled) {
                    this.removeHighlight();
                }
                this.currentRegion = newRegion;
                if (newRegion !== undefined && highlightEnabled) {
                    this.renderHighlight();
                }
                return true;
            }
            return false;
        },

        /**
         * Reset any currently highlighted item
         */
        clearRegionHighlight: function () {
            if (this.currentRegion !== undefined) {
                this.removeHighlight();
                this.currentRegion = undefined;
                return true;
            }
            return false;
        },

        renderHighlight: function () {
            this.changeHighlight(true);
        },

        removeHighlight: function () {
            this.changeHighlight(false);
        },

        changeHighlight: function (highlight)  {},

        /**
         * Fetch the HTML to display as a tooltip
         */
        getCurrentRegionTooltip: function () {
            var options = this.options,
                header = '',
                entries = [],
                fields, formats, formatlen, fclass, text, i,
                showFields, showFieldsKey, newFields, fv,
                formatter, format, fieldlen, j;
            if (this.currentRegion === undefined) {
                return '';
            }
            fields = this.getCurrentRegionFields();
            formatter = options.get('tooltipFormatter');
            if (formatter) {
                return formatter(this, options, fields);
            }
            if (options.get('tooltipChartTitle')) {
                header += '<div class="jqs jqstitle">' + options.get('tooltipChartTitle') + '</div>\n';
            }
            formats = this.options.get('tooltipFormat');
            if (!formats) {
                return '';
            }
            if (!$.isArray(formats)) {
                formats = [formats];
            }
            if (!$.isArray(fields)) {
                fields = [fields];
            }
            showFields = this.options.get('tooltipFormatFieldlist');
            showFieldsKey = this.options.get('tooltipFormatFieldlistKey');
            if (showFields && showFieldsKey) {
                // user-selected ordering of fields
                newFields = [];
                for (i = fields.length; i--;) {
                    fv = fields[i][showFieldsKey];
                    if ((j = $.inArray(fv, showFields)) != -1) {
                        newFields[j] = fields[i];
                    }
                }
                fields = newFields;
            }
            formatlen = formats.length;
            fieldlen = fields.length;
            for (i = 0; i < formatlen; i++) {
                format = formats[i];
                if (typeof format === 'string') {
                    format = new SPFormat(format);
                }
                fclass = format.fclass || 'jqsfield';
                for (j = 0; j < fieldlen; j++) {
                    if (!fields[j].isNull || !options.get('tooltipSkipNull')) {
                        $.extend(fields[j], {
                            prefix: options.get('tooltipPrefix'),
                            suffix: options.get('tooltipSuffix')
                        });
                        text = format.render(fields[j], options.get('tooltipValueLookups'), options);
                        entries.push('<div class="' + fclass + '">' + text + '</div>');
                    }
                }
            }
            if (entries.length) {
                return header + entries.join('\n');
            }
            return '';
        },

        getCurrentRegionFields: function () {},

        calcHighlightColor: function (color, options) {
            var highlightColor = options.get('highlightColor'),
                lighten = options.get('highlightLighten'),
                parse, mult, rgbnew, i;
            if (highlightColor) {
                return highlightColor;
            }
            if (lighten) {
                // extract RGB values
                parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);
                if (parse) {
                    rgbnew = [];
                    mult = color.length === 4 ? 16 : 1;
                    for (i = 0; i < 3; i++) {
                        rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);
                    }
                    return 'rgb(' + rgbnew.join(',') + ')';
                }

            }
            return color;
        }

    });

    barHighlightMixin = {
        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                target = this.target,
                shapeids = this.regionShapes[currentRegion],
                newShapes;
            // will be null if the region value was null
            if (shapeids) {
                newShapes = this.renderRegion(currentRegion, highlight);
                if ($.isArray(newShapes) || $.isArray(shapeids)) {
                    target.replaceWithShapes(shapeids, newShapes);
                    this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {
                        return newShape.id;
                    });
                } else {
                    target.replaceWithShape(shapeids, newShapes);
                    this.regionShapes[currentRegion] = newShapes.id;
                }
            }
        },

        render: function () {
            var values = this.values,
                target = this.target,
                regionShapes = this.regionShapes,
                shapes, ids, i, j;

            if (!this.cls._super.render.call(this)) {
                return;
            }
            for (i = values.length; i--;) {
                shapes = this.renderRegion(i);
                if (shapes) {
                    if ($.isArray(shapes)) {
                        ids = [];
                        for (j = shapes.length; j--;) {
                            shapes[j].append();
                            ids.push(shapes[j].id);
                        }
                        regionShapes[i] = ids;
                    } else {
                        shapes.append();
                        regionShapes[i] = shapes.id; // store just the shapeid
                    }
                } else {
                    // null value
                    regionShapes[i] = null;
                }
            }
            target.render();
        }
    };


    /**
     * Line charts
     */
    $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {
        type: 'line',

        init: function (el, values, options, width, height) {
            line._super.init.call(this, el, values, options, width, height);
            this.vertices = [];
            this.regionMap = [];
            this.xvalues = [];
            this.yvalues = [];
            this.yminmax = [];
            this.hightlightSpotId = null;
            this.lastShapeId = null;
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            var i,
                regionMap = this.regionMap; // maps regions to value positions
            for (i = regionMap.length; i--;) {
                if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {
                    return regionMap[i][2];
                }
            }
            return undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.yvalues[currentRegion] === null,
                x: this.xvalues[currentRegion],
                y: this.yvalues[currentRegion],
                color: this.options.get('lineColor'),
                fillColor: this.options.get('fillColor'),
                offset: currentRegion
            };
        },

        renderHighlight: function () {
            var currentRegion = this.currentRegion,
                target = this.target,
                vertex = this.vertices[currentRegion],
                options = this.options,
                spotRadius = options.get('spotRadius'),
                highlightSpotColor = options.get('highlightSpotColor'),
                highlightLineColor = options.get('highlightLineColor'),
                highlightSpot, highlightLine;

            if (!vertex) {
                return;
            }
            if (spotRadius && highlightSpotColor) {
                highlightSpot = target.drawCircle(vertex[0], vertex[1],
                    spotRadius, undefined, highlightSpotColor);
                this.highlightSpotId = highlightSpot.id;
                target.insertAfterShape(this.lastShapeId, highlightSpot);
            }
            if (highlightLineColor) {
                highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0],
                    this.canvasTop + this.canvasHeight, highlightLineColor);
                this.highlightLineId = highlightLine.id;
                target.insertAfterShape(this.lastShapeId, highlightLine);
            }
        },

        removeHighlight: function () {
            var target = this.target;
            if (this.highlightSpotId) {
                target.removeShapeId(this.highlightSpotId);
                this.highlightSpotId = null;
            }
            if (this.highlightLineId) {
                target.removeShapeId(this.highlightLineId);
                this.highlightLineId = null;
            }
        },

        scanValues: function () {
            var values = this.values,
                valcount = values.length,
                xvalues = this.xvalues,
                yvalues = this.yvalues,
                yminmax = this.yminmax,
                i, val, isStr, isArray, sp;
            for (i = 0; i < valcount; i++) {
                val = values[i];
                isStr = typeof(values[i]) === 'string';
                isArray = typeof(values[i]) === 'object' && values[i] instanceof Array;
                sp = isStr && values[i].split(':');
                if (isStr && sp.length === 2) { // x:y
                    xvalues.push(Number(sp[0]));
                    yvalues.push(Number(sp[1]));
                    yminmax.push(Number(sp[1]));
                } else if (isArray) {
                    xvalues.push(val[0]);
                    yvalues.push(val[1]);
                    yminmax.push(val[1]);
                } else {
                    xvalues.push(i);
                    if (values[i] === null || values[i] === 'null') {
                        yvalues.push(null);
                    } else {
                        yvalues.push(Number(val));
                        yminmax.push(Number(val));
                    }
                }
            }
            if (this.options.get('xvalues')) {
                xvalues = this.options.get('xvalues');
            }

            this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);
            this.miny = this.minyorg = Math.min.apply(Math, yminmax);

            this.maxx = Math.max.apply(Math, xvalues);
            this.minx = Math.min.apply(Math, xvalues);

            this.xvalues = xvalues;
            this.yvalues = yvalues;
            this.yminmax = yminmax;

        },

        processRangeOptions: function () {
            var options = this.options,
                normalRangeMin = options.get('normalRangeMin'),
                normalRangeMax = options.get('normalRangeMax');

            if (normalRangeMin !== undefined) {
                if (normalRangeMin < this.miny) {
                    this.miny = normalRangeMin;
                }
                if (normalRangeMax > this.maxy) {
                    this.maxy = normalRangeMax;
                }
            }
            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {
                this.miny = options.get('chartRangeMin');
            }
            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {
                this.maxy = options.get('chartRangeMax');
            }
            if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {
                this.minx = options.get('chartRangeMinX');
            }
            if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {
                this.maxx = options.get('chartRangeMaxX');
            }

        },

        drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
            var normalRangeMin = this.options.get('normalRangeMin'),
                normalRangeMax = this.options.get('normalRangeMax'),
                ytop = canvasTop + Math.round(canvasHeight - (canvasHeight * ((normalRangeMax - this.miny) / rangey))),
                height = Math.round((canvasHeight * (normalRangeMax - normalRangeMin)) / rangey);
            this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();
        },

        render: function () {
            var options = this.options,
                target = this.target,
                canvasWidth = this.canvasWidth,
                canvasHeight = this.canvasHeight,
                vertices = this.vertices,
                spotRadius = options.get('spotRadius'),
                regionMap = this.regionMap,
                rangex, rangey, yvallast,
                canvasTop, canvasLeft,
                vertex, path, paths, x, y, xnext, xpos, xposnext,
                last, next, yvalcount, lineShapes, fillShapes, plen,
                valueSpots, hlSpotsEnabled, color, xvalues, yvalues, i;

            if (!line._super.render.call(this)) {
                return;
            }

            this.scanValues();
            this.processRangeOptions();

            xvalues = this.xvalues;
            yvalues = this.yvalues;

            if (!this.yminmax.length || this.yvalues.length < 2) {
                // empty or all null valuess
                return;
            }

            canvasTop = canvasLeft = 0;

            rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;
            rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;
            yvallast = this.yvalues.length - 1;

            if (spotRadius && (canvasWidth < (spotRadius * 4) || canvasHeight < (spotRadius * 4))) {
                spotRadius = 0;
            }
            if (spotRadius) {
                // adjust the canvas size as required so that spots will fit
                hlSpotsEnabled = options.get('highlightSpotColor') &&  !options.get('disableInteraction');
                if (hlSpotsEnabled || options.get('minSpotColor') || (options.get('spotColor') && yvalues[yvallast] === this.miny)) {
                    canvasHeight -= Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled || options.get('maxSpotColor') || (options.get('spotColor') && yvalues[yvallast] === this.maxy)) {
                    canvasHeight -= Math.ceil(spotRadius);
                    canvasTop += Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled ||
                     ((options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy))) {
                    canvasLeft += Math.ceil(spotRadius);
                    canvasWidth -= Math.ceil(spotRadius);
                }
                if (hlSpotsEnabled || options.get('spotColor') ||
                    (options.get('minSpotColor') || options.get('maxSpotColor') &&
                        (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy))) {
                    canvasWidth -= Math.ceil(spotRadius);
                }
            }


            canvasHeight--;

            if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {
                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
            }

            path = [];
            paths = [path];
            last = next = null;
            yvalcount = yvalues.length;
            for (i = 0; i < yvalcount; i++) {
                x = xvalues[i];
                xnext = xvalues[i + 1];
                y = yvalues[i];
                xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));
                xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;
                next = xpos + ((xposnext - xpos) / 2);
                regionMap[i] = [last || 0, next, i];
                last = next;
                if (y === null) {
                    if (i) {
                        if (yvalues[i - 1] !== null) {
                            path = [];
                            paths.push(path);
                        }
                        vertices.push(null);
                    }
                } else {
                    if (y < this.miny) {
                        y = this.miny;
                    }
                    if (y > this.maxy) {
                        y = this.maxy;
                    }
                    if (!path.length) {
                        // previous value was null
                        path.push([xpos, canvasTop + canvasHeight]);
                    }
                    vertex = [xpos, canvasTop + Math.round(canvasHeight - (canvasHeight * ((y - this.miny) / rangey)))];
                    path.push(vertex);
                    vertices.push(vertex);
                }
            }

            lineShapes = [];
            fillShapes = [];
            plen = paths.length;
            for (i = 0; i < plen; i++) {
                path = paths[i];
                if (path.length) {
                    if (options.get('fillColor')) {
                        path.push([path[path.length - 1][0], (canvasTop + canvasHeight)]);
                        fillShapes.push(path.slice(0));
                        path.pop();
                    }
                    // if there's only a single point in this path, then we want to display it
                    // as a vertical line which means we keep path[0]  as is
                    if (path.length > 2) {
                        // else we want the first value
                        path[0] = [path[0][0], path[1][1]];
                    }
                    lineShapes.push(path);
                }
            }

            // draw the fill first, then optionally the normal range, then the line on top of that
            plen = fillShapes.length;
            for (i = 0; i < plen; i++) {
                target.drawShape(fillShapes[i],
                    options.get('fillColor'), options.get('fillColor')).append();
            }

            if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {
                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
            }

            plen = lineShapes.length;
            for (i = 0; i < plen; i++) {
                target.drawShape(lineShapes[i], options.get('lineColor'), undefined,
                    options.get('lineWidth')).append();
            }

            if (spotRadius && options.get('valueSpots')) {
                valueSpots = options.get('valueSpots');
                if (valueSpots.get === undefined) {
                    valueSpots = new RangeMap(valueSpots);
                }
                for (i = 0; i < yvalcount; i++) {
                    color = valueSpots.get(yvalues[i]);
                    if (color) {
                        target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)),
                            canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[i] - this.miny) / rangey))),
                            spotRadius, undefined,
                            color).append();
                    }
                }

            }
            if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {
                target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)),
                    canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[yvallast] - this.miny) / rangey))),
                    spotRadius, undefined,
                    options.get('spotColor')).append();
            }
            if (this.maxy !== this.minyorg) {
                if (spotRadius && options.get('minSpotColor')) {
                    x = xvalues[$.inArray(this.minyorg, yvalues)];
                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.minyorg - this.miny) / rangey))),
                        spotRadius, undefined,
                        options.get('minSpotColor')).append();
                }
                if (spotRadius && options.get('maxSpotColor')) {
                    x = xvalues[$.inArray(this.maxyorg, yvalues)];
                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.maxyorg - this.miny) / rangey))),
                        spotRadius, undefined,
                        options.get('maxSpotColor')).append();
                }
            }

            this.lastShapeId = target.getLastShapeId();
            this.canvasTop = canvasTop;
            target.render();
        }
    });


    /**
     * Bar charts
     */
    $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: 'bar',

        init: function (el, values, options, width, height) {
            var barWidth = parseInt(options.get('barWidth'), 10),
                barSpacing = parseInt(options.get('barSpacing'), 10),
                chartRangeMin = options.get('chartRangeMin'),
                chartRangeMax = options.get('chartRangeMax'),
                chartRangeClip = options.get('chartRangeClip'),
                stackMin = Infinity,
                stackMax = -Infinity,
                isStackString, groupMin, groupMax, stackRanges,
                numValues, i, vlen, range, zeroAxis, xaxisOffset, min, max, clipMin, clipMax,
                stacked, vlist, j, slen, svals, val, yoffset, yMaxCalc, canvasHeightEf;
            bar._super.init.call(this, el, values, options, width, height);

            // scan values to determine whether to stack bars
            for (i = 0, vlen = values.length; i < vlen; i++) {
                val = values[i];
                isStackString = typeof(val) === 'string' && val.indexOf(':') > -1;
                if (isStackString || $.isArray(val)) {
                    stacked = true;
                    if (isStackString) {
                        val = values[i] = normalizeValues(val.split(':'));
                    }
                    val = remove(val, null); // min/max will treat null as zero
                    groupMin = Math.min.apply(Math, val);
                    groupMax = Math.max.apply(Math, val);
                    if (groupMin < stackMin) {
                        stackMin = groupMin;
                    }
                    if (groupMax > stackMax) {
                        stackMax = groupMax;
                    }
                }
            }

            this.stacked = stacked;
            this.regionShapes = {};
            this.barWidth = barWidth;
            this.barSpacing = barSpacing;
            this.totalBarWidth = barWidth + barSpacing;
            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);

            this.initTarget();

            if (chartRangeClip) {
                clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;
                clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;
            }

            numValues = [];
            stackRanges = stacked ? [] : numValues;
            var stackTotals = [];
            var stackRangesNeg = [];
            for (i = 0, vlen = values.length; i < vlen; i++) {
                if (stacked) {
                    vlist = values[i];
                    values[i] = svals = [];
                    stackTotals[i] = 0;
                    stackRanges[i] = stackRangesNeg[i] = 0;
                    for (j = 0, slen = vlist.length; j < slen; j++) {
                        val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];
                        if (val !== null) {
                            if (val > 0) {
                                stackTotals[i] += val;
                            }
                            if (stackMin < 0 && stackMax > 0) {
                                if (val < 0) {
                                    stackRangesNeg[i] += Math.abs(val);
                                } else {
                                    stackRanges[i] += val;
                                }
                            } else {
                                stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));
                            }
                            numValues.push(val);
                        }
                    }
                } else {
                    val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];
                    val = values[i] = normalizeValue(val);
                    if (val !== null) {
                        numValues.push(val);
                    }
                }
            }
            this.max = max = Math.max.apply(Math, numValues);
            this.min = min = Math.min.apply(Math, numValues);
            this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;
            this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;

            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {
                min = options.get('chartRangeMin');
            }
            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {
                max = options.get('chartRangeMax');
            }

            this.zeroAxis = zeroAxis = options.get('zeroAxis', true);
            if (min <= 0 && max >= 0 && zeroAxis) {
                xaxisOffset = 0;
            } else if (zeroAxis == false) {
                xaxisOffset = min;
            } else if (min > 0) {
                xaxisOffset = min;
            } else {
                xaxisOffset = max;
            }
            this.xaxisOffset = xaxisOffset;

            range = stacked ? (Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg)) : max - min;

            // as we plot zero/min values a single pixel line, we add a pixel to all other
            // values - Reduce the effective canvas size to suit
            this.canvasHeightEf = (zeroAxis && min < 0) ? this.canvasHeight - 2 : this.canvasHeight - 1;

            if (min < xaxisOffset) {
                yMaxCalc = (stacked && max >= 0) ? stackMax : max;
                yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;
                if (yoffset !== Math.ceil(yoffset)) {
                    this.canvasHeightEf -= 2;
                    yoffset = Math.ceil(yoffset);
                }
            } else {
                yoffset = this.canvasHeight;
            }
            this.yoffset = yoffset;

            if ($.isArray(options.get('colorMap'))) {
                this.colorMapByIndex = options.get('colorMap');
                this.colorMapByValue = null;
            } else {
                this.colorMapByIndex = null;
                this.colorMapByValue = options.get('colorMap');
                if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                    this.colorMapByValue = new RangeMap(this.colorMapByValue);
                }
            }

            this.range = range;
        },

        getRegion: function (el, x, y) {
            var result = Math.floor(x / this.totalBarWidth);
            return (result < 0 || result >= this.values.length) ? undefined : result;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion,
                values = ensureArray(this.values[currentRegion]),
                result = [],
                value, i;
            for (i = values.length; i--;) {
                value = values[i];
                result.push({
                    isNull: value === null,
                    value: value,
                    color: this.calcColor(i, value, currentRegion),
                    offset: currentRegion
                });
            }
            return result;
        },

        calcColor: function (stacknum, value, valuenum) {
            var colorMapByIndex = this.colorMapByIndex,
                colorMapByValue = this.colorMapByValue,
                options = this.options,
                color, newColor;
            if (this.stacked) {
                color = options.get('stackedBarColor');
            } else {
                color = (value < 0) ? options.get('negBarColor') : options.get('barColor');
            }
            if (value === 0 && options.get('zeroColor') !== undefined) {
                color = options.get('zeroColor');
            }
            if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                color = newColor;
            } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                color = colorMapByIndex[valuenum];
            }
            return $.isArray(color) ? color[stacknum % color.length] : color;
        },

        /**
         * Render bar(s) for a region
         */
        renderRegion: function (valuenum, highlight) {
            var vals = this.values[valuenum],
                options = this.options,
                xaxisOffset = this.xaxisOffset,
                result = [],
                range = this.range,
                stacked = this.stacked,
                target = this.target,
                x = valuenum * this.totalBarWidth,
                canvasHeightEf = this.canvasHeightEf,
                yoffset = this.yoffset,
                y, height, color, isNull, yoffsetNeg, i, valcount, val, minPlotted, allMin;

            vals = $.isArray(vals) ? vals : [vals];
            valcount = vals.length;
            val = vals[0];
            isNull = all(null, vals);
            allMin = all(xaxisOffset, vals, true);

            if (isNull) {
                if (options.get('nullColor')) {
                    color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);
                    y = (yoffset > 0) ? yoffset - 1 : yoffset;
                    return target.drawRect(x, y, this.barWidth - 1, 0, color, color);
                } else {
                    return undefined;
                }
            }
            yoffsetNeg = yoffset;
            for (i = 0; i < valcount; i++) {
                val = vals[i];

                if (stacked && val === xaxisOffset) {
                    if (!allMin || minPlotted) {
                        continue;
                    }
                    minPlotted = true;
                }

                if (range > 0) {
                    height = Math.floor(canvasHeightEf * ((Math.abs(val - xaxisOffset) / range))) + 1;
                } else {
                    height = 1;
                }
                if (val < xaxisOffset || (val === xaxisOffset && yoffset === 0)) {
                    y = yoffsetNeg;
                    yoffsetNeg += height;
                } else {
                    y = yoffset - height;
                    yoffset -= height;
                }
                color = this.calcColor(i, val, valuenum);
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));
            }
            if (result.length === 1) {
                return result[0];
            }
            return result;
        }
    });


    /**
     * Tristate charts
     */
    $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: 'tristate',

        init: function (el, values, options, width, height) {
            var barWidth = parseInt(options.get('barWidth'), 10),
                barSpacing = parseInt(options.get('barSpacing'), 10);
            tristate._super.init.call(this, el, values, options, width, height);

            this.regionShapes = {};
            this.barWidth = barWidth;
            this.barSpacing = barSpacing;
            this.totalBarWidth = barWidth + barSpacing;
            this.values = $.map(values, Number);
            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);

            if ($.isArray(options.get('colorMap'))) {
                this.colorMapByIndex = options.get('colorMap');
                this.colorMapByValue = null;
            } else {
                this.colorMapByIndex = null;
                this.colorMapByValue = options.get('colorMap');
                if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                    this.colorMapByValue = new RangeMap(this.colorMapByValue);
                }
            }
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            return Math.floor(x / this.totalBarWidth);
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                color: this.calcColor(this.values[currentRegion], currentRegion),
                offset: currentRegion
            };
        },

        calcColor: function (value, valuenum) {
            var values = this.values,
                options = this.options,
                colorMapByIndex = this.colorMapByIndex,
                colorMapByValue = this.colorMapByValue,
                color, newColor;

            if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                color = newColor;
            } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                color = colorMapByIndex[valuenum];
            } else if (values[valuenum] < 0) {
                color = options.get('negBarColor');
            } else if (values[valuenum] > 0) {
                color = options.get('posBarColor');
            } else {
                color = options.get('zeroBarColor');
            }
            return color;
        },

        renderRegion: function (valuenum, highlight) {
            var values = this.values,
                options = this.options,
                target = this.target,
                canvasHeight, height, halfHeight,
                x, y, color;

            canvasHeight = target.pixelHeight;
            halfHeight = Math.round(canvasHeight / 2);

            x = valuenum * this.totalBarWidth;
            if (values[valuenum] < 0) {
                y = halfHeight;
                height = halfHeight - 1;
            } else if (values[valuenum] > 0) {
                y = 0;
                height = halfHeight - 1;
            } else {
                y = halfHeight - 1;
                height = 2;
            }
            color = this.calcColor(values[valuenum], valuenum);
            if (color === null) {
                return;
            }
            if (highlight) {
                color = this.calcHighlightColor(color, options);
            }
            return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);
        }
    });


    /**
     * Discrete charts
     */
    $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {
        type: 'discrete',

        init: function (el, values, options, width, height) {
            discrete._super.init.call(this, el, values, options, width, height);

            this.regionShapes = {};
            this.values = values = $.map(values, Number);
            this.min = Math.min.apply(Math, values);
            this.max = Math.max.apply(Math, values);
            this.range = this.max - this.min;
            this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;
            this.interval = Math.floor(width / values.length);
            this.itemWidth = width / values.length;
            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {
                this.min = options.get('chartRangeMin');
            }
            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {
                this.max = options.get('chartRangeMax');
            }
            this.initTarget();
            if (this.target) {
                this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');
            }
        },

        getRegion: function (el, x, y) {
            return Math.floor(x / this.itemWidth);
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                offset: currentRegion
            };
        },

        renderRegion: function (valuenum, highlight) {
            var values = this.values,
                options = this.options,
                min = this.min,
                max = this.max,
                range = this.range,
                interval = this.interval,
                target = this.target,
                canvasHeight = this.canvasHeight,
                lineHeight = this.lineHeight,
                pheight = canvasHeight - lineHeight,
                ytop, val, color, x;

            val = clipval(values[valuenum], min, max);
            x = valuenum * interval;
            ytop = Math.round(pheight - pheight * ((val - min) / range));
            color = (options.get('thresholdColor') && val < options.get('thresholdValue')) ? options.get('thresholdColor') : options.get('lineColor');
            if (highlight) {
                color = this.calcHighlightColor(color, options);
            }
            return target.drawLine(x, ytop, x, ytop + lineHeight, color);
        }
    });


    /**
     * Bullet charts
     */
    $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {
        type: 'bullet',

        init: function (el, values, options, width, height) {
            var min, max, vals;
            bullet._super.init.call(this, el, values, options, width, height);

            // values: target, performance, range1, range2, range3
            this.values = values = normalizeValues(values);
            // target or performance could be null
            vals = values.slice();
            vals[0] = vals[0] === null ? vals[2] : vals[0];
            vals[1] = values[1] === null ? vals[2] : vals[1];
            min = Math.min.apply(Math, values);
            max = Math.max.apply(Math, values);
            if (options.get('base') === undefined) {
                min = min < 0 ? min : 0;
            } else {
                min = options.get('base');
            }
            this.min = min;
            this.max = max;
            this.range = max - min;
            this.shapes = {};
            this.valueShapes = {};
            this.regiondata = {};
            this.width = width = options.get('width') === 'auto' ? '4.0em' : width;
            this.target = this.$el.simpledraw(width, height, options.get('composite'));
            if (!values.length) {
                this.disabled = true;
            }
            this.initTarget();
        },

        getRegion: function (el, x, y) {
            var shapeid = this.target.getShapeAt(el, x, y);
            return (shapeid !== undefined && this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                fieldkey: currentRegion.substr(0, 1),
                value: this.values[currentRegion.substr(1)],
                region: currentRegion
            };
        },

        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                shapeid = this.valueShapes[currentRegion],
                shape;
            delete this.shapes[shapeid];
            switch (currentRegion.substr(0, 1)) {
                case 'r':
                    shape = this.renderRange(currentRegion.substr(1), highlight);
                    break;
                case 'p':
                    shape = this.renderPerformance(highlight);
                    break;
                case 't':
                    shape = this.renderTarget(highlight);
                    break;
            }
            this.valueShapes[currentRegion] = shape.id;
            this.shapes[shape.id] = currentRegion;
            this.target.replaceWithShape(shapeid, shape);
        },

        renderRange: function (rn, highlight) {
            var rangeval = this.values[rn],
                rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),
                color = this.options.get('rangeColors')[rn - 2];
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);
        },

        renderPerformance: function (highlight) {
            var perfval = this.values[1],
                perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),
                color = this.options.get('performanceColor');
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1,
                Math.round(this.canvasHeight * 0.4) - 1, color, color);
        },

        renderTarget: function (highlight) {
            var targetval = this.values[0],
                x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - (this.options.get('targetWidth') / 2)),
                targettop = Math.round(this.canvasHeight * 0.10),
                targetheight = this.canvasHeight - (targettop * 2),
                color = this.options.get('targetColor');
            if (highlight) {
                color = this.calcHighlightColor(color, this.options);
            }
            return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);
        },

        render: function () {
            var vlen = this.values.length,
                target = this.target,
                i, shape;
            if (!bullet._super.render.call(this)) {
                return;
            }
            for (i = 2; i < vlen; i++) {
                shape = this.renderRange(i).append();
                this.shapes[shape.id] = 'r' + i;
                this.valueShapes['r' + i] = shape.id;
            }
            if (this.values[1] !== null) {
                shape = this.renderPerformance().append();
                this.shapes[shape.id] = 'p1';
                this.valueShapes.p1 = shape.id;
            }
            if (this.values[0] !== null) {
                shape = this.renderTarget().append();
                this.shapes[shape.id] = 't0';
                this.valueShapes.t0 = shape.id;
            }
            target.render();
        }
    });


    /**
     * Pie charts
     */
    $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {
        type: 'pie',

        init: function (el, values, options, width, height) {
            var total = 0, i;

            pie._super.init.call(this, el, values, options, width, height);

            this.shapes = {}; // map shape ids to value offsets
            this.valueShapes = {}; // maps value offsets to shape ids
            this.values = values = $.map(values, Number);

            if (options.get('width') === 'auto') {
                this.width = this.height;
            }

            if (values.length > 0) {
                for (i = values.length; i--;) {
                    total += values[i];
                }
            }
            this.total = total;
            this.initTarget();
            this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);
        },

        getRegion: function (el, x, y) {
            var shapeid = this.target.getShapeAt(el, x, y);
            return (shapeid !== undefined && this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;
        },

        getCurrentRegionFields: function () {
            var currentRegion = this.currentRegion;
            return {
                isNull: this.values[currentRegion] === undefined,
                value: this.values[currentRegion],
                percent: this.values[currentRegion] / this.total * 100,
                color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],
                offset: currentRegion
            };
        },

        changeHighlight: function (highlight) {
            var currentRegion = this.currentRegion,
                 newslice = this.renderSlice(currentRegion, highlight),
                 shapeid = this.valueShapes[currentRegion];
            delete this.shapes[shapeid];
            this.target.replaceWithShape(shapeid, newslice);
            this.valueShapes[currentRegion] = newslice.id;
            this.shapes[newslice.id] = currentRegion;
        },

        renderSlice: function (valuenum, highlight) {
            var target = this.target,
                options = this.options,
                radius = this.radius,
                borderWidth = options.get('borderWidth'),
                offset = options.get('offset'),
                circle = 2 * Math.PI,
                values = this.values,
                total = this.total,
                next = offset ? (2*Math.PI)*(offset/360) : 0,
                start, end, i, vlen, color;

            vlen = values.length;
            for (i = 0; i < vlen; i++) {
                start = next;
                end = next;
                if (total > 0) {  // avoid divide by zero
                    end = next + (circle * (values[i] / total));
                }
                if (valuenum === i) {
                    color = options.get('sliceColors')[i % options.get('sliceColors').length];
                    if (highlight) {
                        color = this.calcHighlightColor(color, options);
                    }

                    return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);
                }
                next = end;
            }
        },

        render: function () {
            var target = this.target,
                values = this.values,
                options = this.options,
                radius = this.radius,
                borderWidth = options.get('borderWidth'),
                shape, i;

            if (!pie._super.render.call(this)) {
                return;
            }
            if (borderWidth) {
                target.drawCircle(radius, radius, Math.floor(radius - (borderWidth / 2)),
                    options.get('borderColor'), undefined, borderWidth).append();
            }
            for (i = values.length; i--;) {
                if (values[i]) { // don't render zero values
                    shape = this.renderSlice(i).append();
                    this.valueShapes[i] = shape.id; // store just the shapeid
                    this.shapes[shape.id] = i;
                }
            }
            target.render();
        }
    });


    /**
     * Box plots
     */
    $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {
        type: 'box',

        init: function (el, values, options, width, height) {
            box._super.init.call(this, el, values, options, width, height);
            this.values = $.map(values, Number);
            this.width = options.get('width') === 'auto' ? '4.0em' : width;
            this.initTarget();
            if (!this.values.length) {
                this.disabled = 1;
            }
        },

        /**
         * Simulate a single region
         */
        getRegion: function () {
            return 1;
        },

        getCurrentRegionFields: function () {
            var result = [
                { field: 'lq', value: this.quartiles[0] },
                { field: 'med', value: this.quartiles[1] },
                { field: 'uq', value: this.quartiles[2] }
            ];
            if (this.loutlier !== undefined) {
                result.push({ field: 'lo', value: this.loutlier});
            }
            if (this.routlier !== undefined) {
                result.push({ field: 'ro', value: this.routlier});
            }
            if (this.lwhisker !== undefined) {
                result.push({ field: 'lw', value: this.lwhisker});
            }
            if (this.rwhisker !== undefined) {
                result.push({ field: 'rw', value: this.rwhisker});
            }
            return result;
        },

        render: function () {
            var target = this.target,
                values = this.values,
                vlen = values.length,
                options = this.options,
                canvasWidth = this.canvasWidth,
                canvasHeight = this.canvasHeight,
                minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),
                maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),
                canvasLeft = 0,
                lwhisker, loutlier, iqr, q1, q2, q3, rwhisker, routlier, i,
                size, unitSize;

            if (!box._super.render.call(this)) {
                return;
            }

            if (options.get('raw')) {
                if (options.get('showOutliers') && values.length > 5) {
                    loutlier = values[0];
                    lwhisker = values[1];
                    q1 = values[2];
                    q2 = values[3];
                    q3 = values[4];
                    rwhisker = values[5];
                    routlier = values[6];
                } else {
                    lwhisker = values[0];
                    q1 = values[1];
                    q2 = values[2];
                    q3 = values[3];
                    rwhisker = values[4];
                }
            } else {
                values.sort(function (a, b) { return a - b; });
                q1 = quartile(values, 1);
                q2 = quartile(values, 2);
                q3 = quartile(values, 3);
                iqr = q3 - q1;
                if (options.get('showOutliers')) {
                    lwhisker = rwhisker = undefined;
                    for (i = 0; i < vlen; i++) {
                        if (lwhisker === undefined && values[i] > q1 - (iqr * options.get('outlierIQR'))) {
                            lwhisker = values[i];
                        }
                        if (values[i] < q3 + (iqr * options.get('outlierIQR'))) {
                            rwhisker = values[i];
                        }
                    }
                    loutlier = values[0];
                    routlier = values[vlen - 1];
                } else {
                    lwhisker = values[0];
                    rwhisker = values[vlen - 1];
                }
            }
            this.quartiles = [q1, q2, q3];
            this.lwhisker = lwhisker;
            this.rwhisker = rwhisker;
            this.loutlier = loutlier;
            this.routlier = routlier;

            unitSize = canvasWidth / (maxValue - minValue + 1);
            if (options.get('showOutliers')) {
                canvasLeft = Math.ceil(options.get('spotRadius'));
                canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));
                unitSize = canvasWidth / (maxValue - minValue + 1);
                if (loutlier < lwhisker) {
                    target.drawCircle((loutlier - minValue) * unitSize + canvasLeft,
                        canvasHeight / 2,
                        options.get('spotRadius'),
                        options.get('outlierLineColor'),
                        options.get('outlierFillColor')).append();
                }
                if (routlier > rwhisker) {
                    target.drawCircle((routlier - minValue) * unitSize + canvasLeft,
                        canvasHeight / 2,
                        options.get('spotRadius'),
                        options.get('outlierLineColor'),
                        options.get('outlierFillColor')).append();
                }
            }

            // box
            target.drawRect(
                Math.round((q1 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.1),
                Math.round((q3 - q1) * unitSize),
                Math.round(canvasHeight * 0.8),
                options.get('boxLineColor'),
                options.get('boxFillColor')).append();
            // left whisker
            target.drawLine(
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                Math.round((q1 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                options.get('lineColor')).append();
            target.drawLine(
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 4),
                Math.round((lwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight - canvasHeight / 4),
                options.get('whiskerColor')).append();
            // right whisker
            target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                Math.round((q3 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 2),
                options.get('lineColor')).append();
            target.drawLine(
                Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight / 4),
                Math.round((rwhisker - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight - canvasHeight / 4),
                options.get('whiskerColor')).append();
            // median line
            target.drawLine(
                Math.round((q2 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.1),
                Math.round((q2 - minValue) * unitSize + canvasLeft),
                Math.round(canvasHeight * 0.9),
                options.get('medianColor')).append();
            if (options.get('target')) {
                size = Math.ceil(options.get('spotRadius'));
                target.drawLine(
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft),
                    Math.round((canvasHeight / 2) - size),
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft),
                    Math.round((canvasHeight / 2) + size),
                    options.get('targetColor')).append();
                target.drawLine(
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size),
                    Math.round(canvasHeight / 2),
                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size),
                    Math.round(canvasHeight / 2),
                    options.get('targetColor')).append();
            }
            target.render();
        }
    });


    // Setup a very simple "virtual canvas" to make drawing the few shapes we need easier
    // This is accessible as $(foo).simpledraw()

    VShape = createClass({
        init: function (target, id, type, args) {
            this.target = target;
            this.id = id;
            this.type = type;
            this.args = args;
        },
        append: function () {
            this.target.appendShape(this);
            return this;
        }
    });

    VCanvas_base = createClass({
        _pxregex: /(\d+)(px)?\s*$/i,

        init: function (width, height, target) {
            if (!width) {
                return;
            }
            this.width = width;
            this.height = height;
            this.target = target;
            this.lastShapeId = null;
            if (target[0]) {
                target = target[0];
            }
            $.data(target, '_jqs_vcanvas', this);
        },

        drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {
            return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);
        },

        drawShape: function (path, lineColor, fillColor, lineWidth) {
            return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);
        },

        drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {
            return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);
        },

        drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);
        },

        drawRect: function (x, y, width, height, lineColor, fillColor) {
            return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);
        },

        getElement: function () {
            return this.canvas;
        },

        /**
         * Return the most recently inserted shape id
         */
        getLastShapeId: function () {
            return this.lastShapeId;
        },

        /**
         * Clear and reset the canvas
         */
        reset: function () {
            alert('reset not implemented');
        },

        _insert: function (el, target) {
            $(target).html(el);
        },

        /**
         * Calculate the pixel dimensions of the canvas
         */
        _calculatePixelDims: function (width, height, canvas) {
            // XXX This should probably be a configurable option
            var match;
            match = this._pxregex.exec(height);
            if (match) {
                this.pixelHeight = match[1];
            } else {
                this.pixelHeight = $(canvas).height();
            }
            match = this._pxregex.exec(width);
            if (match) {
                this.pixelWidth = match[1];
            } else {
                this.pixelWidth = $(canvas).width();
            }
        },

        /**
         * Generate a shape object and id for later rendering
         */
        _genShape: function (shapetype, shapeargs) {
            var id = shapeCount++;
            shapeargs.unshift(id);
            return new VShape(this, id, shapetype, shapeargs);
        },

        /**
         * Add a shape to the end of the render queue
         */
        appendShape: function (shape) {
            alert('appendShape not implemented');
        },

        /**
         * Replace one shape with another
         */
        replaceWithShape: function (shapeid, shape) {
            alert('replaceWithShape not implemented');
        },

        /**
         * Insert one shape after another in the render queue
         */
        insertAfterShape: function (shapeid, shape) {
            alert('insertAfterShape not implemented');
        },

        /**
         * Remove a shape from the queue
         */
        removeShapeId: function (shapeid) {
            alert('removeShapeId not implemented');
        },

        /**
         * Find a shape at the specified x/y co-ordinates
         */
        getShapeAt: function (el, x, y) {
            alert('getShapeAt not implemented');
        },

        /**
         * Render all queued shapes onto the canvas
         */
        render: function () {
            alert('render not implemented');
        }
    });


    VCanvas_canvas = createClass(VCanvas_base, {
        init: function (width, height, target, interact) {
            VCanvas_canvas._super.init.call(this, width, height, target);
            this.canvas = document.createElement('canvas');
            if (target[0]) {
                target = target[0];
            }
            this.context = this.canvas.getContext('2d');
            var devicePixelRatio = window.devicePixelRatio || 1,
                backingStoreRatio = this.context.webkitBackingStorePixelRatio || this.context.mozBackingStorePixelRatio || this.context.msBackingStorePixelRatio || this.context.oBackingStorePixelRatio || this.context.backingStorePixelRatio || 1,
                ratio = devicePixelRatio / backingStoreRatio;
            $.data(target, '_jqs_vcanvas', this);
            $(this.canvas).css({ display: 'inline-block', width: width, height: height, verticalAlign: 'top' });
            this._insert(this.canvas, target);
            this._calculatePixelDims(width, height, this.canvas);
            this.canvas.width = this.pixelWidth * ratio;
            this.canvas.height = this.pixelHeight * ratio;
            this.context.scale(ratio, ratio);
            this.interact = interact;
            this.shapes = {};
            this.shapeseq = [];
            this.currentTargetShapeId = undefined;
            $(this.canvas).css({width: this.pixelWidth, height: this.pixelHeight});
        },

        _getContext: function (lineColor, fillColor, lineWidth) {
            var context = this.canvas.getContext('2d');
            if (lineColor !== undefined) {
                context.strokeStyle = lineColor;
            }
            context.lineWidth = lineWidth === undefined ? 1 : lineWidth;
            if (fillColor !== undefined) {
                context.fillStyle = fillColor;
            }
            return context;
        },

        reset: function () {
            var context = this._getContext();
            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            this.shapes = {};
            this.shapeseq = [];
            this.currentTargetShapeId = undefined;
        },

        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
            var context = this._getContext(lineColor, fillColor, lineWidth),
                i, plen;
            context.beginPath();
            context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);
            for (i = 1, plen = path.length; i < plen; i++) {
                context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines
            }
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor !== undefined) {
                context.fill();
            }
            if (this.targetX !== undefined && this.targetY !== undefined &&
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
        },

        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
            var context = this._getContext(lineColor, fillColor, lineWidth);
            context.beginPath();
            context.arc(x, y, radius, 0, 2 * Math.PI, false);
            if (this.targetX !== undefined && this.targetY !== undefined &&
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor !== undefined) {
                context.fill();
            }
        },

        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            var context = this._getContext(lineColor, fillColor);
            context.beginPath();
            context.moveTo(x, y);
            context.arc(x, y, radius, startAngle, endAngle, false);
            context.lineTo(x, y);
            context.closePath();
            if (lineColor !== undefined) {
                context.stroke();
            }
            if (fillColor) {
                context.fill();
            }
            if (this.targetX !== undefined && this.targetY !== undefined &&
                context.isPointInPath(this.targetX, this.targetY)) {
                this.currentTargetShapeId = shapeid;
            }
        },

        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
            return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);
        },

        appendShape: function (shape) {
            this.shapes[shape.id] = shape;
            this.shapeseq.push(shape.id);
            this.lastShapeId = shape.id;
            return shape.id;
        },

        replaceWithShape: function (shapeid, shape) {
            var shapeseq = this.shapeseq,
                i;
            this.shapes[shape.id] = shape;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] == shapeid) {
                    shapeseq[i] = shape.id;
                }
            }
            delete this.shapes[shapeid];
        },

        replaceWithShapes: function (shapeids, shapes) {
            var shapeseq = this.shapeseq,
                shapemap = {},
                sid, i, first;

            for (i = shapeids.length; i--;) {
                shapemap[shapeids[i]] = true;
            }
            for (i = shapeseq.length; i--;) {
                sid = shapeseq[i];
                if (shapemap[sid]) {
                    shapeseq.splice(i, 1);
                    delete this.shapes[sid];
                    first = i;
                }
            }
            for (i = shapes.length; i--;) {
                shapeseq.splice(first, 0, shapes[i].id);
                this.shapes[shapes[i].id] = shapes[i];
            }

        },

        insertAfterShape: function (shapeid, shape) {
            var shapeseq = this.shapeseq,
                i;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] === shapeid) {
                    shapeseq.splice(i + 1, 0, shape.id);
                    this.shapes[shape.id] = shape;
                    return;
                }
            }
        },

        removeShapeId: function (shapeid) {
            var shapeseq = this.shapeseq,
                i;
            for (i = shapeseq.length; i--;) {
                if (shapeseq[i] === shapeid) {
                    shapeseq.splice(i, 1);
                    break;
                }
            }
            delete this.shapes[shapeid];
        },

        getShapeAt: function (el, x, y) {
            this.targetX = x;
            this.targetY = y;
            this.render();
            return this.currentTargetShapeId;
        },

        render: function () {
            var shapeseq = this.shapeseq,
                shapes = this.shapes,
                shapeCount = shapeseq.length,
                context = this._getContext(),
                shapeid, shape, i;
            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
            for (i = 0; i < shapeCount; i++) {
                shapeid = shapeseq[i];
                shape = shapes[shapeid];
                this['_draw' + shape.type].apply(this, shape.args);
            }
            if (!this.interact) {
                // not interactive so no need to keep the shapes array
                this.shapes = {};
                this.shapeseq = [];
            }
        }

    });


    VCanvas_vml = createClass(VCanvas_base, {
        init: function (width, height, target) {
            var groupel;
            VCanvas_vml._super.init.call(this, width, height, target);
            if (target[0]) {
                target = target[0];
            }
            $.data(target, '_jqs_vcanvas', this);
            this.canvas = document.createElement('span');
            $(this.canvas).css({ display: 'inline-block', position: 'relative', overflow: 'hidden', width: width, height: height, margin: '0px', padding: '0px', verticalAlign: 'top'});
            this._insert(this.canvas, target);
            this._calculatePixelDims(width, height, this.canvas);
            this.canvas.width = this.pixelWidth;
            this.canvas.height = this.pixelHeight;
            groupel = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '"' +
                    ' style="position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;"></v:group>';
            this.canvas.insertAdjacentHTML('beforeEnd', groupel);
            this.group = $(this.canvas).children()[0];
            this.rendered = false;
            this.prerender = '';
        },

        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {
            var vpath = [],
                initial, stroke, fill, closed, vel, plen, i;
            for (i = 0, plen = path.length; i < plen; i++) {
                vpath[i] = '' + (path[i][0]) + ',' + (path[i][1]);
            }
            initial = vpath.splice(0, 1);
            lineWidth = lineWidth === undefined ? 1 : lineWidth;
            stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
            fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
            closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';
            vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' +
                 ' id="jqsshape' + shapeid + '" ' +
                 stroke +
                 fill +
                ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;" ' +
                ' path="m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e">' +
                ' </v:shape>';
            return vel;
        },

        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
            var stroke, fill, vel;
            x -= radius;
            y -= radius;
            stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
            fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
            vel = '<v:oval ' +
                 ' id="jqsshape' + shapeid + '" ' +
                stroke +
                fill +
                ' style="position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + (radius * 2) + 'px; height:' + (radius * 2) + 'px"></v:oval>';
            return vel;

        },

        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
            var vpath, startx, starty, endx, endy, stroke, fill, vel;
            if (startAngle === endAngle) {
                return '';  // VML seems to have problem when start angle equals end angle.
            }
            if ((endAngle - startAngle) === (2 * Math.PI)) {
                startAngle = 0.0;  // VML seems to have a problem when drawing a full circle that doesn't start 0
                endAngle = (2 * Math.PI);
            }

            startx = x + Math.round(Math.cos(startAngle) * radius);
            starty = y + Math.round(Math.sin(startAngle) * radius);
            endx = x + Math.round(Math.cos(endAngle) * radius);
            endy = y + Math.round(Math.sin(endAngle) * radius);

            if (startx === endx && starty === endy) {
                if ((endAngle - startAngle) < Math.PI) {
                    // Prevent very small slices from being mistaken as a whole pie
                    return '';
                }
                // essentially going to be the entire circle, so ignore startAngle
                startx = endx = x + radius;
                starty = endy = y;
            }

            if (startx === endx && starty === endy && (endAngle - startAngle) < Math.PI) {
                return '';
            }

            vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];
            stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + lineColor + '" ';
            fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
            vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' +
                 ' id="jqsshape' + shapeid + '" ' +
                 stroke +
                 fill +
                ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;" ' +
                ' path="m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e">' +
                ' </v:shape>';
            return vel;
        },

        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {
            return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);
        },

        reset: function () {
            this.group.innerHTML = '';
        },

        appendShape: function (shape) {
            var vel = this['_draw' + shape.type].apply(this, shape.args);
            if (this.rendered) {
                this.group.insertAdjacentHTML('beforeEnd', vel);
            } else {
                this.prerender += vel;
            }
            this.lastShapeId = shape.id;
            return shape.id;
        },

        replaceWithShape: function (shapeid, shape) {
            var existing = $('#jqsshape' + shapeid),
                vel = this['_draw' + shape.type].apply(this, shape.args);
            existing[0].outerHTML = vel;
        },

        replaceWithShapes: function (shapeids, shapes) {
            // replace the first shapeid with all the new shapes then toast the remaining old shapes
            var existing = $('#jqsshape' + shapeids[0]),
                replace = '',
                slen = shapes.length,
                i;
            for (i = 0; i < slen; i++) {
                replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);
            }
            existing[0].outerHTML = replace;
            for (i = 1; i < shapeids.length; i++) {
                $('#jqsshape' + shapeids[i]).remove();
            }
        },

        insertAfterShape: function (shapeid, shape) {
            var existing = $('#jqsshape' + shapeid),
                 vel = this['_draw' + shape.type].apply(this, shape.args);
            existing[0].insertAdjacentHTML('afterEnd', vel);
        },

        removeShapeId: function (shapeid) {
            var existing = $('#jqsshape' + shapeid);
            this.group.removeChild(existing[0]);
        },

        getShapeAt: function (el, x, y) {
            var shapeid = el.id.substr(8);
            return shapeid;
        },

        render: function () {
            if (!this.rendered) {
                // batch the intial render into a single repaint
                this.group.innerHTML = this.prerender;
                this.rendered = true;
            }
        }
    });


}))}(document, Math));
;(function($) {
    // Some named colors to work with
    // From Interface by Stefan Petre
    // http://interface.eyecon.ro/

    var colors = {
        aqua:[0,255,255],
        azure:[240,255,255],
        beige:[245,245,220],
        black:[0,0,0],
        blue:[0,0,255],
        brown:[165,42,42],
        cyan:[0,255,255],
        darkblue:[0,0,139],
        darkcyan:[0,139,139],
        darkgrey:[169,169,169],
        darkgreen:[0,100,0],
        darkkhaki:[189,183,107],
        darkmagenta:[139,0,139],
        darkolivegreen:[85,107,47],
        darkorange:[255,140,0],
        darkorchid:[153,50,204],
        darkred:[139,0,0],
        darksalmon:[233,150,122],
        darkviolet:[148,0,211],
        fuchsia:[255,0,255],
        gold:[255,215,0],
        green:[0,128,0],
        indigo:[75,0,130],
        khaki:[240,230,140],
        lightblue:[173,216,230],
        lightcyan:[224,255,255],
        lightgreen:[144,238,144],
        lightgrey:[211,211,211],
        lightpink:[255,182,193],
        lightyellow:[255,255,224],
        lime:[0,255,0],
        magenta:[255,0,255],
        maroon:[128,0,0],
        navy:[0,0,128],
        olive:[128,128,0],
        orange:[255,165,0],
        pink:[255,192,203],
        purple:[128,0,128],
        violet:[128,0,128],
        red:[255,0,0],
        silver:[192,192,192],
        white:[255,255,255],
        yellow:[255,255,0],
        transparent: [255,255,255]
    };

    /*
    * jQuery Color Animations
    * Copyright 2007 John Resig
    * Released under the MIT and GPL licenses.
    */

    // We override the animation for all of these color styles
    $.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'color', 'outlineColor'], function(i,attr)
    {
            $.fx.step[attr] = function(fx)
            {
                if ( fx.state == 0 )
                {
                        fx.start = getColor( fx.elem, attr );
                        fx.end = getRGB( fx.end );
                }

                fx.elem.style[attr] = "rgb(" + [
                        Math.max(Math.min( parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0],10), 255), 0),
                        Math.max(Math.min( parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1],10), 255), 0),
                        Math.max(Math.min( parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2],10), 255), 0)
                ].join(",") + ")";
            };
    });

    // Color Conversion functions from highlightFade
    // By Blair Mitchelmore
    // http://jquery.offput.ca/highlightFade/

    // Parse strings looking for color tuples [255,255,255]
    function getRGB(color)
    {
            var result;

            // Check if we're already dealing with an array of colors
            if ( color && color.constructor == Array && color.length == 3 )
            {
                return color;
            }

            // Look for rgb(num,num,num)
            if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
            {
                return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];
            }

            // Look for rgb(num%,num%,num%)
            if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
            {
                return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];
            }

            // Look for #a0b1c2
            if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
            {
                return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];
            }

            // Look for #fff
            if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
            {
                return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];
            }

            // Look for rgba(0, 0, 0, 0) == transparent in Safari 3
            if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
            {
                return colors['transparent'];
            }

            // Otherwise, we're most likely dealing with a named color
            return colors[$.trim(color).toLowerCase()];
    }

    function getColor(elem, attr)
    {
        var color;

        do
        {
            color = $.css(elem, attr);

            // Keep going until we find an element that has color, or we hit the body
            if ( color != '' && color != 'transparent' || $.nodeName(elem, "body") )
            {
                break;
            }

            attr = "backgroundColor";
        } while ( elem = elem.parentNode );

        return getRGB(color);
    };

    $.extend({URLEncode:function(c){var o='';var x=0;c=c.toString();var r=/(^[a-zA-Z0-9_.]*)/;
        while(x<c.length){var m=r.exec(c.substr(x));
            if(m!=null && m.length>1 && m[1]!=''){o+=m[1];x+=m[1].length;
            }else{if(c[x]==' ')o+='+';else{var d=c.charCodeAt(x);var h=d.toString(16);
            o+='%'+(h.length<2?'0':'')+h.toUpperCase();}x++;}}return o;},
        URLDecode:function(s){var o=s;var binVal,t;var r=/(%[^%]{2})/;
        while((m=r.exec(o))!=null && m.length>1 && m[1]!=''){b=parseInt(m[1].substr(1),16);
        t=String.fromCharCode(b);o=o.replace(m[1],t);}return o;}
    });

})(jQuery);
;/*!
loadCSS: load a CSS file asynchronously.
[c]2014 @scottjehl, Filament Group, Inc.
Licensed MIT
*/
function loadCSS( href, before, media ){
	"use strict";
	// Arguments explained:
	// `href` is the URL for your CSS file.
	// `before` optionally defines the element we'll use as a reference for injecting our <link>
	// By default, `before` uses the first <script> element in the page.
	// However, since the order in which stylesheets are referenced matters, you might need a more specific location in your document.
	// If so, pass a different reference element to the `before` argument and it'll insert before that instead
	// note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
	var ss = window.document.createElement( "link" );
	var ref = before || window.document.getElementsByTagName( "script" )[ 0 ];
	ss.rel = "stylesheet";
	ss.href = href;
	// temporarily, set media to something non-matching to ensure it'll fetch without blocking render
	ss.media = "only x";
	// inject link
	ref.parentNode.insertBefore( ss, ref );
	// set media back to `all` so that the styleshet applies once it loads
	setTimeout( function(){
		ss.media = media || "all";
	} );
	return ss;
 }
;/*! loadJS: load a JS file asynchronously. [c]2014 @scottjehl, Filament Group, Inc. (Based on http://goo.gl/REQGQ by Paul Irish). Licensed MIT */
function loadJS( src ){
	"use strict";
	var ref = window.document.getElementsByTagName( "script" )[ 0 ];
	var script = window.document.createElement( "script" );
	script.src = src;
	ref.parentNode.insertBefore( script, ref );
	return script;
}
;/*	
 * jQuery mmenu v4.2.2
 * @requires jQuery 1.7.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function(e){function t(t,n,s){if(s){if("object"!=typeof t&&(t={}),"boolean"!=typeof t.isMenu){var o=s.children();t.isMenu=1==o.length&&o.is(n.panelNodetype)}return t}return t=e.extend(!0,{},e[a].defaults,t),("top"==t.position||"bottom"==t.position)&&("back"==t.zposition||"next"==t.zposition)&&(e[a].deprecated('Using position "'+t.position+'" in combination with zposition "'+t.zposition+'"','zposition "front"'),t.zposition="front"),t}function n(t){return t=e.extend(!0,{},e[a].configuration,t),"string"!=typeof t.pageSelector&&(t.pageSelector="> "+t.pageNodetype),t}function s(){r.$wndw=e(window),r.$html=e("html"),r.$body=e("body"),r.$allMenus=e(),e.each([d,c,u],function(e,t){t.add=function(e){e=e.split(" ");for(var n in e)t[e[n]]=t.mm(e[n])}}),d.mm=function(e){return"mm-"+e},d.add("menu ismenu panel list subtitle selected label spacer current highest hidden page blocker modal background opened opening subopened subopen fullsubopen subclose"),d.umm=function(e){return"mm-"==e.slice(0,3)&&(e=e.slice(3)),e},c.mm=function(e){return"mm-"+e},c.add("parent style"),u.mm=function(e){return e+".mm"},u.add("toggle open opening opened close closing closed update setPage setSelected transitionend webkitTransitionEnd mousedown touchstart mouseup touchend scroll touchmove click keydown keyup resize"),r.$wndw.on(u.keydown,function(e){return r.$html.hasClass(d.opened)&&9==e.keyCode?(e.preventDefault(),!1):void 0});var t=0;r.$wndw.on(u.resize,function(e,n){if(n||r.$html.hasClass(d.opened)){var s=r.$wndw.height();(n||s!=t)&&(t=s,r.$page.css("minHeight",s))}}),e[a]._c=d,e[a]._d=c,e[a]._e=u,e[a].glbl=r}function o(t,n){if(t.hasClass(d.current))return!1;var s=e("."+d.panel,n),o=s.filter("."+d.current);return s.removeClass(d.highest).removeClass(d.current).not(t).not(o).addClass(d.hidden),t.hasClass(d.opened)?o.addClass(d.highest).removeClass(d.opened).removeClass(d.subopened):(t.addClass(d.highest),o.addClass(d.subopened)),t.removeClass(d.hidden).removeClass(d.subopened).addClass(d.current).addClass(d.opened),"open"}function i(e,t,n){var s=!1,o=function(){s||t.call(e[0]),s=!0};e.one(u.transitionend,o),e.one(u.webkitTransitionEnd,o),setTimeout(o,1.1*n)}var a="mmenu",l="4.2.2";if(!e[a]){var r={$wndw:null,$html:null,$body:null,$page:null,$blck:null,$allMenus:null},d={},c={},u={},p=0,h=0;e[a]=function(e,t,n){return r.$allMenus=r.$allMenus.add(e),this.$menu=e,this.opts=t,this.conf=n,this.serialnr=p++,this._init(),this},e[a].prototype={open:function(){var e=this;return this._openSetup(),setTimeout(function(){e._openFinish()},50),"open"},_openSetup:function(){h=r.$wndw.scrollTop(),this.$menu.addClass(d.current),r.$allMenus.not(this.$menu).trigger(u.close),r.$page.data(c.style,r.$page.attr("style")||""),r.$wndw.trigger(u.resize,[!0]),this.opts.modal&&r.$html.addClass(d.modal),this.opts.moveBackground&&r.$html.addClass(d.background),"left"!=this.opts.position&&r.$html.addClass(d.mm(this.opts.position)),"back"!=this.opts.zposition&&r.$html.addClass(d.mm(this.opts.zposition)),this.opts.classes&&r.$html.addClass(this.opts.classes),r.$html.addClass(d.opened),this.$menu.addClass(d.opened)},_openFinish:function(){var e=this;i(r.$page,function(){e.$menu.trigger(u.opened)},this.conf.transitionDuration),r.$html.addClass(d.opening),this.$menu.trigger(u.opening)},close:function(){var e=this;return i(r.$page,function(){e.$menu.removeClass(d.current).removeClass(d.opened),r.$html.removeClass(d.opened).removeClass(d.modal).removeClass(d.background).removeClass(d.mm(e.opts.position)).removeClass(d.mm(e.opts.zposition)),e.opts.classes&&r.$html.removeClass(e.opts.classes),r.$page.attr("style",r.$page.data(c.style)),e.$menu.trigger(u.closed)},this.conf.transitionDuration),r.$html.removeClass(d.opening),this.$menu.trigger(u.closing),"close"},_init:function(){if(this.opts=t(this.opts,this.conf,this.$menu),this.direction=this.opts.slidingSubmenus?"horizontal":"vertical",this._initPage(r.$page),this._initMenu(),this._initBlocker(),this._initPanles(),this._initLinks(),this._initOpenClose(),this._bindCustomEvents(),e[a].addons)for(var n=0;n<e[a].addons.length;n++)"function"==typeof this["_addon_"+e[a].addons[n]]&&this["_addon_"+e[a].addons[n]]()},_bindCustomEvents:function(){var t=this;this.$menu.off(u.open+" "+u.close+" "+u.setPage+" "+u.update).on(u.open+" "+u.close+" "+u.setPage+" "+u.update,function(e){e.stopPropagation()}),this.$menu.on(u.open,function(n){return e(this).hasClass(d.current)?(n.stopImmediatePropagation(),!1):t.open()}).on(u.close,function(n){return e(this).hasClass(d.current)?t.close():(n.stopImmediatePropagation(),!1)}).on(u.setPage,function(e,n){t._initPage(n),t._initOpenClose()});var n=this.$menu.find(this.opts.isMenu&&"horizontal"!=this.direction?"ul, ol":"."+d.panel);n.off(u.toggle+" "+u.open+" "+u.close).on(u.toggle+" "+u.open+" "+u.close,function(e){e.stopPropagation()}),"horizontal"==this.direction?n.on(u.open,function(){return o(e(this),t.$menu)}):n.on(u.toggle,function(){var t=e(this);return t.triggerHandler(t.parent().hasClass(d.opened)?u.close:u.open)}).on(u.open,function(){return e(this).parent().addClass(d.opened),"open"}).on(u.close,function(){return e(this).parent().removeClass(d.opened),"close"})},_initBlocker:function(){var t=this;r.$blck||(r.$blck=e('<div id="'+d.blocker+'" />').appendTo(r.$body)),r.$blck.off(u.touchstart).on(u.touchstart,function(e){e.preventDefault(),e.stopPropagation(),r.$blck.trigger(u.mousedown)}).on(u.mousedown,function(e){e.preventDefault(),r.$html.hasClass(d.modal)||t.$menu.trigger(u.close)})},_initPage:function(t){t||(t=e(this.conf.pageSelector,r.$body),t.length>1&&(e[a].debug("Multiple nodes found for the page-node, all nodes are wrapped in one <"+this.conf.pageNodetype+">."),t=t.wrapAll("<"+this.conf.pageNodetype+" />").parent())),t.addClass(d.page),r.$page=t},_initMenu:function(){this.conf.clone&&(this.$menu=this.$menu.clone(!0),this.$menu.add(this.$menu.find("*")).filter("[id]").each(function(){e(this).attr("id",d.mm(e(this).attr("id")))})),this.$menu.contents().each(function(){3==e(this)[0].nodeType&&e(this).remove()}),this.$menu.prependTo("body").addClass(d.menu),this.$menu.addClass(d.mm(this.direction)),this.opts.classes&&this.$menu.addClass(this.opts.classes),this.opts.isMenu&&this.$menu.addClass(d.ismenu),"left"!=this.opts.position&&this.$menu.addClass(d.mm(this.opts.position)),"back"!=this.opts.zposition&&this.$menu.addClass(d.mm(this.opts.zposition))},_initPanles:function(){var t=this;this.__refactorClass(e("."+this.conf.listClass,this.$menu),"list"),this.opts.isMenu&&e("ul, ol",this.$menu).not(".mm-nolist").addClass(d.list);var n=e("."+d.list+" > li",this.$menu);this.__refactorClass(n.filter("."+this.conf.selectedClass),"selected"),this.__refactorClass(n.filter("."+this.conf.labelClass),"label"),this.__refactorClass(n.filter("."+this.conf.spacerClass),"spacer"),n.off(u.setSelected).on(u.setSelected,function(t,s){t.stopPropagation(),n.removeClass(d.selected),"boolean"!=typeof s&&(s=!0),s&&e(this).addClass(d.selected)}),this.__refactorClass(e("."+this.conf.panelClass,this.$menu),"panel"),this.$menu.children().filter(this.conf.panelNodetype).add(this.$menu.find("."+d.list).children().children().filter(this.conf.panelNodetype)).addClass(d.panel);var s=e("."+d.panel,this.$menu);s.each(function(n){var s=e(this),o=s.attr("id")||d.mm("m"+t.serialnr+"-p"+n);s.attr("id",o)}),s.find("."+d.panel).each(function(){var n=e(this),s=n.is("ul, ol")?n:n.find("ul ,ol").first(),o=n.parent(),i=o.find("> a, > span"),a=o.closest("."+d.panel);if(n.data(c.parent,o),o.parent().is("."+d.list)){var l=e('<a class="'+d.subopen+'" href="#'+n.attr("id")+'" />').insertBefore(i);i.is("a")||l.addClass(d.fullsubopen),"horizontal"==t.direction&&s.prepend('<li class="'+d.subtitle+'"><a class="'+d.subclose+'" href="#'+a.attr("id")+'">'+i.text()+"</a></li>")}});var o="horizontal"==this.direction?u.open:u.toggle;if(s.each(function(){var n=e(this),s=n.attr("id");e('a[href="#'+s+'"]',t.$menu).off(u.click).on(u.click,function(e){e.preventDefault(),n.trigger(o)})}),"horizontal"==this.direction){var i=e("."+d.list+" > li."+d.selected,this.$menu);i.add(i.parents("li")).parents("li").removeClass(d.selected).end().each(function(){var t=e(this),n=t.find("> ."+d.panel);n.length&&(t.parents("."+d.panel).addClass(d.subopened),n.addClass(d.opened))}).closest("."+d.panel).addClass(d.opened).parents("."+d.panel).addClass(d.subopened)}else e("li."+d.selected,this.$menu).addClass(d.opened).parents("."+d.selected).removeClass(d.selected);var a=s.filter("."+d.opened);a.length||(a=s.first()),a.addClass(d.opened).last().addClass(d.current),"horizontal"==this.direction&&s.find("."+d.panel).appendTo(this.$menu)},_initLinks:function(){var t=this;e("."+d.list+" > li > a",this.$menu).not("."+d.subopen).not("."+d.subclose).not('[rel="external"]').not('[target="_blank"]').off(u.click).on(u.click,function(n){var s=e(this),o=s.attr("href");t.__valueOrFn(t.opts.onClick.setSelected,s)&&s.parent().trigger(u.setSelected);var i=t.__valueOrFn(t.opts.onClick.preventDefault,s,"#"==o.slice(0,1));i&&n.preventDefault(),t.__valueOrFn(t.opts.onClick.blockUI,s,!i)&&r.$html.addClass(d.blocking),t.__valueOrFn(t.opts.onClick.close,s,i)&&t.$menu.triggerHandler(u.close)})},_initOpenClose:function(){var t=this,n=this.$menu.attr("id");n&&n.length&&(this.conf.clone&&(n=d.umm(n)),e('a[href="#'+n+'"]').off(u.click).on(u.click,function(e){e.preventDefault(),t.$menu.trigger(u.open)}));var n=r.$page.attr("id");n&&n.length&&e('a[href="#'+n+'"]').off(u.click).on(u.click,function(e){e.preventDefault(),t.$menu.trigger(u.close)})},__valueOrFn:function(e,t,n){return"function"==typeof e?e.call(t[0]):"undefined"==typeof e&&"undefined"!=typeof n?n:e},__refactorClass:function(e,t){e.removeClass(this.conf[t+"Class"]).addClass(d[t])}},e.fn[a]=function(o,i){return r.$wndw||s(),o=t(o,i),i=n(i),this.each(function(){var t=e(this);t.data(a)||t.data(a,new e[a](t,o,i))})},e[a].version=l,e[a].defaults={position:"left",zposition:"back",moveBackground:!0,slidingSubmenus:!0,modal:!1,classes:"",onClick:{setSelected:!0}},e[a].configuration={preventTabbing:!0,panelClass:"Panel",listClass:"List",selectedClass:"Selected",labelClass:"Label",spacerClass:"Spacer",pageNodetype:"div",panelNodetype:"ul, ol, div",transitionDuration:400},function(){var t=window.document,n=window.navigator.userAgent,s=(document.createElement("div").style,"ontouchstart"in t),o="WebkitOverflowScrolling"in t.documentElement.style,i=function(){return n.indexOf("Android")>=0?2.4>parseFloat(n.slice(n.indexOf("Android")+8)):!1}();e[a].support={touch:s,oldAndroidBrowser:i,overflowscrolling:function(){return s?o?!0:i?!1:!0:!0}()}}(),e[a].debug=function(){},e[a].deprecated=function(e,t){"undefined"!=typeof console&&"undefined"!=typeof console.warn&&console.warn("MMENU: "+e+" is deprecated, use "+t+" instead.")}}}(jQuery);
/*	
 * jQuery mmenu counters addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function(t){var e="mmenu",n="counters";t[e].prototype["_addon_"+n]=function(){var o=this,u=this.opts[n],a=t[e]._c,r=t[e]._d,d=t[e]._e;a.add("counter noresults"),d.add("updatecounters"),"boolean"==typeof u&&(u={add:u,update:u}),"object"!=typeof u&&(u={}),u=t.extend(!0,{},t[e].defaults[n],u),u.count&&(t[e].deprecated('the option "count" for counters, the option "update"'),u.update=u.count),this.__refactorClass(t("em."+this.conf.counterClass,this.$menu),"counter");var s=t("."+a.panel,this.$menu);if(u.add&&s.each(function(){var e=t(this),n=e.data(r.parent);if(n){var o=t('<em class="'+a.counter+'" />'),u=n.find("> a."+a.subopen);u.parent().find("em."+a.counter).length||u.before(o)}}),u.update){var c=t("em."+a.counter,this.$menu);c.off(d.updatecounters).on(d.updatecounters,function(t){t.stopPropagation()}).each(function(){var e=t(this),n=t(e.next().attr("href"),o.$menu);n.is("."+a.list)||(n=n.find("> ."+a.list)),n.length&&e.on(d.updatecounters,function(){var t=n.children().not("."+a.label).not("."+a.subtitle).not("."+a.hidden).not("."+a.noresults);e.html(t.length)})}).trigger(d.updatecounters),this.$menu.on(d.update,function(){c.trigger(d.updatecounters)})}},t[e].defaults[n]={add:!1,update:!1},t[e].configuration.counterClass="Counter",t[e].addons=t[e].addons||[],t[e].addons.push(n)}(jQuery);
/*	
 * jQuery mmenu dragOpen addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function(e){function t(e,t,a){return t>e&&(e=t),e>a&&(e=a),e}var a="mmenu",o="dragOpen";e[a].prototype["_addon_"+o]=function(){var n=this,r=this.opts[o];if(e.fn.hammer){var i=e[a]._c,s=(e[a]._d,e[a]._e);i.add("dragging"),s.add("dragleft dragright dragup dragdown dragend");var d=e[a].glbl;if("boolean"==typeof r&&(r={open:r}),"object"!=typeof r&&(r={}),"number"!=typeof r.maxStartPos&&(r.maxStartPos="left"==this.opts.position||"right"==this.opts.position?150:75),r=e.extend(!0,{},e[a].defaults[o],r),r.open){var p=0,g=!1,c=0,h=0,l="width";switch(this.opts.position){case"left":case"right":l="width";break;default:l="height"}switch(this.opts.position){case"left":var f={events:s.dragleft+" "+s.dragright,open_dir:"right",close_dir:"left",delta:"deltaX",page:"pageX",negative:!1};break;case"right":var f={events:s.dragleft+" "+s.dragright,open_dir:"left",close_dir:"right",delta:"deltaX",page:"pageX",negative:!0};break;case"top":var f={events:s.dragup+" "+s.dragdown,open_dir:"down",close_dir:"up",delta:"deltaY",page:"pageY",negative:!1};break;case"bottom":var f={events:s.dragup+" "+s.dragdown,open_dir:"up",close_dir:"down",delta:"deltaY",page:"pageY",negative:!0}}var u=this.__valueOrFn(r.pageNode,this.$menu,d.$page);"string"==typeof u&&(u=e(u));var m=d.$page.find("."+i.mm("fixed-top")+", ."+i.mm("fixed-bottom")),v=d.$page;switch(n.opts.zposition){case"back":v=v.add(m);break;case"front":v=n.$menu;break;case"next":v=v.add(n.$menu).add(m)}u.hammer().on(s.touchstart+" "+s.mousedown,function(e){if("touchstart"==e.type)var t=e.originalEvent.touches[0]||e.originalEvent.changedTouches[0],a=t[f.page];else if("mousedown"==e.type)var a=e[f.page];switch(n.opts.position){case"right":case"bottom":a>=d.$wndw[l]()-r.maxStartPos&&(p=1);break;default:a<=r.maxStartPos&&(p=1)}}).on(f.events+" "+s.dragend,function(e){p>0&&(e.gesture.preventDefault(),e.stopPropagation())}).on(f.events,function(e){var a=f.negative?-e.gesture[f.delta]:e.gesture[f.delta];if(g=a>c?f.open_dir:f.close_dir,c=a,c>r.threshold&&1==p){if(d.$html.hasClass(i.opened))return;p=2,n._openSetup(),d.$html.addClass(i.dragging),h=t(d.$wndw[l]()*n.conf[o][l].perc,n.conf[o][l].min,n.conf[o][l].max)}2==p&&v.css(n.opts.position,t(c,10,h)-("front"==n.opts.zposition?h:0))}).on(s.dragend,function(){2==p&&(d.$html.removeClass(i.dragging),v.css(n.opts.position,""),g==f.open_dir?n._openFinish():n.close()),p=0})}}},e[a].defaults[o]={open:!1,threshold:50},e[a].configuration[o]={width:{perc:.8,min:140,max:440},height:{perc:.8,min:140,max:880}},e[a].addons=e[a].addons||[],e[a].addons.push(o)}(jQuery);
/*	
 * jQuery mmenu header addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function(e){var t="mmenu",a="header";e[t].prototype["_addon_"+a]=function(){var n=this,r=this.opts[a],d=this.conf[a],s=e[t]._c,i=(e[t]._d,e[t]._e);s.add("header hasheader prev next title titletext"),i.add("updateheader");var o=e[t].glbl;if("boolean"==typeof r&&(r={add:r,update:r}),"object"!=typeof r&&(r={}),r=e.extend(!0,{},e[t].defaults[a],r),r.add){var h=r.content?r.content:'<a class="'+s.prev+'" href="#"></a><span class="'+s.title+'"></span><a class="'+s.next+'" href="#"></a>';e('<div class="'+s.header+'" />').prependTo(this.$menu).append(h)}var p=e("div."+s.header,this.$menu);if(p.length&&this.$menu.addClass(s.hasheader),r.update&&p.length){var l=p.find("."+s.title),u=p.find("."+s.prev),f=p.find("."+s.next),c="#"+o.$page.attr("id");u.add(f).on(i.click,function(t){t.preventDefault(),t.stopPropagation();var a=e(this).attr("href");"#"!==a&&(a==c?n.$menu.trigger(i.close):e(a,n.$menu).trigger(i.open))}),e("."+s.panel,this.$menu).each(function(){var t=e(this),a=e("."+d.panelHeaderClass,t).text(),n=e("."+d.panelPrevClass,t).attr("href"),o=e("."+d.panelNextClass,t).attr("href");a||(a=e("."+s.subclose,t).text()),a||(a=r.title),n||(n=e("."+s.subclose,t).attr("href")),t.off(i.updateheader).on(i.updateheader,function(e){e.stopPropagation(),l[a?"show":"hide"]().text(a),u[n?"show":"hide"]().attr("href",n),f[o?"show":"hide"]().attr("href",o)}),t.on(i.open,function(){e(this).trigger(i.updateheader)})}).filter("."+s.current).trigger(i.updateheader)}},e[t].defaults[a]={add:!1,content:!1,update:!1,title:"Menu"},e[t].configuration[a]={panelHeaderClass:"Header",panelNextClass:"Next",panelPrevClass:"Prev"},e[t].addons=e[t].addons||[],e[t].addons.push(a)}(jQuery);
/*	
 * jQuery mmenu labels addon
 * @requires mmenu 4.1.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function(e){var l="mmenu",s="labels";e[l].prototype["_addon_"+s]=function(){function a(){var e=t.hassearch&&o.$menu.hasClass(t.hassearch),l=t.hasheader&&o.$menu.hasClass(t.hasheader);return e?l?100:50:l?60:0}var o=this,n=this.opts[s],t=e[l]._c,i=(e[l]._d,e[l]._e);if(t.add("collapsed"),t.add("fixedlabels original clone"),i.add("updatelabels position scroll"),e[l].support.touch&&(i.scroll+=" "+i.mm("touchmove")),"boolean"==typeof n&&(n={collapse:n}),"object"!=typeof n&&(n={}),n=e.extend(!0,{},e[l].defaults[s],n),n.collapse){this.__refactorClass(e("li."+this.conf.collapsedClass,this.$menu),"collapsed");var d=e("."+t.label,this.$menu);d.each(function(){var l=e(this),s=l.nextUntil("."+t.label,"all"==n.collapse?null:"."+t.collapsed);"all"==n.collapse&&(l.addClass(t.opened),s.removeClass(t.collapsed)),s.length&&(l.wrapInner("<span />"),e('<a href="#" class="'+t.subopen+" "+t.fullsubopen+'" />').prependTo(l).on(i.click,function(e){e.preventDefault(),l.toggleClass(t.opened),s[l.hasClass(t.opened)?"removeClass":"addClass"](t.collapsed)}))})}else if(n.fixed){if("horizontal"!=this.direction)return;this.$menu.addClass(t.fixedlabels);var r=e("."+t.panel,this.$menu),d=e("."+t.label,this.$menu);r.add(d).off(i.updatelabels+" "+i.position+" "+i.scroll).on(i.updatelabels+" "+i.position+" "+i.scroll,function(e){e.stopPropagation()});var p=a();r.each(function(){var l=e(this),s=l.find("."+t.label);if(s.length){var o=l.scrollTop();s.each(function(){var s=e(this);s.wrapInner("<div />").wrapInner("<div />");var a,n,d,r=s.find("> div"),c=e();s.on(i.updatelabels,function(){o=l.scrollTop(),s.hasClass(t.hidden)||(c=s.nextAll("."+t.label).not("."+t.hidden).first(),a=s.offset().top+o,n=c.length?c.offset().top+o:!1,d=r.height(),s.trigger(i.position))}),s.on(i.position,function(){var e=0;n&&o+p>n-d?e=n-a-d:o+p>a&&(e=o-a+p),r.css("top",e)})}),l.on(i.updatelabels,function(){o=l.scrollTop(),p=a(),s.trigger(i.position)}).on(i.scroll,function(){s.trigger(i.updatelabels)})}}),this.$menu.on(i.update,function(){r.trigger(i.updatelabels)}).on(i.opening,function(){r.trigger(i.updatelabels).trigger(i.scroll)})}},e[l].defaults[s]={fixed:!1,collapse:!1},e[l].configuration.collapsedClass="Collapsed",e[l].addons=e[l].addons||[],e[l].addons.push(s)}(jQuery);
/*	
 * jQuery mmenu searchfield addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function(e){function s(e){switch(e){case 9:case 16:case 17:case 18:case 37:case 38:case 39:case 40:return!0}return!1}var n="mmenu",t="searchfield";e[n].prototype["_addon_"+t]=function(){var a=this,r=this.opts[t],o=e[n]._c,l=e[n]._d,d=e[n]._e;if(o.add("search hassearch noresults nosubresults counter"),d.add("search reset change"),"boolean"==typeof r&&(r={add:r,search:r}),"object"!=typeof r&&(r={}),r=e.extend(!0,{},e[n].defaults[t],r),r.add&&(e('<div class="'+o.search+'" />').prependTo(this.$menu).append('<input placeholder="'+r.placeholder+'" type="text" autocomplete="off" />'),r.noResults&&e("ul, ol",this.$menu).first().append('<li class="'+o.noresults+'">'+r.noResults+"</li>")),e("div."+o.search,this.$menu).length&&this.$menu.addClass(o.hassearch),r.search){var i=e("div."+o.search,this.$menu).find("input");if(i.length){var u=e("."+o.panel,this.$menu),h=e("."+o.list+"> li."+o.label,this.$menu),c=e("."+o.list+"> li",this.$menu).not("."+o.subtitle).not("."+o.label).not("."+o.noresults),f="> a";r.showLinksOnly||(f+=", > span"),i.off(d.keyup+" "+d.change).on(d.keyup,function(e){s(e.keyCode)||a.$menu.trigger(d.search)}).on(d.change,function(){a.$menu.trigger(d.search)}),this.$menu.off(d.reset+" "+d.search).on(d.reset+" "+d.search,function(e){e.stopPropagation()}).on(d.reset,function(){a.$menu.trigger(d.search,[""])}).on(d.search,function(s,n){"string"==typeof n?i.val(n):n=i.val(),n=n.toLowerCase(),u.scrollTop(0),c.add(h).addClass(o.hidden),c.each(function(){var s=e(this);e(f,s).text().toLowerCase().indexOf(n)>-1&&s.add(s.prevAll("."+o.label).first()).removeClass(o.hidden)}),e(u.get().reverse()).each(function(){var s=e(this),n=s.data(l.parent);if(n){var t=s.add(s.find("> ."+o.list)).find("> li").not("."+o.subtitle).not("."+o.label).not("."+o.hidden);t.length?n.removeClass(o.hidden).removeClass(o.nosubresults).prevAll("."+o.label).first().removeClass(o.hidden):(s.hasClass(o.current)&&n.trigger(d.open),n.addClass(o.nosubresults))}}),a.$menu[c.not("."+o.hidden).length?"removeClass":"addClass"](o.noresults),a.$menu.trigger(d.update)})}}},e[n].defaults[t]={add:!1,search:!1,showLinksOnly:!0,placeholder:"Search",noResults:"No results found."},e[n].addons=e[n].addons||[],e[n].addons.push(t)}(jQuery);;/*! modernizr 3.1.0 (Custom Build) | MIT *
 * http://modernizr.com/download/?-inputtypes !*/
!function(e,t,n){function a(e){var t=u.className,n=Modernizr._config.classPrefix||"";if(f&&(t=t.baseVal),Modernizr._config.enableJSClass){var a=new RegExp("(^|\\s)"+n+"no-js(\\s|$)");t=t.replace(a,"$1"+n+"js$2")}Modernizr._config.enableClasses&&(t+=" "+n+e.join(" "+n),f?u.className.baseVal=t:u.className=t)}function s(e,t){return typeof e===t}function i(){var e,t,n,a,i,o,c;for(var u in r)if(r.hasOwnProperty(u)){if(e=[],t=r[u],t.name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(a=s(t.fn,"function")?t.fn():t.fn,i=0;i<e.length;i++)o=e[i],c=o.split("."),1===c.length?Modernizr[c[0]]=a:(!Modernizr[c[0]]||Modernizr[c[0]]instanceof Boolean||(Modernizr[c[0]]=new Boolean(Modernizr[c[0]])),Modernizr[c[0]][c[1]]=a),l.push((a?"":"no-")+c.join("-"))}}function o(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):f?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}var l=[],r=[],c={_version:"3.1.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){r.push({name:e,fn:t,options:n})},addAsyncTest:function(e){r.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=c,Modernizr=new Modernizr;var u=t.documentElement,f="svg"===u.nodeName.toLowerCase(),p=o("input"),d="search tel url email datetime date month week time datetime-local number range color".split(" "),m={};Modernizr.inputtypes=function(e){for(var a,s,i,o=e.length,l=":)",r=0;o>r;r++)p.setAttribute("type",a=e[r]),i="text"!==p.type&&"style"in p,i&&(p.value=l,p.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(a)&&p.style.WebkitAppearance!==n?(u.appendChild(p),s=t.defaultView,i=s.getComputedStyle&&"textfield"!==s.getComputedStyle(p,null).WebkitAppearance&&0!==p.offsetHeight,u.removeChild(p)):/^(search|tel)$/.test(a)||(i=/^(url|email|number)$/.test(a)?p.checkValidity&&p.checkValidity()===!1:p.value!=l)),m[e[r]]=!!i;return m}(d),i(),a(l),delete c.addTest,delete c.addAsyncTest;for(var h=0;h<Modernizr._q.length;h++)Modernizr._q[h]();e.Modernizr=Modernizr}(window,document);;// moment.js locale configuration
// Locale: Arabic (ar)
// Author: Abdel Said: https://github.com/abdelsaid
// Changes in months, weekdays: Ahmed Elkhatib
// Native plural forms: forabi https://github.com/forabi

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        'كانون الثاني يناير',
        'شباط فبراير',
        'آذار مارس',
        'نيسان أبريل',
        'أيار مايو',
        'حزيران يونيو',
        'تموز يوليو',
        'آب أغسطس',
        'أيلول سبتمبر',
        'تشرين الأول أكتوبر',
        'تشرين الثاني نوفمبر',
        'كانون الأول ديسمبر'
    ];

    return moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'بعد %s',
            past : 'منذ %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/[۰-۹]/g, function (match) {
                return numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : german (de)
// author : lluchs : https://github.com/lluchs
// author: Menelion Elensúle: https://github.com/Oire

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    return moment.defineLocale('de', {
        months : "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
        monthsShort : "Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
        weekdays : "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
        weekdaysShort : "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
        weekdaysMin : "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
        longDateFormat : {
            LT: "HH:mm [Uhr]",
            L : "DD.MM.YYYY",
            LL : "D. MMMM YYYY",
            LLL : "D. MMMM YYYY LT",
            LLLL : "dddd, D. MMMM YYYY LT"
        },
        calendar : {
            sameDay: "[Heute um] LT",
            sameElse: "L",
            nextDay: '[Morgen um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gestern um] LT',
            lastWeek: '[letzten] dddd [um] LT'
        },
        relativeTime : {
            future : "in %s",
            past : "vor %s",
            s : "ein paar Sekunden",
            m : processRelativeTime,
            mm : "%d Minuten",
            h : processRelativeTime,
            hh : "%d Stunden",
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : spanish (es)
// author : Julio Napurí : https://github.com/julionc

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
        monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_");

    return moment.defineLocale('es', {
        months : "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        weekdays : "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
        weekdaysShort : "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
        weekdaysMin : "Do_Lu_Ma_Mi_Ju_Vi_Sá".split("_"),
        longDateFormat : {
            LT : "H:mm",
            L : "DD/MM/YYYY",
            LL : "D [de] MMMM [del] YYYY",
            LLL : "D [de] MMMM [del] YYYY LT",
            LLLL : "dddd, D [de] MMMM [del] YYYY LT"
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : "en %s",
            past : "hace %s",
            s : "unos segundos",
            m : "un minuto",
            mm : "%d minutos",
            h : "una hora",
            hh : "%d horas",
            d : "un día",
            dd : "%d días",
            M : "un mes",
            MM : "%d meses",
            y : "un año",
            yy : "%d años"
        },
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : french (fr)
// author : John Fischer : https://github.com/jfroffice

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    return moment.defineLocale('fr', {
        months : "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
        monthsShort : "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
        weekdays : "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
        weekdaysShort : "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
        weekdaysMin : "Di_Lu_Ma_Me_Je_Ve_Sa".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "DD/MM/YYYY",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd D MMMM YYYY LT"
        },
        calendar : {
            sameDay: "[Aujourd'hui à] LT",
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : "dans %s",
            past : "il y a %s",
            s : "quelques secondes",
            m : "une minute",
            mm : "%d minutes",
            h : "une heure",
            hh : "%d heures",
            d : "un jour",
            dd : "%d jours",
            M : "un mois",
            MM : "%d mois",
            y : "un an",
            yy : "%d ans"
        },
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : Bahasa Indonesia (id)
// author : Mohammad Satrio Utomo : https://github.com/tyok
// reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    return moment.defineLocale('id', {
        months : "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
        monthsShort : "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des".split("_"),
        weekdays : "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
        weekdaysShort : "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
        weekdaysMin : "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
        longDateFormat : {
            LT : "HH.mm",
            L : "DD/MM/YYYY",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY [pukul] LT",
            LLLL : "dddd, D MMMM YYYY [pukul] LT"
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : "dalam %s",
            past : "%s yang lalu",
            s : "beberapa detik",
            m : "semenit",
            mm : "%d menit",
            h : "sejam",
            hh : "%d jam",
            d : "sehari",
            dd : "%d hari",
            M : "sebulan",
            MM : "%d bulan",
            y : "setahun",
            yy : "%d tahun"
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : polish (pl)
// author : Rafal Hirsz : https://github.com/evoL

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    var monthsNominative = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"),
        monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_");

    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }

    function translate(number, withoutSuffix, key) {
        var result = number + " ";
        switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minutę';
        case 'mm':
            return result + (plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzinę';
        case 'hh':
            return result + (plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural(number) ? 'miesiące' : 'miesięcy');
        case 'yy':
            return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    return moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),
        weekdays : "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),
        weekdaysShort : "nie_pon_wt_śr_czw_pt_sb".split("_"),
        weekdaysMin : "N_Pn_Wt_Śr_Cz_Pt_So".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "DD.MM.YYYY",
            LL : "D MMMM YYYY",
            LLL : "D MMMM YYYY LT",
            LLLL : "dddd, D MMMM YYYY LT"
        },
        calendar : {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[W zeszłą niedzielę o] LT';
                case 3:
                    return '[W zeszłą środę o] LT';
                case 6:
                    return '[W zeszłą sobotę o] LT';
                default:
                    return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : "za %s",
            past : "%s temu",
            s : "kilka sekund",
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : "1 dzień",
            dd : '%d dni',
            M : "miesiąc",
            MM : translate,
            y : "rok",
            yy : translate
        },
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : portuguese (pt)
// author : Jefferson : https://github.com/jalex79

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    return moment.defineLocale('pt', {
        months : "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
        monthsShort : "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
        weekdays : "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"),
        weekdaysShort : "dom_seg_ter_qua_qui_sex_sáb".split("_"),
        weekdaysMin : "dom_2ª_3ª_4ª_5ª_6ª_sáb".split("_"),
        longDateFormat : {
            LT : "HH:mm",
            L : "DD/MM/YYYY",
            LL : "D [de] MMMM [de] YYYY",
            LLL : "D [de] MMMM [de] YYYY LT",
            LLLL : "dddd, D [de] MMMM [de] YYYY LT"
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : "em %s",
            past : "há %s",
            s : "segundos",
            m : "um minuto",
            mm : "%d minutos",
            h : "uma hora",
            hh : "%d horas",
            d : "um dia",
            dd : "%d dias",
            M : "um mês",
            MM : "%d meses",
            y : "um ano",
            yy : "%d anos"
        },
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : russian (ru)
// author : Viktorminator : https://github.com/Viktorminator
// Author : Menelion Elensúle : https://github.com/Oire

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }

    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
            'hh': 'час_часа_часов',
            'dd': 'день_дня_дней',
            'MM': 'месяц_месяца_месяцев',
            'yy': 'год_года_лет'
        };
        if (key === 'm') {
            return withoutSuffix ? 'минута' : 'минуту';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    function monthsCaseReplace(m, format) {
        var months = {
            'nominative': 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
            'accusative': 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_')
        },

        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';

        return months[nounCase][m.month()];
    }

    function monthsShortCaseReplace(m, format) {
        var monthsShort = {
            'nominative': 'янв_фев_мар_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
            'accusative': 'янв_фев_мар_апр_мая_июня_июля_авг_сен_окт_ноя_дек'.split('_')
        },

        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';

        return monthsShort[nounCase][m.month()];
    }

    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
            'accusative': 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_')
        },

        nounCase = (/\[ ?[Вв] ?(?:прошлую|следующую)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';

        return weekdays[nounCase][m.day()];
    }

    return moment.defineLocale('ru', {
        months : monthsCaseReplace,
        monthsShort : monthsShortCaseReplace,
        weekdays : weekdaysCaseReplace,
        weekdaysShort : "вс_пн_вт_ср_чт_пт_сб".split("_"),
        weekdaysMin : "вс_пн_вт_ср_чт_пт_сб".split("_"),
        monthsParse : [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[й|я]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i],
        longDateFormat : {
            LT : "HH:mm",
            L : "DD.MM.YYYY",
            LL : "D MMMM YYYY г.",
            LLL : "D MMMM YYYY г., LT",
            LLLL : "dddd, D MMMM YYYY г., LT"
        },
        calendar : {
            sameDay: '[Сегодня в] LT',
            nextDay: '[Завтра в] LT',
            lastDay: '[Вчера в] LT',
            nextWeek: function () {
                return this.day() === 2 ? '[Во] dddd [в] LT' : '[В] dddd [в] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[В прошлое] dddd [в] LT';
                case 1:
                case 2:
                case 4:
                    return '[В прошлый] dddd [в] LT';
                case 3:
                case 5:
                case 6:
                    return '[В прошлую] dddd [в] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : "через %s",
            past : "%s назад",
            s : "несколько секунд",
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : "час",
            hh : relativeTimeWithPlural,
            d : "день",
            dd : relativeTimeWithPlural,
            M : "месяц",
            MM : relativeTimeWithPlural,
            y : "год",
            yy : relativeTimeWithPlural
        },

        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM : function (input) {
            return /^(дня|вечера)$/.test(input);
        },

        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return "ночи";
            } else if (hour < 12) {
                return "утра";
            } else if (hour < 17) {
                return "дня";
            } else {
                return "вечера";
            }
        },

        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-й';
            case 'D':
                return number + '-го';
            case 'w':
            case 'W':
                return number + '-я';
            default:
                return number;
            }
        },

        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });
}));
;// moment.js locale configuration
// locale : chinese
// author : suupic : https://github.com/suupic
// author : Zeno Zeng : https://github.com/zenozeng

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory); // AMD
    } else if (typeof exports === 'object') {
        module.exports = factory(require('../moment')); // Node
    } else {
        factory(window.moment); // Browser global
    }
}(function (moment) {
    return moment.defineLocale('zh-cn', {
        months : "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
        monthsShort : "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
        weekdays : "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
        weekdaysShort : "周日_周一_周二_周三_周四_周五_周六".split("_"),
        weekdaysMin : "日_一_二_三_四_五_六".split("_"),
        longDateFormat : {
            LT : "Ah点mm",
            L : "YYYY-MM-DD",
            LL : "YYYY年MMMD日",
            LLL : "YYYY年MMMD日LT",
            LLLL : "YYYY年MMMD日ddddLT",
            l : "YYYY-MM-DD",
            ll : "YYYY年MMMD日",
            lll : "YYYY年MMMD日LT",
            llll : "YYYY年MMMD日ddddLT"
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return "凌晨";
            } else if (hm < 900) {
                return "早上";
            } else if (hm < 1130) {
                return "上午";
            } else if (hm < 1230) {
                return "中午";
            } else if (hm < 1800) {
                return "下午";
            } else {
                return "晚上";
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? "[今天]Ah[点整]" : "[今天]LT";
            },
            nextDay : function () {
                return this.minutes() === 0 ? "[明天]Ah[点整]" : "[明天]LT";
            },
            lastDay : function () {
                return this.minutes() === 0 ? "[昨天]Ah[点整]" : "[昨天]LT";
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';
                return this.minutes() === 0 ? prefix + "dddAh点整" : prefix + "dddAh点mm";
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
                return this.minutes() === 0 ? prefix + "dddAh点整" : prefix + "dddAh点mm";
            },
            sameElse : 'LL'
        },
        ordinal : function (number, period) {
            switch (period) {
            case "d":
            case "D":
            case "DDD":
                return number + "日";
            case "M":
                return number + "月";
            case "w":
            case "W":
                return number + "周";
            default:
                return number;
            }
        },
        relativeTime : {
            future : "%s内",
            past : "%s前",
            s : "几秒",
            m : "1分钟",
            mm : "%d分钟",
            h : "1小时",
            hh : "%d小时",
            d : "1天",
            dd : "%d天",
            M : "1个月",
            MM : "%d个月",
            y : "1年",
            yy : "%d年"
        },
        week : {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });
}));
;/**!
 * PJAX- Standalone (+ several custom changes for binary.com)
 *
 * A standalone implementation of Pushstate AJAX, for non-jQuery web pages.
 * jQuery are recommended to use the original implementation at: http://github.com/defunkt/jquery-pjax
 *
 * @version 0.6.1
 * @author Carl
 * @source https://github.com/thybag/PJAX-Standalone
 * @license MIT
 */
(function(){

	// Object to store private values/methods.
	var internal = {
		// Is this the first usage of PJAX? (Ensure history entry has required values if so.)
		"firstrun": true,
		// Borrowed wholesale from https://github.com/defunkt/jquery-pjax
		// Attempt to check that a device supports pushstate before attempting to use it.
		"is_supported": window.history && window.history.pushState && window.history.replaceState && !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]|WebApps\/.+CFNetwork)/),
		// Track which scripts have been included in to the page. (used if e)
		"loaded_scripts": []
	};

	// If PJAX isn't supported we can skip setting up the library all together
	// So as not to break any code expecting PJAX to be there, return a shell object containing
	// IE7 + compatible versions of connect (which needs to do nothing) and invoke ( which just changes the page)
	if(!internal.is_supported) {
		// PJAX shell, so any code expecting PJAX will work
		var pjax_shell = {
			"connect": function() { return; },
			"invoke": function() {
				var url = (arguments.length === 2) ? arguments[0] : arguments.url;
				document.location = url;
				return;
			}
		};
		// AMD support
		if (typeof define === 'function' && define.amd) {
			define( function() { return pjax_shell; });
		} else {
			window.pjax = pjax_shell;
		}
		return;
	}

	/**
	 * AddEvent
	 *
	 * @scope private
	 * @param obj Object to listen on
	 * @param event Event to listen for.
	 * @param callback Method to run when event is detected.
	 */
	internal.addEvent = function(obj, event, callback) {
		obj.addEventListener(event, callback, false);
	};

	/**
	 * Clone
	 * Util method to create copies of the options object (so they do not share references)
	 * This allows custom settings on different links.
	 *
	 * @scope private
	 * @param obj
	 * @return obj
	 */
	internal.clone = function(obj) {
		var object = {};
		// For every option in object, create it in the duplicate.
		for (var i in obj) {
			object[i] = obj[i];
		}
		return object;
	};

	/**
	 * triggerEvent
	 * Fire an event on a given object (used for callbacks)
	 *
	 * @scope private
	 * @param node. Objects to fire event on
	 * @return event_name. type of event
	 */
	internal.triggerEvent = function(node, event_name, data) {
		// Good browsers
		var evt = document.createEvent("HTMLEvents");
		evt.initEvent(event_name, true, true);
		// If additional data was provided, add it to event
		if(typeof data !== 'undefined') evt.data = data;
		node.dispatchEvent(evt);
	};

	/**
	 * popstate listener
	 * Listens for back/forward button events and updates page accordingly.
	 */
	internal.addEvent(window, 'popstate', function(st) {
		if(st.state !== null) {

			var opt = {
				'url': st.state.url,
				'container': st.state.container,
                'useClass': st.state.useClass,
                'loggedin': st.state.loggedin,
				'title' : st.state.title,
				'history': false
			};

			// Merge original in original connect options
			if(typeof internal.options !== 'undefined'){
				for(var a in internal.options){
					if(typeof opt[a] === 'undefined') opt[a] = internal.options[a];
				}
			}

			// Convert state data to PJAX options
			var options = internal.parseOptions(opt);
			// If something went wrong, return.
			if(options === false) return;
			// If there is a state object, handle it as a page load.
			internal.handle(options);
		}
	});

	/**
	 * attach
	 * Attach PJAX listeners to a link.
	 * @scope private
	 * @param link_node. link that will be clicked.
	 * @param content_node.
	 */
	internal.attach = function(node, options) {

		// Ignore external links.
		if ( node.protocol !== document.location.protocol ||
			node.host !== document.location.host ) {
			return;
		}

		// Ignore anchors on the same page
		if(node.pathname === location.pathname && node.hash.length > 0) {
			return;
		}

		// Ignore common non-PJAX loadable media types (pdf/doc/zips & images) unless user provides alternate array
		var ignoreFileTypes = ['pdf','doc','docx','zip','rar','7z','gif','jpeg','jpg','png'];
		if(typeof options.ignoreFileTypes === 'undefined') options.ignoreFileTypes = ignoreFileTypes;
		// Skip link if file type is within ignored types array
		if(options.ignoreFileTypes.indexOf( node.pathname.split('.').pop().toLowerCase() ) !== -1){
			return;
		}

		// Add link HREF to object
		options.url = node.href;
		options.update_url = node.pathname + node.search + node.hash;
		options.loggedin = node.classList.contains('with_login_cookies');

		// If PJAX data is specified, use as container
		if(node.getAttribute('data-pjax')) {
			options.container = node.getAttribute('data-pjax');
		}

		// If data-title is specified, use as title.
		if(node.getAttribute('data-title')) {
			options.title = node.getAttribute('data-title');
		}

		// Check options are valid.
		options = internal.parseOptions(options);
		if(options === false) return;

		// Attach event.
		internal.addEvent(node, 'click', function(event) {
			// Allow middle click (pages in new windows)
			if ( event.which > 1 || event.metaKey || event.ctrlKey ) return;
			// Don't fire normal event
			if(event.preventDefault){ event.preventDefault(); }else{ event.returnValue = false; }
			// Take no action if we are already on said page?
			if(document.location.href === options.url) return false;
			// handle the load.
			internal.handle(options);
		});
	};

	/**
	 * parseLinks
	 * Parse all links within a DOM node, using settings provided in options.
	 * @scope private
	 * @param dom_obj. Dom node to parse for links.
	 * @param options. Valid Options object.
	 */
	internal.parseLinks = function(dom_obj, options) {

		var nodes;

		if(typeof options.useClass !== 'undefined'){
			// Get all nodes with the provided class name.
			nodes = dom_obj.getElementsByClassName(options.useClass);
		}else{
			// If no class was provided, just get all the links
			nodes = dom_obj.getElementsByTagName('a');
		}

		// For all returned nodes
		for(var i=0,tmp_opt; i < nodes.length; i++) {
			var node = nodes[i];
			if(typeof options.excludeClass !== 'undefined') {
				if(node.className.indexOf(options.excludeClass) !== -1) continue;
			}
			// Override options history to true, else link parsing could be triggered by back button (which runs in no-history mode)
			tmp_opt = internal.clone(options);
			tmp_opt.history = true;
			internal.attach(node, tmp_opt);
		}

		if(internal.firstrun) {
			// Store array or all currently included script src's to avoid PJAX accidentally reloading existing libraries
			var scripts = document.getElementsByTagName('script');
			for(var c=0; c < scripts.length; c++) {
				if(scripts[c].src && internal.loaded_scripts.indexOf(scripts[c].src) === -1){
					internal.loaded_scripts.push(scripts[c].src);
				}
			}

			// Fire ready event once all links are connected
			internal.triggerEvent(internal.get_container_node(options.container), 'ready');

		}
	};

	/**
	 * SmartLoad
	 * Smartload checks the returned HTML to ensure PJAX ready content has been provided rather than
	 * a full HTML page. If a full HTML has been returned, it will attempt to scan the page and extract
	 * the correct HTML to update our container with in order to ensure PJAX still functions as expected.
	 *
	 * @scope private
	 * @param HTML (HTML returned from AJAX)
	 * @param options (Options object used to request page)
	 * @return HTML to append to our page.
	 */
	internal.smartLoad = function(html, options) {
		// Grab the title if there is one
		var title = html.getElementsByTagName('title')[0];
		if(title)
			document.title = title.innerHTML;

		// Going by caniuse all browsers that support the pushstate API also support querySelector's
		// see: http://caniuse.com/#search=push
		// see: http://caniuse.com/#search=querySelector
		var container = html.querySelector("#" + options.container.id);
		if(container !== null) return container;

		// If our container was not found, HTML will be returned as is.
		return html;
	};

	/**
	 * Update Content
	 * Updates DOM with content loaded via PJAX
	 *
	 * @param html DOM fragment of loaded container
	 * @param options PJAX configuration options
	 * return options
	 */
	internal.updateContent = function(html, options){
		// Create in memory DOM node, to make parsing returned data easier
		var tmp = document.createElement('div');
		tmp.innerHTML = html;

		// Ensure we have the correct HTML to apply to our container.
		if(options.smartLoad) tmp = internal.smartLoad(tmp, options);

		// If no title was provided, extract it
		if(typeof options.title === 'undefined'){
			// Use current doc title (this will be updated via smart load if its enabled)
			options.title = document.title;

			// Attempt to grab title from non-smart loaded page contents
			if(!options.smartLoad){
				var tmpTitle = tmp.getElementsByTagName('title');
				if(tmpTitle.length !== 0) options.title = tmpTitle[0].innerHTML;
			}
		}

		// Update the DOM with the new content
		options.container.innerHTML = tmp.innerHTML;

		// Run included JS?
		if(options.parseJS) internal.runScripts(tmp);

		// Send data back to handle
		return options;
	};

	/**
	 * runScripts
	 * Execute JavaScript on pages loaded via PJAX
	 *
	 * Note: In-line JavaScript is run each time a page is hit, while external JavaScript
	 *		is only loaded once (Although remains loaded while the user continues browsing)
	 *
	 * @param html DOM fragment of loaded container
	 * return void
	 */
	internal.runScripts = function(html){
		// Extract JavaScript & eval it (if enabled)
		var scripts = html.getElementsByTagName('script');
		for(var sc=0; sc < scripts.length;sc++) {
			// If has an src & src isn't in "loaded_scripts", load the script.
			if(scripts[sc].src && internal.loaded_scripts.indexOf(scripts[sc].src) === -1){
				// Append to head to include
				var s = document.createElement("script");
				s.src = scripts[sc].src;
				document.head.appendChild(s);
				// Add to loaded list
				internal.loaded_scripts.push(scripts[sc].src);
			}else{
				// If raw JS, eval it.
				eval(scripts[sc].innerHTML);
			}
		}
	};

	/**
	 * handle
	 * Handle requests to load content via PJAX.
	 * @scope private
	 * @param url. Page to load.
	 * @param node. Dom node to add returned content in to.
	 * @param addtohistory. Does this load require a history event.
	 */
	internal.handle = function(options) {

		// Fire beforeSend Event.
		internal.triggerEvent(options.container, 'beforeSend', options);

		// Do the request
		internal.request(options.url, function(html) {

			// Fail if unable to load HTML via AJAX
			if(html === false){
				internal.triggerEvent(options.container,'complete', options);
				internal.triggerEvent(options.container,'error', options);
				return;
			}

			// Parse page & update DOM
			options = internal.updateContent(html, options);

			// Do we need to add this to the history?
			if(options.history) {
				// If this is the first time pjax has run, create a state object for the current page.
				if(internal.firstrun){
					window.history.replaceState({'url': document.location.href, 'container':  options.container.id, 'useClass': options.useClass, 'loggedin': options.loggedin, 'title': document.title}, document.title);
					internal.firstrun = false;
				}
				// Update browser history
				window.history.pushState({'url': options.url, 'container': options.container.id, 'useClass': options.useClass, 'loggedin': options.loggedin, 'title': options.title }, options.title , options.url);
			}

			// Initialize any new links found within document (if enabled).
			if(options.parseLinksOnload){
				internal.parseLinks(options.container, options);
			}

			// Fire Events
			internal.triggerEvent(options.container,'complete', options);
			internal.triggerEvent(options.container,'success', options);

			// Don't track if page isn't part of history, or if autoAnalytics is disabled
			if(options.autoAnalytics && options.history) {
				// If autoAnalytics is enabled and a Google analytics tracker is detected push
				// a trackPageView, so PJAX loaded pages can be tracked successfully.
				if(window._gaq) _gaq.push(['_trackPageview']);
				if(window.ga) ga('send', 'pageview', {'page': options.url, 'title': options.title});
			}

			// Set new title
			document.title = options.title;

			// Scroll page to top on new page load
			if(options.returnToTop) {
				window.scrollTo(0, 0);
			}
		});
	};

	/**
	 * Request
	 * Performs AJAX request to page and returns the result..
	 *
	 * @scope private
	 * @param location. Page to request.
	 * @param callback. Method to call when a page is loaded.
	 */
	internal.request = function(location, callback) {
		// Create xmlHttpRequest object.
		var xmlhttp;
		try {
			xmlhttp = window.XMLHttpRequest? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
		}  catch (e) {
			console.log("Unable to create XMLHTTP Request");
			return;
		}
		// Add state listener.
		xmlhttp.onreadystatechange = function() {
			if ((xmlhttp.readyState === 4) && (xmlhttp.status === 200)) {
				// Success, Return HTML
				callback(xmlhttp.responseText);
			}else if((xmlhttp.readyState === 4) && (xmlhttp.status === 404 || xmlhttp.status === 500)){
				// error (return false)
				callback(false);
			}
		};
		// Secret pjax ?get param so browser doesn't return pjax content from cache when we don't want it to
		// Switch between ? and & so as not to break any URL params (Based on change by zmasek https://github.com/zmasek/)
		xmlhttp.open("GET", location + ((!/[?&]/.test(location)) ? '?_pjax' : '&_pjax'), true);
		// Add headers so things can tell the request is being performed via AJAX.
		xmlhttp.setRequestHeader('X-PJAX', 'true'); // PJAX header
		xmlhttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');// Standard AJAX header.

		xmlhttp.send(null);
	};

	/**
	 * parseOptions
	 * Validate and correct options object while connecting up any listeners.
	 *
	 * @scope private
	 * @param options
	 * @return false | valid options object
	 */
	internal.parseOptions = function(options) {

		/**  Defaults parse options. (if something isn't provided)
		 *
		 * - history: track event to history (on by default, set to off when performing back operation)
		 * - parseLinksOnload: Enabled by default. Process pages loaded via PJAX and setup PJAX on any links found.
		 * - smartLoad: Tries to ensure the correct HTML is loaded. If you are certain your back end
		 *		will only return PJAX ready content this can be disabled for a slight performance boost.
		 * - autoAnalytics: Automatically attempt to log events to Google analytics (if tracker is available)
		 * - returnToTop: Scroll user back to top of page, when new page is opened by PJAX
		 * - parseJS: Disabled by default, when enabled PJAX will automatically run returned JavaScript
		 */
		var defaults = {
			"history": true,
			"parseLinksOnload": true,
			"smartLoad" : true,
			"autoAnalytics": true,
			"returnToTop": true,
			"parseJS": false
		};

		// Ensure a URL and container have been provided.
		if(typeof options.url === 'undefined' || typeof options.container === 'undefined' || options.container === null) {
			console.log("URL and Container must be provided.");
			return false;
		}

		// Check required options are defined, if not, use default
		for(var o in defaults) {
			if(typeof options[o] === 'undefined') options[o] = defaults[o];
		}

		// Ensure history setting is a boolean.
		options.history = (options.history === false) ? false : true;

		// Get container (if its an id, convert it to a DOM node.)
		options.container = internal.get_container_node(options.container);

		// Events
		var events = ['ready', 'beforeSend', 'complete', 'error', 'success'];

		// If everything went okay thus far, connect up listeners
		for(var e in events){
			var evt = events[e];
			if(typeof options[evt] === 'function'){
				internal.addEvent(options.container, evt, options[evt]);
			}
		}

		// Return valid options
		return options;
	};

	/**
	 * get_container_node
	 * Returns container node
	 *
	 * @param container - (string) container ID | container DOM node.
	 * @return container DOM node | false
	 */
	internal.get_container_node = function(container) {
		if(typeof container === 'string') {
			container = document.getElementById(container);
			if(container === null){
				console.log("Could not find container with id:" + container);
				return false;
			}
		}
		return container;
	};

	/**
	 * connect
	 * Attach links to PJAX handlers.
	 * @scope public
	 *
	 * Can be called in 3 ways.
	 * Calling as connect();
	 *		Will look for links with the data-pjax attribute.
	 *
	 * Calling as connect(container_id)
	 *		Will try to attach to all links, using the container_id as the target.
	 *
	 * Calling as connect(container_id, class_name)
	 *		Will try to attach any links with the given class name, using container_id as the target.
	 *
	 * Calling as connect({
	 *						'url':'somepage.php',
	 *						'container':'somecontainer',
	 *						'beforeSend': function(){console.log("sending");}
	 *					})
	 *		Will use the provided JSON to configure the script in full (including callbacks)
	 */
	this.connect = function(/* options */) {
		// connect();
		var options = {};
		// connect(container, class_to_apply_to)
		if(arguments.length === 2){
			options.container = arguments[0];
			options.useClass = arguments[1];
		}
		// Either JSON or container id
		if(arguments.length === 1){
			if(typeof arguments[0] === 'string' ) {
				//connect(container_id)
				options.container = arguments[0];
			}else{
				//Else connect({url:'', container: ''});
				options = arguments[0];
			}
		}
		// Delete history and title if provided. These options should only be provided via invoke();
		delete options.title;
		delete options.history;

		internal.options = options;
		if(document.readyState === 'complete') {
			internal.parseLinks(document, options);
		} else {
			//Don't run until the window is ready.
			internal.addEvent(window, 'load', function(){
				//Parse links using specified options
				internal.parseLinks(document, options);
			});
		}
	};

	/**
	 * invoke
	 * Directly invoke a pjax page load.
	 * invoke({url: 'file.php', 'container':'content'});
	 *
	 * @scope public
	 * @param options
	 */
	this.invoke = function(/* options */) {

		var options = {};
		// url, container
		if(arguments.length === 2){
			options.url = arguments[0];
			options.container = arguments[1];
		}else{
			options = arguments[0];
		}

		// Process options
		options = internal.parseOptions(options);
		// If everything went okay, activate pjax.
		if(options !== false) internal.handle(options);
	};

	// Make object usable
	var pjax_obj = this;
	if (typeof define === 'function' && define.amd) {
		// Register pjax as AMD module
		define( function() {
			return pjax_obj;
		});
	}else{
		// Make PJAX object accessible in global name space
		window.pjax = pjax_obj;
	}


}).call({});
; /**
  * React v0.14.7
  */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.React = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var ReactDOM = _dereq_(35);
var ReactDOMServer = _dereq_(45);
var ReactIsomorphic = _dereq_(63);

var assign = _dereq_(23);
var deprecated = _dereq_(106);

// `version` will be added here by ReactIsomorphic.
var React = {};

assign(React, ReactIsomorphic);

assign(React, {
  // ReactDOM
  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

  // ReactDOMServer
  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
});

React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

module.exports = React;
},{"106":106,"23":23,"35":35,"45":45,"63":63}],2:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusUtils
 * @typechecks static-only
 */

'use strict';

var ReactMount = _dereq_(65);

var findDOMNode = _dereq_(108);
var focusNode = _dereq_(138);

var Mixin = {
  componentDidMount: function () {
    if (this.props.autoFocus) {
      focusNode(findDOMNode(this));
    }
  }
};

var AutoFocusUtils = {
  Mixin: Mixin,

  focusDOMComponent: function () {
    focusNode(ReactMount.getNode(this._rootNodeID));
  }
};

module.exports = AutoFocusUtils;
},{"108":108,"138":138,"65":65}],3:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = _dereq_(15);
var EventPropagators = _dereq_(19);
var ExecutionEnvironment = _dereq_(130);
var FallbackCompositionState = _dereq_(20);
var SyntheticCompositionEvent = _dereq_(90);
var SyntheticInputEvent = _dereq_(94);

var keyOf = _dereq_(148);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"130":130,"148":148,"15":15,"19":19,"20":20,"90":90,"94":94}],4:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],5:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

'use strict';

var CSSProperty = _dereq_(4);
var ExecutionEnvironment = _dereq_(130);
var ReactPerf = _dereq_(71);

var camelizeStyleName = _dereq_(132);
var dangerousStyleValue = _dereq_(105);
var hyphenateStyleName = _dereq_(143);
var memoizeStringOnly = _dereq_(150);
var warning = _dereq_(155);

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ("development" !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "development" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "development" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    "development" !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
  };

  /**
   * @param {string} name
   * @param {*} value
   */
  var warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function (styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if ("development" !== 'production') {
        warnValidStyle(styleName, styleValue);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function (node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ("development" !== 'production') {
        warnValidStyle(styleName, styles[styleName]);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
  setValueForStyles: 'setValueForStyles'
});

module.exports = CSSPropertyOperations;
},{"105":105,"130":130,"132":132,"143":143,"150":150,"155":155,"4":4,"71":71}],6:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var PooledClass = _dereq_(24);

var assign = _dereq_(23);
var invariant = _dereq_(144);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? "development" !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function () {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function () {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;
},{"144":144,"23":23,"24":24}],7:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = _dereq_(15);
var EventPluginHub = _dereq_(16);
var EventPropagators = _dereq_(19);
var ExecutionEnvironment = _dereq_(130);
var ReactUpdates = _dereq_(83);
var SyntheticEvent = _dereq_(92);

var getEventTarget = _dereq_(114);
var isEventSupported = _dereq_(119);
var isTextInputElement = _dereq_(120);
var keyOf = _dereq_(148);

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
      if (targetID) {
        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"114":114,"119":119,"120":120,"130":130,"148":148,"15":15,"16":16,"19":19,"83":83,"92":92}],8:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

'use strict';

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function () {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;
},{}],9:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

'use strict';

var Danger = _dereq_(12);
var ReactMultiChildUpdateTypes = _dereq_(67);
var ReactPerf = _dereq_(71);

var setInnerHTML = _dereq_(124);
var setTextContent = _dereq_(125);
var invariant = _dereq_(144);

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.

  // fix render order error in safari
  // IE8 will throw error when index out of list size.
  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

  parentNode.insertBefore(childNode, beforeChild);
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: setTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function (updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; i < updates.length; i++) {
      update = updates[i];
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        !updatedChild ? "development" !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup;
    // markupList is either a list of markup or just a list of elements
    if (markupList.length && typeof markupList[0] === 'string') {
      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
    } else {
      renderedMarkup = markupList;
    }

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; k < updates.length; k++) {
      update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.SET_MARKUP:
          setInnerHTML(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
  updateTextContent: 'updateTextContent'
});

module.exports = DOMChildrenOperations;
},{"12":12,"124":124,"125":125,"144":144,"67":67,"71":71}],10:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

'use strict';

var invariant = _dereq_(144);

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? "development" !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };

      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? "development" !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? "development" !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? "development" !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

      if ("development" !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if ("development" !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseAttribute:
   *   Whether the property must be accessed and mutated using `*Attribute()`.
   *   (This includes anything that fails `<propName> in <element>`.)
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasSideEffects:
   *   Whether or not setting a value causes side effects such as triggering
   *   resources to be loaded or text selection changes. If true, we read from
   *   the DOM before updating to ensure that the value is only set if it has
   *   changed.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   * @type {Object}
   */
  getPossibleStandardName: "development" !== 'production' ? {} : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function (nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
},{"144":144}],11:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

'use strict';

var DOMProperty = _dereq_(10);
var ReactPerf = _dereq_(71);

var quoteAttributeValueForBrowser = _dereq_(122);
var warning = _dereq_(155);

// Simplified subset
var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  "development" !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

if ("development" !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function (name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    "development" !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    } else if ("development" !== 'production') {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
      } else if (propertyInfo.mustUseAttribute) {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      } else {
        var propName = propertyInfo.propertyName;
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
    } else if ("development" !== 'production') {
      warnUnknownProperty(name);
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseAttribute) {
        node.removeAttribute(propertyInfo.attributeName);
      } else {
        var propName = propertyInfo.propertyName;
        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if ("development" !== 'production') {
      warnUnknownProperty(name);
    }
  }

};

ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
  setValueForProperty: 'setValueForProperty',
  setValueForAttribute: 'setValueForAttribute',
  deleteValueForProperty: 'deleteValueForProperty'
});

module.exports = DOMPropertyOperations;
},{"10":10,"122":122,"155":155,"71":71}],12:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var createNodesFromMarkup = _dereq_(135);
var emptyFunction = _dereq_(136);
var getMarkupWrap = _dereq_(140);
var invariant = _dereq_(144);

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function (markupList) {
    !ExecutionEnvironment.canUseDOM ? "development" !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? "development" !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? "development" !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if ("development" !== 'production') {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? "development" !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

    !(resultList.length === markupList.length) ? "development" !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? "development" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
    !markup ? "development" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
    !(oldChild.tagName.toLowerCase() !== 'html') ? "development" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

    var newChild;
    if (typeof markup === 'string') {
      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    } else {
      newChild = markup;
    }
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;
},{"130":130,"135":135,"136":136,"140":140,"144":144}],13:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = _dereq_(148);

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

module.exports = DefaultEventPluginOrder;
},{"148":148}],14:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = _dereq_(15);
var EventPropagators = _dereq_(19);
var SyntheticMouseEvent = _dereq_(96);

var ReactMount = _dereq_(65);
var keyOf = _dereq_(148);

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    var fromID = '';
    var toID = '';
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      fromID = topLevelTargetID;
      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
      if (to) {
        toID = ReactMount.getID(to);
      } else {
        to = win;
      }
      to = to || win;
    } else {
      from = win;
      to = topLevelTarget;
      toID = topLevelTargetID;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;
},{"148":148,"15":15,"19":19,"65":65,"96":96}],15:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = _dereq_(147);

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topAbort: null,
  topBlur: null,
  topCanPlay: null,
  topCanPlayThrough: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topDurationChange: null,
  topEmptied: null,
  topEncrypted: null,
  topEnded: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topLoadedData: null,
  topLoadedMetadata: null,
  topLoadStart: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topPause: null,
  topPlay: null,
  topPlaying: null,
  topProgress: null,
  topRateChange: null,
  topReset: null,
  topScroll: null,
  topSeeked: null,
  topSeeking: null,
  topSelectionChange: null,
  topStalled: null,
  topSubmit: null,
  topSuspend: null,
  topTextInput: null,
  topTimeUpdate: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topVolumeChange: null,
  topWaiting: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;
},{"147":147}],16:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var EventPluginRegistry = _dereq_(17);
var EventPluginUtils = _dereq_(18);
var ReactErrorUtils = _dereq_(56);

var accumulateInto = _dereq_(102);
var forEachAccumulated = _dereq_(110);
var invariant = _dereq_(144);
var warning = _dereq_(155);

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
  "development" !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function (InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ("development" !== 'production') {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function () {
      if ("development" !== 'production') {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function (id, registrationName, listener) {
    !(typeof listener === 'function') ? "development" !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(id, registrationName, listener);
    }
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (id, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(id, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function (id) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][id]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(id, registrationName);
      }

      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? "development" !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
},{"102":102,"110":110,"144":144,"155":155,"17":17,"18":18,"56":56}],17:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = _dereq_(144);

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? "development" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? "development" !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? "development" !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? "development" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? "development" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? "development" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? "development" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;
},{"144":144}],18:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = _dereq_(15);
var ReactErrorUtils = _dereq_(56);

var invariant = _dereq_(144);
var warning = _dereq_(155);

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function (InjectedMount) {
    injection.Mount = InjectedMount;
    if ("development" !== 'production') {
      "development" !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if ("development" !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    "development" !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, simulated, listener, domID) {
  var type = event.type || 'unknown-event';
  event.currentTarget = injection.Mount.getNode(domID);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("development" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
  }
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("development" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("development" !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  !!Array.isArray(dispatchListener) ? "development" !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getNode: function (id) {
    return injection.Mount.getNode(id);
  },
  getID: function (node) {
    return injection.Mount.getID(node);
  },

  injection: injection
};

module.exports = EventPluginUtils;
},{"144":144,"15":15,"155":155,"56":56}],19:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = _dereq_(15);
var EventPluginHub = _dereq_(16);

var warning = _dereq_(155);

var accumulateInto = _dereq_(102);
var forEachAccumulated = _dereq_(110);

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
},{"102":102,"110":110,"15":15,"155":155,"16":16}],20:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 * @typechecks static-only
 */

'use strict';

var PooledClass = _dereq_(24);

var assign = _dereq_(23);
var getTextContentAccessor = _dereq_(117);

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"117":117,"23":23,"24":24}],21:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = _dereq_(10);
var ExecutionEnvironment = _dereq_(130);

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
}

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    challenge: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formAction: MUST_USE_ATTRIBUTE,
    formEncType: MUST_USE_ATTRIBUTE,
    formMethod: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: MUST_USE_ATTRIBUTE,
    frameBorder: MUST_USE_ATTRIBUTE,
    headers: null,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    high: null,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    inputMode: MUST_USE_ATTRIBUTE,
    integrity: null,
    is: MUST_USE_ATTRIBUTE,
    keyParams: MUST_USE_ATTRIBUTE,
    keyType: MUST_USE_ATTRIBUTE,
    kind: null,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    low: null,
    manifest: MUST_USE_ATTRIBUTE,
    marginHeight: null,
    marginWidth: null,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    minLength: MUST_USE_ATTRIBUTE,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    nonce: MUST_USE_ATTRIBUTE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcLang: null,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    summary: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,
    wrap: null,

    /**
     * RDFa Properties
     */
    about: MUST_USE_ATTRIBUTE,
    datatype: MUST_USE_ATTRIBUTE,
    inlist: MUST_USE_ATTRIBUTE,
    prefix: MUST_USE_ATTRIBUTE,
    // property is also supported for OpenGraph in meta tags.
    property: MUST_USE_ATTRIBUTE,
    resource: MUST_USE_ATTRIBUTE,
    'typeof': MUST_USE_ATTRIBUTE,
    vocab: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: MUST_USE_ATTRIBUTE,
    autoCorrect: MUST_USE_ATTRIBUTE,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: null,
    // color is for Safari mask-icon link
    color: null,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: MUST_USE_ATTRIBUTE,
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    itemType: MUST_USE_ATTRIBUTE,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: MUST_USE_ATTRIBUTE,
    itemRef: MUST_USE_ATTRIBUTE,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: null,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: MUST_USE_ATTRIBUTE,
    // IE-only attribute that controls focus behavior
    unselectable: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoComplete: 'autocomplete',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    autoSave: 'autosave',
    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
    encType: 'encoding',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;
},{"10":10,"130":130}],22:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

'use strict';

var ReactPropTypes = _dereq_(74);
var ReactPropTypeLocations = _dereq_(73);

var invariant = _dereq_(144);
var warning = _dereq_(155);

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? "development" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? "development" !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? "development" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: ReactPropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        "development" !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
},{"144":144,"155":155,"73":73,"74":74}],23:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;
},{}],24:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = _dereq_(144);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? "development" !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
},{"144":144}],25:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

'use strict';

var ReactInstanceMap = _dereq_(62);

var findDOMNode = _dereq_(108);
var warning = _dereq_(155);

var didWarnKey = '_getDOMNodeDidWarn';

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function () {
    "development" !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
    this.constructor[didWarnKey] = true;
    return findDOMNode(this);
  }
};

module.exports = ReactBrowserComponentMixin;
},{"108":108,"155":155,"62":62}],26:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

'use strict';

var EventConstants = _dereq_(15);
var EventPluginHub = _dereq_(16);
var EventPluginRegistry = _dereq_(17);
var ReactEventEmitterMixin = _dereq_(57);
var ReactPerf = _dereq_(71);
var ViewportMetrics = _dereq_(101);

var assign = _dereq_(23);
var isEventSupported = _dereq_(119);

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
  putListener: 'putListener',
  deleteListener: 'deleteListener'
});

module.exports = ReactBrowserEventEmitter;
},{"101":101,"119":119,"15":15,"16":16,"17":17,"23":23,"57":57,"71":71}],27:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 * @typechecks static-only
 */

'use strict';

var ReactReconciler = _dereq_(76);

var instantiateReactComponent = _dereq_(118);
var shouldUpdateReactComponent = _dereq_(126);
var traverseAllChildren = _dereq_(127);
var warning = _dereq_(155);

function instantiateChild(childInstances, child, name) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, null);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return null;
    }
    var name;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      var prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          ReactReconciler.unmountComponent(prevChild, name);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, null);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        ReactReconciler.unmountComponent(prevChildren[name]);
      }
    }
    return nextChildren;
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  }

};

module.exports = ReactChildReconciler;
},{"118":118,"126":126,"127":127,"155":155,"76":76}],28:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = _dereq_(24);
var ReactElement = _dereq_(52);

var emptyFunction = _dereq_(136);
var traverseAllChildren = _dereq_(127);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"127":127,"136":136,"24":24,"52":52}],29:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var ReactComponent = _dereq_(30);
var ReactElement = _dereq_(52);
var ReactPropTypeLocations = _dereq_(73);
var ReactPropTypeLocationNames = _dereq_(72);
var ReactNoopUpdateQueue = _dereq_(69);

var assign = _dereq_(23);
var emptyObject = _dereq_(137);
var invariant = _dereq_(144);
var keyMirror = _dereq_(147);
var keyOf = _dereq_(148);
var warning = _dereq_(155);

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

var warnedSetProps = false;
function warnSetProps() {
  if (!warnedSetProps) {
    warnedSetProps = true;
    "development" !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
  }
}

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if ("development" !== 'production') {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if ("development" !== 'production') {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if ("development" !== 'production') {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

// noop
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but not in __DEV__
      "development" !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? "development" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? "development" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? "development" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
  !!ReactElement.isValidElement(spec) ? "development" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? "development" !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ("development" !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = (name in RESERVED_SPEC_KEYS);
    !!isReserved ? "development" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

    var isInherited = (name in Constructor);
    !!isInherited ? "development" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? "development" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? "development" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if ("development" !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    /* eslint-disable block-scoped-var, no-undef */
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        "development" !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
      } else if (!args.length) {
        "development" !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
      /* eslint-enable */
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  for (var autoBindKey in component.__reactAutoBindMap) {
    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  setProps: function (partialProps, callback) {
    if ("development" !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueSetProps(this, partialProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  replaceProps: function (newProps, callback) {
    if ("development" !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueReplaceProps(this, newProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  }
};

var ReactClassComponent = function () {};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context, updater) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if ("development" !== 'production') {
        "development" !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindMap) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if ("development" !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "development" !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if ("development" !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? "development" !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

    if ("development" !== 'production') {
      "development" !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
      "development" !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
},{"137":137,"144":144,"147":147,"148":148,"155":155,"23":23,"30":30,"52":52,"69":69,"72":72,"73":73}],30:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var ReactNoopUpdateQueue = _dereq_(69);

var canDefineProperty = _dereq_(104);
var emptyObject = _dereq_(137);
var invariant = _dereq_(144);
var warning = _dereq_(155);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? "development" !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
  }
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if ("development" !== 'production') {
  var deprecatedAPIs = {
    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
    setProps: ['setProps', 'Instead, call render again at the top level.']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          "development" !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
},{"104":104,"137":137,"144":144,"155":155,"69":69}],31:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var ReactDOMIDOperations = _dereq_(40);
var ReactMount = _dereq_(65);

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function (rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  }

};

module.exports = ReactComponentBrowserEnvironment;
},{"40":40,"65":65}],32:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = _dereq_(144);

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkupByID: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? "development" !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
},{"144":144}],33:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var ReactComponentEnvironment = _dereq_(32);
var ReactCurrentOwner = _dereq_(34);
var ReactElement = _dereq_(52);
var ReactInstanceMap = _dereq_(62);
var ReactPerf = _dereq_(71);
var ReactPropTypeLocations = _dereq_(73);
var ReactPropTypeLocationNames = _dereq_(72);
var ReactReconciler = _dereq_(76);
var ReactUpdateQueue = _dereq_(82);

var assign = _dereq_(23);
var emptyObject = _dereq_(137);
var invariant = _dereq_(144);
var shouldUpdateReactComponent = _dereq_(126);
var warning = _dereq_(155);

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  return Component(this.props, this.context, this.updater);
};

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedComponent = null;

    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._rootNodeID = rootID;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    // Initialize the public class
    var inst;
    var renderedElement;

    // This is a way to detect if Component is a stateless arrow function
    // component, which is not newable. It might not be 100% reliable but is
    // something we can do until we start detecting that Component extends
    // React.Component. We already assume that typeof Component === 'function'.
    var canInstantiate = ('prototype' in Component);

    if (canInstantiate) {
      if ("development" !== 'production') {
        ReactCurrentOwner.current = this;
        try {
          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
      }
    }

    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
      renderedElement = inst;
      inst = new StatelessComponent(Component);
    }

    if ("development" !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        "development" !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
      } else {
        // We support ES6 inheriting from React.Component, the module pattern,
        // and stateless components, but not ES6 classes that don't extend
        "development" !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
      }
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = ReactUpdateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if ("development" !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      "development" !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
      "development" !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
      "development" !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
      "development" !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
      "development" !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
      "development" !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
      "development" !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "development" !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    if (inst.componentWillMount) {
      inst.componentWillMount();
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    this._renderedComponent = this._instantiateReactComponent(renderedElement);

    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function () {
    var inst = this._instance;

    if (inst.componentWillUnmount) {
      inst.componentWillUnmount();
    }

    ReactReconciler.unmountComponent(this._renderedComponent);
    this._renderedComponent = null;
    this._instance = null;

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var maskedContext = null;
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if ("development" !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext = inst.getChildContext && inst.getChildContext();
    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? "development" !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
      if ("development" !== 'production') {
        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? "development" !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function (newProps) {
    if ("development" !== 'production') {
      var Component = this._currentElement.type;
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function (propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? "development" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // top-level render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            "development" !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
          } else {
            "development" !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
    }

    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;

    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
    var nextProps;

    // Distinguish between a props update versus a simple state update
    if (prevParentElement === nextParentElement) {
      // Skip checking prop types again -- we don't read inst.props to avoid
      // warning for DOM component props in this upgrade
      nextProps = nextParentElement.props;
    } else {
      nextProps = this._processProps(nextParentElement.props);
      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.

      if (inst.componentWillReceiveProps) {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);

    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

    if ("development" !== 'production') {
      "development" !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      // These two IDs are actually the same! But nothing should rely on that.
      var thisID = this._rootNodeID;
      var prevComponentID = prevComponentInstance._rootNodeID;
      ReactReconciler.unmountComponent(prevComponentInstance);

      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
    }
  },

  /**
   * @protected
   */
  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedComponent = inst.render();
    if ("development" !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedComponent;
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? "development" !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? "development" !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
    var publicComponentInstance = component.getPublicInstance();
    if ("development" !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      "development" !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (inst instanceof StatelessComponent) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent',
  _renderValidatedComponent: '_renderValidatedComponent'
});

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;
},{"126":126,"137":137,"144":144,"155":155,"23":23,"32":32,"34":34,"52":52,"62":62,"71":71,"72":72,"73":73,"76":76,"82":82}],34:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],35:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactCurrentOwner = _dereq_(34);
var ReactDOMTextComponent = _dereq_(46);
var ReactDefaultInjection = _dereq_(49);
var ReactInstanceHandles = _dereq_(61);
var ReactMount = _dereq_(65);
var ReactPerf = _dereq_(71);
var ReactReconciler = _dereq_(76);
var ReactUpdates = _dereq_(83);
var ReactVersion = _dereq_(84);

var findDOMNode = _dereq_(108);
var renderSubtreeIntoContainer = _dereq_(123);
var warning = _dereq_(155);

ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
/* eslint-enable camelcase */
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    CurrentOwner: ReactCurrentOwner,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    Reconciler: ReactReconciler,
    TextComponent: ReactDOMTextComponent
  });
}

if ("development" !== 'production') {
  var ExecutionEnvironment = _dereq_(130);
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    "development" !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

    // shams
    Object.create, Object.freeze];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

module.exports = React;
},{"108":108,"123":123,"130":130,"155":155,"34":34,"46":46,"49":49,"61":61,"65":65,"71":71,"76":76,"83":83,"84":84}],36:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var mouseListenerNames = {
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,

  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
};

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = {
  getNativeProps: function (inst, props, context) {
    if (!props.disabled) {
      return props;
    }

    // Copy the props, except the mouse listeners
    var nativeProps = {};
    for (var key in props) {
      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
        nativeProps[key] = props[key];
      }
    }

    return nativeProps;
  }
};

module.exports = ReactDOMButton;
},{}],37:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

'use strict';

var AutoFocusUtils = _dereq_(2);
var CSSPropertyOperations = _dereq_(5);
var DOMProperty = _dereq_(10);
var DOMPropertyOperations = _dereq_(11);
var EventConstants = _dereq_(15);
var ReactBrowserEventEmitter = _dereq_(26);
var ReactComponentBrowserEnvironment = _dereq_(31);
var ReactDOMButton = _dereq_(36);
var ReactDOMInput = _dereq_(41);
var ReactDOMOption = _dereq_(42);
var ReactDOMSelect = _dereq_(43);
var ReactDOMTextarea = _dereq_(47);
var ReactMount = _dereq_(65);
var ReactMultiChild = _dereq_(66);
var ReactPerf = _dereq_(71);
var ReactUpdateQueue = _dereq_(82);

var assign = _dereq_(23);
var canDefineProperty = _dereq_(104);
var escapeTextContentForBrowser = _dereq_(107);
var invariant = _dereq_(144);
var isEventSupported = _dereq_(119);
var keyOf = _dereq_(148);
var setInnerHTML = _dereq_(124);
var setTextContent = _dereq_(125);
var shallowEqual = _dereq_(153);
var validateDOMNesting = _dereq_(128);
var warning = _dereq_(155);

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var CHILDREN = keyOf({ children: null });
var STYLE = keyOf({ style: null });
var HTML = keyOf({ __html: null });

var ELEMENT_NODE_TYPE = 1;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

var legacyPropsDescriptor;
if ("development" !== 'production') {
  legacyPropsDescriptor = {
    props: {
      enumerable: false,
      get: function () {
        var component = this._reactInternalComponent;
        "development" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
        return component._currentElement.props;
      }
    }
  };
}

function legacyGetDOMNode() {
  if ("development" !== 'production') {
    var component = this._reactInternalComponent;
    "development" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return this;
}

function legacyIsMounted() {
  var component = this._reactInternalComponent;
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return !!component;
}

function legacySetStateEtc() {
  if ("development" !== 'production') {
    var component = this._reactInternalComponent;
    "development" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
}

function legacySetProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function legacyReplaceProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined becauses undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  "development" !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if ("development" !== 'production') {
    if (voidElementTags[component._tag]) {
      "development" !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? "development" !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? "development" !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
  }
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
    "development" !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
  }
  !(props.style == null || typeof props.style === 'object') ? "development" !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if ("development" !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    "development" !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? "development" !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
  var node = ReactMount.getNode(inst._rootNodeID);
  !node ? "development" !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

  switch (inst._tag) {
    case 'iframe':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
        }
      }

      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
      break;
  }
}

function mountReadyInputWrapper() {
  ReactDOMInput.mountReadyWrapper(this);
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

// NOTE: menuitem's close tag should be omitted, but that causes problems.
var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = ({}).hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? "development" !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContextDev(context, inst) {
  // Pass down our tag name to child components for validation purposes
  context = assign({}, context);
  var info = context[validateDOMNesting.ancestorInfoContextKey];
  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  return context;
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag.toLowerCase();
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._nodeWithLegacyProperties = null;
  if ("development" !== 'production') {
    this._unprocessedContextDev = null;
    this._processedContextDev = null;
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  construct: function (element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (rootID, transaction, context) {
    this._rootNodeID = rootID;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'button':
        props = ReactDOMButton.getNativeProps(this, props, context);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, context);
        props = ReactDOMInput.getNativeProps(this, props, context);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, context);
        props = ReactDOMOption.getNativeProps(this, props, context);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, context);
        props = ReactDOMSelect.getNativeProps(this, props, context);
        context = ReactDOMSelect.processChildContext(this, props, context);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, context);
        props = ReactDOMTextarea.getNativeProps(this, props, context);
        break;
    }

    assertValidProps(this, props);
    if ("development" !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    if ("development" !== 'production') {
      this._unprocessedContextDev = context;
      this._processedContextDev = processChildContextDev(context, this);
      context = this._processedContextDev;
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement(this._currentElement.type);
      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
      // Populate node cache
      ReactMount.getID(el);
      this._updateDOMProperties({}, props, transaction, el);
      this._createInitialChildren(transaction, props, context, el);
      mountImage = el;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
      // falls through
      case 'button':
      case 'select':
      case 'textarea':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if ("development" !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (propKey !== CHILDREN) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, el) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        setInnerHTML(el, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        setTextContent(el, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          el.appendChild(mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'button':
        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
        break;
      case 'input':
        ReactDOMInput.updateWrapper(this);
        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
        break;
    }

    if ("development" !== 'production') {
      // If the context is reference-equal to the old one, pass down the same
      // processed object so the update bailout in ReactReconciler behaves
      // correctly (and identically in dev and prod). See #5005.
      if (this._unprocessedContextDev !== context) {
        this._unprocessedContextDev = context;
        this._processedContextDev = processChildContextDev(context, this);
      }
      context = this._processedContextDev;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction, null);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    if (!canDefineProperty && this._nodeWithLegacyProperties) {
      this._nodeWithLegacyProperties.props = nextProps;
    }

    if (this._tag === 'select') {
      // <select> value update needs to occur after <option> children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if ("development" !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        if (propKey === CHILDREN) {
          nextProp = null;
        }
        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertantly setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      if (!node) {
        node = ReactMount.getNode(this._rootNodeID);
      }
      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function () {
    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
        ReactDOMInput.unmountWrapper(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? "development" !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
        break;
    }

    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
    this._wrapperState = null;
    if (this._nodeWithLegacyProperties) {
      var node = this._nodeWithLegacyProperties;
      node._reactInternalComponent = null;
      this._nodeWithLegacyProperties = null;
    }
  },

  getPublicInstance: function () {
    if (!this._nodeWithLegacyProperties) {
      var node = ReactMount.getNode(this._rootNodeID);

      node._reactInternalComponent = this;
      node.getDOMNode = legacyGetDOMNode;
      node.isMounted = legacyIsMounted;
      node.setState = legacySetStateEtc;
      node.replaceState = legacySetStateEtc;
      node.forceUpdate = legacySetStateEtc;
      node.setProps = legacySetProps;
      node.replaceProps = legacyReplaceProps;

      if ("development" !== 'production') {
        if (canDefineProperty) {
          Object.defineProperties(node, legacyPropsDescriptor);
        } else {
          // updateComponent will update this property on subsequent renders
          node.props = this._currentElement.props;
        }
      } else {
        // updateComponent will update this property on subsequent renders
        node.props = this._currentElement.props;
      }

      this._nodeWithLegacyProperties = node;
    }
    return this._nodeWithLegacyProperties;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent'
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
},{"10":10,"104":104,"107":107,"11":11,"119":119,"124":124,"125":125,"128":128,"144":144,"148":148,"15":15,"153":153,"155":155,"2":2,"23":23,"26":26,"31":31,"36":36,"41":41,"42":42,"43":43,"47":47,"5":5,"65":65,"66":66,"71":71,"82":82}],38:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFactories
 * @typechecks static-only
 */

'use strict';

var ReactElement = _dereq_(52);
var ReactElementValidator = _dereq_(53);

var mapObject = _dereq_(149);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if ("development" !== 'production') {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  image: 'image',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOMFactories;
},{"149":149,"52":52,"53":53}],39:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFeatureFlags
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: false
};

module.exports = ReactDOMFeatureFlags;
},{}],40:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = _dereq_(9);
var DOMPropertyOperations = _dereq_(11);
var ReactMount = _dereq_(65);
var ReactPerf = _dereq_(71);

var invariant = _dereq_(144);

/**
 * Errors for properties that should not be updated with `updatePropertyByID()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? "development" !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertantly setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (value != null) {
      DOMPropertyOperations.setValueForProperty(node, name, value);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, name);
    }
  },

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
  },

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (updates, markup) {
    for (var i = 0; i < updates.length; i++) {
      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
    }
    DOMChildrenOperations.processUpdates(updates, markup);
  }
};

ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
});

module.exports = ReactDOMIDOperations;
},{"11":11,"144":144,"65":65,"71":71,"9":9}],41:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var ReactDOMIDOperations = _dereq_(40);
var LinkedValueUtils = _dereq_(22);
var ReactMount = _dereq_(65);
var ReactUpdates = _dereq_(83);

var assign = _dereq_(23);
var invariant = _dereq_(144);

var instancesByReactID = {};

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getNativeProps: function (inst, props, context) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var nativeProps = assign({}, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if ("development" !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null,
      onChange: _handleChange.bind(inst)
    };
  },

  mountReadyWrapper: function (inst) {
    // Can't be in mountWrapper or else server rendering leaks.
    instancesByReactID[inst._rootNodeID] = inst;
  },

  unmountWrapper: function (inst) {
    delete instancesByReactID[inst._rootNodeID];
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
    }

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactMount.getNode(this._rootNodeID);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React with non-React.
      var otherID = ReactMount.getID(otherNode);
      !otherID ? "development" !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
      var otherInstance = instancesByReactID[otherID];
      !otherInstance ? "development" !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
},{"144":144,"22":22,"23":23,"40":40,"65":65,"83":83}],42:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var ReactChildren = _dereq_(28);
var ReactDOMSelect = _dereq_(43);

var assign = _dereq_(23);
var warning = _dereq_(155);

var valueContextKey = ReactDOMSelect.valueContextKey;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, context) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("development" !== 'production') {
      "development" !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
    }

    // Look up whether this option is 'selected' via context
    var selectValue = context[valueContextKey];

    // If context key is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + props.value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  getNativeProps: function (inst, props, context) {
    var nativeProps = assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      nativeProps.selected = inst._wrapperState.selected;
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        "development" !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
      }
    });

    if (content) {
      nativeProps.children = content;
    }

    return nativeProps;
  }

};

module.exports = ReactDOMOption;
},{"155":155,"23":23,"28":28,"43":43}],43:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var LinkedValueUtils = _dereq_(22);
var ReactMount = _dereq_(65);
var ReactUpdates = _dereq_(83);

var assign = _dereq_(23);
var warning = _dereq_(155);

var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    if (props.multiple) {
      "development" !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    } else {
      "development" !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactMount.getNode(inst._rootNodeID).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  valueContextKey: valueContextKey,

  getNativeProps: function (inst, props, context) {
    return assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if ("development" !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };
  },

  processChildContext: function (inst, props, context) {
    // Pass down initial value so initial generated markup has correct
    // `selected` attributes
    var childContext = assign({}, context);
    childContext[valueContextKey] = inst._wrapperState.initialValue;
    return childContext;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // the context value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  this._wrapperState.pendingUpdate = true;
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
},{"155":155,"22":22,"23":23,"65":65,"83":83}],44:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var getNodeForCharacterOffset = _dereq_(116);
var getTextContentAccessor = _dereq_(117);

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"116":116,"117":117,"130":130}],45:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMServer
 */

'use strict';

var ReactDefaultInjection = _dereq_(49);
var ReactServerRendering = _dereq_(80);
var ReactVersion = _dereq_(84);

ReactDefaultInjection.inject();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
  version: ReactVersion
};

module.exports = ReactDOMServer;
},{"49":49,"80":80,"84":84}],46:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = _dereq_(9);
var DOMPropertyOperations = _dereq_(11);
var ReactComponentBrowserEnvironment = _dereq_(31);
var ReactMount = _dereq_(65);

var assign = _dereq_(23);
var escapeTextContentForBrowser = _dereq_(107);
var setTextContent = _dereq_(125);
var validateDOMNesting = _dereq_(128);

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (props) {
  // This constructor and its argument is currently used by mocks.
};

assign(ReactDOMTextComponent.prototype, {

  /**
   * @param {ReactText} text
   * @internal
   */
  construct: function (text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;

    // Properties
    this._rootNodeID = null;
    this._mountIndex = 0;
  },

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    if ("development" !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    this._rootNodeID = rootID;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement('span');
      DOMPropertyOperations.setAttributeForID(el, rootID);
      // Populate node cache
      ReactMount.getID(el);
      setTextContent(el, this._stringText);
      return el;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this in a `span` for the reasons stated above, but
        // since this is a situation where React won't take over (static pages),
        // we can simply return the text as it is.
        return escapedText;
      }

      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var node = ReactMount.getNode(this._rootNodeID);
        DOMChildrenOperations.updateTextContent(node, nextStringText);
      }
    }
  },

  unmountComponent: function () {
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  }

});

module.exports = ReactDOMTextComponent;
},{"107":107,"11":11,"125":125,"128":128,"23":23,"31":31,"65":65,"9":9}],47:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var LinkedValueUtils = _dereq_(22);
var ReactDOMIDOperations = _dereq_(40);
var ReactUpdates = _dereq_(83);

var assign = _dereq_(23);
var invariant = _dereq_(144);
var warning = _dereq_(155);

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getNativeProps: function (inst, props, context) {
    !(props.dangerouslySetInnerHTML == null) ? "development" !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    var nativeProps = assign({}, props, {
      defaultValue: undefined,
      value: undefined,
      children: inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if ("development" !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      if ("development" !== 'production') {
        "development" !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
      }
      !(defaultValue == null) ? "development" !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? "development" !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(props);

    inst._wrapperState = {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue),
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
},{"144":144,"155":155,"22":22,"23":23,"40":40,"83":83}],48:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = _dereq_(83);
var Transaction = _dereq_(100);

var assign = _dereq_(23);
var emptyFunction = _dereq_(136);

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"100":100,"136":136,"23":23,"83":83}],49:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = _dereq_(3);
var ChangeEventPlugin = _dereq_(7);
var ClientReactRootIndex = _dereq_(8);
var DefaultEventPluginOrder = _dereq_(13);
var EnterLeaveEventPlugin = _dereq_(14);
var ExecutionEnvironment = _dereq_(130);
var HTMLDOMPropertyConfig = _dereq_(21);
var ReactBrowserComponentMixin = _dereq_(25);
var ReactComponentBrowserEnvironment = _dereq_(31);
var ReactDefaultBatchingStrategy = _dereq_(48);
var ReactDOMComponent = _dereq_(37);
var ReactDOMTextComponent = _dereq_(46);
var ReactEventListener = _dereq_(58);
var ReactInjection = _dereq_(59);
var ReactInstanceHandles = _dereq_(61);
var ReactMount = _dereq_(65);
var ReactReconcileTransaction = _dereq_(75);
var SelectEventPlugin = _dereq_(86);
var ServerReactRootIndex = _dereq_(87);
var SimpleEventPlugin = _dereq_(88);
var SVGDOMPropertyConfig = _dereq_(85);

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if ("development" !== 'production') {
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      var ReactDefaultPerf = _dereq_(50);
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};
},{"13":13,"130":130,"14":14,"21":21,"25":25,"3":3,"31":31,"37":37,"46":46,"48":48,"50":50,"58":58,"59":59,"61":61,"65":65,"7":7,"75":75,"8":8,"85":85,"86":86,"87":87,"88":88}],50:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

'use strict';

var DOMProperty = _dereq_(10);
var ReactDefaultPerfAnalysis = _dereq_(51);
var ReactMount = _dereq_(65);
var ReactPerf = _dereq_(71);

var performanceNow = _dereq_(152);

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function () {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function () {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function () {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  getMeasurementsSummaryMap: function (measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
    return summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  printDOM: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function (item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result.type = item.type;
      result.args = JSON.stringify(item.args);
      return result;
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  _recordWrite: function (id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function (moduleName, fnName, func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0,
          created: {}
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
        return rv;
      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === '_mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function (update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
          });
        } else {
          // basic format
          var id = args[0];
          if (typeof id === 'object') {
            id = ReactMount.getID(args[0]);
          }
          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
      fnName === '_renderValidatedComponent')) {

        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
          return func.apply(this, args);
        }

        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          entry.created[rootNodeID] = true;
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.getName(),
          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;
},{"10":10,"152":152,"51":51,"65":65,"71":71}],51:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

'use strict';

var assign = _dereq_(23);

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  '_mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  SET_MARKUP: 'set innerHTML',
  TEXT_CONTENT: 'set textContent',
  'setValueForProperty': 'update attribute',
  'setValueForAttribute': 'update attribute',
  'deleteValueForProperty': 'remove attribute',
  'setValueForStyles': 'update styles',
  'replaceNodeWithMarkup': 'replace',
  'updateTextContent': 'set textContent'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  measurements.forEach(function (measurement) {
    Object.keys(measurement.writes).forEach(function (id) {
      measurement.writes[id].forEach(function (write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    });
  });
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function (a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function (a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    // check if component newly created
    if (measurement.created[id]) {
      isDirty = true;
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;
},{"23":23}],52:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var ReactCurrentOwner = _dereq_(34);

var assign = _dereq_(23);
var canDefineProperty = _dereq_(104);

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if ("development" !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    Object.freeze(element.props);
    Object.freeze(element);
  }

  return element;
};

ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

  if ("development" !== 'production') {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }

  return newElement;
};

ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
},{"104":104,"23":23,"34":34}],53:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactElement = _dereq_(52);
var ReactPropTypeLocations = _dereq_(73);
var ReactPropTypeLocationNames = _dereq_(72);
var ReactCurrentOwner = _dereq_(34);

var canDefineProperty = _dereq_(104);
var getIteratorFn = _dereq_(115);
var invariant = _dereq_(144);
var warning = _dereq_(155);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
  if (addenda === null) {
    // we already showed the warning
    return;
  }
  "development" !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} messageType A key used for de-duping warnings.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 * @returns {?object} A set of addenda to use in the warning message, or null
 * if the warning has already been shown before (and shouldn't be shown again).
 */
function getAddendaForKeyUse(messageType, element, parentType) {
  var addendum = getDeclarationErrorAddendum();
  if (!addendum) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      addendum = ' Check the top-level render call using <' + parentName + '>.';
    }
  }

  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
  if (memoizer[addendum]) {
    return null;
  }
  memoizer[addendum] = true;

  var addenda = {
    parentOrOwner: addendum,
    url: ' See https://fb.me/react-warning-keys for more information.',
    childOwner: null
  };

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  return addenda;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? "development" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      "development" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        "development" !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    "development" !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    "development" !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if ("development" !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            "development" !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
},{"104":104,"115":115,"144":144,"155":155,"34":34,"52":52,"72":72,"73":73}],54:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var ReactElement = _dereq_(52);
var ReactEmptyComponentRegistry = _dereq_(55);
var ReactReconciler = _dereq_(76);

var assign = _dereq_(23);

var placeholderElement;

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function (component) {
    placeholderElement = ReactElement.createElement(component);
  }
};

var ReactEmptyComponent = function (instantiate) {
  this._currentElement = null;
  this._rootNodeID = null;
  this._renderedComponent = instantiate(placeholderElement);
};
assign(ReactEmptyComponent.prototype, {
  construct: function (element) {},
  mountComponent: function (rootID, transaction, context) {
    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
    this._rootNodeID = rootID;
    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
  },
  receiveComponent: function () {},
  unmountComponent: function (rootID, transaction, context) {
    ReactReconciler.unmountComponent(this._renderedComponent);
    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
    this._rootNodeID = null;
    this._renderedComponent = null;
  }
});

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{"23":23,"52":52,"55":55,"76":76}],55:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponentRegistry
 */

'use strict';

// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIDsRegistry = {};

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return !!nullComponentIDsRegistry[id];
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIDsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIDsRegistry[id];
}

var ReactEmptyComponentRegistry = {
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID,
  deregisterNullComponentID: deregisterNullComponentID
};

module.exports = ReactEmptyComponentRegistry;
},{}],56:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {?String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a, b) {
  try {
    return func(a, b);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
    return undefined;
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if ("development" !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
      var boundFunc = func.bind(null, a, b);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
},{}],57:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = _dereq_(16);

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"16":16}],58:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = _dereq_(129);
var ExecutionEnvironment = _dereq_(130);
var PooledClass = _dereq_(24);
var ReactInstanceHandles = _dereq_(61);
var ReactMount = _dereq_(65);
var ReactUpdates = _dereq_(83);

var assign = _dereq_(23);
var getEventTarget = _dereq_(114);
var getUnboundedScrollPosition = _dereq_(141);

var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  // TODO: Re-enable event.path handling
  //
  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
  //   // New browsers have a path attribute on native events
  //   handleTopLevelWithPath(bookKeeping);
  // } else {
  //   // Legacy browsers don't have a path attribute on native events
  //   handleTopLevelWithoutPath(bookKeeping);
  // }

  void handleTopLevelWithPath; // temporarily unused
  handleTopLevelWithoutPath(bookKeeping);
}

// Legacy browsers don't have a path attribute on native events
function handleTopLevelWithoutPath(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// New browsers have a path attribute on native events
function handleTopLevelWithPath(bookKeeping) {
  var path = bookKeeping.nativeEvent.path;
  var currentNativeTarget = path[0];
  var eventsFired = 0;
  for (var i = 0; i < path.length; i++) {
    var currentPathElement = path[i];
    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
      currentNativeTarget = path[i + 1];
    }
    // TODO: slow
    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
    if (reactParent === currentPathElement) {
      var currentPathElementID = ReactMount.getID(currentPathElement);
      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
      bookKeeping.ancestors.push(currentPathElement);

      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
      eventsFired++;
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

      // Jump to the root of this React render tree
      while (currentPathElementID !== newRootID) {
        i++;
        currentPathElement = path[i];
        currentPathElementID = ReactMount.getID(currentPathElement);
      }
    }
  }
  if (eventsFired === 0) {
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"114":114,"129":129,"130":130,"141":141,"23":23,"24":24,"61":61,"65":65,"83":83}],59:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = _dereq_(10);
var EventPluginHub = _dereq_(16);
var ReactComponentEnvironment = _dereq_(32);
var ReactClass = _dereq_(29);
var ReactEmptyComponent = _dereq_(54);
var ReactBrowserEventEmitter = _dereq_(26);
var ReactNativeComponent = _dereq_(68);
var ReactPerf = _dereq_(71);
var ReactRootIndex = _dereq_(78);
var ReactUpdates = _dereq_(83);

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"10":10,"16":16,"26":26,"29":29,"32":32,"54":54,"68":68,"71":71,"78":78,"83":83}],60:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = _dereq_(44);

var containsNode = _dereq_(133);
var focusNode = _dereq_(138);
var getActiveElement = _dereq_(139);

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"133":133,"138":138,"139":139,"44":44}],61:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

'use strict';

var ReactRootIndex = _dereq_(78);

var invariant = _dereq_(144);

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 10000;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  !(isValidID(ancestorID) && isValidID(destinationID)) ? "development" !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
  !isAncestorIDOf(ancestorID, destinationID) ? "development" !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  var i;
  for (i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  !isValidID(longestCommonID) ? "development" !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {*} arg Argument to invoke the callback with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  !(start !== stop) ? "development" !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
  var traverseUp = isAncestorIDOf(stop, start);
  !(traverseUp || isAncestorIDOf(start, stop)) ? "development" !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start;; /* until break */id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    !(depth++ < MAX_TREE_DEPTH) ? "development" !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function () {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function (rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function (id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Same as `traverseTwoPhase` but skips the `targetID`.
   */
  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, true);
      traverseParentPath(targetID, '', cb, arg, true, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function (targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;
},{"144":144,"78":78}],62:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],63:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactIsomorphic
 */

'use strict';

var ReactChildren = _dereq_(28);
var ReactComponent = _dereq_(30);
var ReactClass = _dereq_(29);
var ReactDOMFactories = _dereq_(38);
var ReactElement = _dereq_(52);
var ReactElementValidator = _dereq_(53);
var ReactPropTypes = _dereq_(74);
var ReactVersion = _dereq_(84);

var assign = _dereq_(23);
var onlyChild = _dereq_(121);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if ("development" !== 'production') {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign
};

module.exports = React;
},{"121":121,"23":23,"28":28,"29":29,"30":30,"38":38,"52":52,"53":53,"74":74,"84":84}],64:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = _dereq_(103);

var TAG_END = /\/?>/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags and self-closing tags)
    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"103":103}],65:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMProperty = _dereq_(10);
var ReactBrowserEventEmitter = _dereq_(26);
var ReactCurrentOwner = _dereq_(34);
var ReactDOMFeatureFlags = _dereq_(39);
var ReactElement = _dereq_(52);
var ReactEmptyComponentRegistry = _dereq_(55);
var ReactInstanceHandles = _dereq_(61);
var ReactInstanceMap = _dereq_(62);
var ReactMarkupChecksum = _dereq_(64);
var ReactPerf = _dereq_(71);
var ReactReconciler = _dereq_(76);
var ReactUpdateQueue = _dereq_(82);
var ReactUpdates = _dereq_(83);

var assign = _dereq_(23);
var emptyObject = _dereq_(137);
var containsNode = _dereq_(133);
var instantiateReactComponent = _dereq_(118);
var invariant = _dereq_(144);
var setInnerHTML = _dereq_(124);
var shouldUpdateReactComponent = _dereq_(126);
var validateDOMNesting = _dereq_(128);
var warning = _dereq_(155);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if ("development" !== 'production') {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        !!isValid(cached, id) ? "development" !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * Finds the node with the supplied public React instance.
 *
 * @param {*} instance A public React instance.
 * @return {?DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNodeFromInstance(instance) {
  var id = ReactInstanceMap.get(instance)._rootNodeID;
  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
    return null;
  }
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    !(internalGetID(node) === id) ? "development" !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
  if (ReactDOMFeatureFlags.useCreateElement) {
    context = assign({}, context);
    if (container.nodeType === DOC_NODE_TYPE) {
      context[ownerDocumentContextKey] = container;
    } else {
      context[ownerDocumentContextKey] = container.ownerDocument;
    }
  }
  if ("development" !== 'production') {
    if (context === emptyObject) {
      context = {};
    }
    var tag = container.nodeName.toLowerCase();
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
  }
  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* forceHTML */shouldReuseMarkup);
  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container) {
  ReactReconciler.unmountComponent(instance);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(node) {
  var reactRootID = getReactRootID(node);
  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
}

/**
 * Returns the first (deepest) ancestor of a node which is rendered by this copy
 * of React.
 */
function findFirstReactDOMImpl(node) {
  // This node might be from another React instance, so we make sure not to
  // examine the node cache here
  for (; node && node.parentNode !== node; node = node.parentNode) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      continue;
    }
    var nodeID = internalGetID(node);
    if (!nodeID) {
      continue;
    }
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

    // If containersByReactRootID contains the container we find by crawling up
    // the tree, we know that this instance of React rendered the node.
    // nb. isValid's strategy (with containsNode) does not work because render
    // trees may be nested and we don't want a false positive in that case.
    var current = node;
    var lastID;
    do {
      lastID = internalGetID(current);
      current = current.parentNode;
      if (current == null) {
        // The passed-in node has been detached from the container it was
        // originally rendered into.
        return null;
      }
    } while (lastID !== reactRootID);

    if (current === containersByReactRootID[reactRootID]) {
      return node;
    }
  }
  return null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var TopLevelWrapper = function () {};
TopLevelWrapper.prototype.isReactComponent = {};
if ("development" !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  // this.props is actually a ReactElement
  return this.props;
};

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    if ("development" !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function (nextComponent, container) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? "development" !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    "development" !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(componentInstance, container);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

    if ("development" !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? "development" !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !ReactElement.isValidElement(nextElement) ? "development" !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

    "development" !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if ("development" !== 'production') {
      "development" !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            "development" !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function (container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    "development" !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? "development" !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var containerID = internalGetID(container);
      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

      if ("development" !== 'production') {
        "development" !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
      }

      return false;
    }
    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if ("development" !== 'production') {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function (id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if ("development" !== 'production') {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        "development" !== 'production' ? warning(
        // Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
        var containerChild = container.firstChild;
        if (containerChild && reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          "development" !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function (id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component rendered by this copy of React.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function (node) {
    return findFirstReactDOMImpl(node);
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function (ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    if ("development" !== 'production') {
      // This will throw on the next line; give an early warning
      "development" !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
    }

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }
        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    !false ? "development" !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
  },

  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? "development" !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if ("development" !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? "development" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

        if ("development" !== 'production') {
          "development" !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? "development" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      container.appendChild(markup);
    } else {
      setInnerHTML(container, markup);
    }
  },

  ownerDocumentContextKey: ownerDocumentContextKey,

  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  getNodeFromInstance: getNodeFromInstance,

  isValid: isValid,

  purgeID: purgeID
};

ReactPerf.measureMethods(ReactMount, 'ReactMount', {
  _renderNewRootComponent: '_renderNewRootComponent',
  _mountImageIntoNode: '_mountImageIntoNode'
});

module.exports = ReactMount;
},{"10":10,"118":118,"124":124,"126":126,"128":128,"133":133,"137":137,"144":144,"155":155,"23":23,"26":26,"34":34,"39":39,"52":52,"55":55,"61":61,"62":62,"64":64,"71":71,"76":76,"82":82,"83":83}],66:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactComponentEnvironment = _dereq_(32);
var ReactMultiChildUpdateTypes = _dereq_(67);

var ReactCurrentOwner = _dereq_(34);
var ReactReconciler = _dereq_(76);
var ReactChildReconciler = _dereq_(27);

var flattenChildren = _dereq_(109);

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueInsertMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    content: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the markup of a node.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function enqueueSetMarkup(parentID, markup) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.SET_MARKUP,
    markupIndex: null,
    content: markup,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    content: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if ("development" !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
      var nextChildren;
      if ("development" !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements);
          } finally {
            ReactCurrentOwner.current = null;
          }
          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements);
      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        // TODO: The setTextContent operation should be enough
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChild(prevChildren[name]);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        this.setMarkup(nextMarkup);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildrenElements, transaction, context);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
      this._renderedChildren = nextChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChild(prevChild);
          }
          // The child must be instantiated before it's mounted.
          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          this._unmountChild(prevChildren[name]);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function () {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, mountImage) {
      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function (textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Sets this markup string.
     *
     * @param {string} markup Markup to set.
     * @protected
     */
    setMarkup: function (markup) {
      enqueueSetMarkup(this._rootNodeID, markup);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
      child._mountIndex = index;
      this.createChild(child, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child) {
      this.removeChild(child);
      child._mountIndex = null;
    }

  }

};

module.exports = ReactMultiChild;
},{"109":109,"27":27,"32":32,"34":34,"67":67,"76":76}],67:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = _dereq_(147);

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  SET_MARKUP: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;
},{"147":147}],68:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var assign = _dereq_(23);
var invariant = _dereq_(144);

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? "development" !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
  return new genericComponentClass(element.type, element.props);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;
},{"144":144,"23":23}],69:[function(_dereq_,module,exports){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNoopUpdateQueue
 */

'use strict';

var warning = _dereq_(155);

function warnTDZ(publicInstance, callerName) {
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnTDZ(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnTDZ(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnTDZ(publicInstance, 'setState');
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    warnTDZ(publicInstance, 'setProps');
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    warnTDZ(publicInstance, 'replaceProps');
  }

};

module.exports = ReactNoopUpdateQueue;
},{"155":155}],70:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = _dereq_(144);

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function (object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? "development" !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? "development" !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
},{"144":144}],71:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

'use strict';

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * @param {object} object
   * @param {string} objectName
   * @param {object<string>} methodNames
   */
  measureMethods: function (object, objectName, methodNames) {
    if ("development" !== 'production') {
      for (var key in methodNames) {
        if (!methodNames.hasOwnProperty(key)) {
          continue;
        }
        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
      }
    }
  },

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function (objName, fnName, func) {
    if ("development" !== 'production') {
      var measuredFunc = null;
      var wrapper = function () {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function (measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;
},{}],72:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if ("development" !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
},{}],73:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = _dereq_(147);

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"147":147}],74:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = _dereq_(52);
var ReactPropTypeLocationNames = _dereq_(72);

var emptyFunction = _dereq_(136);
var getIteratorFn = _dereq_(115);

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return '<<anonymous>>';
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"115":115,"136":136,"52":52,"72":72}],75:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

'use strict';

var CallbackQueue = _dereq_(6);
var PooledClass = _dereq_(24);
var ReactBrowserEventEmitter = _dereq_(26);
var ReactDOMFeatureFlags = _dereq_(39);
var ReactInputSelection = _dereq_(60);
var Transaction = _dereq_(100);

var assign = _dereq_(23);

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(forceHTML) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"100":100,"23":23,"24":24,"26":26,"39":39,"6":6,"60":60}],76:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = _dereq_(77);

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, rootID, transaction, context) {
    var markup = internalInstance.mountComponent(rootID, transaction, context);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent();
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction) {
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;
},{"77":77}],77:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = _dereq_(70);

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;

  return(
    // This has a few false positives w/r/t empty components.
    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
  );
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"70":70}],78:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

'use strict';

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function (_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;
},{}],79:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerBatchingStrategy
 * @typechecks
 */

'use strict';

var ReactServerBatchingStrategy = {
  isBatchingUpdates: false,
  batchedUpdates: function (callback) {
    // Don't do anything here. During the server rendering we don't want to
    // schedule any updates. We will simply ignore them.
  }
};

module.exports = ReactServerBatchingStrategy;
},{}],80:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
'use strict';

var ReactDefaultBatchingStrategy = _dereq_(48);
var ReactElement = _dereq_(52);
var ReactInstanceHandles = _dereq_(61);
var ReactMarkupChecksum = _dereq_(64);
var ReactServerBatchingStrategy = _dereq_(79);
var ReactServerRenderingTransaction = _dereq_(81);
var ReactUpdates = _dereq_(83);

var emptyObject = _dereq_(137);
var instantiateReactComponent = _dereq_(118);
var invariant = _dereq_(144);

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  !ReactElement.isValidElement(element) ? "development" !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  !ReactElement.isValidElement(element) ? "development" !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, emptyObject);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};
},{"118":118,"137":137,"144":144,"48":48,"52":52,"61":61,"64":64,"79":79,"81":81,"83":83}],81:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

'use strict';

var PooledClass = _dereq_(24);
var CallbackQueue = _dereq_(6);
var Transaction = _dereq_(100);

var assign = _dereq_(23);
var emptyFunction = _dereq_(136);

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = false;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"100":100,"136":136,"23":23,"24":24,"6":6}],82:[function(_dereq_,module,exports){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactCurrentOwner = _dereq_(34);
var ReactElement = _dereq_(52);
var ReactInstanceMap = _dereq_(62);
var ReactUpdates = _dereq_(83);

var assign = _dereq_(23);
var invariant = _dereq_(144);
var warning = _dereq_(155);

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if ("development" !== 'production') {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      "development" !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
    }
    return null;
  }

  if ("development" !== 'production') {
    "development" !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if ("development" !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        "development" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {
    !(typeof callback === 'function') ? "development" !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    !(typeof callback === 'function') ? "development" !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
  },

  enqueueSetPropsInternal: function (internalInstance, partialProps) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? "development" !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    var props = assign({}, element.props, partialProps);
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
  },

  enqueueReplacePropsInternal: function (internalInstance, props) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? "development" !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  enqueueElementInternal: function (internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  }

};

module.exports = ReactUpdateQueue;
},{"144":144,"155":155,"23":23,"34":34,"52":52,"62":62,"83":83}],83:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var CallbackQueue = _dereq_(6);
var PooledClass = _dereq_(24);
var ReactPerf = _dereq_(71);
var ReactReconciler = _dereq_(76);
var Transaction = _dereq_(100);

var assign = _dereq_(23);
var invariant = _dereq_(144);

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? "development" !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
}

assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? "development" !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? "development" !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? "development" !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? "development" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? "development" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? "development" !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
},{"100":100,"144":144,"23":23,"24":24,"6":6,"71":71,"76":76}],84:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactVersion
 */

'use strict';

module.exports = '0.14.7';
},{}],85:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var DOMProperty = _dereq_(10);

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

var SVGDOMPropertyConfig = {
  Properties: {
    clipPath: MUST_USE_ATTRIBUTE,
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    xlinkActuate: MUST_USE_ATTRIBUTE,
    xlinkArcrole: MUST_USE_ATTRIBUTE,
    xlinkHref: MUST_USE_ATTRIBUTE,
    xlinkRole: MUST_USE_ATTRIBUTE,
    xlinkShow: MUST_USE_ATTRIBUTE,
    xlinkTitle: MUST_USE_ATTRIBUTE,
    xlinkType: MUST_USE_ATTRIBUTE,
    xmlBase: MUST_USE_ATTRIBUTE,
    xmlLang: MUST_USE_ATTRIBUTE,
    xmlSpace: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {
    clipPath: 'clip-path',
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space'
  }
};

module.exports = SVGDOMPropertyConfig;
},{"10":10}],86:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = _dereq_(15);
var EventPropagators = _dereq_(19);
var ExecutionEnvironment = _dereq_(130);
var ReactInputSelection = _dereq_(60);
var SyntheticEvent = _dereq_(92);

var getActiveElement = _dereq_(139);
var isTextInputElement = _dereq_(120);
var keyOf = _dereq_(148);
var shallowEqual = _dereq_(153);

var topLevelTypes = EventConstants.topLevelTypes;

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case topLevelTypes.topSelectionChange:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (id, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"120":120,"130":130,"139":139,"148":148,"15":15,"153":153,"19":19,"60":60,"92":92}],87:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

'use strict';

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function () {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;
},{}],88:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = _dereq_(15);
var EventListener = _dereq_(129);
var EventPropagators = _dereq_(19);
var ReactMount = _dereq_(65);
var SyntheticClipboardEvent = _dereq_(89);
var SyntheticEvent = _dereq_(92);
var SyntheticFocusEvent = _dereq_(93);
var SyntheticKeyboardEvent = _dereq_(95);
var SyntheticMouseEvent = _dereq_(96);
var SyntheticDragEvent = _dereq_(91);
var SyntheticTouchEvent = _dereq_(97);
var SyntheticUIEvent = _dereq_(98);
var SyntheticWheelEvent = _dereq_(99);

var emptyFunction = _dereq_(136);
var getEventCharCode = _dereq_(111);
var invariant = _dereq_(144);
var keyOf = _dereq_(148);

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  abort: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAbort: true }),
      captured: keyOf({ onAbortCapture: true })
    }
  },
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  canPlay: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlay: true }),
      captured: keyOf({ onCanPlayCapture: true })
    }
  },
  canPlayThrough: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlayThrough: true }),
      captured: keyOf({ onCanPlayThroughCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  durationChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDurationChange: true }),
      captured: keyOf({ onDurationChangeCapture: true })
    }
  },
  emptied: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEmptied: true }),
      captured: keyOf({ onEmptiedCapture: true })
    }
  },
  encrypted: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEncrypted: true }),
      captured: keyOf({ onEncryptedCapture: true })
    }
  },
  ended: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEnded: true }),
      captured: keyOf({ onEndedCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  loadedData: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedData: true }),
      captured: keyOf({ onLoadedDataCapture: true })
    }
  },
  loadedMetadata: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedMetadata: true }),
      captured: keyOf({ onLoadedMetadataCapture: true })
    }
  },
  loadStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadStart: true }),
      captured: keyOf({ onLoadStartCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  pause: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPause: true }),
      captured: keyOf({ onPauseCapture: true })
    }
  },
  play: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlay: true }),
      captured: keyOf({ onPlayCapture: true })
    }
  },
  playing: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlaying: true }),
      captured: keyOf({ onPlayingCapture: true })
    }
  },
  progress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onProgress: true }),
      captured: keyOf({ onProgressCapture: true })
    }
  },
  rateChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onRateChange: true }),
      captured: keyOf({ onRateChangeCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  seeked: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeked: true }),
      captured: keyOf({ onSeekedCapture: true })
    }
  },
  seeking: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeking: true }),
      captured: keyOf({ onSeekingCapture: true })
    }
  },
  stalled: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onStalled: true }),
      captured: keyOf({ onStalledCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  suspend: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSuspend: true }),
      captured: keyOf({ onSuspendCapture: true })
    }
  },
  timeUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTimeUpdate: true }),
      captured: keyOf({ onTimeUpdateCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  volumeChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onVolumeChange: true }),
      captured: keyOf({ onVolumeChangeCapture: true })
    }
  },
  waiting: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWaiting: true }),
      captured: keyOf({ onWaitingCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topAbort: eventTypes.abort,
  topBlur: eventTypes.blur,
  topCanPlay: eventTypes.canPlay,
  topCanPlayThrough: eventTypes.canPlayThrough,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topDurationChange: eventTypes.durationChange,
  topEmptied: eventTypes.emptied,
  topEncrypted: eventTypes.encrypted,
  topEnded: eventTypes.ended,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topLoadedData: eventTypes.loadedData,
  topLoadedMetadata: eventTypes.loadedMetadata,
  topLoadStart: eventTypes.loadStart,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topPause: eventTypes.pause,
  topPlay: eventTypes.play,
  topPlaying: eventTypes.playing,
  topProgress: eventTypes.progress,
  topRateChange: eventTypes.rateChange,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSeeked: eventTypes.seeked,
  topSeeking: eventTypes.seeking,
  topStalled: eventTypes.stalled,
  topSubmit: eventTypes.submit,
  topSuspend: eventTypes.suspend,
  topTimeUpdate: eventTypes.timeUpdate,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topVolumeChange: eventTypes.volumeChange,
  topWaiting: eventTypes.waiting,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topAbort:
      case topLevelTypes.topCanPlay:
      case topLevelTypes.topCanPlayThrough:
      case topLevelTypes.topDurationChange:
      case topLevelTypes.topEmptied:
      case topLevelTypes.topEncrypted:
      case topLevelTypes.topEnded:
      case topLevelTypes.topError:
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topLoadedData:
      case topLevelTypes.topLoadedMetadata:
      case topLevelTypes.topLoadStart:
      case topLevelTypes.topPause:
      case topLevelTypes.topPlay:
      case topLevelTypes.topPlaying:
      case topLevelTypes.topProgress:
      case topLevelTypes.topRateChange:
      case topLevelTypes.topReset:
      case topLevelTypes.topSeeked:
      case topLevelTypes.topSeeking:
      case topLevelTypes.topStalled:
      case topLevelTypes.topSubmit:
      case topLevelTypes.topSuspend:
      case topLevelTypes.topTimeUpdate:
      case topLevelTypes.topVolumeChange:
      case topLevelTypes.topWaiting:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? "development" !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (id, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var node = ReactMount.getNode(id);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (id, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;
},{"111":111,"129":129,"136":136,"144":144,"148":148,"15":15,"19":19,"65":65,"89":89,"91":91,"92":92,"93":93,"95":95,"96":96,"97":97,"98":98,"99":99}],89:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = _dereq_(92);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"92":92}],90:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = _dereq_(92);

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"92":92}],91:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = _dereq_(96);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"96":96}],92:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

'use strict';

var PooledClass = _dereq_(24);

var assign = _dereq_(23);
var emptyFunction = _dereq_(136);
var warning = _dereq_(155);

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if ("development" !== 'production') {
      "development" !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if ("development" !== 'production') {
      "development" !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;
},{"136":136,"155":155,"23":23,"24":24}],93:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = _dereq_(98);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"98":98}],94:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = _dereq_(92);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"92":92}],95:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = _dereq_(98);

var getEventCharCode = _dereq_(111);
var getEventKey = _dereq_(112);
var getEventModifierState = _dereq_(113);

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"111":111,"112":112,"113":113,"98":98}],96:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = _dereq_(98);
var ViewportMetrics = _dereq_(101);

var getEventModifierState = _dereq_(113);

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"101":101,"113":113,"98":98}],97:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = _dereq_(98);

var getEventModifierState = _dereq_(113);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"113":113,"98":98}],98:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = _dereq_(92);

var getEventTarget = _dereq_(114);

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"114":114,"92":92}],99:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = _dereq_(96);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"96":96}],100:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = _dereq_(144);

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? "development" !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? "development" !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occurred.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;
},{"144":144}],101:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],102:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = _dereq_(144);

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? "development" !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
},{"144":144}],103:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    for (; i < Math.min(i + 4096, m); i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],104:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule canDefineProperty
 */

'use strict';

var canDefineProperty = false;
if ("development" !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
},{}],105:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

'use strict';

var CSSProperty = _dereq_(4);

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"4":4}],106:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule deprecated
 */

'use strict';

var assign = _dereq_(23);
var warning = _dereq_(155);

/**
 * This will log a single deprecation notice per function and forward the call
 * on to the new API.
 *
 * @param {string} fnName The name of the function
 * @param {string} newModule The module that fn will exist in
 * @param {string} newPackage The module that fn will exist in
 * @param {*} ctx The context this forwarded call should run in
 * @param {function} fn The function to forward on to
 * @return {function} The function that will warn once and then call fn
 */
function deprecated(fnName, newModule, newPackage, ctx, fn) {
  var warned = false;
  if ("development" !== 'production') {
    var newFn = function () {
      "development" !== 'production' ? warning(warned,
      // Require examples in this string must be split to prevent React's
      // build tools from mistaking them for real requires.
      // Otherwise the build tools will attempt to build a '%s' module.
      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
      warned = true;
      return fn.apply(ctx, arguments);
    };
    // We need to make sure all properties of the original fn are copied over.
    // In particular, this is needed to support PropTypes
    return assign(newFn, fn);
  }

  return fn;
}

module.exports = deprecated;
},{"155":155,"23":23}],107:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;
},{}],108:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = _dereq_(34);
var ReactInstanceMap = _dereq_(62);
var ReactMount = _dereq_(65);

var invariant = _dereq_(144);
var warning = _dereq_(155);

/**
 * Returns the DOM node rendered by this element.
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if ("development" !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      "development" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }
  if (ReactInstanceMap.has(componentOrElement)) {
    return ReactMount.getNodeFromInstance(componentOrElement);
  }
  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? "development" !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
  !false ? "development" !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
}

module.exports = findDOMNode;
},{"144":144,"155":155,"34":34,"62":62,"65":65}],109:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var traverseAllChildren = _dereq_(127);
var warning = _dereq_(155);

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if ("development" !== 'production') {
    "development" !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;
},{"127":127,"155":155}],110:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function (arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;
},{}],111:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],112:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

'use strict';

var getEventCharCode = _dereq_(111);

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"111":111}],113:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],114:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],115:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * @typechecks static-only
 */

'use strict';

/* global Symbol */
var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],116:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],117:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"130":130}],118:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

'use strict';

var ReactCompositeComponent = _dereq_(33);
var ReactEmptyComponent = _dereq_(54);
var ReactNativeComponent = _dereq_(68);

var assign = _dereq_(23);
var invariant = _dereq_(144);
var warning = _dereq_(155);

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function () {};
assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  if (node === null || node === false) {
    instance = new ReactEmptyComponent(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? "development" !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? "development" !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
  }

  if ("development" !== 'production') {
    "development" !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
  }

  // Sets up the instance. This can probably just move into the constructor now.
  instance.construct(node);

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if ("development" !== 'production') {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if ("development" !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
},{"144":144,"155":155,"23":23,"33":33,"54":54,"68":68}],119:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"130":130}],120:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
}

module.exports = isTextInputElement;
},{}],121:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = _dereq_(52);

var invariant = _dereq_(144);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? "development" !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
  return children;
}

module.exports = onlyChild;
},{"144":144,"52":52}],122:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = _dereq_(107);

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"107":107}],123:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = _dereq_(65);

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"65":65}],124:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

/* globals MSApp */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function (node, html) {
  node.innerHTML = html;
};

// Win8 apps: Allow all html to be inserted
if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
  setInnerHTML = function (node, html) {
    MSApp.execUnsafeLocalFunction(function () {
      node.innerHTML = html;
    });
  };
}

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;
},{"130":130}],125:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = _dereq_(130);
var escapeTextContentForBrowser = _dereq_(107);
var setInnerHTML = _dereq_(124);

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"107":107,"124":124,"130":130}],126:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;
},{}],127:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var ReactCurrentOwner = _dereq_(34);
var ReactElement = _dereq_(52);
var ReactInstanceHandles = _dereq_(61);

var getIteratorFn = _dereq_(115);
var invariant = _dereq_(144);
var warning = _dereq_(155);

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

var didWarnAboutMaps = false;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} text Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("development" !== 'production') {
          "development" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("development" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "development" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"115":115,"144":144,"155":155,"34":34,"52":52,"61":61}],128:[function(_dereq_,module,exports){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var assign = _dereq_(23);
var emptyFunction = _dereq_(136);
var warning = _dereq_(155);

var validateDOMNesting = emptyFunction;

if ("development" !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    parentTag: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.parentTag = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    /*eslint-disable space-after-keywords */
    do {
      /*eslint-enable space-after-keywords */
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        "development" !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
      } else {
        "development" !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
      }
    }
  };

  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
},{"136":136,"155":155,"23":23}],129:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = _dereq_(136);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function () {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if ("development" !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function () {}
};

module.exports = EventListener;
},{"136":136}],130:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],131:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],132:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

'use strict';

var camelize = _dereq_(131);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"131":131}],133:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

'use strict';

var isTextNode = _dereq_(146);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(_x, _x2) {
  var _again = true;

  _function: while (_again) {
    var outerNode = _x,
        innerNode = _x2;
    _again = false;

    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      _x = outerNode;
      _x2 = innerNode.parentNode;
      _again = true;
      continue _function;
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
}

module.exports = containsNode;
},{"146":146}],134:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFromMixed
 * @typechecks
 */

'use strict';

var toArray = _dereq_(154);

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return(
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"154":154}],135:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

'use strict';

var ExecutionEnvironment = _dereq_(130);

var createArrayFromMixed = _dereq_(134);
var getMarkupWrap = _dereq_(140);
var invariant = _dereq_(144);

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? "development" !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? "development" !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = createArrayFromMixed(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
},{"130":130,"134":134,"140":140,"144":144}],136:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],137:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

'use strict';

var emptyObject = {};

if ("development" !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
},{}],138:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],139:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
'use strict';

function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],140:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

/*eslint-disable fb-www/unsafe-html */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var invariant = _dereq_(144);

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? "development" !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
},{"130":130,"144":144}],141:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],142:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

'use strict';

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],143:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

'use strict';

var hyphenate = _dereq_(142);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"142":142}],144:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if ("development" !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],145:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
'use strict';

function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],146:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

'use strict';

var isNode = _dereq_(145);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"145":145}],147:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = _dereq_(144);

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function (obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? "development" !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
},{"144":144}],148:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without losing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
"use strict";

var keyOf = function (oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],149:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;
},{}],150:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],151:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = _dereq_(130);

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"130":130}],152:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

'use strict';

var performance = _dereq_(151);

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function () {
    return performance.now();
  };
} else {
  performanceNow = function () {
    return Date.now();
  };
}

module.exports = performanceNow;
},{"151":151}],153:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 * @typechecks
 * 
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],154:[function(_dereq_,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

'use strict';

var invariant = _dereq_(144);

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? "development" !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

  !(typeof length === 'number') ? "development" !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

  !(length === 0 || length - 1 in obj) ? "development" !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;
},{"144":144}],155:[function(_dereq_,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

'use strict';

var emptyFunction = _dereq_(136);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("development" !== 'production') {
  warning = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
},{"136":136}]},{},[1])(1)
});;/**
 * ReactDOM v0.14.7
 *
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
// Based off https://github.com/ForbesLindesay/umd/blob/master/template.js
;(function(f) {
  // CommonJS
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f(require('react'));

  // RequireJS
  } else if (typeof define === "function" && define.amd) {
    define(['react'], f);

  // <script>
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      // works providing we're not in "use strict";
      // needed for Java 8 Nashorn
      // see https://github.com/facebook/react/issues/3037
      g = this;
    }
    g.ReactDOM = f(g.React);
  }

})(function(React) {
  return React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
});
;var idd_codes = {"ne":"227","gg":null,"bd":"880","ki":"686","mm":"95","mc":"377","tr":"90","sj":null,"gl":"299","hn":"504","ug":"256","my":"60","nu":"683","ci":"225","ro":"40","tn":"216","dk":"45","nc":"687","co":"57","rw":"250","br":"55","aq":"672","bo":"591","cy":"357","st":"239","ck":"682","hm":null,"tc":"1649","bv":null,"ke":"254","mo":"853","ps":"970","gq":"240","ge":"995","dm":"1767","bf":"226","km":null,"ao":"244","af":"93","gr":"30","va":"379","ls":"266","mv":"960","tm":"993","is":"354","jm":"1876","mt":"356","pg":"675","ky":"1345","ga":"241","la":"856","gi":"350","bh":"973","ms":"1664","bt":"975","gb":"44","pn":"649","sv":"503","it":"39","wf":"681","mq":"596","sb":"677","hu":"36","za":"27","ly":"218","ng":"234","se":"46","gt":"502","uy":"598","ai":"1264","iq":"964","lu":"352","na":"264","ve":"58","pt":"351","il":"972","mh":"692","ba":"387","eg":"20","ph":"63","kg":"996","pf":"689","no":"47","um":null,"lv":"371","tf":null,"fr":"33","kz":"7","ma":"212","in":"91","id":"62","sr":"597","si":"386","re":null,"me":null,"om":"968","vg":"1284","by":"375","fi":"358","gs":null,"fj":"679","ir":"98","py":"595","pm":"508","sn":"221","li":"417","tz":"255","td":"235","sd":"249","cg":"242","pa":"507","au":"61","sl":"232","am":"374","tv":"688","gh":"233","us":"1","jo":"962","mr":"222","bi":"257","ee":"372","cd":"243","ye":"967","dz":"213","pk":"92","kn":"1869","cm":"237","bw":"267","mn":"976","lk":"94","gd":"1473","nz":"64","as":"684","ae":"971","lc":"1758","mg":"261","tk":"690","sc":"248","rs":"381","cn":"86","ru":null,"ag":"1268","mx":"52","cx":"618","sy":"963","cr":"506","vi":"1340","az":"994","ec":"593","sg":"65","kh":"855","mz":"258","bm":"1441","lb":"961","nr":"674","bz":"501","vu":"678","kw":"965","ml":"223","bj":"229","gf":"594","al":"355","mf":null,"uz":"998","pr":"1787","fk":"500","lr":"231","eh":"21","nf":null,"np":"977","do":"1809","ht":"509","mp":"1670","bs":"1242","gm":"220","mw":"265","to":"676","cu":"53","ch":"41","mu":"230","ni":"505","gu":"671","bg":"359","pw":"680","aw":"297","gy":"592","pl":"48","ca":null,"sk":"421","pe":"51","an":"599","ua":"380","ax":null,"gw":"245","es":"34","kr":"82","je":"441534","tt":"1868","fo":"298","yt":"269","cc":null,"kp":"850","bb":"1246","sh":"290","sa":"966","zm":"260","io":"246","th":"66","hk":"852","et":"251","ie":"353","so":"252","tl":"670","er":"291","tj":"992","cf":"236","im":"441624","cz":"420","mk":"389","lt":"370","de":"49","hr":"385","gn":"224","be":"32","qa":"974","vc":"1784","cv":"238","fm":"691","md":"373","jp":"81","cl":"56","tw":"886","ws":"685","ad":"376","sz":"268","bn":"673","at":"43","tg":"228","vn":"84","zw":"263","gp":"590","ar":"54","sm":"378","nl":"31","dj":"253","bl":null};;var texts_json = {};
texts_json['EN'] = {"[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"min"};
texts_json['ID'] = {"Accounts_And_Payments_Executive":"Akuntan Dan Eksekutif Pembayaran","Prices":"OHLC","Stop_Loss_Level":"Tingkat Stop Loss","Please_select":"Tolong pilih","This_contract_won":"Kontrak ini untung","Oil/EUR":"Minyak/EUR","Spot":"Posisi","US_Index":"Indeks AS","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Permintaan Anda untuk mentransfer [_1] [_2] dari [_3] ke [_4] berhasil diproses.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Anda telah menarik dana sebesar [_1] [_2] dalam tempo [_3] hari terakhir.","Payout":"Hasil","Period":"Masa","stays_between":"tetap antara","Verification_Token":"Token Verifikasi","Deposit_of":"Deposit dari","Wednesday":"Rabu","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Mewakili jumlah maksimum pembelian kontrak dalam satu hari trading.","Dubai_Index":"Indeks Dubai","month":"bulan","Minimum_of_[_1]_characters_required_":"Minimal [_1] karakter diperlukan.","Industry_of_Employment":"Industri Kerja","Human_Resource_Executive":"Eksekutif Sumber Daya Manusia","Opens":"Dibuka","Exit_Spot":"Spot akhir","Potential_Payout":"Potensi Hasil","Bull_Market_Index":"Indeks Bull Market ","Points":"Poin","Score":"Skor","touches":"menyentuh","Secondary":"Sekunder","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Batas penarikan Anda adalah [_1] [_2] (atau setara dengan mata uang lain).","Marketing_Executives":"Eksekutif Pemasaran","No_Live_price_update":"Tidak tersedia harga Live","Please_select_a_payment_agent":"Silahkan pilih agen pembayaran","Real_Account":"Akun Riil","Europe/Africa":"Eropa/Afrika","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Salinan scan dari tagihan utilitas atau rekening koran (tidak melebihi 3 bulan).","30-50_million_JPY":"30-50 juta JPY","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Kata sandi tambahan dapat digunakan untuk membatasi akses ke kasir.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Akun Anda telah terbukti dan batasan penarikan Anda telah dihapuskan.","GBP_Index":"Indeks GBP","Shenzhen_300_Index":"Indeks Shenzhen 300","Binary_options_or_other_financial_derivatives_trading_experience":"Opsi Binary atau pengalaman trading pada keuangan derivatif lainnya","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Kata sandi Anda sudah berhasil dibuat ulang. Silahkan akes akun Anda menggunakan kata sandi baru.","Less_than_$100,000":"Kurang dari $100,000","Upcoming_Events":"Acara Mendatang","minimum_available_duration":"durasi minimal yang tersedia","Now":"Sekarang","Construction":"Konstruksi","Norwegian_Index":"Indeks Norwegia","Korean_Index":"Indeks Korea","Number_of_ticks":"Jumlah tik","Save_as_PDF":"Simpan dalam PDF","Contract_Confirmation":"Konfirmasi Kontrak","numbers":"nomor","View_your_statement":"Lihat pernyataan Anda","Delete":"Hapus","Profit/Loss_(points)":"Untung/Rugi (poin)","3-5_million_JPY":"3-5 juta JPY","spread_down":"spread turun","AUD_Index":"Indeks AUD","Continuous_Indices":"Indeks Berterusan","Quality_Assurance_Engineer":"Insinyur Penjamin Kualitas","Information_Technology":"Teknologi Informasi","Quantitative_Developer":"Pengembang Kuantitatif","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"Saat ini kami tidak menerima pembukaan akun dari penduduk negara berikut.","Australian_Index":"Indeks Australia","0-5_transactions_in_the_past_12_months":"0-5 transaksi dalam 12 bulan terakhir","Start_time":"Waktu mulai","Americas":"Amerika","Japanese_Index":"Indeks Jepang","Salaried_Employee":"Gaji Karyawan","There_was_some_invalid_character_in_an_input_field_":"Terdapat beberapa karakter yang tidak berlaku pada kolom input.","Long":"Panjang","is_required__Current_spread":"dibutuhkan. Spread saat ini","Less_than_$25,000":"Kurang dari $25,000","Mr":"Bapak","Volatility_25_Index":"Indeks Volatilitas 25","1-2_years":"1-2 tahun","March":"Maret","(Bejing/CST_-8_hours)":"(Bejing/CST -8 jam)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] telah memperbarui [_2]. Dengan mengklik OK, berarti Anda sudah membaca dan menyetujui [_2] terbaru.","hyphen":"tanda penghubung","Smart_FX":"FX Smart","Invalid_amount,_maximum_is":"Jumlah tidak berlaku, maksimal","US_Smart_Index":"Indeks Smart AS","Week_of":"Minggu ke","Entry_Spot":"Spot entri","You_should_enter_between_[_1]_characters_":"Anda harus memasukkan antara [_1] karakter.","Nov":"Nop","spread_up":"spread naik","Contract_is_not_started_yet":"Kontrak belum dimulai","Indicative":"Indikatif","Dutch_Index":"Indeks Belanda","Volatility_100_Index":"Indeks Volatilitas 100","Metals":"Logam","We":"Kami","Please_enter_a_number_between_0_and_[_1]":"Silakan masukkan nomor antara 0 dan 1%","Quantitative_Analyst":"Analis Kuantitatif","Level_of_Education":"Tingkat Pendidikan","New_token_created_":"Token baru dibuat.","5-10_million_JPY":"5-10 juta JPY","Authorise_your_account_":"Otorisasi akun Anda.","Education":"Edukasi","Contract_Sold":"Kontrak Terjual","Gaming_Account":"Akun Trading","July":"Juli","June":"Juni","Thursday":"Kamis","Limit":"Batas","Smart_Indices":"Indeks Smart","Your_details_have_been_updated_":"Rincian Anda telah diperbarui.","Over_$1,000,000":"Lebih dari $1,000,000","Financial_Assessment":"Penilaian Keuangan","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Akun [_1] ini untuk sementara dibekukan, silahkan hubungi [_2].","Password_is_very_strong":"Kata sandi sangat kuat","USD_Index":"Indeks USD","1-3_years":"1-3 tahun","Both_the_above":"Keduanya diatas","password":"kata sandi","1-3_million_JPY":"1-3 juta JPY","Commodities_trading_frequency":"Frekuensi trading komoditas","Transfer_to":"Kirim ke","Price":"Harga","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Oleh karena itu jumlah maksimal yang dapat Anda cairkan langsung (jika saldo mencukupi) adalah [_1] [_2].","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Setelah mengklik 'Ok' Anda akan dikecualikan dari trading hingga tanggal yang dipilih.","ticks":"tik","Questions":"Pertanyaan","and":"dan","months":"bulan","Potential_Profit":"Potensi Hasil","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Layanan trading finansial yang disediakan pada situs ini hanya cocok untuk Pelanggan yang mampu menanggung kerugian pada semua modal yang mereka tanamkan dan bagi yang mengerti dan memiliki pengalaman tentang risiko yang akan dialami pada trading kontrak finansial. Kontrak transaksi finansial adalah memiliki risiko tinggi. Jika prediksi Anda tidak tepat maka anda akan kehilangan semua modal yang anda tanamkan berupa harga kontrak yang anda bayarkan.","Random":"Secara Acak","Sale_Date":"Tanggal Jual","Exercise_period":"Periode latihan","February":"Pebruari","Exclude_time_cannot_be_less_than_6_months_":"Waktu pengecualian tidak boleh kurang dari 6 bulan.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Batas penarikan [_1] hari Anda saat ini adalah [_2] [_3] (atau setara dengan mata uang lainnya).","Your_current_balance_is":"Saldo Anda saat ini","Singapore_Index":"Indeks Singapura","This_contract_lost":"Kontrak ini rugi","Duration":"Durasi","Indices_trading_frequency":"Frekuensi trading indeks","Other_financial_instruments_trading_frequency":"Frekuensi trading instrumen keuangan lainnya","Password_is_strong":"Kata sandi kuat","EUR_Index":"Indeks EUR","Stop_Profit_Level":"Tingkat Stop Profit","Try_adding_more_letters_":"Coba tambahkan lebih huruf.","Egypt_Index":"Indeks Egypt","Net_profit":"Laba bersih","Verification_code_format_incorrect_":"Format kode verifikasi salah.","There_was_a_problem_accessing_the_server_during_purchase_":"Terjadi masalah mengakses server saat pembelian berlangsung.","Adjust_trade_parameters":"Menyesuaikan parameter trading","Dutch_Stocks":"Saham Belanda","Over_$500,001":"Lebih $500,001","Th":"Kam","Oct":"Oktober","Barrier_offset":"Diluar Batasan","This_feature_is_not_relevant_to_virtual-money_accounts_":"Fasilitas ini tidak tersedia untuk akun uang virtual.","Password_should_have_lower_and_uppercase_letters_with_numbers_":"Kata sandi harus memiliki huruf kecil dan besar beserta angka.","Next_Day":"Hari Berikutnya","Step":"Langkah","Applications":"Aplikasi","Save_as_CSV":"Simpan dalam CSV","Mo":"Sen","Loss":"Rugi","Other":"Lainnya","Health":"Kesehatan","Dutch_Smart_Index":"Indeks Smart Belanda","Tick":"Tik","letters":"huruf","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Statistik digit terakhir untuk [_1] tik pada [_2]","Energy":"Energi","Over_3_years":"Lebih dari 3 tahun","From":"Dari","does_not_touch":"tidak menyentuh","hour":"jam","View":"Lihat","Sorry,_an_error_occurred_while_processing_your_account_":"Maaf, error terjadi ketika memproses rekening Anda.","An_error_occured_":"Terjadi error.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Maka dengan itu jumlah maksimal yang dapat Anda tarik (tergantung pada saldo tunai yang tersedia) adalah [_1] [_2] (atau setara dengan mata uang lainnya).","Russian_10_Index":"Indeks Rusia 10","New_Password":"Kata Sandi Baru","Trading_Limits":"Batasan Trading","German_Smart_Index":"Indeks Smart Jerman","Details":"Rincian","Login_History":"Catatan Login","Invalid_amount,_minimum_is":"Jumlah tidak berlaku, minimal","minute":"menit","Please_deposit_before_transfer_to_client_":"Silahkan deposit sebelum melakukan transfer ke klien.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Silahkan ikuti pola 3 angka, garis, diikuti oleh 4 angka.","Password_Reset":"Merubah Kata Sandi","August":"Agustus","Maximum_account_cash_balance":"Maksimum saldo tunai","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Akun Anda telah terbukti. Anda dapat melihat batasan trading [_1] Anda disini","Bombay_Index":"Bombay Indeks","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Pastikan Anda telah memilih Agen Pembayaran yang benar, salah transfer adalah diluar tanggungjawab kami:","Euro_50_Smart_Index":"Indeks Smart Euro 50","US_Tech_Composite_Index":"Indeks Gabungan Tech US","Lock_Cashier":"Kunci Kasir","Sa":"Sab","seconds":"detik","apostrophe":"apostrof","Select_your_market":"Pilih market anda","Canadian_Index":"Indeks Kanada","Finish":"Selesai","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"Kata sandi harus mengandung minimal 1 angka, 1 huruf besar dan 1 huruf kecil.","False":"Salah","Human_Resources":"Sumber Daya Manusia","Mrs":"Ibu","Purchase":"Beli","Profit_Table":"Tabel Laba Rugi","Tourism":"Pariwisata","10-30_million_JPY":"10-30 juta JPY","Shenzhen_Index":"Indeks Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Kasir Anda terkunci sesuai permintaan Anda - untuk membuka kunci, masukkan kata sandi.","Invalid_email_address":"Invalid alamat email","Please_enter_an_integer_value":"Silahkan masukan nilai penuh","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Maaf, fasilitas ini hanya tersedia untuk rekening virtual saja.","Investment_Account":"Akun Investasi","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Anda tidak dibenarkan menarik dana menggunakan agen pembayaran.","Quantitative_Analysis":"Analisis Kuantitatif","Miss":"Nona","Wall_Street_Smart_Index":"Indeks Smart Wall Street","Please_check_your_email_for_the_value_of_this_token":"Silahkan cek email Anda untuk melihat token ini","Forex_trading_experience":"Pengalaman trading forex","Amount":"Jumlah","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Jumlah maksimum token ([_1]) telah tercapai.","Global_Customer_Service_Representatives":"Perwakilan Customer Service Global","Print_chart":"Cetak grafik","Please_try_again_":"Silahkan coba kembali.","Withdrawal_Limits":"Batas Penarikan","Your_transaction_reference_is":"Referensi transaksi Anda adalah","Compliance":"Kepatuhan","Save_as_SVG":"Simpan dalam SVG","You_have_already_withdrawn_[_1]_[_2]_":"Anda telah menarik dana sebesar [_1] [_2].","Profit/Loss":"Untung/Rugi","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Silahkan isi Login ID dan jumlah yang ingin Anda transfer ke klien Anda dalam formulir di bawah ini:","Password_does_not_match_":"Kata sandi tidak cocok.","Commodities":"Komoditi","Transfer_to_Login_ID":"Transfer ke Login ID","Update":"Memperbarui","Fr":"Jum","Volatility_75_Index":"Indeks Volatilitas 75","goes_outside":"bergerak keluar","High_Barrier":"Batasan Tinggi","Chart":"Grafik","Date_of_Birth":"Tanggal Lahir","space":"ruang","Portuguese_Smart_Index":"Indeks Smart Portugis","Saturday":"Sabtu","Never_Used":"Tidak pernah dipakai","Volatility_50_Index":"Indeks Volatilitas 50","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Mewakili jumlah maksimum hasil kontrak pada portopolio Anda. Jika jumlah maksimum tercapai maka Anda tidak dapat membeli kontrak baru tanpa menyelesaikan salah satu posisi Anda.","Description":"Deskripsi","Sell":"Jual","Abu_Dhabi_Index":"Indeks Abu Dhabi","Euro_50_Index":"Indeks Euro 50","October":"Oktober","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Saat ini Anda sedang mengakses akun uang riil pada [_1] ([_2]).","Only_2_decimal_points_are_allowed_":"Hanya 2 poin desimal diperbolehkan.","Terms_&_Conditions":"Syarat & Ketentuan","period":"periode","Password_score_is:_[_1]__Passing_score_is:_20_":"Skor kata sandi: [_1]. Skor lulus adalah: 20.","Note":"Catatan","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Mewakili jumlah kontrak pada portopolio Anda. Setiap baris pada portopolio Anda dihitung sebagai satu posisi. Jika jumlah maksimum tercapai maka Anda perlu menutup salah satu posisi untuk membeli kontrak atau posisi lainnya.","Italian_30_Index":"Indeks Italia 30","Password_is_not_strong_enough_":"Kata sandi tidak cukup kuat.","Asset":"Aset","Duerr_AG":"Drr AG","Swiss_Smart_Index":"Indeks Smart Swis","0-1_year":"0-1 tahun","Contract_Information":"Informasi Kontrak","Translator":"Penterjemah","Hong_Kong_Index":"Indeks Hong Kong","Sorry,_account_opening_is_unavailable_":"Maaf, pembukaan akun tidak tersedia.","Anti-Fraud_Officer":"Petugas Anti-Penipuan","Barrier":"Batasan","Password_is_moderate":"Kata sandi moderat","Current_Level":"Tingkat Terkini","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Klien Anda akan menerima e-mail pemberitahuan bahwa transfer mereka telah diproses.","Failed_to_reset_password__[_1],_please_retry_":"Gagal untuk mereset kata sandi. [_1], silahkan coba lagi.","Low_Barrier":"Batasan Rendah","Previous_Day":"Hari Sebelumnya","Tu":"Kam","IP_Address":"Alamat IP","Sale_Price":"Harga Jual","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Masukan batasan yang merupakan selisih harga spot. Jika Anda memasukan +0.005, maka Anda akan membeli kontrak dengan batasan 0.005 lebih tinggi dari spot masuk. Spot masuk adalah tik setelah kontrak Anda diproses","Short":"Pendek","Social_Media_Executive":"Social Media Eksekutif","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Mohon konfirmasikan kontrak pada bagian pernyataan sebelum melanjutkan.","Reset_Password":"Ulang Kata Sandi","Year":"Tahun","Other_financial_instruments_trading_experience":"Pengalaman trading instrumen keuangan lainnya","Purchase_Time":"Waktu Beli","Forex_trading_frequency":"Frekuensi trading forex","Day":"Hari","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Salinan scan dari paspor, SIM atau KTP, yang memperlihatkan nama dan tanggal lahir Anda.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Permohonan penarikan Anda [_1] [_2] dari account [_3] ke Agen Pembayaran [_4] telah diproses.","Old_password_is_wrong_":"Kata sandi lama salah.","Trading_and_Withdrawal_Limits":"Batasan Penarikan","Housewife_/_Househusband":"Ibu Rumah Tangga / Kepala Rumah Tangga","High_barrier_offset":"Batasan offset tinggi","Aug":"Agustus","Are_you_sure_that_you_want_to_permanently_delete_token":"Apakah Anda yakin untuk menghapus token secara permanen","Open":"Awal","KBC_Groep":"KBC Group","ends_outside":"berakhir di luar","You_did_not_change_anything_":"Anda tidak melakukan perubahan.","{JAPAN_ONLY}Even_if_the_option_is_exercise_or_not_exercised,_the_original_option_premium_remains_with_the_option_seller_":"{JAPAN ONLY}If the buyer of an option does not exercise the option rights, there will be no fee payable to the option seller.","Russian_Regular_Index":"Indeks Reguler Rusia","Feb":"Peb","The_two_passwords_that_you_entered_do_not_match_":"Kedua-dua password yang Anda masukkan tidak cocok.","Failed":"Gagal","You_have_not_granted_access_to_any_apps_":"Anda belum memperoleh akses ke dalam aplikasi.","Return":"Laba","This_field_is_required_":"Bagian ini diperlukan.","Marketing":"Pemasaran","Tertiary":"Tersier","Swiss_Index":"Indeks Swis","Indices_trading_experience":"Pengalaman trading indeks","6-10_transactions_in_the_past_12_months":"6-10 transaksi pada 12 bulan terakhir","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Setelah mengklik tombol 'Kirim', dana akan ditarik dari akun Anda dan ditransfer ke dalam akun Klien Anda.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"min","True":"Benar","day":"hari","Save_as_JPEG":"Simpan dalam JPEG","Internal_Audit":"Audit Internal","hours":"jam","Income_Source":"Sumber Penghasilan","second":"detik","Euro_100_Index":"Indeks Euro 100","Date":"Tanggal","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Anda telah melakukan penarikan setara dengan [_1] [_2].","Belgian_Stocks":"Saham Belgia","Waiting_for_entry_tick_":"Menunggu tik masuk...","lower":"lebih rendah","Country_Manager":"Country Manajer","Confirm_New_Password":"Konfirmasi Kata Sandi Baru","Select_your_underlying_asset":"Pilih aset dasar Anda","Last_Digit_Prediction":"Analisa Digit Terakhir","Try_adding_more_letters_or_numbers_":"Coba tambahkan lebih huruf atau angka.","US_Tech_100_Index":"Indeks US 100 Tech","Purchase_Price":"Harga Beli","Jakarta_Index":"Indeks Jakarta","UK_Smart_Index":"Indeks Smart Inggris","days":"hari","Never":"Tidak pernah","Name":"Nama","Save_as_PNG":"Simpan dalam PNG","New_Zealand_Index":"Indeks Selandia Baru","Su":"Mgg","Major_Pairs":"Pasangan Utama","Please_enter_a_number_between_[_1]_":"Silakan masukkan nomor antara [_1].","Marketing_Project_Manager":"Manajer Proyek Pemasaran","Jump_To":"Lompat Ke","loading___":"pemuatan...","Accounting":"Akuntansi","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Setelah mengklik \"Ok\" Anda akan dikecualikan dari trading hingga tanggal yang dipilih.","French_Index":"Indeks Perancis","Spot_Time":"Waktu Spot","Closes":"Ditutup","To":"Kepada","Reference_ID":"ID referensi","Istanbul_Index":"Indeks Istanbul","Administrative_Executive":"Eksekutif Administrasi","Tuesday":"Selasa","Sorry,_this_feature_is_not_available_":"Maaf, fasilitas ini tidak tersedia.","High_barrier":"Batasan Tinggi","Select_market":"Pilih pasar","Closed":"Tutup","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Anda harus menyetujui syarat dan ketentuan untuk mendaftar akun.","50-100_million_JPY":"50-100 juta JPY","Dec":"Des","Portuguese_Index":"Indeks Portugis","higher":"lebih tinggi","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Tambahkan Deposit [_1] [_2] dana virtual kedalam akun [_3] Anda","Monday":"Senin","Current":"Saat ini","Predict_the_direction<br_/>and_purchase":"Analisa arah<br />dan beli","Self-Employed":"Wirausaha","Oil/AUD":"Minyak/AUD","Estimated_Net_Worth":"Estimasi Nilai Bersih","Binary_options_or_other_financial_derivatives_trading_frequency":"Opsi Binary atau frekuensi trading keuangan derivatif lainnya","Action":"Aksi","French_Smart_Index":"Indeks Smart Perancis","Ford_Motor_Comapny":"Ford Motor Company","comma":"koma","minutes":"menit","Last_Used":"Terakhir digunakan","Indian_50_Index":"Indeks India 50","Oil/GBP":"Minyak/GBP","Wall_Street_Index":"Indeks Wall Street","Kuwait_Index":"Indeks Kuwait","This_contract_has_LOST":"Kontrak ini telah RUGI","Net_Annual_Income":"Penghasilan Bersih Tahunan","Previous":"Sebelumnya","40_transactions_or_more_in_the_past_12_months":"40 transaksi atau lebih pada 12 bulan terakhir","Investments_&_Dividends":"Investasi & Dividen","Euro_150_Index":"Indeks Euro 150","Your_withdrawal_limit_is_[_1]_[_2]_":"Batas penarikan Anda adalah [_1] [_2].","Failed_to_update_trade_description_":"Gagal memperbarui deskripsi kontrak.","Stocks_trading_frequency":"Frekuensi trading saham","Please_enter_a_number_greater_or_equal_to_[_1]_":"Masukkan angka lebih besar atau sama dengan [_1].","Bear_Market_Index":"Indeks Market Bear","Stocks":"Saham","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"Fasilitas Agen Pembayaran tidak tersedia pada negara anda.","Buy":"Beli","not_available":"tidak tersedia","Next":"Lanjutkan","Exclude_time_cannot_be_for_more_than_5_years_":"Waktu pengecualian tidak dapat melebihi 5 tahun.","Friday":"Jum'at","Your_account_has_no_trading_activity_":"Akun Anda tidak memiliki aktifitas trading.","Your_trading_statistics_since_[_1]_":"Statistik trading Anda sejak [_1].","Your_settings_have_been_updated_successfully_":"Pengaturan Anda telah sukses diperbarui.","Your_password_cannot_be_the_same_as_your_email":"Kata sandi tidak boleh sama dengan alamat email","Please_select_a_valid_date":"Silahkan pilih tanggal","Walkthrough_Guide":"Panduan Langsung","verification_token":"token verifikasi","Shanghai_Index":"Indeks Shanghai","points":"nilai","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Untuk membuktikan identitas Anda, silakan email hal berikut ini ke [_1]","December":"Desember","Contract_Expiry":"Kontrak berakhir","Quality_Assurance":"Jaminan Kualitas","Primary":"Primer","Revoke_access":"Mencabut akses","Try_adding_more_numbers_":"Coba tambahkan angka.","Saudi_Arabia_Index":"Indeks Arab Saudi","Password_is_weak":"Kata sandi lemah","Stake":"Modal","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Saat ini Anda sedang mengakses akun uang virtual ([_2]).","Amount_per_point":"Jumlah per poin","Date_and_Time":"Tanggal dan Waktu","Total_Profit/Loss":"Total Untung/Rugi","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Mewakili jumlah maksimum saldo tunai pada akun anda. Jika jumlah maksimum tercapai, maka anda perlu menarik dana anda.","Sorry,_an_error_occurred_while_processing_your_request_":"Maaf, error terjadi ketika memproses permohonan Anda.","Jun":"Juni","Confirm":"Lanjutkan","Back":"Kembali","Balance":"Saldo","Statement":"Pernyataan","Contract_/_Temporary_/_Part_Time":"Kontrak / Sementara / Paruh Waktu","ends_between":"berakhir antara","Select_your_trade_type":"Pilih jenis kontrak Anda","Your_account_has_no_Login/Logout_activity_":"Akun Anda tidak memiliki aktifitas Login/Logout.","Japanese_Smart_Index":"Indeks Smart Jepang","Exit_Spot_Time":"Waktu Exit Spot","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Kami tidak dapat memberikan striming harga live untuk saat ini. Untuk menikmati striming harga live silahkan coba merefresh halaman, atau coba browser lain","Low_barrier":"Batasan rendah","Commodities_trading_experience":"Pengalaman trading komoditas","Minor_Pairs":"Pasangan Ringan","Spreads":"Spread","Contract_ID":"ID Kontrak","Only_[_1]_are_allowed_":"Hanya [_1] dibenarkan.","Virtual_Account":"Akun Virtual","Our_site_does_not_charge_any_transfer_fees_":"Situs kami tidak membebankan biaya transfer.","Daily_Reset_Indices":"Indeks Reset Harian","French_Stocks":"Saham Perancis","Please_input_a_valid_date":"Masukkan tanggal yang benar","Sunday":"Minggu","years":"tahun","Explanation":"Penjelasan","This_contract_has_WON":"Kontrak ini telah UNTUNG","Please_wait_<br_/>Your_request_is_being_processed_":"Silahkan tunggu.<br />Permohonan Anda sedang diproses.","Irish_Index":"Indeks Irlandia","6_months_to_1_year":"6 bulan hingga 1 tahun","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Akun [_1] ini untuk sementara dibekukan, silahkan hubungi [_2].","Volatility_Indices":"Indeks Volatilitas","Belgian_Index":"Indeks Belgia","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Token Anda telah berakhir. Silahkan klik <a class=\"pjaxload\" href=\"[_1]\">disini</a> untuk memulai kembali proses verifikasi.","Remaining_Time":"Waktu Yang Tersisa","January":"Januari","Your_transaction_reference_number_is_[_1]":"Nomor referensi transaksi Anda adalah [_1]","There_was_an_error":"Terdapat error","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Format: tahun-bulan-tanggal (tidak diperlukan untuk akun uang virtual)","Maximum_number_of_open_positions":"Maksimal jumlah posisi terbuka","Start_Time":"Waktu Mulai","Exit_Level":"Tingkat Keluar","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] telah dikreditkan kedalam akun uang virtual Anda [_3]","Please_submit_a_valid_[_1]_":"Silakan kirim [_1] yang berlaku.","Session_duration_limit_cannot_be_more_than_6_weeks_":"Batas durasi sesi tidak dapat lebih dari 6 minggu.","Indices":"Indeks","Maximum_aggregate_payouts_on_open_positions":"Jumlah maksimal hasil rata-rata pada posisi terbuka","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"Kontrak akan dijual pada harga pasar terkini ketika permintaan diterima oleh server kami. Harga ini mungkin berbeda dari harga yang diindikasikan.","Credit/Debit":"Kredit/Debit","End_Time":"Waktu berakhir","There_was_a_problem_accessing_the_server_":"Terjadi masalah pada saat mengakses server.","year":"tahun","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Silahkan periksa email Anda untuk memperoleh token diperlukan untuk mereset kata sandi Anda.","German_Index":"Indeks Jerman","Finance":"Keuangan","Brazilian_Index":"Indeks Brasil","Graphic_Designers":"Desainer Grafis","November":"Nopember","Contract":"Kontrak","South_African_Index":"Indeks Afrika Selatan","Keep_track_of_your_authorised_applications_":"Melacak aplikasi resmi Anda.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Masukkan tanggal setidaknya 6 bulan dari sekarang.","Please_enter_a_valid_amount_":"Tolong masukan jumlah yang benar.","Your_changes_have_been_updated_":"Perubahan Anda telah diperbarui.","Ms":"Sdri.","May":"Mei","Profit":"Keuntungan","Exclude_time_must_be_after_today_":"Waktu pengecualian harus setelah hari ini.","Total_Cost":"Total Biaya","Invalid_date_of_birth_":"Tanggal lahir salah.","Sell_at_market":"Jual pada pasar","Date_(GMT)":"Tanggal (GMT)","Maximum_daily_turnover":"Maksimum turnover harian","You_have_sold_this_contract_at_[_1]_[_2]":"Anda telah menjual kontrak pada [_1] [_2]","3-5_years":"3-5 tahun","Foreign_currency_deposit":"Deposito valuta asing","Last_Digit_Stats":"Statistik Digit Terakhir","Permissions":"Izin","Settles":"Diselesaikan","Compliance_Executive":"Eksekutif Compliance","Stocks_trading_experience":"Pengalaman trading saham","Item":"Bagian","Month":"Bulan","Successful":"Berhasil","Unlock_Cashier":"Buka Kasir","Middle_East":"Timur Tengah","Low_barrier_offset":"Batasan offset rendah","Proofreader":"Korektor","Pension":"Pensiun"};
texts_json['RU'] = {"Accounts_And_Payments_Executive":"Администратор счетов и выплат","Prices":"Котировки","Stop_Loss_Level":"Уровень стоп-лосс","Please_select":"Выберите","This_contract_won":"Контракт выиграл","Oil/EUR":"Нефть/EUR","Spot":"Спот-котировка","US_Index":"Амер. индекс","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Ваш запрос на перевод [_1] [_2] с [_3] на [_4] был выполнен успешно.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Вы уже в целом вывели сумму, эквивалентную [_1] [_2] за последние [_3] суток.","Payout":"Выплата","Period":"Период","stays_between":"останется между","Verification_Token":"Проверочный токен","Deposit_of":"Пополнение в размере","odd":"нечётное число","Wednesday":"Среда","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Представляет собой максимальный объём контрактов, который Вы можете приобрести в течение любого торгового дня.","Dubai_Index":"Дубайский индекс","month":"мес.","Minimum_of_[_1]_characters_required_":"Необходимо минимум [_1] знака(ов).","In/Out":"Внутри/Вне","Industry_of_Employment":"Индустрия занятости","Human_Resource_Executive":"Глава отдела кадров","Opens":"Открывается","Exit_Spot":"Выходная котировка","Potential_Payout":"Потенциальная выплата","Bull_Market_Index":"Индекс восходящего рынка","Points":"Пункты","Gold/AUD":"Золото/AUD","touches":"коснется","Secondary":"Вторичн.","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Ваш лимит на вывод составляет [_1] [_2] (или эквивалентную сумму в другой валюте).","Marketing_Executives":"Главы отдела маркетинга","No_Live_price_update":"Нет обновления настоящей котировки","Please_select_a_payment_agent":"Пожалуйста, выберите платежного агента","Real_Account":"Реальный счет","Europe/Africa":"Европа/Африка","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Отсканированная копия счета за коммунальные услуги или выписка из банка с адресом (датированные не ранее, чем 3 последние месяца).","Ok":"ОК","Spanish_Index":"Испанский индекс","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Можно использовать дополнительный пароль для ограничения доступа к кассе.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Ваш счет полностью авторизован, и лимит на вывод был снят.","Swedish_Index":"Шведский индекс","GBP_Index":"GBP индекс","Shenzhen_300_Index":"Shenzhen 300 индекс","Binary_options_or_other_financial_derivatives_trading_experience":"Опыт торговли бинарными опционами или другими производными финансовыми инструментами","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Ваш пароль был изменен. Пожалуйста, зайдите на счет, используя новый пароль.","Less_than_$100,000":"Менее $100,000","Jul":"Июл","Upcoming_Events":"Приближающиеся события","minimum_available_duration":"мин. доступный период","Gold/EUR":"Золото/EUR","Now":"Сейчас","Construction":"Строительство","Norwegian_Index":"Норвежский индекс","Korean_Index":"Корейский индекс","Number_of_ticks":"Кол-во тиков","asian_up":"азиатские вверх","Entry_Level":"Уровень входа","Asians":"Азиатские","September":"Сентябрь","Save_as_PDF":"Сохранить в формате PDF","Contract_Confirmation":"Подтверждение контракта","numbers":"цифры","View_your_statement":"Смотрите свою историю счета","Delete":"Удалить","Profit/Loss_(points)":"Прибыль/убытки (пункты)","spread_down":"спред вниз","AUD_Index":"AUD индекс","Continuous_Indices":"Непрерывные индексы","Quality_Assurance_Engineer":"Инженер службы тех. контроля","Information_Technology":"Информацион. технологии","Digits":"Цифров.","Quantitative_Developer":"Количественный разработчик","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"В настоящее время мы не открываем счета для резидентов этой страны.","Browser":"Браузер","Australian_Index":"Австралийский индекс","Login_ID":"Логин","0-5_transactions_in_the_past_12_months":"0-5 транзакций за последние 12 месяцев","Start_time":"Время начала","Americas":"Америка","Japanese_Index":"Японский индекс","Salaried_Employee":"Наемный работник","There_was_some_invalid_character_in_an_input_field_":"Неразрешённый символ в поле ввода.","matches":"Совпадет","Long":"Длинная позиция","is_required__Current_spread":"необходим. Текущий спред","Less_than_$25,000":"Менее $25,000","Mr":"Господин","Volatility_25_Index":"Индекс волатильности 25","1-2_years":"1-2 года","March":"Март","(Bejing/CST_-8_hours)":"(Пекин/CST -8 часов)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] обновил [_2]. Нажав OK, Вы подтвердите, что прочитали и приняли новые [_2].","hyphen":"дефис","Invalid_amount,_maximum_is":"Неправильная сумма. Максимум:","US_Smart_Index":"США Smart-индексы","Week_of":"Нед.","Entry_Spot":"Входная котировка","You_should_enter_between_[_1]_characters_":"Вы должны ввести [_1] знаков.","Nov":"Ноя","Ref_":"Номер","spread_up":"спред вверх","Contract_is_not_started_yet":"Контракт ещё не начался","Indicative":"Временная цена","Dutch_Index":"Голландский индекс","Volatility_100_Index":"Индекс волатильности 100","Metals":"Металлы","We":"Ср","Please_enter_a_number_between_0_and_[_1]":"Пожалуйста, введите цифру от 0 до [_1]","Quantitative_Analyst":"Специалист по количественному анализу","Level_of_Education":"Уровень образования","New_token_created_":"Создан новый токен.","even":"чётное число","Authorise_your_account_":"Авторизуйте свой счет.","Education":"Обучение","Contract_Sold":"Контракт продан","Gaming_Account":"Игровой счет","July":"Июль","June":"Июнь","Thursday":"Четверг","Limit":"Лимит","Smart_Indices":"Smart-индексы","Your_details_have_been_updated_":"Ваши данные успешно обновлены.","Over_$1,000,000":"Свыше $1,000,000","Financial_Assessment":"Финансовая отчетность","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Ваш счет [_1] в данный момент недоступен. Пожалуйста, свяжитесь со следующим отделом: [_2].","Password_is_very_strong":"Очень надёжный пароль","USD_Index":"USD индекс","password":"пароль","Stop-type":"Тип стопа","Commodities_trading_frequency":"Частота торговли сырьевыми товарами","Transfer_to":"Перевести на имя","Price":"Цена","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Следовательно, Ваш максимальный лимит на вывод на данный момент составляет [_1] [_2].","ticks":"тиков","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Когда Вы нажмёте \"ОК\", Вы будете отстранены от работы на сайте до окончания выбранной даты.","Questions":"Вопросы","and":"и","Apr":"Апр","months":"мес.","Potential_Profit":"Потенциальная прибыль","over":"больше","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Услуги финансового трейдинга на данном сайте предоставляются только клиентам, которые готовы к возможной потере всех инвестированных ими средств и осознают риск, связанный с приобретением финансовых контрактов. Транзакции в рамках финансовых контрактов подразумевают высокую степень риска. Если купленный контракт истекает без выплаты, Вы теряете всю сумму, потраченную на приобретение данного контракта.","Random":"Индексы Random","Sale_Date":"Дата продажи","Nocturnes":"Ночные","Exercise_period":"Период исполнения","February":"Февраль","Exclude_time_cannot_be_less_than_6_months_":"Период ограничения не может быть менее 6 месяцев.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Ваш дневной [_1] лимит на вывод в настоящее время составляет [_2] [_3] (или эквивалентную сумму в другой валюте).","Copywriter":"Автор статей","Incyte_Corpoartion":"Incyte Corporation","Your_current_balance_is":"Текущий баланс Вашего счета составляет","Singapore_Index":"Сингапурский индекс","Duration":"Продолжительность","This_contract_lost":"Контракт проиграл","Indices_trading_frequency":"Частота торговли индексами","Other_financial_instruments_trading_frequency":"Частота торговли другими финансовыми инструментами","Password_is_strong":"Надёжный пароль","EUR_Index":"EUR индекс","Stop_Profit_Level":"Уровень стоп-профит","Try_adding_more_letters_":"Попробуйте добавить больше букв.","Egypt_Index":"Египетский индекс","Net_profit":"Чистая прибыль","Status":"Статус","Verification_code_format_incorrect_":"Неправильный формат кода проверки личности.","There_was_a_problem_accessing_the_server_during_purchase_":"Возникла проблема с доступом к серверу во время процесса покупки.","Adjust_trade_parameters":"Изменить параметры контракта","Dutch_Stocks":"Голландские акции","Over_$500,001":"Более $500,001","Th":"Чт","Oct":"Окт","Even/Odd":"Чётное/Нечётное","Barrier_offset":"Изменение барьера","This_feature_is_not_relevant_to_virtual-money_accounts_":"Данная функция недоступна на демо-счетах.","Gold/USD":"Золото/USD","Password_should_have_lower_and_uppercase_letters_with_numbers_":"Пароль должен содержать заглавные и строчные буквы и цифры.","Step":"Изменение","Next_Day":"Следующий день","Applications":"Приложения","Save_as_CSV":"Сохранить в формате CSV","Internal_Auditor":"Внутренний аудитор","Loss":"Потери","Mo":"Пн","Other":"Другое","Health":"Здоровье","Dutch_Smart_Index":"Голландский Smart индекс","Tick":"Тики","letters":"буквы","under":"меньше","Silver/USD":"Серебро/USD","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Последняя десятичная начинается для последних [_1] тиков для [_2]","Energy":"Энергия","Over_3_years":"В течение 3 лет","From":"от","does_not_touch":"не коснется","hour":"час.","View":"Просмотр","Sorry,_an_error_occurred_while_processing_your_account_":"Извините, произошла ошибка.","An_error_occured_":"Произошла ошибка.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Поэтому максимально возможная сумма к выводу на данный момент (если на счету есть средства) составляет [_1] [_2] (или эквивалентную сумму в другой валюте).","Russian_10_Index":"Russia 10 индекс","New_Password":"Новый пароль","Trading_Limits":"Торговые лимиты","German_Smart_Index":"Немецкий Smart индекс","Details":"Подробности","Login_History":"История входа в систему","Invalid_amount,_minimum_is":"Неправильная сумма. Минимум:","minute":"минут(ы)","Please_deposit_before_transfer_to_client_":"Пожалуйста, пополните счёт перед переводом клиенту.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Пожалуйста, следуйте данной схеме: 3 цифры, тире, а затем 4 цифры.","Password_Reset":"Изменение пароля","Maximum_account_cash_balance":"Максимальный баланс на счету","August":"Август","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Ваш счет полностью авторизован. Вы можете посмотреть свои торговые лимиты [_1] здесь","Bombay_Index":"Бомбейский индекс","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Просим подтвердить данные транзакции для завершения перевода:","Euro_50_Smart_Index":"Euro 50 Smart индекс","Lock_Cashier":"Закрыть кассу паролем","Sa":"Сб","seconds":"секунд(ы)","Matches/Differs":"Совпадение/отличие","Select_your_market":"Выбрать рынок","apostrophe":"апостроф","Canadian_Index":"Канад. индекс","Finish":"Завершить","Gold/GBP":"Золото/GBP","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"Пароль должен содержать минимум 1 цифру, 1 заглавную букву и 1 строчную букву.","Oil/USD":"Нефть/USD","Up/Down":"Вверх/Вниз","Human_Resources":"Отдел кадров","Mrs":"Госпожа","Profit_Table":"Анализ счета","Purchase":"Покупка","Tourism":"Туризм","Shenzhen_Index":"Шеньчженьский индекс","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Ваша касса закрыта по Вашему запросу - для открытия, пожалуйста, внесите пароль.","Invalid_email_address":"Недействительный e-mail","Please_enter_an_integer_value":"Пожалуйста, введите целое число","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Извините, эта опция доступна только для демо-счетов.","Investment_Account":"Инвестиционный счет","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Вы не можете выводить средства через платежного агента.","Quantitative_Analysis":"Количественный анализ","Miss":"Госпожа","Wall_Street_Smart_Index":"Wall Street Smart индекс","Please_check_your_email_for_the_value_of_this_token":"Пожалуйста, проверьте свой email; Вам должен прийти токен","Forex_trading_experience":"Опыт торговли на Форекс","Amount":"Количество","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Достигнуто максимальное число токенов ([_1]).","Global_Customer_Service_Representatives":"Сотрудники мирового отдела обслуживания клиентов","Withdrawal_Limits":"Лимиты на вывод","Print_chart":"Напечатать график","Please_try_again_":"Пожалуйста, попробуйте снова.","Your_transaction_reference_is":"Ссылка на Вашу сделку","Compliance":"Регулирование и контроль","Save_as_SVG":"Сохранить в формате SVG","You_have_already_withdrawn_[_1]_[_2]_":"Вы уже вывели со счета [_1] [_2].","Profit/Loss":"Плюс/Минус","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Просим указать логин и сумму, которую Вы желаете перевести Клиенту, в форме ниже:","Password_does_not_match_":"Пароль не совпадает.","Commodities":"Сырьевые товары","Transfer_to_Login_ID":"Перевести на логин","Update":"Обновить","Fr":"Пт","Volatility_75_Index":"Индекс волатильности 75","goes_outside":"выйдет за пределы","Chart":"График","High_Barrier":"Высший Барьер","Date_of_Birth":"Дата рождения","space":"пробел","Portuguese_Smart_Index":"Португальский Smart индекс","Saturday":"Суббота","Never_Used":"Никогда не использовался","Volatility_50_Index":"Индекс волатильности 50","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Представляет общую максимальную сумму выплат по открытым ставкам в Вашем портфолио. Когда будет достигнута максимальная сумма, Вы не сможете приобретать новые контракты без закрытия действующих.","Description":"Описание","Sell":"Продажа","Abu_Dhabi_Index":"Индекс Абу-Даби","October":"Октябрь","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Сейчас Вы находитесь на своем реальном счету на [_1] ([_2]).","Terms_&_Conditions":"Правила и условия","Only_2_decimal_points_are_allowed_":"Разрешены лишь 2 десятичные.","period":"период","Password_score_is:_[_1]__Passing_score_is:_20_":"Сложность пароля: [_1]. Проходной балл: 20.","Stays_In/Goes_Out":"Останется Внутри/Выйдет за пределы","Note":"Примечание","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Представляет собой максимальное количество открытых контрактов в Вашем портфолио. Каждая линия в Вашем портфолио считается как открытая позиция. Когда Вы достигаете лимита, Вы не можете создавать новые контракты, пока не закроете существующие.","Italian_30_Index":"Итальянский индекс 30","Password_is_not_strong_enough_":"Пароль недостаточно надёжный.","Asset":"Актив","Swiss_Smart_Index":"Швейцарский Smart индекс","0-1_year":"0-1 года","Contract_Information":"Детали контракта","Translator":"Переводчик","Hong_Kong_Index":"Гонконгский индекс","Sorry,_account_opening_is_unavailable_":"Извините, но открытие счёта недоступно.","Anti-Fraud_Officer":"Специалист по борьбе с мошенничеством","Barrier":"Барьер","Current_Level":"Текущий уровень","Password_is_moderate":"Средний уровень защиты пароля","Failed_to_reset_password__[_1],_please_retry_":"Не удалось изменить пароль. [_1], пожалуйста, попробуйте ещё раз.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Ваш клиент получит по электронной почте уведомление о том, что перевод был выполнен.","Low_Barrier":"Нижний Барьер","Previous_Day":"Предыдущ. день","Senior_Perl_Developer":"Старший разработчик Perl","IP_Address":"IP-адрес","Tu":"Вт","Senior_Front-End_Developer":"Старший Front-End разработчик","Sale_Price":"Цена прод.","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Внесите барьер для изменения спот-котировки. Если Вы внесете +0.005, Вы покупаете контракт с барьером на 0.005 выше, чем спот-котировка. Спот-котировкой считается следующий тик после покупки контракта","Social_Media_Executive":"Глава информационного отдела","Short":"Короткая позиция","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Пожалуйста, подтвердите контракт в своей истории счета, прежде чем продолжить.","Reset_Password":"Изменить пароль","Token":"Токен","Year":"год","Other_financial_instruments_trading_experience":"Опыт торговли другими финансовыми инструментами","Forex_trading_frequency":"Частота торговли на Форекс","Purchase_Time":"Время покупки","Day":"День","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Отсканированная копия действительного паспорта, водительских прав или национального удостоверения личности, которая показывает имя, фамилию и дату рождения.","Old_password_is_wrong_":"Старый пароль неверный.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Ваш запрос на вывод [_1] [_2] с Вашего счета [_3] на счет платежного агента [_4] был выполнен успешно.","DevOps_Manager":"Менеджер команды DevOps","Trading_and_Withdrawal_Limits":"Лимиты на торговлю и вывод","High_barrier_offset":"Изменение высшего барьера","Aug":"Авг","Are_you_sure_that_you_want_to_permanently_delete_token":"Вы уверены, что хотите навсегда удалить токен?","Open":"Значение при открытии","ends_outside":"закончится вне","You_did_not_change_anything_":"Вы не внесли никаких изменений.","Russian_Regular_Index":"Российский станд.инд.","Over/Under":"Над/Под","Feb":"Фев","The_two_passwords_that_you_entered_do_not_match_":"Введенные пароли не совпадают.","Failed":"Возникла ошибка","You_have_not_granted_access_to_any_apps_":"У Вас нет доступа к приложениям.","Stop-loss":"Стоп-лосс","This_field_is_required_":"Данное поле является необходимым.","Return":"Прибыль","Marketing":"Маркетинг","Tertiary":"Третичн.","Swiss_Index":"Швейцарский индекс","Indices_trading_experience":"Опыт торговли индексами","6-10_transactions_in_the_past_12_months":"6-10 транзакций за последние 12 месяцев","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Когда Вы нажмете кнопку 'Подтвердить', средства будет сняты с Вашего счета и перечислены на счет клиента.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"мин.","True":"Верно","day":"дн.","Internal_Audit":"Внутренний аудит","Save_as_JPEG":"Сохранить в формате JPEG","Platinum/USD":"Платина/USD","Income_Source":"Источник дохода","hours":"час.","second":"секунд(ы)","Belgian_Stocks":"Бельгийские акции","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Вы уже вывели со счета сумму, эквивалентную [_1] [_2].","Date":"Дата","Asia/Oceania":"Азия","Italian_Index":"Итальянский индекс","Waiting_for_entry_tick_":"В ожидании входного тика...","lower":"ниже","Confirm_New_Password":"Подтвердить новый пароль","Country_Manager":"Региональный менеджер","April":"Апрель","Select_your_underlying_asset":"Выбрать базовый актив","Last_Digit_Prediction":"Прогноз последней десятичной","Try_adding_more_letters_or_numbers_":"Попробуйте добавить больше букв или цифр.","Sep":"Сен","Jakarta_Index":"Индекс Джакарты","Purchase_Price":"Цена покупки","UK_Smart_Index":"Брит. Smart-индексы","days":"дн.","Never":"Никогда","Name":"Имя и фамилия","Save_as_PNG":"Сохранить в формате PNG","New_Zealand_Index":"Новозеландский индекс","Major_Pairs":"Основные пары","Su":"Вс","Please_enter_a_number_between_[_1]_":"Пожалуйста, введите цифру между [_1].","Marketing_Project_Manager":"Менеджер маркетингового проекта","Jump_To":"Перейти к","loading___":"загружается...","Accounting":"Отчётность","French_Index":"Французский индекс","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Когда Вы нажмёте &quot;ОК&quot;, Вы будете отстранены от работы на сайте до окончания выбранной даты.","Spot_Time":"Спот-время","Closes":"Закрывается","To":"До","Istanbul_Index":"Стамбульский индекс","Reference_ID":"Номер","Administrative_Executive":"Глава отдела управления","Tuesday":"Вторник","Sorry,_this_feature_is_not_available_":"Извините, данная функция недоступна.","Select_market":"Выбрать рынок","High_barrier":"Высший барьер","Closed":"Закрыть","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Для открытия счета необходимо согласиться с правилами и условиями.","Mar":"Мар","Dec":"Дек","Portuguese_Index":"Португальский индекс","higher":"выше","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Внести [_1] [_2] виртуальных денег на Ваш счет [_3]","Jan":"Янв","Monday":"Понедельник","differs":"отличается","Current":"Текущие","Predict_the_direction<br_/>and_purchase":"Предскажите направление движения<br />и купите","Oil/AUD":"Нефть/AUD","Self-Employed":"Частный предприниматель","Estimated_Net_Worth":"Собственный капитал","Binary_options_or_other_financial_derivatives_trading_frequency":"Частота торговли бинарными опционами или другими производными финансовыми инструментами","Action":"Акт","French_Smart_Index":"Французский Smart индекс","Customer_Support":"Поддержка клиентов","Ford_Motor_Comapny":"Ford Motor Company","comma":"запятая","minutes":"минут(ы)","Last_Used":"Последние","Oil/GBP":"Нефть/GBP","Indian_50_Index":"India 50 индекс","Kuwait_Index":"Кувейтский индекс","This_contract_has_LOST":"Контракт ПРОИГРАЛ","Net_Annual_Income":"Чистый годовой доход","40_transactions_or_more_in_the_past_12_months":"40 или более транзакций за последние 12 месяцев","Previous":"Предыдущ.","Investments_&_Dividends":"Инвестиции & Дивиденды","Stocks_trading_frequency":"Частота торговли акциями","Your_withdrawal_limit_is_[_1]_[_2]_":"Ваш лимит на вывод составляет [_1] [_2].","Failed_to_update_trade_description_":"Невозможно обновить описание контракта.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Пожалуйста, введите цифру выше или равную [_1].","Bear_Market_Index":"Индекс нисходящего рынка","Stocks":"Акции","not_available":"нет данных","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"Оплата через платежного агента в данный момент недоступна для Вашей страны.","Buy":"Покупка","Exclude_time_cannot_be_for_more_than_5_years_":"Период ограничения не может быть больше 5 лет.","Next":"Далее","Friday":"пятница","Your_account_has_no_trading_activity_":"На Вашем счету нет торговой деятельности.","Your_trading_statistics_since_[_1]_":"Ваша торговая статистика с [_1].","Your_settings_have_been_updated_successfully_":"Настройки успешно обновлены.","Your_password_cannot_be_the_same_as_your_email":"Ваш пароль не может быть таким же, как Ваш эл.адрес","Please_select_a_valid_date":"Пожалуйста, выберите правильную дату","Walkthrough_Guide":"Гид по рынкам","Shanghai_Index":"Шанхайский индекс","verification_token":"проверочный токен","points":"пункты","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Для авторизации счета вышлите следующее по электронной почте на [_1]","Contract_Expiry":"Срок истечения контракта","December":"Декабрь","Quality_Assurance":"Технический контроль","Primary":"Первичн.","Revoke_access":"Отмена доступа","Saudi_Arabia_Index":"Индекс Саудовской Аравии","Try_adding_more_numbers_":"Попробуйте добавить больше цифр.","Password_is_weak":"Слабый пароль","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Сейчас Вы находитесь на своем демо-счету ([_2]).","Higher/Lower":"Выше/Ниже","Stake":"Ставка","Amount_per_point":"Сумма за пункт","Date_and_Time":"Дата и время","Total_Profit/Loss":"Общая прибыль/потери","Sorry,_an_error_occurred_while_processing_your_request_":"Извините, при обработке Вашего запроса произошла ошибка.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Представляет максимальную сумму средств на Вашем счету. Когда Вы достигаете лимита, Вас попросят вывести часть средств.","Jun":"Июн","Confirm":"Подтвердить","Back":"назад","Balance":"Баланс","Statement":"История счета","ends_between":"закончится между","Japanese_Smart_Index":"Японский Smart индекс","Your_account_has_no_Login/Logout_activity_":"На Вашем счету нет активности входов/выходов.","Select_your_trade_type":"Выбрать тип контракта","asian_down":"азиатские вниз","Exit_Spot_Time":"Время выходной котировки","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Мы не в состоянии предложить живые цены в данный момент. Чтобы посмотреть живые цены, попробуйте перезагрузить страницу. Если вы получаете это сообщение повторно, используйте другой браузер","Low_barrier":"Нижний барьер","Commodities_trading_experience":"Опыт торговли сырьевыми товарами","Forex":"Форекс","Minor_Pairs":"Вторичные пары","Spreads":"Спреды","Contract_ID":"ID контракта","Only_[_1]_are_allowed_":"Разрешены только [_1].","Virtual_Account":"Демо-счет","Our_site_does_not_charge_any_transfer_fees_":"Наш сайт не берёт комиссий за перевод.","Daily_Reset_Indices":"Ежедневные индексы Reset","Deposit":"Пополнение","French_Stocks":"Французские акции","Please_input_a_valid_date":"Пожалуйста, введите правильную дату","years":"год(а)/лет","Sunday":"Воскресенье","Explanation":"Объяснение","This_contract_has_WON":"Контракт ВЫИГРАЛ","Please_wait_<br_/>Your_request_is_being_processed_":"Пожалуйста, подождите.<br/>Запрос в обработке.","Irish_Index":"Ирландский индекс","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Ваши счета [_1] в данный момент недоступны. Пожалуйста, свяжитесь со следующим отделом: [_2].","Volatility_Indices":"Индексы волатильности","Belgian_Index":"Бельгийский индекс","Palladium/USD":"Палладий/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Срок действия Вашего токена истёк. Пожалуйста, нажмите <a class=\"pjaxload\" href=\"[_1]\">здесь,</a> чтобы повторно запустить процесс проверки.","Remaining_Time":"Оставшееся время","Your_transaction_reference_number_is_[_1]":"Номер Вашей сделки [_1]","January":"Январь","There_was_an_error":"Произошла ошибка","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Формат: гггг-мм-дд (не требуется для демо-счетов)","Maximum_number_of_open_positions":"Максимальное количество открытых позиций","Start_Time":"Время начала","Exit_Level":"Уровень окончания","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] было зачислено на Ваш Демо-счет [_3]","Please_submit_a_valid_[_1]_":"Пожалуйста, правильно введите [_1].","Session_duration_limit_cannot_be_more_than_6_weeks_":"Лимит на продолжительность сессии не может превышать 6 недель.","Ends_In/Out":"Заканчивается Внутри/Вне","Indices":"Индексы","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"Контракт будет продан по цене, действующей на момент получения запроса нашими серверами. Эта цена может отличаться от указанной в настоящее время.","Maximum_aggregate_payouts_on_open_positions":"Максимальная совокупная выплата по открытым позициям","UK_Index":"Великобританский индекс","Credit/Debit":"Кредит/Дебет","End_Time":"Окончание","There_was_a_problem_accessing_the_server_":"Возникла проблема с доступом к серверу.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Пожалуйста, проверьте свой эл. адрес; Вам должен прийти токен для изменения пароля.","year":"год(а)/лет","German_Index":"Немецкий индекс","Brazilian_Index":"Бразильский индекс","Finance":"Финансы","Graphic_Designers":"Графические дизайнеры","Administrator":"Администратор","November":"Ноябрь","South_African_Index":"Южноафрик. инд.","Contract":"Контракт","Keep_track_of_your_authorised_applications_":"Следите за доступными приложениями.","Please_enter_a_valid_amount_":"Пожалуйста, введите правильную сумму.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Внесите дату, по меньшей мере, в 6 месяцах от настоящей.","Zoom":"Приблизить","Your_changes_have_been_updated_":"Ваши изменения внесены успешно.","Ms":"Госпожа","May":"Май","Profit":"Прибыль","Exclude_time_must_be_after_today_":"Время начала ограничения должно быть позднее сегодняшней даты.","Rise/Fall":"Повышение/Падение","Total_Cost":"Общая стоимость","Touch/No_Touch":"Касание/Нет касания","Invalid_date_of_birth_":"Неправильная дата рождения.","Sell_at_market":"Продать по текущей цене","Date_(GMT)":"Дата (GMT)","Maximum_daily_turnover":"Максимальный дневной оборот","You_have_sold_this_contract_at_[_1]_[_2]":"Вы продали данный контракт по цене [_1] [_2]","Last_Digit_Stats":"Статистика последних тиков","Permissions":"Разрешения","Compliance_Executive":"Глава отдела регулир. и контроля","Settles":"Заканчивается","Stocks_trading_experience":"Опыт торговли акциями","Item":"Описание","Month":"Месяц","Successful":"Успешно","Unlock_Cashier":"Открыть кассу","Middle_East":"Ближний Восток","Pension":"Пенсия","Proofreader":"Корректор","Low_barrier_offset":"Изменение нижнего барьера"};
texts_json['ES'] = {"Accounts_And_Payments_Executive":"Ejecutivo de Contabilidad y Pagos","Prices":"Precios","Stop_Loss_Level":"Nivel de stop loss","Please_select":"Seleccione","This_contract_won":"Este contrato ganó","Oil/EUR":"Petróleo/EUR","Spot":"Precio actual del mercado","US_Index":"Índice EEUU","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Su solicitud de transferencia [_1] [_2] de [_3] a [_4] ha sido procesada exitosamente.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Usted ya retiró un total equivalente a [_1] [_2]  en los últimos [_3] días.","Payout":"Pago","Period":"Período","stays_between":"queda dentro","Verification_Token":"Token de Verificación","Deposit_of":"Depósito de","odd":"impar","Wednesday":"Miércoles","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Representa el volumen máximo de contratos que puede comprar en un día de comercialización determinado.","Dubai_Index":"Índice Dubai","Margin_FX":"Margen FX","month":"mes","Minimum_of_[_1]_characters_required_":"Mínimo de [_1] caracteres requeridos.","In/Out":"Dentro/Fuera","Industry_of_Employment":"Industria de Empleo","Human_Resource_Executive":"Ejecutivo de Recursos Humanos","Opens":"Abre","Exit_Spot":"Punto de salida","Potential_Payout":"Pago potencial","Bull_Market_Index":"Índice de Mercado Bull","Points":"Puntos","Gold/AUD":"Oro/AUD","touches":"toca","Secondary":"Secundario","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Su límite de retirada es [_1] [_2] (o el equivalente en otra divisa).","Marketing_Executives":"Ejecutivo de Marketing","No_Live_price_update":"Falta de actualización de precios en tiempo real","Please_select_a_payment_agent":"Seleccione un agente de pago","Real_Account":"Cuenta real","Europe/Africa":"Europa/África","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Una copia escaneada de un extracto bancario o una factura que muestra su dirección residencial actual (que no sea más antigua de 3 meses).","30-50_million_JPY":"30-50 millones JPY","Ok":"Aceptar","Spanish_Index":"Índice España","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Se puede utilizar una contraseña adicional para restringir el acceso al cajero.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Su cuenta está totalmente autenticada y su límite de retirada ha sido aumentado.","Swedish_Index":"Índice Suecia","GBP_Index":"Índice GBP","Shenzhen_300_Index":"Índice Shenzhen 300","Binary_options_or_other_financial_derivatives_trading_experience":"Experiencia comercial con opciones binarias o derivados de otros instrumentos financieros","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Su contraseña se ha restablecido. Por favor, inicie sesión en su cuenta utilizando su nueva contraseña.","Less_than_$100,000":"Menos de $100.000","Upcoming_Events":"Próximos eventos","minimum_available_duration":"duración mínima disponible","Gold/EUR":"Oro/EUR","Now":"Ahora","Construction":"Construcción","Norwegian_Index":"Índice de Noruega","Korean_Index":"Índice de Corea","Number_of_ticks":"Número de intervalos","asian_up":"asiáticos arriba","Entry_Level":"Nivel de entrada","Asians":"Asiáticas","September":"Septiembre","Save_as_PDF":"Guardar en formato PDF","Contract_Confirmation":"Confirmación del contrato","numbers":"números","View_your_statement":"Vea su extracto","Delete":"Eliminar","Profit/Loss_(points)":"Beneficios/Pérdidas (puntos)","3-5_million_JPY":"3-5 millones JPY","spread_down":"spread abajo","AUD_Index":"Índice AUD","Continuous_Indices":"Índices Continuos","Quality_Assurance_Engineer":"Ingeniero de Control de Calidad","Information_Technology":"Informática","Digits":"Dígitos","Quantitative_Developer":"Desarrollador Cuantitativo","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"En este momento, no aceptamos cuentas de residentes de este país.","Browser":"Navegador","Australian_Index":"Índice Australia","Login_ID":"Identificación de acceso","0-5_transactions_in_the_past_12_months":"0-5 transacciones en los úlitmos 12 meses","Start_time":"Hora de comienzo","Americas":"América","Japanese_Index":"Índice de Japón","Salaried_Employee":"Empleado asalariado","Less_than_1_million_JPY":"Menos de 1 millón JPY","There_was_some_invalid_character_in_an_input_field_":"Había un carácter no válido en el campo de entrada.","matches":"iguales","Long":"Largos","is_required__Current_spread":"es requerido. El spread actual","Less_than_$25,000":"Menos de $25,000","Mr":"Sr","Volatility_25_Index":"Índice de Volatilidad 25","1-2_years":"1-2 años","March":"Marzo","(Bejing/CST_-8_hours)":"(Bejing/CST -8 horas)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] ha actualizado sus [_2]. Al hacer clic en Aceptar, usted confirma que ha leído y aceptado los [_2] actualizados.","hyphen":"guión","Invalid_amount,_maximum_is":"Monto invalido. El máximo es","US_Smart_Index":"Índice Smart EEUU","Week_of":"Semana de","Entry_Spot":"Punto de entrada","You_should_enter_between_[_1]_characters_":"Debe ingresar entre [_1] caracteres.","spread_up":"spread arriba","Contract_is_not_started_yet":"El contrato no ha comenzado todavía","Indicative":"Indicativo","Dutch_Index":"Índice Holanda","Volatility_100_Index":"Índice de Volatilidad 100","Metals":"Metales","We":"MI","Please_enter_a_number_between_0_and_[_1]":"Ingrese un valor entre 0 y [_1]","Quantitative_Analyst":"Analítico Cuantitativo","Level_of_Education":"Nivel de formación","New_token_created_":"Un token nuevo ha sido creado.","5-10_million_JPY":"5-10 milliones JPY","even":"par","Hedging":"Cobertura","Authorise_your_account_":"Autorice su cuenta.","Education":"Formación","Contract_Sold":"Contrato Vendido","Gaming_Account":"Cuenta de juego","July":"Julio","June":"Junio","Thursday":"Jueves","Limit":"Límite","Smart_Indices":"Índices Smart","Your_details_have_been_updated_":"Sus datos se han actualizado.","No_experience":"Sin experiencia","Over_$1,000,000":"Más de $1,000,000","Financial_Assessment":"Asesoramiento financiero","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Su cuenta [_1] no está disponible. Ante cualquier duda comuníquese con el [_2].","Password_is_very_strong":"La contraseña es muy fuerte","USD_Index":"Índice USD","1-3_years":"1-3 años","Both_the_above":"Ambos mencionados arriba","password":"contraseña","Stop-type":"Tipo de stop","1-3_million_JPY":"1-3 millones JPY","Commodities_trading_frequency":"Frecuencia de comercio con materias primas","Transfer_to":"Transferir a","Price":"Precio","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Por lo tanto, la cantidad máxima que puede retirar de forma inmediata (sujeta a la existencia de fondos suficientes en su cuenta) es [_1] [_2].","ticks":"intervalos","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Al hacer clic en \"OK\" usted será excluido de las operaciones en la web hasta la fecha seleccionada.","Questions":"Preguntas","and":"y","Apr":"Abr","months":"meses","Potential_Profit":"Beneficios potenciales","over":"sobre","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Los servicios contractuales financieros de este sitio solo son adecuados para los Clientes que pueden lidiar con la pérdida del dinero que invierten y que comprenden y tienen experiencia con los riesgos implícitos en la adquisición de contratos financieros. Las transacciones en los contractos financieros implican muchas posibilidades de riesgo. Si los contratos comprados caducan sin valor, sufrirá la pérdida total de su inversión, que consistirá en la prima contractual.","Sale_Date":"Fecha de venta","Nocturnes":"Nocturnos","Exercise_period":"Período del ejercicio","February":"Febrero","Exclude_time_cannot_be_less_than_6_months_":"El tiempo de exclusión no puede ser menor a 6 meses.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Su [_1] límite diario para retirar dinero es actualmente [_2] [_3] (o el equivalente en otra divisa).","Incyte_Corpoartion":"Incyte Corporation","Your_current_balance_is":"El balance actual  de su cuenta es","Singapore_Index":"Índice Singapur","Duration":"Duración","This_contract_lost":"Este contrato perdió","Indices_trading_frequency":"Frecuencia de comercio con índices","Other_financial_instruments_trading_frequency":"Frecuencia de comercio con otros instrumentos financieros","Password_is_strong":"La contraseña es fuerte","EUR_Index":"Índice EUR","Stop_Profit_Level":"Nivel de stop profit","Try_adding_more_letters_":"Pruebe añadir más letras.","Egypt_Index":"Índice Egipto","Net_profit":"Beneficio Neto","Status":"Estado","Verification_code_format_incorrect_":"El formato del código de verificación es incorrecto.","There_was_a_problem_accessing_the_server_during_purchase_":"Hubo un problema al acceder al servidor durante la compra.","Adjust_trade_parameters":"Ajustar parámetros de comercio","Others":"Otros","Dutch_Stocks":"Acciones Holanda","Over_$500,001":"Más de $500,001","Th":"JU","Even/Odd":"Par/Impar","Barrier_offset":"Desplazamiento de barrera","Over_5_years":"Más de 5 años","This_feature_is_not_relevant_to_virtual-money_accounts_":"Esta característica no es relevante para cuentas de dinero virtual.","Gold/USD":"Oro/USD","Password_should_have_lower_and_uppercase_letters_with_numbers_":"La contraseña debe tener letras minúsculas y mayúsculas con números.","Step":"Paso","Next_Day":"Día siguiente","Applications":"Aplicaciones","Save_as_CSV":"Guardar en formato CSV","Internal_Auditor":"Auditor Interno","Loss":"Pérdida","Mo":"LU","Other":"Otro","Health":"Salud","Dutch_Smart_Index":"Índice Smart Holanda","Tick":"Intervalo","letters":"letras","under":"bajo","Silver/USD":"Plata/USD","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Los últimos dígitos para los [_1] intervalos más recientes a [_2]","Energy":"Energía","Over_3_years":"Durante 3 años","From":"Desde","does_not_touch":"no toca","hour":"hora","View":"Ver","Sorry,_an_error_occurred_while_processing_your_account_":"Lo sentimos, ha ocurrido un error mientras se procesaba su cuenta.","An_error_occured_":"Ha ocurrido un error.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Por lo tanto, la cantidad máxima que puede retirar de forma inmediata (sujeta a la existencia de fondos suficientes en su cuenta) es [_1] [_2] (o su equivalente en otra divisa).","Russian_10_Index":"Índice Ruso 10","New_Password":"Contraseña nueva","Trading_Limits":"Límites","German_Smart_Index":"Índice Smart Alemania","Details":"detalles","Login_History":"Historial de accesos","Invalid_amount,_minimum_is":"Monto inválido, el mínimo es","minute":"minuto","Public_worker":"Trabajador público","Please_deposit_before_transfer_to_client_":"Por favor deposite antes de la transferencia al cliente.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Por favor, siga el patrón de 3 números y un guión seguido de 4 números.","Password_Reset":"Contraseña Restablecida","Maximum_account_cash_balance":"Saldo de caja máximo en la cuenta","August":"Agosto","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Su cuenta está totalmente autenticada. Usted puede ver sus límites de operaciones [_1] aquí","Bombay_Index":"Índice Bombay","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Confirme los detalles de la transacción para completar la transferencia:","Euro_50_Smart_Index":"Índice Smart Euro 50","US_Tech_Composite_Index":"Índice US Tech Composite","Lock_Cashier":"Bloquear cajero","Sa":"SA","seconds":"segundos","Matches/Differs":"Iguales/Diferentes","Select_your_market":"Seleccione su mercado","apostrophe":"apóstrofe","Canadian_Index":"Índice Canadá","Finish":"Terminar","Gold/GBP":"Oro/GBP","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"La contraseña debe contener al menos 1 dígito, 1 letra mayúscula y 1 letra minúscula.","Oil/USD":"Petróleo/USD","Up/Down":"Arriba/Abajo","Human_Resources":"Recursos Humanos","Mrs":"Srta.","Profit_Table":"Tabla de beneficios","Purchase":"Comprar","Tourism":"Turismo","10-30_million_JPY":"10-30 millones JPY","Shenzhen_Index":"Índice Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Su cajero está bloqueado según su petición - para desbloquearlo, por favor introduzca la contraseña.","Invalid_email_address":"Correo electrónico no válido","Please_enter_an_integer_value":"Ingrese un valor entero","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Lo sentimos, esta característica está disponible solo para cuentas virtuales.","Investment_Account":"Cuenta de inversión","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Usted no está autorizado para retirar dinero a través de agente de pago.","Quantitative_Analysis":"Análisis Cuantitativo","Miss":"Srta.","Wall_Street_Smart_Index":"Índice Smart Wall Street","Please_check_your_email_for_the_value_of_this_token":"Por favor verifique su correo electrónico para el valor de este token","Forex_trading_experience":"Experiencia de comercio en forex","Amount":"Monto","The_maximum_number_of_tokens_([_1])_has_been_reached_":"El máximo número de tokens ([_1]) ha sido alcanzado.","Global_Customer_Service_Representatives":"Representantes del Servicio de Atención al Cliente Global","Withdrawal_Limits":"Límites de retiro","Print_chart":"Imprimir el gráfico","Please_try_again_":"Por favor, inténtelo de nuevo.","Your_transaction_reference_is":"La referencia de su transacción es","Compliance":"Сumplimiento","Save_as_SVG":"Guardar en formato SVG","You_have_already_withdrawn_[_1]_[_2]_":"Usted ya retiró [_1] [_2].","Profit/Loss":"Ganado/Perdido","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Complete con su identificación de acceso y el monto que desea transferir a su cliente en el formulario a continuación:","Password_does_not_match_":"La contraseña no coincide.","Commodities":"Materias primas","Transfer_to_Login_ID":"Transferir a usuario","Update":"Actualizar","Fr":"VI","Volatility_75_Index":"Índice de Volatilidad 75","goes_outside":"sale fuera","Chart":"Gráfico","High_Barrier":"Barrera Superior","Date_of_Birth":"Fecha de Nacimiento","Self-employed":"Autónomo","space":"espacio","Portuguese_Smart_Index":"Índice Smart Portugal","Saturday":"Sábado","Never_Used":"Nunca usado","Volatility_50_Index":"Índice de Volatilidad 50","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Presenta el pago total máximo de los contratos pendientes en su cartera. Si se ajusta al máximo, no podrá comprar contratos adicionales sin primero cerrar las posiciones actuales.","Description":"Descripción","Sell":"Venta","Abu_Dhabi_Index":"Índice Abu Dhabi","Euro_50_Index":"Índice Euro 50","October":"Octubre","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Actualmente está en su cuenta de dinero real de [_1] ([_2]).","Office_worker":"Trabajador de oficina","Terms_&_Conditions":"Términos & condiciones","Only_2_decimal_points_are_allowed_":"Se permiten solo [_1].","period":"período","Password_score_is:_[_1]__Passing_score_is:_20_":"La fuerza de la contraseña es: [_1]. El puntaje para aprobar es: 20.","Stays_In/Goes_Out":"Queda Dentro/Sale Fuera","Note":"Nota","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Representa el número máximo de contratos pendientes en su cartera. Cada línea de su cartera cuenta para una posición abierta. Una vez que se alcanza el máximo no podrá abrir nuevas posiciones sin cerrar las posiciones existentes primero.","Italian_30_Index":"Índice Italia 30","Password_is_not_strong_enough_":"La contraseña no es lo suficientemente fuerte.","Asset":"Activo","Swiss_Smart_Index":"Índice Smart Suiza","0-1_year":"0-1 año(s)","Contract_Information":"Información del Contrato","Translator":"Traductor","Hong_Kong_Index":"Índice Hong Kong","Sorry,_account_opening_is_unavailable_":"Lo sentimos, apertura de una cuenta actualmente no está disponible.","Anti-Fraud_Officer":"Oficial Contra Fraude","Barrier":"Límite","Current_Level":"Nivel actual","Password_is_moderate":"La contraseña es de fuerza mediana","Failed_to_reset_password__[_1],_please_retry_":"Error al restablecer la contraseña. [_1], por favor vuelva a intentarlo.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Su Cliente recibirá una notificación por correo electrónico informándole a él/ella que la transferencia ha sido procesada.","Low_Barrier":"Barrera Inferior","Previous_Day":"Día Anterior","Senior_Perl_Developer":"Desarrollador Senior de Perl","IP_Address":"Dirección IP","Tu":"MA","Senior_Front-End_Developer":"Desarrolador Senior de Front-End","Sale_Price":"Precio venta","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Introduzca el límite en términos de la diferencia con el precio al contado. Si usted introduce +0.005, estará adquiriendo un contrato con un límite 0.005 por encima del precio al contado. El precio al contado es el precio recibido una vez ejecutada la orden de la compra","Social_Media_Executive":"Ejecutivo de Medios Sociales","Short":"Cortos","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Por favor, confirme el contrato en su cartera antes de proceder.","Reset_Password":"Restablecer contraseña","Year":"Año","Other_financial_instruments_trading_experience":"Experiencia de comercio con otros instrumentos financieros","Forex_trading_frequency":"Frecuencia de comercio en forex","Purchase_Time":"Hora de compra","Day":"Día","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Una copia escaneada de su pasaporte, el carnet de conducción actual (provisional o completo) o de la tarjeta de identidad que muestra su nombre, apellido y fecha de nacimiento.","Old_password_is_wrong_":"Su antigua contraseña es incorrecta.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Su solicitud de retirada de [_1] [_2] de su cuenta [_3] al agente de pagos [_4] se ha procesado correctamente.","DevOps_Manager":"Director del Equipo de Operaciones de Desarrollo","Trading_and_Withdrawal_Limits":"Límites de comercialización y de retiro","Housewife_/_Househusband":"Ama / Amo de casa","High_barrier_offset":"Desplazamiento de la barrera superior","Aug":"Ago","Are_you_sure_that_you_want_to_permanently_delete_token":"Está seguro de querer eliminar el token","Open":"Abierto","ends_outside":"Finaliza fuera","You_did_not_change_anything_":"No ha cambiado nada.","Russian_Regular_Index":"Índice regular Rusia","Over/Under":"Encima/Debajo","The_two_passwords_that_you_entered_do_not_match_":"Las dos contraseñas introducidas no coinciden.","Failed":"Fallado","You_have_not_granted_access_to_any_apps_":"Usted no ha concedido acceso a ninguna aplicación.","Stop-loss":"Stop loss","This_field_is_required_":"Este campo es obligatorio.","Return":"Ganancias","Tertiary":"Terciario","Swiss_Index":"Índice Suiza","AP_Ordinary":"AP Ordinario","Indices_trading_experience":"Experiencia de comercio con índices","6-10_transactions_in_the_past_12_months":"6-10 transacciones en los úlitmos 12 meses","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Una vez que haga clic en el botón \"Enviar\" los fondos se retirarán de su cuenta y se enviarán a la cuenta de su Cliente.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"min","day":"día","Internal_Audit":"Auditoría interna","Save_as_JPEG":"Guardar en formato JPEG","Platinum/USD":"Platino/USD","Income_Source":"Fuente de ingresos","hours":"horas","Euro_100_Index":"Índice Euro 30","second":"segundo","Belgian_Stocks":"Acciones Bélgica","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Usted ya retiró el equivalente a [_1] [_2].","Date":"Fecha","Asia/Oceania":"Asia/Oceanía","Italian_Index":"Índice Italia","Waiting_for_entry_tick_":"Esperando el tick de entrada.","lower":"inferior","Confirm_New_Password":"Confirmar Contraseña Nueva","Country_Manager":"Gerente de país","April":"Abril","Select_your_underlying_asset":"Seleccione el activo subyacente","AUDZAR":"AUD/ZAR","Last_Digit_Prediction":"Predicción del último dígito","Try_adding_more_letters_or_numbers_":"Pruebe a añadir más letras o números.","US_Tech_100_Index":"Índice US Tech 100","Jakarta_Index":"Índice Jakarta","Purchase_Price":"Precio de compra","UK_Smart_Index":"Índice Smart Reino Unido","days":"días","Never":"Nunca","Name":"Nombre","Save_as_PNG":"Guardar en formato PNG","New_Zealand_Index":"Índice Nueva Zelanda","Major_Pairs":"Pares mayores","Su":"DO","Please_enter_a_number_between_[_1]_":"Por favor, introduzca un número entre [_1].","Marketing_Project_Manager":"Director de proyectos de marketing","Jump_To":"Saltar a","loading___":"cargando...","Accounting":"Contabilidad","French_Index":"Índice Francia","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Al hacer clic en \"OK\" usted será excluido de las operaciones en la web hasta la fecha seleccionada.","Spot_Time":"Tiempo Spot","Over_100_million_JPY":"Más de 100 millones JPY","Closes":"Cierra","To":"Al","Istanbul_Index":"Índice Estambul","Reference_ID":"ID de Referencia","Administrative_Executive":"Ejecutivo de Administración","Tuesday":"Martes","Sorry,_this_feature_is_not_available_":"Esta funcionalidad no está disponible.","Select_market":"Seleccione mercado","High_barrier":"Barrera superior","Closed":"Cerrado","50-100_million_JPY":"50-100 milliones JPY","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Usted debe aceptar los términos y condiciones para abrir una cuenta.","USDZAR":"USD/ZAR","Dec":"Dic","Portuguese_Index":"Índice Portugal","higher":"superior","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Deposite [_1] [_2] de dinero virtual en su cuenta [_3]","Jan":"Ene","Monday":"Lunes","differs":"diferentes","Current":"Actual","Predict_the_direction<br_/>and_purchase":"Prediga la dirección<br /> y compre","Oil/AUD":"Petróleo/AUD","Self-Employed":"Autónomo","Estimated_Net_Worth":"Valor neto estimado","Binary_options_or_other_financial_derivatives_trading_frequency":"Frecuencia de comercio con opciones binarias o de otros derivados financieros","Action":"Acción","French_Smart_Index":"Índice Smart Francia","Customer_Support":"Atención al cliente","Ford_Motor_Comapny":"Ford Motor Company","comma":"coma","minutes":"minutos","Last_Used":"Último usado","Oil/GBP":"Petróleo/GBP","Indian_50_Index":"Índice India 50","Wall_Street_Index":"Índice Wall Street","Kuwait_Index":"Índice Kuwait","Less_than_6_months":"Menos de 6 meses","This_contract_has_LOST":"Este contrato ha PERDIDO","Net_Annual_Income":"Ingreso anual neto","40_transactions_or_more_in_the_past_12_months":"40 transacciones o más en los úlitmos 12 meses","Previous":"Anterior","Euro_150_Index":"Índice Euro 150","Investments_&_Dividends":"Inversiones y dividendos","Stocks_trading_frequency":"Frecuencia de comercio con acciones","Your_withdrawal_limit_is_[_1]_[_2]_":"Su límite de retirada es [_1] [_2].","Failed_to_update_trade_description_":"Error al actualizar la desripción del contrato.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Por favor ingrese un valor mayor o igual a [_1].","Bear_Market_Index":"Índice de Mercado Bear","Stocks":"Acciones","not_available":"no disponible","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"Los agentes de pagos no están disponibles actualmente para su país.","Buy":"Comprar","Exclude_time_cannot_be_for_more_than_5_years_":"El tiempo de exclusión no puede ser mayor a 5 años.","Next":"Siguiente","Friday":"Viernes","Your_account_has_no_trading_activity_":"Su cuenta no tiene actividad comercial.","Your_trading_statistics_since_[_1]_":"Las estadísticas de sus transacciones desde [_1].","Your_settings_have_been_updated_successfully_":"Su configuración se ha actualizado exitosamente.","Your_password_cannot_be_the_same_as_your_email":"Su contraseña no puede ser la misma que su dirección de correo electrónico","Please_select_a_valid_date":"Seleccione una fecha válida","Walkthrough_Guide":"Guía tutorial","Shanghai_Index":"Índice Shanghai","verification_token":"token de verificación","points":"puntos","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Para autenticar por completo su cuenta, envíe lo siguiente por correo electrónico a [_1]","Contract_Expiry":"Vencimiento del Contrato","December":"Diciembre","Quality_Assurance":"Control de Calidad","Primary":"Primario","Revoke_access":"Revocar el acceso","Saudi_Arabia_Index":"Índice Arabia Saudí","Try_adding_more_numbers_":"Pruebe añadir más números.","Password_is_weak":"La contraseña es débil","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Actualmente está en su cuenta de dinero virtual  ([_2]).","Higher/Lower":"Superior/Inferior","Stake":"Inversión","Amount_per_point":"Cantidad por punto","Date_and_Time":"Fecha y Hora","Total_Profit/Loss":"Beneficios/perdidas totales","Sorry,_an_error_occurred_while_processing_your_request_":"Lo sentimos, ha ocurrido un error mientras se procesaba su petición.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Representa el monto máximo de dinero que puede tener en su cuenta. Si se alcanza el máximo se le pedirá que retire sus fondos.","Confirm":"Confirmar","Back":"Atrás","Balance":"Saldo","Statement":"Extracto","Contract_/_Temporary_/_Part_Time":"Contrato / Temporal / A tiempo parcial","ends_between":"Finaliza dentro","Japanese_Smart_Index":"Índice Smart Japón","Your_account_has_no_Login/Logout_activity_":"Su cuenta no tiene actividad de accesos/cierres de sesión.","Select_your_trade_type":"Seleccione el tipo de contrato","asian_down":"asiáticas abajo","Exit_Spot_Time":"Tiempo de Punto de Salida","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"En estos momento no somos capaces de transmitir los precios en tiempo real. Para ver los precios en directo intente actualizar la página. Si el problema persiste después de repetidos intentos, pruebe un navegador diferente","Low_barrier":"Barrera inferior","Commodities_trading_experience":"Experiencia de comercio con materias primas","Minor_Pairs":"Pares menores","Contract_ID":"ID del Contrato","Only_[_1]_are_allowed_":"Se permiten solo [_1].","Virtual_Account":"Cuenta virtual","Our_site_does_not_charge_any_transfer_fees_":"Nuestro sitio no cobra ninguna tarifa de transferencia.","Daily_Reset_Indices":"Índices de Reajuste Diario","Deposit":"Depósito","French_Stocks":"Acciones Francia","Please_input_a_valid_date":"Ingrese una fecha válida","years":"años","Sunday":"Domingo","Explanation":"Explicación","This_contract_has_WON":"Este contrato ha GANADO","Please_wait_<br_/>Your_request_is_being_processed_":"Por favor, aguarde.<br />Su solicitud se está procesando.","Irish_Index":"Índice Irlanda","6_months_to_1_year":"6 meses a un año","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Su cuenta [_1] no está disponible. Ante cualquier duda comuníquese con el [_2].","Volatility_Indices":"Índices de Volatilidad","Belgian_Index":"Índice Bélgica","Palladium/USD":"Paladio/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Su token ha caducado. Por favor haga clic <a class=\"pjaxload\" href=\"[_1]\">aquí</a> para reiniciar el proceso de verificación.","Remaining_Time":"Tiempo Restante","Your_transaction_reference_number_is_[_1]":"El número de referencia de su transacción es [_1]","January":"Enero","There_was_an_error":"Hubo un error","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Formato: aaaa-mm-dd (no requerido para las cuentas de dinero virtual)","Maximum_number_of_open_positions":"Número máximo de posiciones abiertas","Start_Time":"Hora de comienzo","Exit_Level":"Nivel de salida","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] se ha acreditado en su cuenta de dinero virtual [_3]","Please_submit_a_valid_[_1]_":"Por favor ingrese un valor válido de [_1].","Session_duration_limit_cannot_be_more_than_6_weeks_":"El límite de la duración de la sesión no puede ser superior a 6 semanas.","Ends_In/Out":"Finaliza Dentro/Fuera","Indices":"Índices","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"El contrato se venderá al precio vigente en el mercado en el momento de la recepción de la solicitud de venta por nuestros servidores. Este precio puede ser diferente del precio indicado.","Maximum_aggregate_payouts_on_open_positions":"Máximo de pagos agregados en posiciones abiertas","UK_Index":"Índice Reino Unido","Credit/Debit":"Crédito/débito","End_Time":"Hora de finalización","There_was_a_problem_accessing_the_server_":"Hubo un problema al acceder al servidor.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Por favor verifique su correo electrónico para encontrar el token que necesita para restablecer su contraseña.","year":"año","German_Index":"Índice Alemania","Brazilian_Index":"Índice de Brazil","Finance":"Finanzas","Graphic_Designers":"Diseñadores gráficos","Administrator":"Administrador","November":"Noviembre","South_African_Index":"Índice de Sudáfrica","Contract":"Contrato","Keep_track_of_your_authorised_applications_":"Realizar un seguimiento de sus aplicaciones autorizadas.","Please_enter_a_valid_amount_":"Ingrese un monto válido.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Por favor, elija una fecha que es por lo menos 6 meses a partir de ahora.","Zoom":"Enfocar","Your_changes_have_been_updated_":"Sus cambios se han actualizado.","Ms":"Sra.","Profit":"Beneficios","Exclude_time_must_be_after_today_":"El tiempo de exclusión debe ser a partir de mañana.","Rise/Fall":"Alza/Baja","Total_Cost":"Coste total","Touch/No_Touch":"Toque/Sin toque","Invalid_date_of_birth_":"Fecha de nacimiento incorrecta.","Sell_at_market":"Vender al precio del mercado actual","Date_(GMT)":"Fecha (GMT)","Maximum_daily_turnover":"Volumen de negocios diario máximo","You_have_sold_this_contract_at_[_1]_[_2]":"Usted ha vendido este contrato en [_1] [_2]","3-5_years":"3-5 años","Foreign_currency_deposit":"Depósito en moneda extranjera","Last_Digit_Stats":"Estadísticas del último dígito","Permissions":"Permisos","Compliance_Executive":"Ejecutivo de cumplimiento","Settles":"Establece","Stocks_trading_experience":"Experiencia de comercio con acciones","Item":"Artículo","Month":"Mes","Successful":"Exitoso","Unlock_Cashier":"Desbloquear cajero","Middle_East":"Medio Oriente","Pension":"Pensión","Proofreader":"Corrector","Low_barrier_offset":"Desplazamiento de la barrera inferior"};
texts_json['FR'] = {"Prices":"Prix","Stop_Loss_Level":"Niveau stop-loss","Please_select":"Veuillez sélectionner","This_contract_won":"Ce contrat remporté","Oil/EUR":"Pétrole/EUR","Spot":"Actuel","US_Index":"Indice US","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Votre demande de transférer [_1] [_2] de [_3] à [_4] a été traitée avec succès.","Payout":"Paiement","Period":"Période","stays_between":"reste entre","Deposit_of":"Dépôt de","odd":"impair","Wednesday":"Mercredi","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Représente le volume maximal de contrats que vous pouvez acheter au cours d'une journée de trading donnée.","Dubai_Index":"Indice de Dubaï","month":"mois","Minimum_of_[_1]_characters_required_":"Un minimum de [_1] caractères est requis.","In/Out":"Dans/Hors de","Industry_of_Employment":"Industrie d'Emploi","Opens":"Ouvre","Exit_Spot":"Point de Sortie","Potential_Payout":"Gain Potentiel","Gold/AUD":"Or/AUD","touches":"touche","Secondary":"Secondair","No_Live_price_update":"Pas de mises à jour du prix en Direct","Please_select_a_payment_agent":"Veuillez sélectionner un agent de paiement","Real_Account":"Compte réel","Europe/Africa":"Europe/Afrique","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Une copie scannée d'une facture de services publics ou un extrait de compte (pas plus vieux que 3 mois).","Spanish_Index":"Indice Espagnol","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Un mot de passe supplémentaire peut être utilisé afin de restreindre l'accès à la caisse.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Votre compte est entièrement authentifié et vos limites de retrait ont été levées.","Swedish_Index":"Indice Suède","GBP_Index":"Indice GBP","Binary_options_or_other_financial_derivatives_trading_experience":"Expérience du trading d'options binaires ou d'autres instruments dérivés","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Votre mot de passe a été réinitialisé avec succès. Veuillez vous connecter à votre compte en utilisant votre nouveau mot de passe.","Less_than_$100,000":"Moins de $100,000","Jul":"Juil","Upcoming_Events":"Prochains Évènements","minimum_available_duration":"durée minimale disponible","Gold/EUR":"Or/EUR","Now":"Maintenant","Norwegian_Index":"Indice de Norvège","Korean_Index":"Indice de Corée","Number_of_ticks":"Nombre d'intervalles","asian_up":"haut asiatique","Entry_Level":"Niveau d'entrée","Asians":"Asiatiques","September":"Septembre","Save_as_PDF":"Sauvegarder comme PDF","Contract_Confirmation":"Confirmation du Contrat","numbers":"chiffres","View_your_statement":"Voir votre extrait","Delete":"Supprimer","Profit/Loss_(points)":"Bénéfice/Perte (points)","spread_down":"Option courte","AUD_Index":"Indice AUD","Digits":"Chiffres","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"Nous n'acceptions pas de comptes de résidents de ce pays pour le moment.","Australian_Index":"Indice Australien","Login_ID":"Identifiant de connexion","0-5_transactions_in_the_past_12_months":"0-5 transactions dans les 12 derniers mois","Start_time":"Heure du début","Americas":"Amériques","Japanese_Index":"Indice du Japon","Salaried_Employee":"Employé Salarié","Deutsche_Bank_AG":"Deutchse Bank AG","matches":"est égale à","is_required__Current_spread":"est requis. Spread actuel","Less_than_$25,000":"Moins de $25,000","Mr":"M.","1-2_years":"1-2 ans","March":"Mars","(Bejing/CST_-8_hours)":"(Pékin/CST -8 heures)","hyphen":"trait d'union","Smart_FX":"FX Intelligent","Invalid_amount,_maximum_is":"Montant non valide, le maximum est de","US_Smart_Index":"Indice Intelligent Américain","Week_of":"Semaine de","Entry_Spot":"Point d'Entrée","You_should_enter_between_[_1]_characters_":"Vous sevez saisir entre [_1] caractères.","Ref_":"Réf.","spread_up":"Option longue","Indicative":"Indicatif","Dutch_Index":"Indice Néerlandais","Metals":"Métaux","We":"Me","Level_of_Education":"Niveau d'Éducation","New_token_created_":"Nouveau jeton d'authentification créé.","even":"pair","Education":"Formation","Gaming_Account":"Compte de Jeux","July":"Juillet","June":"Juin","Thursday":"Jeudi","Limit":"Limite","Smart_Indices":"Indices Intelligents","Your_details_have_been_updated_":"Vos détails ont été actualisés.","Over_$1,000,000":"Plus de 1 000 000 $","Financial_Assessment":"Évaluation Financière","USD_Index":"Indice USD","password":"mot de passe","Stop-type":"Type d'ordre stop","Commodities_trading_frequency":"Fréquence de trading de matières premières","Transfer_to":"Transfert à","Price":"Prix","ticks":"intervalles","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Lorsque vous cliquez 'Ok' vous serez exclus des trades sur ce site jusqu'à la date sélectionnée.","and":"et","Apr":"avr","months":"mois","Potential_Profit":"Gain Potentiel","over":"supérieur","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Les services financiers disponibles sur ce site conviennent uniquement aux Clients capables d’assumer la perte de l’ensemble des fonds qu’ils investissent, et qui comprennent et ont l’expérience des risques liés à l’acquisition de contrats financiers. Les transactions effectuées dans le cadre de contrats financiers présentent un niveau de risque élevé. Si les contrats achetés expirent sans valeur, vous subirez une perte totale de votre investissement, à savoir la prime du contrat.","Random":"Aléatoire","Sale_Date":"Date de Vente","Exercise_period":"Période d'exercice","February":"Février","Exclude_time_cannot_be_less_than_6_months_":"Le temps d'exclusion ne peut pas être moins de 6 mois.","Your_current_balance_is":"Votre solde actuel est de","Singapore_Index":"Indice Singapour","Duration":"Durée","This_contract_lost":"Ce contrat perdu","Indices_trading_frequency":"Fréquence de trading d'indices","Other_financial_instruments_trading_frequency":"Fréquence de trading d'instruments financiers","EUR_Index":"Indice EUR","Stop_Profit_Level":"Niveau stop-profit","Try_adding_more_letters_":"Essayez d'ajouter des lettres.","Egypt_Index":"Indice égyptien","Net_profit":"Bénéfice net","Status":"Statut","There_was_a_problem_accessing_the_server_during_purchase_":"Il y a eu un problème d'accès au serveur durant l'achat.","Adjust_trade_parameters":"Définir les paramètres de la transaction","Dutch_Stocks":"Actions Hollandaises","Over_$500,001":"Plus de $500,001","Th":"Je","Barrier_offset":"Compensation Barrière","Gold/USD":"Or/USD","Step":"Etape","Next_Day":"Jour suivant","Save_as_CSV":"Sauvegarder comme CSV","Loss":"Perte","Mo":"Lu","Other":"Autre","Health":"Santé","Dutch_Smart_Index":"Indice Intelligent Néerlandais","Tick":"Intervalle","letters":"lettres","under":"inférieur","Silver/USD":"Argent/USD","Energy":"Energie","Over_3_years":"Plus de 3 ans","From":"De","does_not_touch":"ne touche pas","hour":"heure","Credit_Agricole":"Crédit Agricole","View":"Voir","Sorry,_an_error_occurred_while_processing_your_account_":"Désolé, une erreur est survenu pendant le traitement de votre compte.","An_error_occured_":"Une erreur s'est produite.","New_Password":"Nouveau mot de passe","Trading_Limits":"Limites de Trading","German_Smart_Index":"Indice Intelligent Allemand","Details":"Informations","Invalid_amount,_minimum_is":"Montant non valide, le minimum est de","Maximum_account_cash_balance":"Solde de trésorerie maximal du compte","August":"août","Bombay_Index":"Indice Bombay","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Veuillez confirmer les détails de la transaction afin de compléter le transfert:","Euro_50_Smart_Index":"Indice Intelligent Euro 50","US_Tech_Composite_Index":"Indice US Tech Composite","Lock_Cashier":"Verrouiller la caisse","seconds":"secondes","Select_your_market":"Sélectionnez votre marché","Canadian_Index":"Indice Canadien","Finish":"Finnois","Gold/GBP":"Or/GBP","Oil/USD":"Pétrole/USD","Up/Down":"Haut/Bas","Mrs":"Mme","Profit_Table":"Tableau des bénéfices","Purchase":"Achat","Tourism":"Tourisme","Shenzhen_Index":"Indice Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Votre caisse est verrouillée conformément à votre demande - si vous souhaitez la déverrouiller, veuillez saisir le mot de passe.","Invalid_email_address":"Adresse email non valide","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Désolé, cette fonctionnalité est disponible uniquement pour les comptes virtuels.","Investment_Account":"Compte d'Investissement","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Vous n'êtes pas habilité à faire des retraits via un agent de paiement.","Miss":"Mlle","Wall_Street_Smart_Index":"Indice Intelligent Wall Street","Forex_trading_experience":"Expérience du trading Forex","Amount":"Montant","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Le nombre maximum de jetons d'authentification ([_1]) est atteint.","Withdrawal_Limits":"Limites de retrait","Print_chart":"Imprimer graphique","Please_try_again_":"Veuillez essayer une nouvelle fois.","Your_transaction_reference_is":"Votre référence de transaction est","Save_as_SVG":"Sauvegarder comme SVG","Profit/Loss":"Bénéfice/Perte","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Veuillez compléter votre Identifiant de connexion et le Montant que vous souhaitez transférer à votre Client dans le formulaire ci-dessous:","Commodities":"Matières premières","Transfer_to_Login_ID":"Transfert à l'Identifiant de Connexion","Update":"Mise à Jour","Fr":"Ve","goes_outside":"sort de","Chart":"Graphique","High_Barrier":"Barrière Supérieure","space":"espace","Portuguese_Smart_Index":"Indice Intelligent Portugais","Saturday":"Samedi","Never_Used":"Jamais utilisé","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Présente les gains cumulés maximaux sur les contrats actifs dans votre portefeuille. Si le maximum est atteint, vous ne pouvez pas acheter de contrats supplémentaires sans fermer d'abord des positions existantes.","Sell":"Vendre","Abu_Dhabi_Index":"Indice d'Abou Dabi","Euro_50_Index":"Indice Euro 50","October":"Octobre","Password_score_is:_[_1]__Passing_score_is:_20_":"Le niveau de sécurité du mot de passe est de : [_1]. Le niveau de sécurité minimum est de : 20.","Stays_In/Goes_Out":"Reste dans/Sort de la zone","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Représente le nombre maximal de contrats actifs dans votre portefeuille. Chaque ligne dans votre portefeuille compte pour une position ouverte. Une fois le maximum atteint, vous ne serez pas en mesure d'ouvrir de nouvelles positions sans d'abord fermer une position existante.","Italian_30_Index":"Indice Italien 30","Password_is_not_strong_enough_":"Le mot de passe n'est pas assez fiable.","Asset":"Actif","Swiss_Smart_Index":"Indice Intelligent Suisse","Airbus_Group":"Groupe Airbus","0-1_year":"0-1 an","Hong_Kong_Index":"Indice Hong Kong","Sorry,_account_opening_is_unavailable_":"Désolé, l'ouverture de compte est indisponible.","Barrier":"Barrière","Current_Level":"Niveau actuel","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Votre Client va recevoir un émail de notification l'informant que le transfert a été effectué.","Low_Barrier":"Barrière Inférieure","Previous_Day":"Jour précédent","IP_Address":"Adresse IP","Tu":"Ma","$100,000_-_$250,000":"100 000 $ - 250 000 $","Sale_Price":"Prix de vente","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Entrez la barrière sous forme de différence avec le prix ponctuel. Si vous entrez +0,005, vous achèterez un contrat avec une barrière supérieure de 0,005 au prix d'entrée. Le prix d'entrée sera celui du prochain intervalle après que votre ordre a été reçue","Short":"Court","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Veuillez confirmer le trade sur votre extrait avant de procéder.","Reset_Password":"Réinitialiser le Mot de Passe","Token":"Jeton d'authentification","Year":"Année","Other_financial_instruments_trading_experience":"Expérience du trading sur d'autres instruments financiers","Forex_trading_frequency":"Fréquence de trading Forex","Purchase_Time":"Heure d'Achat","Day":"Jour","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Une copie scannée de votre passeport ; de votre permis de conduire (provisoire ou normal) ou de votre carte d'identité, qui montre votre nom et date de naissance.","$250,000_-_$1,000,000":"250 000 $ - 1 000 000 $","Old_password_is_wrong_":"Ancien mot de passe est faux.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Votre demande de retirer [_1] [_2] de votre compte [_3] pour le compte de l'Agent de Paiement [_4] a été traitée avec succès.","Trading_and_Withdrawal_Limits":"Limites de Trading et de Retrait","High_barrier_offset":"Compensation barrière supérieure","Aug":"août","Are_you_sure_that_you_want_to_permanently_delete_token":"Êtes-vous sûr de vouloir supprimer le jeton d'authentification de façon permanente","Open":"Ouvert","KBC_Groep":"Groupe KBC","ends_outside":"Finit hors de","Russian_Regular_Index":"Indice Régulier de Russie","Feb":"Fév","The_two_passwords_that_you_entered_do_not_match_":"Les deux mots de passe que vous avez entrés ne correspondent pas.","This_field_is_required_":"Ce champ est requis.","Return":"Retour","Tertiary":"Tertiaire","$25,000_-_$100,000":"25 000 $ - 100 000 $","Swiss_Index":"Indice Suisse","AP_Ordinary":"AP Ordinaire","Indices_trading_experience":"Expérience du trading sur indices","6-10_transactions_in_the_past_12_months":"6-10 transactions dans les derniers 12 mois","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"min","day":"jour","Internal_Audit":"Audit interne","Save_as_JPEG":"Sauvegarder comme JPEG","Platinum/USD":"Platine/USD","Income_Source":"Source de Revenu","hours":"heures","Euro_100_Index":"Indice Euro 100","second":"seconde","Belgian_Stocks":"Actions Belges","Asia/Oceania":"Asie/Océanie","Italian_Index":"Indice Italien","lower":"inférieur","Country_Manager":"Responsable pays","April":"avril","Select_your_underlying_asset":"Sélectionnez votre actif sous-jacent","Last_Digit_Prediction":"Prédiction du Dernier Chiffre","Try_adding_more_letters_or_numbers_":"Essayez d'ajouter des lettres ou des chiffres.","US_Tech_100_Index":"Indice US Tech 100","Jakarta_Index":"Indice Jakarta","Purchase_Price":"Prix d'achat","XPD/EUR":"FPD/EUR","UK_Smart_Index":"Indice intelligent Royaume-Uni","days":"jours","Name":"Nom","Save_as_PNG":"Sauvegarder comme PNG","New_Zealand_Index":"Indice Nouvelle-Zélande","Electricite_de_France":"Électricité de France","Major_Pairs":"Paires majeures","Su":"Di","Jump_To":"Aller à","loading___":"chargement...","French_Index":"Indice Français","Closes":"Ferme","To":"Pour","Tuesday":"Mardi","Sorry,_this_feature_is_not_available_":"Désolé, cette option n'est pas disponible.","Select_market":"Sélectionnez marché","High_barrier":"Barrière supérieure","Closed":"Fermé","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Vous devez accepter les conditions générales pour ouvrir un compte.","Mar":"Mars","Dec":"Déc","Portuguese_Index":"Indice du Portugal","higher":"supérieur","Monday":"Lundi","differs":"diffère","Societe_Generale":"Société Générale","Oil/AUD":"Pétrole/AUD","Self-Employed":"Non-Salarié","Estimated_Net_Worth":"Valeur Nette Estimée","Binary_options_or_other_financial_derivatives_trading_frequency":"Fréquence de trading d'options binaires ou d'autres instruments dérivés","French_Smart_Index":"Indice Intelligent Français","Customer_Support":"Service à la clientèle","comma":"virgule","Last_Used":"Dernier utilisé","Oil/GBP":"Pétrole/GBP","Indian_50_Index":"Indice 50 d'Inde","Wall_Street_Index":"Indice Wall Street","Net_Annual_Income":"Revenu Annuel Net","40_transactions_or_more_in_the_past_12_months":"40 transactions ou plus dans les derniers 12 mois","Previous":"Précédent","Euro_150_Index":"Indice Euro 150","Investments_&_Dividends":"Investissements & Dividendes","Stocks_trading_frequency":"Fréquence de trading d'actions","Failed_to_update_trade_description_":"Échec de mise à jour de la description du trade","Stocks":"Actions","not_available":"non disponible","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"L'option des Agents de Paiement n'est pas disponible pour le moment dans votre pays.","Buy":"Achetez","Next":"Suivant","Friday":"Vendredi","Your_settings_have_been_updated_successfully_":"Vos paramètres ont été actualisés avec succès.","Your_password_cannot_be_the_same_as_your_email":"Votre mot de passe ne peut pas être identique à votre e-mail","Shanghai_Index":"Indice Shanghai","points":"croix","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Pour authentifier votre compte, veuillez envoyer par émail avec les informations suivantes à [_1]","December":"Décembre","Primary":"Principal","Try_adding_more_numbers_":"Essayez d'ajouter des chiffres.","Higher/Lower":"Supérieur/Inférieur","Stake":"Gain","Amount_per_point":"Montant par point de base","Total_Profit/Loss":"Gain/Perte Total","L'Oreal":"L'Oréal","Sorry,_an_error_occurred_while_processing_your_request_":"Désolé, une erreur s'est produite pendant le traitement de votre demande.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Représente le montant d'argent maximal que vous pouvez garder sur votre compte.  Si le maximum est atteint, il vous sera demandé de retirer des fonds.","Jun":"Juin","Confirm":"Confirmer","Back":"Retour","Balance":"Solde","Statement":"Relevé","ends_between":"Finit Entre","Japanese_Smart_Index":"Indice Intelligent Japonais","Select_your_trade_type":"Sélectionnez votre type de transaction","asian_down":"bas asiatique","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Nous ne pouvons pas diffuser des prix en direct en ce moment. Afin de profiter de la diffusion en direct de prix, veuillez rafraîchir la page, si vous avez ce problème après plusieurs tentatives, essayer un navigateur différent","Low_barrier":"Barrière inférieure","Commodities_trading_experience":"Expérience du trading sur matières premières","Minor_Pairs":"Paires mineures","Only_[_1]_are_allowed_":"Un maximum [_1] est autorisé.","Virtual_Account":"Compte Virtuel","Deposit":"Dépôt","French_Stocks":"Actions Françaises","Please_input_a_valid_date":"Veuillez saisir une date valide","years":"années","Sunday":"Dimanche","Explanation":"Explication","Please_wait_<br_/>Your_request_is_being_processed_":"Veuillez patienter.<br />Votre demande est en cours de traitement.","Irish_Index":"Indice Irlandais","Belgian_Index":"Indice Belge","Your_transaction_reference_number_is_[_1]":"Le numéro de référence de votre transaction est [_1]","January":"Janvier","Maximum_number_of_open_positions":"Nombre maximal de positions ouvertes","Start_Time":"Heure du Début","Exit_Level":"Niveau de sortie","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2]  ont été crédités sur votre compte d'argent virtuel [_3]","Please_submit_a_valid_[_1]_":"Veuillez saisir une [_1] valide.","Session_duration_limit_cannot_be_more_than_6_weeks_":"La limite de durée de la session ne peut excéder 6 semaines.","Ends_In/Out":"In/Out","Maximum_aggregate_payouts_on_open_positions":"Maximum de versements cumulés sur les positions ouvertes","UK_Index":"Indice GB","Credit/Debit":"Crédit/ Débit","End_Time":"Moment de Fin","There_was_a_problem_accessing_the_server_":"Il y a eu un problème d'accès au serveur.","year":"année","German_Index":"Indice Allemand","Brazilian_Index":"Indice du Brésil","November":"Novembre","South_African_Index":"Indice d'Afrique du Sud","Contract":"Contrat","Please_enter_a_valid_amount_":"Veuillez entrer un montant valide.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Veuillez introduire une date qui est au moins 6 mois plus tard.","$100,000_-_$500,000":"100 000 $ - 500 000 $","Ms":"Mme ou Mlle","May":"Mai","Profit":"Bénéfice","Exclude_time_must_be_after_today_":"Le temps d'exclusion doit être postérieur à aujourd'hui.","Rise/Fall":"Hausse/Baisse","Total_Cost":"Coût Total","Touch/No_Touch":"Touche","Hang_Seng_China":"Hang Seng Chine","Sell_at_market":"Vendre au marché","Maximum_daily_turnover":"Chiffre d'affaires maximal journalier","Commbank_(Australia)":"Commbank (Australie)","Last_Digit_Stats":"Stats du Dernier Chiffre","Compliance_Executive":"Chargé de conformité","Settles":"Configuration","Stocks_trading_experience":"Expérience du trading sur actions","Item":"Elément","Month":"Mois","Unlock_Cashier":"Déverrouiller la caisse","Middle_East":"Moyen-Orient","Pension":"Retraite","Low_barrier_offset":"Compensation barrière inférieure"};
texts_json['IT'] = {"Accounts_And_Payments_Executive":"Addetti Account e Pagamenti","Prices":"Prezzi","Stop_Loss_Level":"Livello dello Stop Loss","Please_select":"Seleziona","This_contract_won":"Questo contratto ha vinto","Oil/EUR":"Petrolio/EUR","US_Index":"Indice USA","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"La tua richiesta di trasferire [_1] [_2] da [_3] a [_4] è stata elaborata con successo.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Hai già prelevato l'equivalente complessivo di [_1] [_2] negli ultimi [_3] giorni.","Period":"Periodo","stays_between":"Rimane fra","Verification_Token":"Token di verifica","Deposit_of":"Deposito di","odd":"dispari","Wednesday":"Mercoledì","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Rappresenta il volume massimo di contratti che puoi acquistare in un dato giorno di trading.","Dubai_Index":"Indice di Dubai","month":"mese","Minimum_of_[_1]_characters_required_":"Sono richiesti minimo [_1] caratteri.","Industry_of_Employment":"Settore di occupazione","Human_Resource_Executive":"Addetti alle risorse umane","Opens":"Apre","Exit_Spot":"Prezzo di uscita","Potential_Payout":"Payout potenziale","Bull_Market_Index":"Indice Bull Market","Points":"Punti","Score":"Punteggio","Gold/AUD":"Oro/AUD","touches":"tocca","Secondary":"Secondario","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Il tuo limite di prelievo è [_2] [_1] (oppure equivalente in altra valuta).","Marketing_Executives":"Addetti al marketing","No_Live_price_update":"Nessun aggiornamento dei prezzi in tempo reale","Please_select_a_payment_agent":"Seleziona un agente di pagamento","Real_Account":"Account reale","Europe/Africa":"Europa/Africa","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Una copia scannerizzata di una bolletta o di un estratto conto (non antecedente i 3 mesi).","Spanish_Index":"Indice spagnolo","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Può essere utilizzata una password aggiuntiva per limitare l'accesso alla cassa.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Il tuo account è stato completamente convalidato e sono stati rimossi i tuoi limiti di prelievo.","Swedish_Index":"Indice Svezia","GBP_Index":"Indice GBP","Shenzhen_300_Index":"Indice di Shenzhen 300","Binary_options_or_other_financial_derivatives_trading_experience":"Esperienza di trading in opzioni binarie o altri prodotti finanziari derivati","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"La tua password è stata ripristinata con successo. Effettua il login sul tuo account utilizzando la tua nuova password.","Less_than_$100,000":"Meno di $100.000","Jul":"Lug","Upcoming_Events":"Prossimi eventi","minimum_available_duration":"durata minima disponibile","Gold/EUR":"Oro/EUR","Now":"Adesso","Construction":"Costruzione","Norwegian_Index":"Indice della Norvegia","Korean_Index":"Indice della Corea","Number_of_ticks":"Numero di tick","asian_up":"asiatiche up","Entry_Level":"Livello di entrata","Asians":"Asiatiche","September":"Settembre","Save_as_PDF":"Salva come PDF","Contract_Confirmation":"Conferma del contratto","numbers":"numeri","View_your_statement":"Mostra il tuo estratto","Delete":"Elimina","Profit/Loss_(points)":"Profitto/Perdita (punti)","AUD_Index":"Indice AUD","Continuous_Indices":"Indici continui","Quality_Assurance_Engineer":"Ingegnere per la garanzia della qualità","Digits":"Cifre","Quantitative_Developer":"Sviluppatore quantitativo","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"Al momento non accettiamo account di persone residenti in questo paese.","Australian_Index":"Indice Australia","Login_ID":"ID di accesso","0-5_transactions_in_the_past_12_months":"0-5 transazioni negli ultimi 12 mesi","Start_time":"Orario d'inizio","Americas":"America","Japanese_Index":"Indice giapponese","Salaried_Employee":"Lavoratore dipendente","There_was_some_invalid_character_in_an_input_field_":"Un campo di immissione testo conteneva uno o più caratteri non validi.","matches":"combacia","Long":"A lungo","is_required__Current_spread":"è richiesto. Spread attuale","Less_than_$25,000":"Meno di $25.000","Mr":"Sig.","Volatility_25_Index":"Indice Volatility 25","1-2_years":"1-2 anni","March":"Marzo","(Bejing/CST_-8_hours)":"(Pechino/CST -8 ore)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] ha aggiornato i suoi [_2]. Cliccando su OK, confermi di aver letto e accettato i [_2] aggiornati.","hyphen":"trattino","Invalid_amount,_maximum_is":"Importo non valido, il massimo è","US_Smart_Index":"Indice Smart USA","Week_of":"Settimana di","Entry_Spot":"Punto d'ingresso","You_should_enter_between_[_1]_characters_":"Dovresti inserire tra i [_1] caratteri.","Ref_":"Rif.","Contract_is_not_started_yet":"Il contratto non è ancora iniziato","Indicative":"Indicativo","Dutch_Index":"Indice olandese","Volatility_100_Index":"Indice Volatility 100","Metals":"Metalli","We":"Noi","Please_enter_a_number_between_0_and_[_1]":"Inserisci un numero compreso tra 0 e [_1]","Quantitative_Analyst":"Analista quantitativo","Level_of_Education":"Livello di istruzione","New_token_created_":"Nuovo token creato.","even":"pari","Authorise_your_account_":"Autorizza il tuo account.","Education":"Formazione","Contract_Sold":"Contratto venduto","Gaming_Account":"Account di gioco","July":"Luglio","June":"Giugno","Thursday":"Giovedì","Limit":"Limite","Smart_Indices":"Indici Smart","Your_details_have_been_updated_":"I tuoi dettagli sono stati aggiornati.","Over_$1,000,000":"Più di $1.000.000","Financial_Assessment":"Valutazione finanziaria","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Il tuo account [_1] non è disponibile. Per qualsiasi domanda contattare [_2].","Password_is_very_strong":"La password è molto forte","USD_Index":"Indice USD","Commodities_trading_frequency":"Frequenza del trading con le materie prime","Transfer_to":"Trasferisci a","Price":"Prezzo","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Pertanto il tuo attuale prelievo massimo immediato (soggetto alla disponibilità di fondi sufficienti nell'account) è pari a [_1] [_2].","ticks":"tick","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Quando clicchi su \"Ok\" verrai escluso dal trading sul sito fino alla data selezionata.","Questions":"Domande","and":"e","months":"mesi","Potential_Profit":"Profitto potenziale","over":"sopra","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"I servizi di trading finanziario contenuti in questo sito sono adatti solo per i Clienti in grado di subire la perdita di tutti i soldi investiti e che comprendono ed hanno esperienza dei rischi connessi all'acquisizione di contratti finanziari. Le transazioni su contratti finanziari hanno un alto livello di rischio. Se i contratti acquistati scadono in negativo, subirai una perdita totale del tuo investimento che consiste nel premio del contratto.","Sale_Date":"Data della vendita","Nocturnes":"Notturni","Exercise_period":"Periodo di prova","February":"Febbraio","Exclude_time_cannot_be_less_than_6_months_":"Il periodo di esclusione non può essere inferiore a 6 mesi.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Il tuo limite di prelievo giornaliero di [_1] è attualmente [_2] [_3] (oppure equivalente in un'altra valuta).","Copywriter":"Redattore Pubblicitario","Incyte_Corpoartion":"Incyte Corporation","Your_current_balance_is":"Il tuo saldo attuale è","Singapore_Index":"Indice Singapore","Duration":"Durata","This_contract_lost":"Questo contratto ha perso","Indices_trading_frequency":"Frequenza del trading con indici","Other_financial_instruments_trading_frequency":"Frequenza di trading con altri strumenti finanziari","Password_is_strong":"La password è forte","EUR_Index":"Indice EUR","Stop_Profit_Level":"Livello dello Stop Profit","Try_adding_more_letters_":"Cerca di aggiungere più lettere.","Egypt_Index":"Indice dell'Egitto","Net_profit":"Profitto netto","Status":"Stato","Santos_LimitedStar_Stock":"Azioni Santos LimitedStar","Verification_code_format_incorrect_":"Formato del codice di verifica non corretto.","There_was_a_problem_accessing_the_server_during_purchase_":"Durante l'acquisto si è verificato un problema d'accesso al server.","Adjust_trade_parameters":"Regola i parametri di trading","Dutch_Stocks":"Azioni Olanda","Over_$500,001":"Più di $500.001","Th":"Gio","Oct":"Ott","Even/Odd":"Pari/Dispari","Barrier_offset":"Correzione della barriera","This_feature_is_not_relevant_to_virtual-money_accounts_":"Questa funzione non è riferita agli account con denaro virtuale.","Gold/USD":"Oro/USD","Password_should_have_lower_and_uppercase_letters_with_numbers_":"La password deve contenere lettere minuscole e maiuscole con numeri.","Next_Day":"Giorno successivo","Applications":"Applicazioni","Save_as_CSV":"Salva come CSV","Internal_Auditor":"Revisore interno","Loss":"Perdita","Mo":"Lun","Other":"Altro","Health":"Salute","Dutch_Smart_Index":"Indice Smart olandese","letters":"lettere","under":"sotto","Silver/USD":"Argento/USD","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Le statistiche delle ultime cifre per i [_1] tick più recenti su [_2]","Energy":"Energia","Over_3_years":"Più di 3 anni","From":"Da","does_not_touch":"non tocca","hour":"ora","View":"Mostra","Sorry,_an_error_occurred_while_processing_your_account_":"Siamo spiacenti, si è verificato un errore durante l'elaborazione del tuo account.","An_error_occured_":"Si è verificato un errore.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Pertanto il tuo attuale prelievo massimo immediato (soggetto alla disponibilità di fondi sufficienti nell'account) è pari a [_1] [_2] (o equivalente in un'altra valuta).","Russian_10_Index":"Indice Russo 10","New_Password":"Nuova password","Trading_Limits":"Limiti del trading","German_Smart_Index":"Indice Smart tedesco","Details":"Dettagli","Login_History":"Cronologia dei login","Invalid_amount,_minimum_is":"Importo non valido, il minimo è","minute":"minuto","Please_deposit_before_transfer_to_client_":"Deposita prima di trasferire al cliente.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Segui il modello con 3 numeri, un trattino e 4 numeri.","Password_Reset":"Reset della password","Maximum_account_cash_balance":"Saldo di cassa massimo sull'account","August":"Agosto","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Il tuo account è stato pienamente convalidato. Puoi vedere i tuoi limiti di trading di [_1] qui","Bombay_Index":"Indice di Bombay","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Per completare il trasferimento, conferma i dettagli della transazione:","Euro_50_Smart_Index":"Indice Smart Euro 50","US_Tech_Composite_Index":"Indice composto US Tech","Lock_Cashier":"Blocca la Cassa","Sa":"Sab","seconds":"secondi","Matches/Differs":"Combacia/Differisce","Select_your_market":"Seleziona il tuo mercato","apostrophe":"apostrofo","Canadian_Index":"Indice canadese","Finish":"Termina","Gold/GBP":"Oro/GBP","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"La password deve contenere almeno 1 numero, 1 lettera maiuscola e 1 lettera minuscola.","Oil/USD":"Petrolio/USD","False":"Falso","Human_Resources":"Risorse umane","Mrs":"Sig.ra","Profit_Table":"Tabella dei profitti","Purchase":"Acquisto","Tourism":"Turismo","Shenzhen_Index":"Indice di Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Come da tua richiesta, la cassa è bloccata. Per sbloccarla, inserisci la password.","Invalid_email_address":"Indirizzo email non valido","Please_enter_an_integer_value":"Inserisci un numero intero","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Siamo spiacenti, questa funzione è disponibile solo sugli account virtuali.","Investment_Account":"Account d'investimento","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Non sei autorizzato a prelevare tramite un agente di pagamento.","Quantitative_Analysis":"Analisi quantitativa","Miss":"Sig.ra","Wall_Street_Smart_Index":"Indice Smart Wall Street","Please_check_your_email_for_the_value_of_this_token":"Verifica il tuo indirizzo e-mail per il valore di questo token","Forex_trading_experience":"Esperienza di trading su Forex","Amount":"Importo","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Il numero massimo di token ([_1]) è stato raggiunto.","Global_Customer_Service_Representatives":"Rappresentati del Servizio Clienti globale","Withdrawal_Limits":"Limiti per i Prelievi","Print_chart":"Stampa grafico","Please_try_again_":"Riprova.","Your_transaction_reference_is":"Il tuo riferimento per le transazioni è","Compliance":"Conformità","Save_as_SVG":"Salva come SVG","You_have_already_withdrawn_[_1]_[_2]_":"Hai già prelevato [_1] [_2].","Profit/Loss":"Profitto/Perdita","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Inserisci l'ID di accesso e l'Importo che desideri trasferire al tuo Cliente nel modulo sottostante:","Password_does_not_match_":"La password non corrisponde.","Commodities":"Materie prime","Transfer_to_Login_ID":"Trasferisci a ID di login","Update":"Aggiorna","Fr":"Ven","Volatility_75_Index":"Indice Volatility 75","goes_outside":"esce fuori","Chart":"Grafico","High_Barrier":"Barriera superiore","Date_of_Birth":"Data di nascita","space":"spazio","Portuguese_Smart_Index":"Indice Smart Portogallo","Saturday":"Sabato","Never_Used":"Mai utilizzato","Volatility_50_Index":"Indice Volatility 50","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Presenta i payout complessivi massimi sui contratti in essere nel tuo portafoglio. Se si raggiunge il numero massimo, non sarà possibile acquistare altri contratti senza prima chiudere delle posizioni esistenti.","Description":"Descrizione","Sell":"Vendi","Abu_Dhabi_Index":"Indice di Abu Dhabi","Euro_50_Index":"Indice Euro 50","October":"Ottobre","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Attualmente sei sul tuo account reale con [_1] ([_2]).","Office_worker":"Impiegato","Terms_&_Conditions":"Termini e condizioni","Only_2_decimal_points_are_allowed_":"Sono consentite solo 2 cifre decimali.","period":"periodo","Password_score_is:_[_1]__Passing_score_is:_20_":"Il punteggio della password è: [_1]. Il punteggio minimo è: 20.","Stays_In/Goes_Out":"Stays In (Rimane in) / Goes Out (Esce fuori)","Note":"Nota","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Rappresenta il numero massimo di contratti in essere nel tuo portafoglio. Ogni riga presente sul tuo portafoglio vale una posizione aperta. Una volta raggiunto il valore massimo, non potrai aprire nuove posizioni senza prima chiudere una posizione esistente.","Italian_30_Index":"Indice Italia 30","Password_is_not_strong_enough_":"La password non è sufficientemente forte.","Swiss_Smart_Index":"Indice Smart svizzero","0-1_year":"da 0 a 1 anno","Contract_Information":"Informazioni del contratto","Translator":"Traduttore","Hong_Kong_Index":"Indice di Hong Kong","Sorry,_account_opening_is_unavailable_":"Siamo spiacenti, l'apertura di account non è disponibile.","Anti-Fraud_Officer":"Responsabile Anti-frodi","Barrier":"Barriera","Current_Level":"Livello attuale","Password_is_moderate":"La password è discreta","Failed_to_reset_password__[_1],_please_retry_":"Ripristino della password non riuscito. [_1], riprova.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Il tuo Cliente riceverà un'email di notifica in cui gli viene comunicato che il trasferimento è stato elaborato.","Low_Barrier":"Barriera inferiore","Previous_Day":"Giorno precedente","Senior_Perl_Developer":"Sviluppatore Senior Perl","IP_Address":"Indirizzo IP","Tu":"Mar","$100,000_-_$250,000":"$100.000 - $250.000","Senior_Front-End_Developer":"Sviluppatore Senior front-end","Sale_Price":"Prezzo di vendita","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Inserisci il limite in termini di differenza dal prezzo spot. Se inserisci +0.005, allora starai acquistando un contratto con un limite 0.005 più alto rispetto al punto d'ingresso. Quest'ultimo sarà il tick successivo dopo aver ricevuto l'ordine","Social_Media_Executive":"Addetti ai social media","Short":"Breve","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Prima di procedere, conferma il trade sul tuo estratto.","Reset_Password":"Ripristina password","Year":"Anno","Other_financial_instruments_trading_experience":"Esperienza di trading con altri strumenti finanziari","Forex_trading_frequency":"Frequenza di trading su Forex","Purchase_Time":"Orario d'acquisto","Day":"Giorno","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Una copia scannerizzata del tuo passaporto, patente (provvisoria o definitiva) o carta d'identità, indicante il tuo nome e la tua data di nascita.","$250,000_-_$1,000,000":"$250.000 - $1.000.000","Old_password_is_wrong_":"La password vecchia è errata.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"La tua richiesta di prelevare [_1] [_2] dal tuo account [_3] all'account dell'Agente di pagamento [_4] è stata elaborata con successo.","DevOps_Manager":"Manager DevOps","Trading_and_Withdrawal_Limits":"Limiti di trading e dei prelievi","High_barrier_offset":"Sfasamento della barriera superiore","Aug":"Ago","Are_you_sure_that_you_want_to_permanently_delete_token":"Sei sicuro di voler eliminare definitivamente il token","Open":"Apri","ends_outside":"termina fuori","You_did_not_change_anything_":"Non hai modificato nulla.","Russian_Regular_Index":"Indice regolare russo","Over/Under":"Sopra/Sotto","The_two_passwords_that_you_entered_do_not_match_":"Le due password inserite non combaciano.","Failed":"Non riuscito","You_have_not_granted_access_to_any_apps_":"Non hai accesso ad alcuna applicazione.","Stop-loss":"Stop Loss","This_field_is_required_":"Questo campo è obbligatorio.","Return":"Rendimento","Tertiary":"Terziario","$25,000_-_$100,000":"$25.000 - $100.000","Swiss_Index":"Indice svizzero","AP_Ordinary":"AP Ordinario","Indices_trading_experience":"Esperienza di trading con gli indici","6-10_transactions_in_the_past_12_months":"6-10 transazioni negli ultimi 12 mesi","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Una volta cliccato sul pulsante \"Invia\", i fondi verranno prelevati dal tuo account e trasferiti sull'account del tuo Cliente.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"minimo ","True":"Vero","day":"giorno","Internal_Audit":"Revisione interna","Save_as_JPEG":"Salva come JPEG","Platinum/USD":"Platino/USD","Income_Source":"Fonte di reddito","hours":"ore","Euro_100_Index":"Indice Euro 100","second":"secondo","Belgian_Stocks":"Azioni Belgio","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Hai già prelevato l'equivalente di [_1] [_2].","Date":"Data","Italian_Index":"Indice italiano","Waiting_for_entry_tick_":"In attesa del tick d'ingresso.","lower":"inferiore","Confirm_New_Password":"Conferma la nuova password","Country_Manager":"Manager del paese","April":"Aprile","Select_your_underlying_asset":"Scegli il tuo asset sottostante","Last_Digit_Prediction":"Previsione dell'ultima cifra","Try_adding_more_letters_or_numbers_":"Prova ad aggiungere più lettere o numeri.","US_Tech_100_Index":"Indice US Tech 100","Sep":"Sett","Jakarta_Index":"Indice Jakarta","Purchase_Price":"Prezzo d'acquisto","UK_Smart_Index":"Indice Smart Regno Unito","days":"giorni","Never":"Mai","Name":"Nome","Save_as_PNG":"Salva come PNG","New_Zealand_Index":"Indice Nuova Zelanda","Major_Pairs":"Coppie principali","Su":"Dom","Please_enter_a_number_between_[_1]_":"Inserisci un numero compreso tra [_1].","Marketing_Project_Manager":"Project Manager commerciale","Jump_To":"Salta a","loading___":"caricamento...","Accounting":"Contabilità","French_Index":"Indice Francia","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Quando clicchi su \"Ok\" verrai escluso dal trading sul sito fino alla data selezionata.","Spot_Time":"Orario dello spot","Closes":"Chiude","To":"A","Istanbul_Index":"Indice di Instanbul","Reference_ID":"ID di riferimento","Administrative_Executive":"Addetti Amministrazione","Tuesday":"Martedì","Sorry,_this_feature_is_not_available_":"Siamo spiacenti, questa funzione non è disponibile.","Select_market":"Seleziona il mercato","High_barrier":"Barriera superiore","Closed":"Chiuso","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Per aprire un account, devi accettare i termini e le condizioni.","Dec":"Dic","General_Motors_Company":"General Motors","Portuguese_Index":"Indice Portogallo","higher":"superiore","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Deposita il denaro virtuale di [_1] [_2] sul suo account [_3]","Jan":"Gen","Monday":"Lunedì","differs":"differisce","Current":"Attuale","Predict_the_direction<br_/>and_purchase":"Prevedi la direzione<br />e acquista","Oil/AUD":"Petrolio/AUD","Self-Employed":"Lavoratore autonomo","Estimated_Net_Worth":"Valore netto stimato","Binary_options_or_other_financial_derivatives_trading_frequency":"Frequenza del trading in opzioni binarie o altri prodotti finanziari derivati","Action":"Azione","French_Smart_Index":"Indice Smart francese","Customer_Support":"Assistenza clienti","comma":"virgola","minutes":"minuti","Last_Used":"Ultimo utilizzato","Oil/GBP":"Petrolio/GBP","Indian_50_Index":"Indice Indian 50","Wall_Street_Index":"Indice Wall Street","Kuwait_Index":"Indice del Kuwait","This_contract_has_LOST":"Questo contratto ha PERSO","Net_Annual_Income":"Reddito annuale netto","40_transactions_or_more_in_the_past_12_months":"40 transazioni o più negli ultimi 12 mesi","Previous":"Precedente","Euro_150_Index":"Indice Euro 150","Investments_&_Dividends":"Investimenti e Dividendi","Stocks_trading_frequency":"Frequenza del trading in azioni","Your_withdrawal_limit_is_[_1]_[_2]_":"Il tuo limite di prelievo è [_1] [_2].","Failed_to_update_trade_description_":"Impossibile aggiornare la descrizione del trade.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Inserisci un numero maggiore o uguale a [_1].","Bear_Market_Index":"Indice Bear Market","Stocks":"Azioni","not_available":"non disponibile","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"La funzione dell'Agente di pagamento al momento non è disponibile nel tuo paese.","Buy":"Acquista","Exclude_time_cannot_be_for_more_than_5_years_":"Il periodo di esclusione non può essere superiore a 5 anni.","Next":"Successivo","Friday":"Venerdì","Your_account_has_no_trading_activity_":"Sul tuo account non c'è alcuna attività di trading.","Your_trading_statistics_since_[_1]_":"Le tue statistiche di trading dal [_1].","Your_settings_have_been_updated_successfully_":"Le tue impostazioni sono state aggiornate con successo.","Your_password_cannot_be_the_same_as_your_email":"La tua password non può essere uguale alla tua email","Please_select_a_valid_date":"Seleziona una data valida","Walkthrough_Guide":"Guida dettagliata","Shanghai_Index":"Indice Shanghai","verification_token":"token di verifica","points":"punti","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Per convalidare il tuo account, ti chiediamo gentilmente di inviare quanto segue tramite email all'indirizzo [_1]","Contract_Expiry":"Scadenza del contratto","December":"Dicembre","Quality_Assurance":"Garanzia della qualità","Primary":"Primario","Revoke_access":"Revocare l'accesso","Saudi_Arabia_Index":"Indice dell'Arabia Saudita","Try_adding_more_numbers_":"Cerca di aggiungere più numeri.","Password_is_weak":"La password è debole","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Attualmente sei sul tuo account virtuale ([_2]).","Higher/Lower":"High/Low","Stake":"Puntata","Amount_per_point":"Importo per punto","Date_and_Time":"Data e orario","Total_Profit/Loss":"Profitto/Perdita totale","Sorry,_an_error_occurred_while_processing_your_request_":"Siamo spiacenti, si è verificato un errore durante l'elaborazione della tua richiesta.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Rappresenta l'importo massimo di denaro che può essere tenuto sul tuo account. Se raggiungi tale valore massimo, ti verrà richiesto di prelevare fondi.","Jun":"Giu","Confirm":"Conferma","Back":"Precedente","Balance":"Saldo","Statement":"Estratto","ends_between":"finisce tra","Japanese_Smart_Index":"Indice Smart Giappone","Your_account_has_no_Login/Logout_activity_":"Sul tuo account non c'è alcuna attività di Login/Logout.","Select_your_trade_type":"Seleziona la tua tipologia di trade","asian_down":"asiatiche down","Exit_Spot_Time":"Orario del prezzo di uscita","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Al momento non siamo in grado di trasmettere i prezzi in tempo reale. Per godere dello streaming live dei prezzi, prova a riaggiornare la pagina, se dopo vari tentativi si verifica sempre lo stesso problema, prova un browser diverso","Low_barrier":"Barriera inferiore","Commodities_trading_experience":"Esperienza di trading con le materie prime","Minor_Pairs":"Coppie minori","Spreads":"Spread","Contract_ID":"ID del contratto","Only_[_1]_are_allowed_":"Sono consentiti solo 1%.","Virtual_Account":"Account virtuale","Our_site_does_not_charge_any_transfer_fees_":"Il nostro sito non applica alcuna commissione sui trasferimenti di denaro.","Daily_Reset_Indices":"Indici di Reset giornalieri","Deposit":"Deposita","French_Stocks":"Azioni Francia","Please_input_a_valid_date":"Inserisci una data valida","years":"anni","Sunday":"Domenica","Explanation":"Spiegazione","This_contract_has_WON":"Questo contratto ha VINTO","Please_wait_<br_/>Your_request_is_being_processed_":"Attendi.<br />La tua richiesta sta per essere elaborata.","Irish_Index":"Indice irlandese","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Il tuo account [_1] non è disponibile. Per qualsiasi domanda contattare [_2].","Volatility_Indices":"Indici di volatilità","Belgian_Index":"Indice belga","Palladium/USD":"Palladio/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Il tuo token è scaduto. Clicca <a class=\"pjaxload\" href=\"[_1]\">qui</a> per riavviare la procedura di verifica.","Remaining_Time":"Tempo residuo","Your_transaction_reference_number_is_[_1]":"Il tuo numero di riferimento per le transazioni è [_1]","January":"Gennaio","There_was_an_error":"Si è verificato un errore","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Formato: aaaa-mm-gg (non richiesto per gli account di denaro virtuale)","Maximum_number_of_open_positions":"Numero massimo di posizioni aperte","Start_Time":"Orario di inizio","Exit_Level":"Livello di uscita","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] sono stati accreditati sul tuo Account di moneta virtuale [_3]","Please_submit_a_valid_[_1]_":"Invia un [_1] valido.","Session_duration_limit_cannot_be_more_than_6_weeks_":"Il limite di durata della sessione non può essere superiore a 6 settimane.","Ends_In/Out":"Termina In/Out","Indices":"Indici","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"Il Contratto verrá venduto al prezzo di mercato prevalente nel momento in cui i nostri server ricevono la richiesta. Tale prezzo può differire rispetto al prezzo indicato.","Maximum_aggregate_payouts_on_open_positions":"Payout totali massimi su posizioni aperte","UK_Index":"Indice del Regno Unito","Credit/Debit":"Credito/Debito","End_Time":"Orario di fine","There_was_a_problem_accessing_the_server_":"Si è verificato un problema d'accesso al server.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Verifica il tuo indirizzo e-mail per ottenere il token necessario per ripristinare la tua password.","year":"anno","German_Index":"Indice tedesco","Brazilian_Index":"Indice brasiliano","Finance":"Finanza","Graphic_Designers":"Graphic Designer","Administrator":"Amministratore","November":"Novembre","South_African_Index":"Indice del Sudafrica","Contract":"Contratto","Keep_track_of_your_authorised_applications_":"Tieni traccia delle tue applicazioni autorizzate.","Please_enter_a_valid_amount_":"Inserisci un importo valido.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Inserisci una data che sia distante almeno 6 mesi a partire da oggi.","$100,000_-_$500,000":"$100.000 - $500.000","Your_changes_have_been_updated_":"Le tue modifiche sono state aggiornate.","Ms":"Sig.ra","May":"Mag","Profit":"Profitto","Exclude_time_must_be_after_today_":"Il periodo di esclusione deve essere successivo a oggi.","Rise/Fall":"Rialzo/Ribasso","Total_Cost":"Costo totale","Touch/No_Touch":"Touch/No touch","Invalid_date_of_birth_":"Data di nascita non valida.","Sell_at_market":"Vendi sul mercato","Date_(GMT)":"Data (GMT)","Maximum_daily_turnover":"Turnover massimo giornaliero","You_have_sold_this_contract_at_[_1]_[_2]":"Hai venduto questo contratto a [_1] [_2]","Last_Digit_Stats":"Statistiche sull'ultima cifra","Permissions":"Autorizzazioni","Compliance_Executive":"Esecutivo di conformità","Settles":"Liquida","Stocks_trading_experience":"Esperienza di trading con azioni","Item":"Voce","Month":"Mese","Successful":"Riuscito","Unlock_Cashier":"Sblocca Cassa","Middle_East":"Medio Oriente","Pension":"Pensione","Low_barrier_offset":"Scostamento della barriera inferiore"};
texts_json['PT'] = {"Accounts_And_Payments_Executive":"Executivo de contas e pagamentos","Prices":"Preços","Stop_Loss_Level":"Nível do limite de perdas","Please_select":"Selecione","This_contract_won":"Esse contrato ganhou","Oil/EUR":"Petróleo/EUR","Spot":"Preço atual","US_Index":"Índice USA","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"O seu pedido para transferir [_1] [_2] de [_3] para [_4] foi processado com sucesso.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Você já retirou o equivalente a [_1] [_2] em agregado durante os últimos [_3] dias.","Payout":"Prêmio","Period":"Período","stays_between":"fica entre","Verification_Token":"Token de verificação","Deposit_of":"Depósito de","odd":"número ímpar","Wednesday":"Quarta-feira","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Representa o volume máximo de contratos que pode comprar em qualquer dia de negociações.","Director":"Diretor","Dubai_Index":"Índice de Dubai","month":"mês","Minimum_of_[_1]_characters_required_":"Um mínimo de [_1] caracteres é necessário.","In/Out":"Dentro/Fora","Industry_of_Employment":"Indústria de emprego","Human_Resource_Executive":"Executivo de recursos humanos","Opens":"Abre","Exit_Spot":"Preço de saída","Potential_Payout":"Possível Prêmio","Bull_Market_Index":"Índice \"Mercado em Alta\"","Points":"Pontos","Score":"Classificação","ITC_Ltd":"ITC Ltda","Gold/AUD":"Ouro/AUD","touches":"toca","Secondary":"Ensino Secundário","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"O seu limite de retiradas é [_1] [_2] (ou equivalente em outra moeda).","Legrand_electrical_components_&_equipm":"Legrand - componentes e equipamento elétricos","Marketing_Executives":"Executivos de marketing","No_Live_price_update":"Sem atualização de preço ao vivo","Please_select_a_payment_agent":"Selecione um valor agente de pagamentos","Real_Account":"Conta Real","Europe/Africa":"Europa/África","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Uma cópia digitalizada de uma conta de serviços públicos ou extrato de conta bancária (não deverão ter mais de três meses).","Spanish_Index":"Índice Espanhol","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Uma senha adicional pode ser usada para restringir acesso ao caixa.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"A sua conta está totalmente autenticada e os seus limites de retirada de fundos foram aumentados.","Swedish_Index":"Índice Sueco","GBP_Index":"Índice GBP","Shenzhen_300_Index":"Índice Shenzhen 300","Binary_options_or_other_financial_derivatives_trading_experience":"Experiência com negociações de opções binárias ou outros derivados financeiros","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"A sua senha foi redefinida com sucesso. Por favor, inicie sessão na sua conta, usando a sua nova senha.","Less_than_$100,000":"Menos de $100.000","Upcoming_Events":"Próximos Eventos","minimum_available_duration":"duração mínima disponível","Gold/EUR":"Ouro/EUR","Now":"Agora","Construction":"Construção","Norwegian_Index":"Índice Norueguês","Korean_Index":"Índice Coreano","Number_of_ticks":"Número de tique-taques","asian_up":"Alta Asiática","Entry_Level":"Nível básico","Asians":"Asiáticas","September":"Setembro","Save_as_PDF":"Salve como PDF","Contract_Confirmation":"Confirmação de Contrato","numbers":"números","View_your_statement":"Veja o seu extrato","Delete":"Excluir","Profit/Loss_(points)":"Ganho/Perda (pontos)","AUD_Index":"Índice AUD","Continuous_Indices":"Índices Contínuos","Quality_Assurance_Engineer":"Engenheiro de garantia de qualidade","Information_Technology":"Tecnologias de informação","Digits":"Dígitos","AstraZeneca_plc":"AstraZeneca","Quantitative_Developer":"Desenvolvedor quantitativo","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"Não aceitamos atualmente contas de residentes deste país.","Browser":"Navegador","Australian_Index":"índice Australiano","Login_ID":"ID de Login","0-5_transactions_in_the_past_12_months":"0-5 transações nos últimos 12 meses","Start_time":"Hora de início","Americas":"Américas","Japanese_Index":"Índice Japonês","Salaried_Employee":"Trabalhador assalariado","Deutsche_Bank_AG":"Deutsche Bank","There_was_some_invalid_character_in_an_input_field_":"Houve algum caractere inválido no campo de entradas.","matches":"Combina","Long":"Longo","is_required__Current_spread":"é obrigatório. Spread atual","Less_than_$25,000":"Menos de $25.000","Mr":"Sr.","Volatility_25_Index":"Índice Volatility 25","1-2_years":"1-2 anos","March":"Março","(Bejing/CST_-8_hours)":"(Pequim/CST -8 horas)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"A [_1] atualizou os seus [_2]. Ao clicar em OK, você confirma que leu e aceita os [_2] atualizados.","hyphen":"hífen","Smart_FX":"Inteligente FX","Invalid_amount,_maximum_is":"Valor inválido, o máximo é","US_Smart_Index":"Índice Inteligente dos EUA","Week_of":"Semana de","Entry_Spot":"Preço de entrada","You_should_enter_between_[_1]_characters_":"Você dever inserir entre [_1] caracteres.","Contract_is_not_started_yet":"O contrato ainda não foi iniciado","QUALCOMM":"Qualcomm","Indicative":"Indicativo","Dutch_Index":"Índice Holandês","EUR/BRL":"EUR/GBRL","Volatility_100_Index":"Índice Volatility 100","Metals":"Metais","We":"Qua","Please_enter_a_number_between_0_and_[_1]":"Digite um número entre 0 e [_1]","Quantitative_Analyst":"Análise quantitativa","Level_of_Education":"Nível de Instrução","New_token_created_":"Novo token criado.","even":"número par","Hedging":"Cobertura","Authorise_your_account_":"Autorize a sua conta.","Education":"Formação","Contract_Sold":"Contrato vendido","Gaming_Account":"Conta de Jogos","July":"Julho","June":"Junho","Infosys_Ltd":"Infosys Ltda","Thursday":"Quinta-feira","Limit":"Limite","Smart_Indices":"Índices Inteligentes","Your_details_have_been_updated_":"As suas informações foram atualizadas.","Over_$1,000,000":"Mais de $100.000","Financial_Assessment":"Avaliação financeira","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"A sua conta [_1] não está disponível. Para qualquer questão, contate o [_2].","Password_is_very_strong":"A senha é muito forte","USD_Index":"Índice USD","ANZ_Banking_Group_Ltd":"Australia and New Zealand Banking Group Ltd (ANZ)","USD/MXN":"USD/MXR","Both_the_above":"Ambos acima","HDFC_Bank_Ltd":"HDFC Bank Ltda","password":"senha","Stop-type":"Tipo de limite","Commodities_trading_frequency":"Frequência de negociação de matérias-primas","Transfer_to":"Transferir para","Price":"Preço","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Portanto, a sua retirada máxima imediata atual (sujeita à existência de fundos suficientes na sua conta) é [_1] [_2].","ticks":"tique-taques","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Quando você clicar em 'Ok', você será excluído das negociações no site até a data escolhida.","Questions":"Perguntas","and":"e","Apr":"Abr","months":"meses","Potential_Profit":"Lucro Potencial","over":"acima","Reliance_Industries_Ltd":"Reliance Industries Ltda","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Os serviços de negociação financeira contidos neste site são adequados apenas para clientes que sejam capazes de suportar a perda de todo o dinheiro que investem e que entendem e têm experiência nos riscos envolvidos na aquisição de contratos financeiros. As transações em contratos financeiros têm um elevado grau de risco. Se os contratos adquiridos finalizarem sem valor, você sofrerá uma perda total do seu investimento, que consistirá no prêmio do contrato.","Random":"Random (Aleatório)","Sale_Date":"Data de Venda","Nocturnes":"Noturno","Exercise_period":"Período do exercício","February":"Fevereiro","Exclude_time_cannot_be_less_than_6_months_":"O tempo de exclusão não pode ser inferior a seis meses.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"O seu limite de retiradas de [_1] dia(s) é atualmente [_2] [_3] (ou equivalente em outra moeda).","Copywriter":"Redator","Incyte_Corpoartion":"Incyte Corporation","Your_current_balance_is":"O seu saldo atual é","Singapore_Index":"Índice de Singapura","Duration":"Duração","This_contract_lost":"Esse contrato perdeu","Indices_trading_frequency":"Frequência de negociação de índices","Other_financial_instruments_trading_frequency":"Frequência de negociação de outros instrumentos financeiros","Password_is_strong":"A senha é forte","EUR_Index":"Índice EUR","Stop_Profit_Level":"Nível do limite de ganhos","Try_adding_more_letters_":"Experimente adicionar mais letras.","Egypt_Index":"Índice de Egito","Net_profit":"Lucro líquido","Status":"Estado","Verification_code_format_incorrect_":"Formato incorreto de código de verificação.","There_was_a_problem_accessing_the_server_during_purchase_":"Ocorreu um problema ao aceder ao servidor durante a aquisição.","Adjust_trade_parameters":"Ajustar parâmetros de negociação","Others":"Outros","Dutch_Stocks":"Ações Holandesas","Over_$500,001":"Mais de $500.001","Th":"Qui","Oct":"Out","Even/Odd":"Par/Ímpar","Barrier_offset":"Compensação de Barreira","Over_5_years":"Mais de 5 anos","This_feature_is_not_relevant_to_virtual-money_accounts_":"Este recurso não é relevante para as contas de dinheiro virtual.","Gold/USD":"Ouro/USD","Password_should_have_lower_and_uppercase_letters_with_numbers_":"A senha deve conter letras minúsculas, maiúsculas e números.","Step":"Etapa","Next_Day":"Dia seguinte","BHP_Billiton_Ltd":"BHP Billiton Ltda","Applications":"Aplicativos","Save_as_CSV":"Salve como CVS","Internal_Auditor":"Auditor interno","Loss":"Perda","Mo":"Seg","Other":"Outro","Health":"Saúde","Dutch_Smart_Index":"Índice Inteligente Holandês","Tick":"Tique-taque","letters":"caracteres","under":"abaixo","Silver/USD":"Prata/USD","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Estatísticas dos últimos dígitos dos últimos [_1] tique-taques de [_2]","Energy":"Energia","Over_3_years":"Mais de 3 anos","From":"De","does_not_touch":"não toca","hour":"hora","View":"Ver","Sorry,_an_error_occurred_while_processing_your_account_":"Lamentamos, ocorreu um erro durante o processamento da sua conta.","An_error_occured_":"Ocorreu um erro.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Portanto, a sua retirada máxima imediata atual (sujeito à existência de fundos suficientes na sua conta) é [_1] [_2] (ou equivalente em outra moeda).","Russian_10_Index":"Índice Russo 10","New_Password":"Nova Senha","Trading_Limits":"Limites de Negociação","German_Smart_Index":"Índice Inteligente Alemão","Details":"Dados","Login_History":"Histórico de logins","Invalid_amount,_minimum_is":"Valor inválido, o mínimo é","Technip_oil_equipment_and_services":"Technip - Equipamentos de óleo e serviços","minute":"minuto","Public_worker":"Funcionário público","Please_deposit_before_transfer_to_client_":"Deposite antes de transferir para o cliente.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Siga o padrão: 3 números, um hífen, seguidos por 4 números.","Password_Reset":"Redefinição de senha","Maximum_account_cash_balance":"Saldo máximo em conta","August":"Agosto","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"A sua conta está totalmente autenticada. É possível consultar os seus limites de negociação [_1] aqui","Bombay_Index":"Índice de Bombaim","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Confirme os detalhes da transação para concluir a transferência:","Euro_50_Smart_Index":"Índice Inteligente Euro 50","US_Tech_Composite_Index":"Índice US Tech Composite","Lock_Cashier":"Bloquear Caixa","Sa":"Sáb","seconds":"segundos","Matches/Differs":"Combina/Difere","Select_your_market":"Selecione o seu mercado","apostrophe":"apóstrofe","Canadian_Index":"Índice Canadense","Finish":"Terminar","Gold/GBP":"Ouro/GBP","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"A senha deve conter pelo menos um número, uma maiúscula e uma minúscula.","Oil/USD":"Petróleo/USD","False":"Falso","Up/Down":"Acima/Abaixo","Human_Resources":"Recursos humanos","Mrs":"Sra.","Profit_Table":"Tabela de Lucros","Purchase":"Comprar","Tourism":"Turismo","Shenzhen_Index":"Índice de Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"O seu caixa está bloqueado conforme pedido - para desbloqueá-lo, digite a senha.","Invalid_email_address":"Endereço de e-mail inválido","Please_enter_an_integer_value":"Insira um valor inteiro","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Lamentamos, este recurso está disponível somente para contas virtuais.","Investment_Account":"Conta de Investimento","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Você não está autorizado a fazer uma retirada por meio de agente de pagamento.","Quantitative_Analysis":"Análise quantitativa","Miss":"Srª.","Wall_Street_Smart_Index":"Índice Inteligente da Wall Street","Please_check_your_email_for_the_value_of_this_token":"Verifique a sua caixa de e-mail para o valor deste token","Forex_trading_experience":"Experiência com negociações forex","Amount":"Quantia","The_maximum_number_of_tokens_([_1])_has_been_reached_":"O número máximo de tokens ([_1]) foi atingido.","Global_Customer_Service_Representatives":"Representantes globais do apoio ao cliente","Withdrawal_Limits":"Limites de retirada","Print_chart":"Imprimir gráfico","Please_try_again_":"Por favor, tente novamente.","Your_transaction_reference_is":"A referência da sua transação é","Diageo_plc":"Diageo PLC","Compliance":"Conformidade","Glencore_Xstrat":"GlencoreXtrata","National_Australia_Bank_Ltd":"National Australia Bank Ltda","Save_as_SVG":"Salve como SVG","You_have_already_withdrawn_[_1]_[_2]_":"Você já retirou [_1] [_2].","Profit/Loss":"Lucro/Perda","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Preencha o ID de Início de Sessão e a Quantia que pretende transferir para o seu Cliente no formulário abaixo:","Password_does_not_match_":"A senha não corresponde.","Commodities":"Matérias-primas","Transfer_to_Login_ID":"Transferir para ID de Início de Sessão","Update":"Atualização","Fr":"Sex","Volatility_75_Index":"Índice Volatility 75","goes_outside":"sai fora","Chart":"Gráfico","High_Barrier":"Barreira Alta","Date_of_Birth":"Data de nascimento","Self-employed":"Trabalhador independente","space":"espaço","Portuguese_Smart_Index":"Índice Inteligente Português","{JAPAN_ONLY}Option_prices_are_normally_dependant_on_elements_such_as_the_underlying_asset_price,_the_exercise_price,_the_length_of_time_until_the_exercise_point,_volatility,_and_interest_rates__However,_when_the_remaining_time_to_the_exercise_point_is_very_short,_there_is_no_need_to_consider_these_when_managing_option_trading_risk,_as_all_these_elements_are_constant_":"{JAPAN ONLY}Option prices are normally dependent on elements such as the underlying asset price, the exercise price, the length of time until the exercise point, volatility, and interest rates. However, when the remaining time to the exercise point is very short, there is no need to consider these when managing option trading risk, as all these elements are constant.","Saturday":"Sábado","Never_Used":"Nunca utilizado","Volatility_50_Index":"Índice Volatility 50","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Apresenta os pagamentos agregados máximos referentes aos contratos pendente do seu portfólio. Se o máximo for atingido, você não poderá comprar contratos adicionais sem primeiro fechar as posições existentes.","Description":"Descrição","Sell":"Vender","Abu_Dhabi_Index":"Índice de Abu Dhabi","Euro_50_Index":"Índice 50 Europeu","October":"Outubro","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Você está atualmente conectado à sua conta de dinheiro real com [_1] ([_2]).","Office_worker":"Funcionário de escritório","Terms_&_Conditions":"Termos e Condições","Only_2_decimal_points_are_allowed_":"Apenas 2 pontos decimais são permitidos.","period":"ponto","Password_score_is:_[_1]__Passing_score_is:_20_":"A classificação da senha é [_1]. A classificação de aprovação é: 20.","Stays_In/Goes_Out":"Fica dentro/Sai fora","Note":"Nota","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Representa o número máximo de contratos pendentes no seu portfólio. Cada linha do seu portfólio conta para uma posição em aberto. Depois de atingido o máximo, não poderá abrir novas posições sem fechar primeiro uma posição existente.","Italian_30_Index":"Índice 30 Italiano","Password_is_not_strong_enough_":"A senha não é suficiente.","Asset":"Ativos","Swiss_Smart_Index":"Índice Inteligente Suíço","0-1_year":"0-1 ano","Contract_Information":"Informação do contrato","Translator":"Tradutor","Hong_Kong_Index":"Índice de Hong Kong","Sorry,_account_opening_is_unavailable_":"Lamentamos, mas a abertura de contas está indisponível.","Anti-Fraud_Officer":"Funcionário antifraude","Barrier":"Barreira","Current_Level":"Nível atual","Password_is_moderate":"A senha é moderada","Failed_to_reset_password__[_1],_please_retry_":"Falha na redefinição da senha. [_1], tente novamente.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"O seu Cliente receberá uma notificação por e-mail com a informação de que a transferência foi processada.","Low_Barrier":"Barreira Baixa","Previous_Day":"Dia anterior","NZDCHF":"NZD/CHF","Senior_Perl_Developer":"Desenvolvedor Perl sénior","IP_Address":"Endereço IP","Tu":"Qui","$100,000_-_$250,000":"$100.000 - $250.000","Senior_Front-End_Developer":"Desenvolvedor front-end sénior","Sale_Price":"Preço de venda","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Digite a barreira em termos da diferença do preço atual. Se você digitar +0,005, estará comprando um contrato com uma barreira superior ao preço inicial em 0,005. O preço inicial será o próximo movimento mínimo após o seu pedido ter sido recebido","Social_Media_Executive":"Executivo de mídia social","Short":"Curto","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Confirme a negociação no seu extrato antes de continuar.","Reset_Password":"Redefinir senha","Year":"Ano","Other_financial_instruments_trading_experience":"Experiência com a negociação de outros instrumentos financeiros","Forex_trading_frequency":"Frequência de negociação forex","Purchase_Time":"Hora da Compra","Day":"Dia","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Uma cópia digitalizada do seu passaporte, carta de habilitação/condução (provisória ou definitiva), ou carteira de Identidade/cartão de cidadão, onde constam o seu nome e a sua data de nascimento.","$250,000_-_$1,000,000":"$250.000 - $1.000.000","Old_password_is_wrong_":"A senha antiga está errada.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"O seu pedido para levantar [_1] [_2] da sua conta [_3] para a conta [_4] do Agente de Pagamentos foi processado com sucesso.","AT&T":"AT&T Inc.","DevOps_Manager":"Gestor DevOps","Trading_and_Withdrawal_Limits":"Limites de Negociação e de Retirada","Housewife_/_Househusband":"Dona de casa / Dono de casa","High_barrier_offset":"Variação de barreira alta","ICICI_Bank_Ltd":"ICICI Bank Ltda","Aug":"Ago","Are_you_sure_that_you_want_to_permanently_delete_token":"Tem certeza que deseja excluir permanentemente o token","Open":"Início","ends_outside":"termina fora","You_did_not_change_anything_":"Você não alterou nada.","Russian_Regular_Index":"Índice Regulador Russo","Over/Under":"Acima/Abaixo","Feb":"Fev","The_two_passwords_that_you_entered_do_not_match_":"As palavras-chave que introduziu não coincidem.","Failed":"Falhou","You_have_not_granted_access_to_any_apps_":"Você não concedeu acesso a quaisquer aplicativos.","Stop-loss":"Limite de perdas","This_field_is_required_":"Este campo é obrigatório.","Return":"Prêmio","Tertiary":"Ensino Superior","$25,000_-_$100,000":"$25.000 - $100.000","Swiss_Index":"Índice Suíço","AP_Ordinary":"AP Ordinária","Indices_trading_experience":"Experiência com negociações de índices","6-10_transactions_in_the_past_12_months":"6-10 transações nos últimos 12 meses","Deutsche_Lufthansa":"Deutsche Lufthansa AG","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Depois de clicar no botão 'Enviar', os fundos serão retirados da sua conta e transferidos para a conta do seu Cliente.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"min","True":"Verdadeiro","day":"dia","Internal_Audit":"Auditoria interna","Save_as_JPEG":"Salve como JPEG","Platinum/USD":"Platina/USD","Income_Source":"Fonte de rendimento","hours":"horas","Euro_100_Index":"Índice 100 Europeu","second":"segundo","Belgian_Stocks":"Ações Belgas","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Você já retirou o equivalente a [_1] [_2].","Date":"Data","Asia/Oceania":"Ásia/Oceânia","Italian_Index":"Índice Italiano","Waiting_for_entry_tick_":"Aguardando tick de entrada.","lower":"inferior","Confirm_New_Password":"Confirme a nova senha","Country_Manager":"Gestor de País","April":"Abril","ICAG_(British_Airways)":"British Airways","Select_your_underlying_asset":"Selecione o ativo subjacente","Last_Digit_Prediction":"Previsão do último dígito","Try_adding_more_letters_or_numbers_":"Experimente adicionar mais letras ou números.","US_Tech_100_Index":"Índice US Tech 100","Sep":"Set","Jakarta_Index":"Índice de Jacarta","Purchase_Price":"Preço de Compra","UK_Smart_Index":"Índice Inteligente do Reino Unido","days":"dias","{JAPAN_ONLY}Prices_for_currency_options_are_calculated_relative_the_value_of_theunderlying_spot_price,_and_are_dependant_on_multiple_factors_which_may_vary_":"{JAPAN ONLY}Prices for currency options are calculated relative the value of the underlying spot price, and are dependent on multiple factors which may vary.","Never":"Nunca","Name":"Nome","Save_as_PNG":"Salve como PNG","New_Zealand_Index":"Índice da Nova Zelândia","Major_Pairs":"Pares Principais","Su":"Dom","Please_enter_a_number_between_[_1]_":"Digite um número entre [_1].","Marketing_Project_Manager":"Gestor de projetos de marketing","Jump_To":"Pular para","loading___":"a carregar...","Accounting":"Contabilidade","French_Index":"Índice Francês","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Quando você clicar em \"Ok\", você será excluído das negociações no site até a data escolhida.","Spot_Time":"Hora à vista","Over_100_million_JPY":"Mais de 100 milhões de JPY","BP_plc":"BP PLC","Closes":"Fecha","To":"Para","Istanbul_Index":"Índice de Istambul","Reference_ID":"ID de referência","Administrative_Executive":"Executivo administrativo","Tuesday":"Terça-feira","Sorry,_this_feature_is_not_available_":"Este recurso não está disponível.","Select_market":"Selecione o mercado","High_barrier":"Barreira alta","Closed":"Fechado","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Tem de aceitar os termos e condições para abrir uma conta.","Dec":"Dez","Gemalto_cyber_security":"Gemalto - cibersegurança","US_S&P_100":"EUA S&P 100","Portuguese_Index":"Índice Português","higher":"superior","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Deposite [_1][_2] em dinheiro virtual na sua conta [_3]","Monday":"Segunda-feira","differs":"difere","Current":"Atual","Predict_the_direction<br_/>and_purchase":"Preveja a direção<br />e compre","Oil/AUD":"Petróleo/AUD","Self-Employed":"Trabalhador independente","Estimated_Net_Worth":"Patrimônio líquido estimado","Student":"Estudante","Binary_options_or_other_financial_derivatives_trading_frequency":"Frequência de negociação de opções binárias ou outros derivados financeiros","Action":"Ação","French_Smart_Index":"Índice Inteligente Francês","Customer_Support":"Apoio ao cliente","comma":"vírgula","minutes":"minutos","Last_Used":"Última utilização","Oil/GBP":"Petróleo/GBP","Indian_50_Index":"Índice Indiano 50","Wall_Street_Index":"Índice de Wall Street","Kuwait_Index":"Índice Kuwait","This_contract_has_LOST":"Este contrato PERDEU","Net_Annual_Income":"Rendimento anual líquido","40_transactions_or_more_in_the_past_12_months":"40 transações ou mais nos últimos 12 meses","Previous":"Prévia","Euro_150_Index":"Índice 150 Europeu","Investments_&_Dividends":"Investimentos e dividendos","Stocks_trading_frequency":"Frequência de negociação de ações","Your_withdrawal_limit_is_[_1]_[_2]_":"O seu limite de retiradas é [_1] [_2].","Failed_to_update_trade_description_":"Falha na atualização dos dados da negociação.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Digite um número superior ou igual a [_1].","Bear_Market_Index":"Índice \"Mercado em Baixa\"","Stocks":"Ações","not_available":"Indisponível","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"A opção Agentes de Pagamentos não está atualmente disponível no seu país.","Buy":"Comprar","Exclude_time_cannot_be_for_more_than_5_years_":"O tempo de exclusão não pode ser superior a 5 anos.","Next":"Próximo","Friday":"Sexta-feira","Your_account_has_no_trading_activity_":"A sua conta não tem nenhuma atividade de negociação.","Your_trading_statistics_since_[_1]_":"As suas estatísticas de negociação desde [_1].","Your_settings_have_been_updated_successfully_":"As suas definições foram atualizadas com sucesso.","Your_password_cannot_be_the_same_as_your_email":"A sua senha não pode ser igual ao seu e-mail","Please_select_a_valid_date":"Selecione uma data válida","Walkthrough_Guide":"Guia passo a passo","Unemployed":"Desempregado","Shanghai_Index":"Índice Xangai","verification_token":"token de verificação","points":"pontos","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Para autenticar a sua conta, envie um e-mail para [_1]","Contract_Expiry":"Validade do contrato","December":"Dezembro","Quality_Assurance":"Garantia de qualidade","Primary":"Principal","Revoke_access":"Revogar acesso","Saudi_Arabia_Index":"Índice de Arábia Saudita","Try_adding_more_numbers_":"Experimente adicionar mais números.","Password_is_weak":"A senha é fraca","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Você está atualmente conectado à sua conta de dinheiro virtual ([_2]).","Higher/Lower":"Superior/Inferior","Stake":"Aposta","GlaxoSmithKline_plc":"GlaxoSmithKline","Amount_per_point":"Quantia por ponto","Date_and_Time":"Data e hora","The_Coca-Cola_Company":"Coca-Cola Company","Total_Profit/Loss":"Lucro/Perda Total","Sorry,_an_error_occurred_while_processing_your_request_":"Lamentamos, ocorreu um erro durante o processamento do seu pedido.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Representa a quantia máxima de dinheiro que pode manter na sua conta. Se o máximo for atingido, vamos solicitar-lhe a retirada dos fundos.","Confirm":"Confirmar","Back":"Voltar","Balance":"Saldo","Statement":"Extrato","Contract_/_Temporary_/_Part_Time":"Contrato / Temporário / Meio período","ends_between":"termina entre","Japanese_Smart_Index":"Índice Inteligente Japonês","Your_account_has_no_Login/Logout_activity_":"A sua conta não tem nenhuma atividade de login/sair.","Select_your_trade_type":"Selecione o tipo de negociação","asian_down":"queda asiático","Exit_Spot_Time":"Hora do preço de saída","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Não podemos transmitir ao vivo os preços no momento. Para ver os preços ao vivo tente recarregar a página, se o problema persistir após repetidas tentativas tente um navegar diferente","Low_barrier":"Barreira Baixa","Commodities_trading_experience":"Experiência com negociação de matérias-primas","Forex":"Forex (Mercado de Câmbio)","Minor_Pairs":"Pares secundários","Contract_ID":"ID de contrato","Only_[_1]_are_allowed_":"Apenas [_1] são permitidos.","Virtual_Account":"Conta Virtual","Our_site_does_not_charge_any_transfer_fees_":"O nosso site não cobra taxas de transferência.","Daily_Reset_Indices":"Índices \"Reinício Diário\"","Deposit":"Depositar","French_Stocks":"Ações Francesas","Please_input_a_valid_date":"Insira uma data válida","years":"anos","Sunday":"Domingo","Explanation":"Explicação","This_contract_has_WON":"Este contrato GANHOU","Please_wait_<br_/>Your_request_is_being_processed_":"Por favor aguarde.<br />O seu pedido está a ser processado.","Irish_Index":"Índice Irlandês","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"As suas contas [_1] não estão disponíveis. Para qualquer questão, contate o [_2].","Volatility_Indices":"Índices Volatility","Belgian_Index":"Índice Belga","Palladium/USD":"Paládio/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"O seu token expirou. Clique <a class=\"pjaxload\" href=\"[_1]\">aqui</a> para reiniciar o processo de verificação.","Remaining_Time":"Tempo restante","Your_transaction_reference_number_is_[_1]":"O número de referência da sua transação é [_1]","January":"Janeiro","There_was_an_error":"Houve um erro","Targeting_medium-term_/_long-term_profits":"À procura de lucros de médio / longo prazo","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Formato: aaaa-mm-dd (não é necessário para contas de dinheiro virtual)","Maximum_number_of_open_positions":"Número máximo de posições em aberto","Start_Time":"Hora de Início","Publicis_media_agencies":"Publicis - agências de mídia","Exit_Level":"Nível de saída","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] foram creditados na sua conta de dinheiro Virtual [_3]","Please_submit_a_valid_[_1]_":"Insira um [_1] válido.","Session_duration_limit_cannot_be_more_than_6_weeks_":"O limite de duração de sessões não pode ser superior a 6 semanas.","Ends_In/Out":"Termina Dentro/Fora","Indices":"Índices","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"O contrato será vendido ao preço prevalecente do mercado no momento em que o pedido for recebido pelos nossos servidores. Esse preço pode ser diferente do preço indicado.","Maximum_aggregate_payouts_on_open_positions":"Máximo de pagamentos agregados sobre posições em aberto","UK_Index":"Índice do RU","Credit/Debit":"Crédito/Débito","End_Time":"Hora final","There_was_a_problem_accessing_the_server_":"Ocorreu um problema ao aceder ao servidor.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Verifique a sua caixa de e-mail para obter o token necessário para a redefinição da sua senha.","year":"ano","German_Index":"Índice Alemão","Brazilian_Index":"Índice Brasileiro","Finance":"Finanças","Graphic_Designers":"Designers gráficos","Administrator":"Administrador","November":"Novembro","South_African_Index":"Índice Sul Africano","Contract":"Contrato","Keep_track_of_your_authorised_applications_":"Mantenha um registro dos seus aplicativos autorizados.","Please_enter_a_valid_amount_":"Introduza uma quantia válida.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Por favor, digite uma data que seja, no mínimo, seis meses a partir de agora.","$100,000_-_$500,000":"$100.000 - $500.000","Zoom":"Ampliar","Your_changes_have_been_updated_":"As suas alterações foram atualizadas.","Ms":"Sra.","May":"Maio","Profit":"Lucro","Exclude_time_must_be_after_today_":"A hora da exclusão tem que ser depois de hoje.","Rise/Fall":"Sobe/Desce","Total_Cost":"Custo Total","Touch/No_Touch":"Toca","Invalid_date_of_birth_":"Data de nascimento inválida.","Sell_at_market":"Venda no mercado","Date_(GMT)":"Data (GMT)","Maximum_daily_turnover":"Volume de negócios máximo diário","Targeting_short-term_profits":"À procura de lucros de curto prazo","You_have_sold_this_contract_at_[_1]_[_2]":"Você vendeu este contrato por [_1] [_2]","Commbank_(Australia)":"Commbank (Austrália)","Royal_Dutch_Shell_plc":"Royal Dutch Shell PLC","Foreign_currency_deposit":"Depósito em moeda estrangeira","Last_Digit_Stats":"Estatísticas do último dígito","Permissions":"Permissões","Compliance_Executive":"Executivo de conformidade","Settles":"Liquida","Stocks_trading_experience":"Experiência com negociação de ações","{JAPAN_ONLY}Option_prices_are_normally_dependant_on_elements_such_as_the_underlying_asset_price,_the_exercise_price,_the_length_of_time_until_the_exercise_point,_volatility,_and_interest_rates__Apart_from_the_fixed_exercise_price,_all_other_elements_are_changing_constantly,_so_an_understanding_of_the_relationships_between_each_element_and_changes_in_the_options_price_is_necessary_for_the_management_of_options_trading_risk_":"{JAPAN ONLY}Option prices are normally dependent on elements such as the underlying asset price, the exercise price, the length of time until the exercise point, volatility, and interest rates. Apart from the fixed exercise price, all other elements are changing constantly, so an understanding of the relationships between each element and changes in the options price is necessary for the management of options trading risk.","Item":"Artigo","Month":"Mês","Successful":"Bem-sucedido","Unlock_Cashier":"Desbloquear o Caixa","Middle_East":"Oriente Médio","Reckitt_Benckiser_Group_plc":"Reckitt Benckiser Group PLC","Pension":"Pensão de aposentação","Proofreader":"Revisor","Low_barrier_offset":"Variação de barreira baixa"};
texts_json['PL'] = {"Accounts_And_Payments_Executive":"Starszy specjalista ds. księgowości i płatności","{JAPAN_ONLY}If_you_sell_a_currency_binary_option_at_a_price_of_500_yen,_and_the_judgment_price_meets_the_conditions_so_you_need_to_payout_1,000_yen,_then_your_profit_will_be_minus_500_yen_after_subtracting_the_500_yen_that_was_received_as_a_fee_from_the_option_buyer_":"If you sell a currency binary option at a price of 500 yen, and the judgment price meets the conditions so you need to payout 1,000 yen, then your profit will be minus 500 yen after subtracting the 500 yen that was received as a fee from the option buyer.","{JAPAN_ONLY}The_price_of_OTC_binary_options_of_the_same_conditions,_(sometimes)_the_price_varies_depending_on_transactions_dealers_handling_financial_instruments_business_":"The price of OTC binary options of the same conditions, (sometimes) the price varies depending on transactions dealers handling financial instruments business.","Prices":"Ceny","Stop_Loss_Level":"Poziom Stop stratom","Please_select":"Wybierz","This_contract_won":"Ten kontrakt wygrał","Oil/EUR":"Ropa/EUR","Spot":"Cena aktualna","US_Index":"Indeks USA","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Twój wniosek o przelanie [_2] [_1] z [_3] na [_4] został zrealizowany.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Łączny ekwiwalent [_2] [_1] został już wypłacony w ciągu ostatnich [_3] dni.","Payout":"Wypłata","{JAPAN_ONLY}A_binary_option_which_is_out-of-the-money_will_have_a_lower_price_than_an_option_which_is_in-the-money_because_the_probability_of_receiving_the_payout_amount_is_lower_":"A binary option which is out-of-the-money will have a lower price than an option which is in-the-money because the probability of receiving the payout amount is lower.","Period":"Okres","stays_between":"pozostaje pomiędzy","Verification_Token":"Token weryfikacyjny","Deposit_of":"Wpłata w wysokości","odd":"nieparzysta","{JAPAN_ONLY}Because_option_prices_are_determined_by_the_probability_of_being_exercised,_it_cannot_be_said_that_cheaper_options_have_any_natural_advantage_over_expensive_options_":"Because option prices are determined by the probability of being exercised, it cannot be said that cheaper options have any natural advantage over expensive options.","Wednesday":"Środa","{JAPAN_ONLY}An_option_holder_must_buy_(_or_sell_)_the_underlying_asset_at_a_predetermined_price_within_a_specified_period_(_or_at_a_specific_time_)_":"An option holder must buy ( or sell ) the underlying asset at a predetermined price within a specified period ( or at a specific time ).","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Pokazuje maksymalną liczbę kontraktów, które możesz nabyć w danym dniu handlowym.","Dubai_Index":"Indeks dubajski","month":"miesiąc","{JAPAN_ONLY}Unless_special_arrangements_are_made,_cooling-off_will_not_be_available_after_OTC_binary_options_trading_contract_has_been_made_":"Unless special arrangements are made, cooling-off will not be available after OTC binary options trading contract has been made.","Minimum_of_[_1]_characters_required_":"Minimalna liczba znaków: [_1].","In/Out":"Zakłady w/poza","Industry_of_Employment":"Sektor zatrudnienia","Human_Resource_Executive":"Kierownik ds. zasobów ludzkich","{JAPAN_ONLY}If_the_buyer_of_an_option_does_not_exercise_the_option_rights,_there_will_be_no_fee_payable_to_the_option_seller_":"If the buyer of an option does not exercise the option rights, there will be no fee payable to the option seller.","Opens":"Otwarcie","Exit_Spot":"Punkt wyjściowy","Potential_Payout":"Możliwa wypłata","{JAPAN_ONLY}If_the_buyer_of_an_option_waives_his_right_to_exercise,_a_transaction_in_the_underlying_asset_will_not_be_dealt_between_the_seller_and_the_buyer_":"If the buyer of an option waives his right to exercise, a transaction in the underlying asset will not be dealt between the seller and the buyer.","Bull_Market_Index":"Indeks hossy","{JAPAN_ONLY}If_you_sell_a_currency_binary_put_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_need_to_payout_1,000_yen_to_the_buyer_of_the_option_":"If you sell a currency binary put option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will need to payout 1,000 yen to the buyer of the option.","{JAPAN_ONLY}The_seller_of_a_vanilla_option_can_not_choose_whether_to_exercise_the_option_or_not__His_profit_is_limited_to_the_price_received_for_the_option,_whereas_his_potential_loss_is_unlimited_and_could_be_substantial_":"The seller of a vanilla option can not choose whether to exercise the option or not. His profit is limited to the price received for the option, whereas his potential loss is unlimited and could be substantial.","Points":"Punkty","Score":"Wynik","Gold/AUD":"Złoto/AUD","touches":"osiąga","Secondary":"Drugorzędne","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Twój limit wypłat to [_2] [_1] (lub jego ekwiwalent w innej walucie).","{JAPAN_ONLY}As_the_time_to_the_exercise_point_shortens,_the_time-value_of_a_plain_vanilla_option_decreases_":"As the time to the exercise point shortens, the time-value of a plain vanilla option decreases.","{JAPAN_ONLY}Options_are_said_to_be_leveraged_products_because_in_the_case_of_large_moves_in_the_underlying_asset_price,_the_values_of_the_options_can_increase_by_large_amounts_compared_to_the_price_paid_for_the_option_":"Options are said to be leveraged products because in the case of large moves in the underlying asset price, the values of the options can increase by large amounts compared to the price paid for the option.","{JAPAN_ONLY}The_buyer_of_a_vanilla_option_can_choose_whether_to_exercise_the_option_or_not__His_loss_is_limited_to_the_price_paid_for_the_option,_whereas_his_potential_profit_is_unlimited_":"The buyer of a vanilla option can choose whether to exercise the option or not. His loss is limited to the price paid for the option, whereas his potential profit is unlimited.","Marketing_Executives":"Kierownicy ds. marketingu","No_Live_price_update":"Brak aktualnych cen","Please_select_a_payment_agent":"Proszę wybrać pośrednika płatności","{JAPAN_ONLY}Even_if_all_details_of_the_binary_options_match_perfectly,_there_may_still_be_differences_in_the_prices_shown_by_different_broking_companies_":"Even if all details of the binary options match perfectly, there may still be differences in the prices shown by different broking companies.","Real_Account":"Prawdziwe konto","Europe/Africa":"Europa/Afryka","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Skan rachunku za media lub wyciągu bankowego (z ostatnich 3 miesięcy).","Ok":"OK","Spanish_Index":"Indeks hiszpański","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Dodatkowe hasło może być wykorzystane do ograniczania dostępu do sekcji Kasjer.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Twoje konto jest w pełni zweryfikowane, a Twój limit wypłat został zwiększony.","Swedish_Index":"Indeks szwedzki","GBP_Index":"Indeks brytyjski (GBP)","Shenzhen_300_Index":"Indeks Shenzhen 300","Binary_options_or_other_financial_derivatives_trading_experience":"Doświadczenie w handlowaniu opcjami binarnymi lub innymi instrumentami pochodnymi","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Twoje hasło zostało zresetowane. Zaloguj się na swoje konto, używając swojego nowego hasła.","Less_than_$100,000":"Mniej niż 100 000 $","Jul":"Lipiec","Upcoming_Events":"Nadchodzące wydarzenia","minimum_available_duration":"minimalny dostępny czas trwania","Gold/EUR":"Złoto/EUR","Now":"Teraz","Construction":"Budownictwo","{JAPAN_ONLY}For_an_out-of-the-money_option,_the_further_away_from_the_underlying_asset_price_that_the_option_exercise_price_is,_the_lower_the_price_of_the_option_will_be_":"For an out-of-the-money option, the further away from the underlying asset price that the option exercise price is, the lower the price of the option will be.","Norwegian_Index":"Indeks norweski","{JAPAN_ONLY}The_Black-Scholes_model_is_widely_used_to_calculate_theoretical_option_prices_":"The Black-Scholes model is widely used to calculate theoretical option prices.","{JAPAN_ONLY}It_is_possible_to_use_two_binary_options_to_make_a_profit_if_the_asset_price_settles_outside_the_two_strikes__It_is_also_possible_to_buy_a_single_range_option_that_will_achieve_the_same_result_":"It is possible to use two binary options to make a profit if the asset price settles outside the two strikes. It is also possible to buy a single range option that will achieve the same result.","Korean_Index":"Indeks koreański","Number_of_ticks":"Liczba najmniejszych przyrostów ceny","asian_up":"azjatyckie w górę","ArcelorMittal_steel":"ArcelorMittal: stal","Entry_Level":"Poziom wejściowy","{JAPAN_ONLY}For_a_currency_binary_option_which_has_the_underlying_exchange_rate_of_dollars_against_yen,_the_right_to_receive_a_payout_if_the_yen_becomes_weaker_is_known_as_a_dollar-put_binary_option_":"For a currency binary option which has the underlying exchange rate of dollars against yen, the right to receive a payout if the yen becomes weaker is known as a dollar-put binary option.","Asians":"Azjatyckie","September":"Wrzesień","Save_as_PDF":"Zapisz jako PDF","{JAPAN_ONLY}Dear_customer,_you_are_not_allowed_to_take_knowledge_test_until_[_1]_\\nLast_test_taken_at_[_2]_":"Szanowny użytkowniku, nie możesz podejść do testu wiedzy przed [_1].\\\\nOstatnia próba zdania testu odbyła się [_2].","Contract_Confirmation":"Potwierdzenie kontraktu","numbers":"liczby","View_your_statement":"Zobacz swój wyciąg","{JAPAN_ONLY}Sorry,_you_have_failed_the_test,_please_try_again_after_24_hours_":"Sorry, you have failed the test, please try again after 24 hours.","Delete":"Usuń","{JAPAN_ONLY}Binary_options_have_lower_risk_than_vanilla_options_for_option_sellers,_because_with_binary_options_the_maximum_loss_is_fixed_":"Binary options have lower risk than vanilla options for option sellers, because with binary options the maximum loss is fixed.","Profit/Loss_(points)":"Zysk/Strata (punkty)","spread_down":"spread w dół","AUD_Index":"Indeks australijski (AUD)","Continuous_Indices":"Wskaźniki ciągłe","Quality_Assurance_Engineer":"Inżynier ds. jakości","{JAPAN_ONLY}The_exit_price_is_important_in_binary_options__In_case_of_handling_the_OTC_currency-related_binary_options_trading_for_private_individuals,_the_broker_company_must_perform_inspections_of_the_exit_prices_which_have_been_used_for_determining_option_payout,_and_must_check_whether_there_is_an_error_in_the_data_in_cases_where_that_the_company_has_used_rated_data_provided_by_third_company_":"The exit price is important in binary options. In case of handling the OTC currency-related binary options trading for private individuals, the broker company must perform inspections of the exit prices which have been used for determining option payout, and must check whether there is an error in the data in cases where that the company has used rated data provided by third company.","Information_Technology":"Technologie informacyjne (IT)","Digits":"Cyfry","Quantitative_Developer":"Programista danych ilościowych","{JAPAN_ONLY}Historical_volatility_is_a_prediction_of_the_future_rate_of_change_in_the_underlying_asset_":"Historical volatility is a prediction of the future rate of change in the underlying asset.","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"W tej chwili nie otwieramy kont dla mieszkańców z tych krajów.","Browser":"Przeglądarka","Australian_Index":"Indeks australijski","Login_ID":"Login","0-5_transactions_in_the_past_12_months":"0-5 transakcji w ciągu ostatnich 12 miesięcy","Start_time":"Godzina rozpoczęcia","{JAPAN_ONLY}Congratulations,_you_have_pass_the_test,_our_Customer_Support_will_contact_you_shortly_":"Congratulations, you have pass the test, our Customer Support will contact you shortly.","Americas":"Ameryki","Japanese_Index":"Indeks japoński","Salaried_Employee":"Pracownik etatowy","There_was_some_invalid_character_in_an_input_field_":"Nieprawidłowy znak w polu formularza.","matches":"zgadza się","Long":"Długie","is_required__Current_spread":"jest wymagany. Obecny spread","Less_than_$25,000":"Mniej niż 25 000 $","Mr":"Pan","Volatility_25_Index":"Indeks zmienności 25","1-2_years":"1-2 lata","{JAPAN_ONLY}The_price_of_an_option_can_be_affected_by_the_underlying_asset_price,_by_the_volatility_rate_of_the_underlying_asset,_or_by_the_time_remaining_to_the_exercise_time_":"The price of an option can be affected by the underlying asset price, by the volatility rate of the underlying asset, or by the time remaining to the exercise time.","March":"Marzec","(Bejing/CST_-8_hours)":"(Pekin/CST - 8 godzin)","{JAPAN_ONLY}When_buying_a_vanilla_put_option,_the_break-even_price_at_the_exercise_point_is_the_strike_price_minus_the_option_price_paid_in_units_of_the_underlying_":"When buying a vanilla put option, the break-even price at the exercise point is the strike price minus the option price paid in units of the underlying.","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"Firma [_1] zaktualizowała swój [_2]. Kliknięcie OK oznacza, że [_2] w nowej wersji jest Ci znany i wyrażasz zgodę na jego postanowienia.","hyphen":"myślnik","Smart_FX":"Inteligentny forex","Invalid_amount,_maximum_is":"Nieprawidłowa kwota, maksimum wynosi","US_Smart_Index":"Inteligentny indeks amerykański","{JAPAN_ONLY}Knowledge_Test_Result":"Knowledge Test Result","Week_of":"Tydzień","Entry_Spot":"Pozycja wejściowa","You_should_enter_between_[_1]_characters_":"Proszę wprowadzić następującą liczbę znaków: [_1].","Nov":"Listopad","spread_up":"spread w górę","Contract_is_not_started_yet":"Kontrakt jeszcze się nie rozpoczął","Indicative":"Orientacyjny","Dutch_Index":"Indeks holenderski","{JAPAN_ONLY}Section_4:_Risk":"Section 4: Risk","Volatility_100_Index":"Indeks zmienności 100","Metals":"Metale","{JAPAN_ONLY}A_binary_option_price_cannot_exceed_the_payout_amount_":"Cena opcji binarnej nie może przewyższać kwoty wypłaty.","We":"Środa","Please_enter_a_number_between_0_and_[_1]":"Proszę wpisać liczbę od 0 do [_1]","Quantitative_Analyst":"Analityk ilościowy","Level_of_Education":"Poziom wykształcenia","New_token_created_":"Utworzono nowy token.","even":"parzysta","Authorise_your_account_":"Autoryzuj swoje konto.","Education":"Edukacja","Contract_Sold":"Kontrakt został sprzedany","{JAPAN_ONLY}A_Binary_Option_contains_the_right_for_the_buyer_to_receive_a_certain_fixed_amount_if_the_market_price_reaches_the_exercise_price_by_the_exercise_time,_but_it_does_not_contain_any_rights_to_sell_or_buy_the_underlying_asset_":"A Binary Option contains the right for the buyer to receive a certain fixed amount if the market price reaches the exercise price by the exercise time, but it does not contain any rights to sell or buy the underlying asset.","Gaming_Account":"Konto gracza","July":"Lipiec","June":"Czerwiec","{JAPAN_ONLY}Although_customers_and_brokers_will_set_limits_on_customers_trading_losses,_even_if_those_losses_are_exceeded,_it_is_the_customer's_responsibility_to_close_the_position_and_so_mandatory_loss-cuts_will_not_be_executed_by_the_broker_company_":"Although customers and brokers will set limits on customers trading losses, even if those losses are exceeded, it is the customer's responsibility to close the position and so mandatory loss-cuts will not be executed by the broker company.","Thursday":"Czwartek","Smart_Indices":"Inteligentne wskaźniki","Your_details_have_been_updated_":"Twoje dane zostały uaktualnione.","Over_$1,000,000":"Ponad 1 000 000 $","Financial_Assessment":"Ocena finansowa","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Twoje konto [_1] jest niedostępne. W przypadku jakichkolwiek pytań prosimy o kontakt z [_2].","Password_is_very_strong":"Bardzo silne hasło","USD_Index":"Indeks amerykański (USD)","{JAPAN_ONLY}The_payout_is_the_amount_that_the_option_seller_must_pay_to_the_buyer_if_the_buyer_exercises_his_right_when_the_conditions_for_a_payout_have_been_satisfied_":"The payout is the amount that the option seller must pay to the buyer if the buyer exercises his right when the conditions for a payout have been satisfied.","{JAPAN_ONLY}To_compensate_for_any_rise_in_the_price_of_an_underlying_asset_that_you_intend_to_buy_in_future,_you_should_buy_a_call_option_":"To compensate for any rise in the price of an underlying asset that you intend to buy in future, you should buy a call option.","{JAPAN_ONLY}Short_positions_in_FX_Binary_Options_must_be_covered_by_initial_margin_and_any_further_losses_must_be_covered_by_further_margin_deposits_":"Short positions in FX Binary Options must be covered by initial margin and any further losses must be covered by further margin deposits.","password":"hasło","Stop-type":"Stop-typ","{JAPAN_ONLY}If_you_believe_the_underlying_asset_price_will_move_by_a_large_amount_in_either_direction,_you_can_benefit_by_buying_both_a_call_and_a_put_option,_with_the_exercise_prices_set_above_and_below_the_current_underlying_price_":"If you believe the underlying asset price will move by a large amount in either direction, you can benefit by buying both a call and a put option, with the exercise prices set above and below the current underlying price.","Commodities_trading_frequency":"Częstość handlowania towarami","Transfer_to":"Przelew do","Price":"Cena","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Dlatego w chwili obecnej Twoja maksymalna natychmiastowa wypłata (o ile posiadasz na koncie wystarczające środki) wynosi [_2] [_1].","{JAPAN_ONLY}Even_though_losses_in_binary_options_are_limited,_it_is_still_necessary_to_take_care_not_to_engage_in_excessive_speculative_trading_and_to_moderate_your_transactions_volume_":"Even though losses in binary options are limited, it is still necessary to take care not to engage in excessive speculative trading and to moderate your transactions volume.","ticks":"zmiany ceny","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Po kliknięciu przycisku OK handlowanie na portalu nie będzie możliwe aż do wybranej daty.","Questions":"Pytania","and":"i","Apr":"Kwiecień","months":"miesiące","Potential_Profit":"Możliwy zysk","over":"ponad","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Usługi zawierania transakcji finansowych oferowane na niniejszym portalu są odpowiednie tylko dla klientów, którzy są w stanie ponieść stratę wszystkich zainwestowanych pieniędzy i którzy rozumieją zagrożenia związane z nabywaniem kontraktów finansowych i mają doświadczenie w tym zakresie. Transakcje finansowe niosą ze sobą wysokie ryzyko. Jeśli zakupiony kontrakt zakończy się bez wartości, stracisz całą zainwestowaną sumę, na którą składać się będzie premia z kontraktu.","Random":"Losowy","Sale_Date":"Data sprzedaży","Nocturnes":"Nokturny","{JAPAN_ONLY}The_Exit_Price_is_the_price_that_is_observed_at_the_judgment_time,_and_is_used_to_determine_whether_a_payout_should_be_made_":"The Exit Price is the price that is observed at the judgment time, and is used to determine whether a payout should be made.","Exercise_period":"Okres ćwiczeń","February":"Luty","Exclude_time_cannot_be_less_than_6_months_":"Czas wyłączenia nie może być krótszy niż 6 miesięcy.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Twój [_1]-dniowy limit wypłat wynosi obecnie [_3] [_2] (Lub jego ekwiwalent w innej walucie).","Your_current_balance_is":"Obecnie Twoje saldo wynosi","Singapore_Index":"Indeks singapurski","Duration":"Czas trwania","This_contract_lost":"Ten kontrakt przegrał","Indices_trading_frequency":"Częstość handlowania wskaźnikami","{JAPAN_ONLY}A__Net_Settlement_type_of_option_is_one_where_the_underlying_asset_does_not_include_yen,_but_the_option_fee_and_settlement_are_paid_in_yen;_it_therefore_requires_some_definition_of_how_the_settlement_amounts_will_be_calculated_and_converted_to_yen_":"A  Net Settlement type of option is one where the underlying asset does not include yen, but the option fee and settlement are paid in yen; it therefore requires some definition of how the settlement amounts will be calculated and converted to yen.","Other_financial_instruments_trading_frequency":"Częstość handlowania innymi instrumentami finansowymi","Password_is_strong":"Silne hasło","EUR_Index":"Indeks EUR","Stop_Profit_Level":"Poziom Stop zyskom","Try_adding_more_letters_":"Dodaj więcej liter.","Egypt_Index":"Indeks egipski","Net_profit":"Zysk netto","Verification_code_format_incorrect_":"Format kodu weryfikującego jest nieprawidłowy.","There_was_a_problem_accessing_the_server_during_purchase_":"Wystąpił błąd podczas uzyskiwania dostępu do serwera w trakcie zakupu.","Adjust_trade_parameters":"Dostosuj parametry handlowe","Dutch_Stocks":"Akcje holenderskie","Over_$500,001":"Ponad 500 001 $","Th":"czwartek","Oct":"Październik","{JAPAN_ONLY}For_a_currency_binary_option_with_the_underlying_exchange_rate_of_dollars_against_yen,_the_right_to_receive_a_payout_if_the_yen_becomes_stronger_is_known_as_a_dollar-put_binary_option_":"For a currency binary option with the underlying exchange rate of dollars against yen, the right to receive a payout if the yen becomes stronger is known as a dollar-put binary option.","Even/Odd":"Parzysta/nieparzysta","Barrier_offset":"Limit","This_feature_is_not_relevant_to_virtual-money_accounts_":"Ta funkcja nie jest dostępna dla kont z wirtualnymi pieniędzmi.","Gold/USD":"Złoto/USD","Password_should_have_lower_and_uppercase_letters_with_numbers_":"Hasło powinno zawierać wielkie i małe litery oraz cyfry.","Step":"Krok","Next_Day":"Następny dzień","{JAPAN_ONLY}A_Currency_Option_confers_the_right_to_sell_one_currency_in_exchange_for_another_currency_as_the_underlying_asset__For_example,_the_right_to_sell_Yen_and_buy_Dollars_is_known_as_a_Yen_Put_/_Dollar_Call_Option,_or_just_Yen_Put_for_short;_and_the_opposite_right_to_buy_Yen_and_sell_Dollar_is_called_a_Yen_Call_/_Dollar_Put_Option,_or_just_Yen_Call_for_short_":"A Currency Option confers the right to sell one currency in exchange for another currency as the underlying asset. For example, the right to sell Yen and buy Dollars is known as a Yen Put / Dollar Call Option, or just Yen Put for short; and the opposite right to buy Yen and sell Dollar is called a Yen Call / Dollar Put Option, or just Yen Call for short.","Applications":"Aplikacje","Save_as_CSV":"Zapisz jako CSV","Internal_Auditor":"Audytor wewnętrzny","{JAPAN_ONLY}If_implied_volatility_increases_then_the_prices_of_both_call_and_put_types_of_plain_vanilla_options_will_increase_":"If implied volatility increases then the prices of both call and put types of plain vanilla options will increase.","Loss":"Strata","Mo":"Poniedziałek","Other":"Inne","Health":"Zdrowie","Dutch_Smart_Index":"Inteligentny indeks holenderski","Tick":"Zmiana ceny","letters":"litery","under":"poniżej","Silver/USD":"Srebro/USD","m":"miesiąc","{JAPAN_ONLY}In_OTC_currency_binary_options_trading,_if_the_exchange_rate_during_the_trading_period_moves_by_more_than_expected_in_one_direction,_and_there_are_no_longer_any_exercise_prices_which_can_continue_to_trade,_it_is_possible_under_certain_conditions_to_add_further_exercise_prices__However,_even_when_further_exercise_price_have_been_added,_the_prices_of_the_original_options_will_not_be_affected_":"In OTC currency binary options trading, if the exchange rate during the trading period moves by more than expected in one direction, and there are no longer any exercise prices which can continue to trade, it is possible under certain conditions to add further exercise prices. However, even when further exercise price have been added, the prices of the original options will not be affected.","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Statystyki końcowych cyfr dla ostatnich [_1] transakcji z najmniejszym przyrostem ceny dla rynku [_2]","Energy":"Energetyka","Over_3_years":"Ponad 3 lata","From":"Od","does_not_touch":"nie osiąga","hour":"godzina","View":"Widok","Sorry,_an_error_occurred_while_processing_your_account_":"Przepraszamy, wystąpił błąd podczas operacji na Twoim koncie.","An_error_occured_":"Wystąpił błąd.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Dlatego w chwili obecnej Twoja maksymalna natychmiastowa wypłata (o ile posiadasz na koncie wystarczające środki) wynosi [_2] [_1] (lub równoważność tej kwoty w innej walucie).","{JAPAN_ONLY}If_you_buy_a_currency_binary_option_at_a_price_of_500_yen,_and_the_judgment_price_meets_the_conditions_so_you_receive_a_payout_of_1,000_yen,_then_your_profit_can_be_calculated_500_yen_after_subtracting_the_500_yen_that_was_paid_as_a_fee_to_the_option_seller_":"If you buy a currency binary option at a price of 500 yen, and the judgment price meets the conditions so you receive a payout of 1,000 yen, then your profit can be calculated 500 yen after subtracting the 500 yen that was paid as a fee to the option seller.","Russian_10_Index":"Indeks rosyjski 10","New_Password":"Nowe hasło","Trading_Limits":"Limity handlowe","German_Smart_Index":"Inteligentny indeks niemiecki","{JAPAN_ONLY}Price_of_OTC_currency_option_is_the_calculated_value_based_on_multiple_elements_and_is_determined_by_relative_trading_basically_":"Price of OTC currency option is the calculated value based on multiple elements and is determined by relative trading basically.","Details":"Szczegóły","Login_History":"Historia logowania","{JAPAN_ONLY}Unlike_a_plain_vanilla_option,_an_in-the-money_binary_option_will_have_a_lower_price,_the_further_away_it_is_from_the_exercise_point_":"Unlike a plain vanilla option, an in-the-money binary option will have a lower price, the further away it is from the exercise point.","Invalid_amount,_minimum_is":"Nieprawidłowa kwota, minimum wynosi","minute":"min","{JAPAN_ONLY}Section_5:_Calculation":"Section 5: Calculation","Please_deposit_before_transfer_to_client_":"Wpłać środki przed ich wysłaniem do klienta.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Proszę zastosować schemat: 3 cyfry, myślnik, 4 cyfry.","Password_Reset":"Resetowanie hasła","{JAPAN_ONLY}If_you_believe_the_underlying_asset_price_will_be_only_moderately_volatile,_you_could_still_benefit_by_buying_both_a_call_and_put_option_with_exercise_prices_that_are_above_and_below_the_exercise_price_":"If you believe the underlying asset price will be only moderately volatile, you could still benefit by buying both a call and put option with exercise prices that are above and below the exercise price.","Maximum_account_cash_balance":"Maksymalne saldo gotówki na koncie","August":"Sierpień","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Twoje konto jest w pełni zweryfikowane. Możesz sprawdzić swoje [_1]limity handlowe tutaj","{JAPAN_ONLY}For_a_call_option,_if_the_price_of_the_underlying_asset_is_higher_than_the_option_exercise_price,_it_is_know_as_an_out-of-the-money_option_":"For a call option, if the price of the underlying asset is higher than the option exercise price, it is know as an out-of-the-money option.","Bombay_Index":"Indeks bombajski","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Proszę potwierdzić szczegóły transakcji w celu zakończenia przelewu:","Euro_50_Smart_Index":"Inteligentny indeks Euro 50","US_Tech_Composite_Index":"Indeks\tUS Tech Composite","Lock_Cashier":"Zablokuj sekcję Kasjer","{JAPAN_ONLY}Options_may_be_European_or_American_style_of_exercise,_and_those_which_can_be_exercised_at_only_one_expiry_time_are_the_European_style_options_":"Options may be European or American style of exercise, and those which can be exercised at only one expiry time are the European style options.","Sa":"sobota","seconds":"sek.","{JAPAN_ONLY}The_maximum_loss_for_the_buyer_of_an_option_is_the_price_paid,_and_the_maximium_loss_for_the_option_seller_will_be_the_payout_amount_minus_the_opion_price_he_received_":"The maximum loss for the buyer of an option is the price paid, and the maximium loss for the option seller will be the payout amount minus the opion price he received.","{JAPAN_ONLY}A_binary_call_option_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_decline_to_below_the_strike_price_by_the_judgment_time_":"A binary call option buyer will benefit from a correct prediction that the asset price will decline to below the strike price by the judgment time.","Matches/Differs":"Zgadza się/Różni się","Select_your_market":"Wybierz rynek","apostrophe":"apostrof","Canadian_Index":"Indeks kanadyjski","Finish":"Zakończ","Gold/GBP":"Złoto/GBP","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"Hasło musi zawierać minimum 1 cyfrę, 1 wielką literę i 1 małą literę.","Oil/USD":"Ropa/USD","False":"Fałsz","Up/Down":"Góra/dół","Human_Resources":"Zasoby ludzkie","Mrs":"Pani","Profit_Table":"Tabela zysków","Purchase":"Kup","{JAPAN_ONLY}There_are_some_types_of_Binary_Option,_such_as_Range_Binary_Options,_Touch_or_No-Touch_Binary_Options,_that_are_exceptions_to_the_general_rule_where_payment_is_made_at_a_known_exercise_time__For_these_types_of_option_a_payment_is_made_automatically_at_Exit_Time_when_certain_conditions_have_been_met_":"There are some types of Binary Option, such as Range Binary Options, Touch or No-Touch Binary Options, that are exceptions to the general rule where payment is made at a known exercise time. For these types of option a payment is made automatically at Exit Time when certain conditions have been met.","Tourism":"Turystyka","{JAPAN_ONLY}There_are_many_types_of_Binary_Option,_including_some_such_as_Range_Binary_Options_and_Touch_or_No-Touch_Binary_Options_which_do_not_always_require_automatic_payment_at_Exercise_Time_and_which_will_be_settled_earlier_if_certain_conditions_have_been_met__However,_in_all_cases,_for_a_payment_to_be_required,_the_option_must_end_In_The_Money_":"There are many types of Binary Option, including some such as Range Binary Options and Touch or No-Touch Binary Options which do not always require automatic payment at Exercise Time and which will be settled earlier if certain conditions have been met. However, in all cases, for a payment to be required, the option must end In The Money.","Shenzhen_Index":"Indeks Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Sekcja Kasjer została zablokowana na Twoją prośbę - jeśli chcesz ją odblokować, prosimy o podanie hasła.","Invalid_email_address":"Nieprawidłowy adres e-mail","Please_enter_an_integer_value":"Wpisz liczbę całkowitą","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Przepraszamy, ta funkcja jest dostępna tylko dla kont wirtualnych.","{JAPAN_ONLY}Price_of_call_option_will_be_lower_interest_rates_of_the_underlying_assets_is_low,_but_the_price_of_the_put_option,_go_up_when_the_interest_rates_of_the_underlying_assets_is_low_":"Price of call option will be lower interest rates of the underlying assets is low, but the price of the put option, go up when the interest rates of the underlying assets is low.","Investment_Account":"Konto inwestycyjne","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Nie jesteś upoważniony do wypłat przez pośrednika płatności.","Quantitative_Analysis":"Analiza ilościowa","Miss":"Pani","Wall_Street_Smart_Index":"Inteligentny indeks Wall Street","Please_check_your_email_for_the_value_of_this_token":"Informacja na temat tego tokenu została wysłana na Twój adres e-mail","Forex_trading_experience":"Doświadczenie w handlowaniu walutami","{JAPAN_ONLY}It_cannot_be_said_that_binary_options_trading_is_unconditionally_advanteous_over_regular_spot_fx_trading,_because_investors_may_lose_all_of_their_investment_whereas_in_spot_fx_trading_there_will_still_be_some_value_in_the_trading_position_":"It cannot be said that binary options trading is unconditionally advanteous over regular spot fx trading, because investors may lose all of their investment whereas in spot fx trading there will still be some value in the trading position.","Amount":"Kwota","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Maksymalna liczba tokenów ([_1]) została osiągnięta.","Global_Customer_Service_Representatives":"Pracownicy obsługi klienta","Withdrawal_Limits":"Limity wypłat","Print_chart":"Drukuj wykres","Please_try_again_":"Spróbuj ponownie.","Your_transaction_reference_is":"Kod referencyjny Twojej transakcji to","Compliance":"Zgodność","Save_as_SVG":"Zapisz jako SVG","You_have_already_withdrawn_[_1]_[_2]_":"Właśnie dokonano wypłaty [_2] [_1].","Profit/Loss":"Zysk/Strata","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"W formularzu poniżej wpisz login i kwotę, którą chcesz przekazać swojemu Klientowi:","Password_does_not_match_":"Hasło się nie zgadza.","Commodities":"Towary","Transfer_to_Login_ID":"Przelew dla loginu","Update":"Aktualizuj","Fr":"piątek","Volatility_75_Index":"Indeks zmienności 75","goes_outside":"przekracza","Chart":"Wykres","High_Barrier":"Wysoki limit","Date_of_Birth":"Data urodzenia","space":"spacja","Portuguese_Smart_Index":"Inteligentny indeks portugalski","{JAPAN_ONLY}Option_prices_are_normally_dependant_on_elements_such_as_the_underlying_asset_price,_the_exercise_price,_the_length_of_time_until_the_exercise_point,_volatility,_and_interest_rates__However,_when_the_remaining_time_to_the_exercise_point_is_very_short,_there_is_no_need_to_consider_these_when_managing_option_trading_risk,_as_all_these_elements_are_constant_":"Option prices are normally dependant on elements such as the underlying asset price, the exercise price, the length of time until the exercise point, volatility, and interest rates. However, when the remaining time to the exercise point is very short, there is no need to consider these when managing option trading risk, as all these elements are constant.","Saturday":"Sobota","{JAPAN_ONLY}To_avoid_or_hedge_the_future_price_of_an_underlying_asset_which_you_hold,_you_should_buy_a_call_option_":"To avoid or hedge the future price of an underlying asset which you hold, you should buy a call option.","Never_Used":"Nigdy nie użyte","Volatility_50_Index":"Wskaźnik zmienności 50","{JAPAN_ONLY}In_Japan_there_are_defined_trading_periods_for_binary_options_must_be_2_hours_or_longer,_and_all_trades_must_be_conducted_at_the_start_of_each_trading_period_":"In Japan there are defined trading periods for binary options must be 2 hours or longer, and all trades must be conducted at the start of each trading period.","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Pokazuje maksymalne zagregowane wypłaty dla niezapłaconych kontraktów w Twoim portfolio. Jeżeli maksimum zostanie osiągnięte, nie będziesz mieć możliwości zakupienia dodatkowych kontraktów bez uprzedniego zamknięcia aktualnych pozycji.","Description":"Opis","Sell":"Sprzedaj","Abu_Dhabi_Index":"Indeks Abu Zabi","{JAPAN_ONLY}Where_broking_companies_show_bid_and_offer_prices_for_purchasing_and_sell-back_of_positions,_these_prices_may_become_further_apart_the_nearer_you_are_to_the_exercise_time_":"Where broking companies show bid and offer prices for purchasing and sell-back of positions, these prices may become further apart the nearer you are to the exercise time.","Euro_50_Index":"Indeks Euro 50","October":"Październik","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Jesteś obecnie zalogowany/a do konta z prawdziwymi pieniędzmi w [_1] ([_2]).","Terms_&_Conditions":"Regulamin","Only_2_decimal_points_are_allowed_":"Dozwolone są tylko 2 miejsca po przecinku.","period":"okres","Password_score_is:_[_1]__Passing_score_is:_20_":"Ocena tego hasła to: [_1]. Akceptowalna ocena to: 20.","Stays_In/Goes_Out":"Pozostanie w/przekroczy","Note":"Uwaga","{JAPAN_ONLY}A_Currency_Binary_Option_is_one_where_there_is_a_target_for_a_particular_currency_pair,_so_a_strike_price_for_the_exchange_rate_is_agreed,_and_a_payout_will_be_due_if_the_judgment_price_meets_the_conditions_of_being_over_or_under_the_target_strike_price,_depending_on_the_option_type,_by_the_exercise_time_":"A Currency Binary Option is one where there is a target for a particular currency pair, so a strike price for the exchange rate is agreed, and a payout will be due if the judgment price meets the conditions of being over or under the target strike price, depending on the option type, by the exercise time.","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Pokazuje maksymalną liczbę niezapłaconych kontraktów w Twoim portfolio. Każda linia w Twoim portfolio liczy się jako jedna otwarta pozycja. Po osiągnięciu maksimum nie będziesz mieć możliwości otwierania nowych pozycji bez uprzedniego zamknięcia dotychczasowych pozycji.","Italian_30_Index":"Indeks włoski 30","Password_is_not_strong_enough_":"Hasło jest za słabe.","{JAPAN_ONLY}Using_binary_options_for_hedging_a_position_in_the_underlying_asset_means_that_only_part_of_the_loss_or_gain_can_be_hedged,_because_the_payout_amount_is_fixed_":"Using binary options for hedging a position in the underlying asset means that only part of the loss or gain can be hedged, because the payout amount is fixed.","Asset":"Kapitał","{JAPAN_ONLY}A_binary_put_option_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_decline_to_below_the_strike_price_by_the_judgment_time_":"A binary put option buyer will benefit from a correct prediction that the asset price will decline to below the strike price by the judgment time.","Swiss_Smart_Index":"Inteligentny indeks szwajcarski","{JAPAN_ONLY}As_the_expected_volatility_of_the_underlying_asset_increases,_a_plain_vanilla_option_price_will_move_higher_":"As the expected volatility of the underlying asset increases, a plain vanilla option price will move higher.","0-1_year":"0-1 rok","Contract_Information":"Informacje o kontrakcie","{JAPAN_ONLY}If_the_probablility_of_a_payout_is_50%_then_when_the_potential_payout_is_less_than_100%_of_the_price_paid_for_the_option,_the_expected_return_on_the_investment_will_be_less_than_100%_":"If the probablility of a payout is 50% then when the potential payout is less than 100% of the price paid for the option, the expected return on the investment will be less than 100%.","Translator":"Tłumacz","Hong_Kong_Index":"Indeks hongkoński","{JAPAN_ONLY}A_modified_version_of_the_Black-Scholes_model_is_widely_used_to_calculate_the_theoretical_prices_of_binary_options_":"Zmodyfikowaną wersję modelu Blacka-Scholesa stosuje się powszechnie do wyliczania teoretycznych cen opcji binarnych.","Sorry,_account_opening_is_unavailable_":"Przepraszamy, otwarcie konta jest niemożliwe.","Anti-Fraud_Officer":"Specjalista ds. wyłudzeń","Barrier":"Limit","Current_Level":"Obecny poziom","Password_is_moderate":"Średnie hasło","Failed_to_reset_password__[_1],_please_retry_":"Nie udało się zresetować hasła. [_1], spróbuj ponownie.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Twój Klient dostanie powiadomienie e-mailem z informacją, że przelew został wykonany.","Low_Barrier":"Niski limit","Previous_Day":"Poprzedni dzień","Senior_Perl_Developer":"Starszy programista Perl","IP_Address":"Adres IP","Tu":"Wtorek","$100,000_-_$250,000":"100 000 $ – 250 000 $","Senior_Front-End_Developer":"Starszy programista front-end","Sale_Price":"Cena sprzedaży","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Wprowadź limit w zakresie różnicy od aktualnej ceny. Jeśli wprowadzisz +0,005, zakupisz kontrakt z limitem 0,005 wyższym niż pozycja wejściowa. Pozycja wejściowa to następny najmniejszy przyrost ceny po otrzymaniu zamówienia","Social_Media_Executive":"Kierownik ds. mediów społecznościowych","Short":"Krótkie","{JAPAN_ONLY}In_general_the_price_of_a_binary_option_will_be_lower_than_the_price_of_a_plain_vanilla_option_because_the_payout_amount_is_fixed_":"In general the price of a binary option will be lower than the price of a plain vanilla option because the payout amount is fixed.","{JAPAN_ONLY}Section_1:_Structure":"Section 1: Structure","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Aby przejść dalej, proszę potwierdzić transakcję w sekcji Stan konta.","{JAPAN_ONLY}For_an_in-the-money_option,_the_further_away_from_the_underlying_asset_price_that_the_option_exercise_price_is,_the_lower_the_price_of_the_option_will_be_":"For an in-the-money option, the further away from the underlying asset price that the option exercise price is, the lower the price of the option will be.","Reset_Password":"Zresetuj hasło","{JAPAN_ONLY}Dear_customer,_you've_already_completed_the_knowledge_test,_please_proceed_to_next_step_":"Szanowny użytkowniku, test wiedzy został już ukończony. Przejdź do następnego etapu.","Year":"Rok","Other_financial_instruments_trading_experience":"Doświadczenie w handlowaniu innymi instrumentami finansowymi","Forex_trading_frequency":"Częstość handlowania walutami","{JAPAN_ONLY}Regarding_to_the_OTC_price_of_financial_instruments,_in_case_that_financial_instruments_business_operator_suggests_both_of__bid_and_ask_price_(or_trading_price_and_cancellation_price),_generally_there_is_a_difference_of_them__This_option_will_be_wider_as_the_expiration_approaches_":"Regarding to the OTC price of financial instruments, in case that financial instruments business operator suggests both of  bid and ask price (or trading price and cancellation price), generally there is a difference of them. This option will be wider as the expiration approaches.","Purchase_Time":"Godzina zakupu","Day":"Dzień","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Skan Twojego paszportu, prawa jazdy (czasowego lub normalnego) lub dowodu osobistego z Twoim imieniem i nazwiskiem oraz datą urodzenia.","$250,000_-_$1,000,000":"250 000 $ – 1 000 000 $","Old_password_is_wrong_":"Stare hasło jest nieprawidłowe.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Twój wniosek o wypłatę [_2] [_1] z Twojego konta [_3] na konto pośrednika płatności [_4] został zrealizowany.","DevOps_Manager":"Kierownik zespołu DevOps","Trading_and_Withdrawal_Limits":"Limity handlowe i limity wypłat","High_barrier_offset":"Offset wysokiego limitu","{JAPAN_ONLY}Implied_volatility_is_a_prediction_of_the_future_rate_of_change_in_the_underlying_asset_":"Każda opcja binarna to prognoza przyszłego zachowania się rynku podstawowego.","{JAPAN_ONLY}For_a_put_option,_if_the_underlying_asset_price_is_higher_than_the_option_exercise_price,_it_is_known_as_an_in-the-money_option_":"For a put option, if the underlying asset price is higher than the option exercise price, it is known as an in-the-money option.","Aug":"Sierpień","Are_you_sure_that_you_want_to_permanently_delete_token":"Czy na pewno chcesz trwale usunąć token","Open":"Otwarcie","ends_outside":"kończy się poza","You_did_not_change_anything_":"Nic nie zostało zmienione.","{JAPAN_ONLY}Even_if_the_option_is_exercise_or_not_exercised,_the_original_option_premium_remains_with_the_option_seller_":"Even if the option is exercise or not exercised, the original option premium remains with the option seller.","Russian_Regular_Index":"Regularny indeks rosyjski","Over/Under":"Ponad/poniżej","{JAPAN_ONLY}If_the_underlying_asset_price_is_100_yen,_the_exercise_price_is_80_yen,_and_the_call_option_price_is_45_yen,_then_it_can_be_said_that_the_option's_intrinsic-value_is_20_yen,_and_its_time-value_is_25_yen_":"If the underlying asset price is 100 yen, the exercise price is 80 yen, and the call option price is 45 yen, then it can be said that the option's intrinsic-value is 20 yen, and its time-value is 25 yen.","{JAPAN_ONLY}If_the_exercise_period_passes_without_the_option_being_exercised_by_the_buyer,_the_option_premium_received_by_the_seller_will_be_the_profit_made_on_the_trade_":"If the exercise period passes without the option being exercised by the buyer, the option premium received by the seller will be the profit made on the trade.","Feb":"Luty","{JAPAN_ONLY}A_binary_call_options_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_rise_above_the_strike_price_by_the_judgment_time_":"A binary call options buyer will benefit from a correct prediction that the asset price will rise above the strike price by the judgment time.","The_two_passwords_that_you_entered_do_not_match_":"Wprowadzone hasła nie są identyczne.","Failed":"Zakończone niepowodzeniem","You_have_not_granted_access_to_any_apps_":"Nie udzielono Ci dostępu do żadnej aplikacji.","{JAPAN_ONLY}A_binary_put_options_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_rise_above_the_strike_price_by_the_judgment_time_":"A binary put options buyer will benefit from a correct prediction that the asset price will rise above the strike price by the judgment time.","Stop-loss":"Stop-stratom","{JAPAN_ONLY}As_the_exercise_deadline_approaches,_the_price_of_an_out-of-the-money_binary_option_will_move_towards_zero_":"As the exercise deadline approaches, the price of an out-of-the-money binary option will move towards zero.","This_field_is_required_":"To pole jest wymagane.","Return":"Zwrot","{JAPAN_ONLY}A_Covered_option_position_is_where_you_hold_an_offsetting_position_in_the_underlying_asset_":"A Covered option position is where you hold an offsetting position in the underlying asset.","Tertiary":"Trzeciorzędne","$25,000_-_$100,000":"25 000 $ – 100 000 $","Swiss_Index":"Indeks szwajcarski","AP_Ordinary":"Zwykłe AP","Indices_trading_experience":"Doświadczenie w handlowaniu wskaźnikami","6-10_transactions_in_the_past_12_months":"6-10 transakcji w ciągu ostatnich 12 miesięcy","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Po kliknięciu przycisku „Prześlij” środki zostaną wypłacone z Twojego konta i przesłane na Twoje konto Klienta.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"min","True":"Prawda","day":"dzień","Internal_Audit":"Audyt wewnętrzny","Save_as_JPEG":"Zapisz jako JPEG","{JAPAN_ONLY}Take_knowledge_test":"Take knowledge test","Platinum/USD":"Platyna/USD","Income_Source":"Źródło dochodu","hours":"godziny","Euro_100_Index":"Indeks Euro 100","second":"sek.","Belgian_Stocks":"Akcje belgijskie","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Już wypłaciłeś/aś ekwiwalent [_2] [_1].","Date":"Data","Asia/Oceania":"Azja/Oceania","Italian_Index":"Indeks włoski","Waiting_for_entry_tick_":"Oczekuje na pierwszą zmianę ceny.","TOTAL":"SUMA","lower":"niższa","Confirm_New_Password":"Potwierdź nowe hasło","Country_Manager":"Dyrektor generalny na dany kraj","April":"Kwiecień","{JAPAN_ONLY}An_option_price_is_the_sum_of_the_intrinsic-value_and_the_time-value_":"An option price is the sum of the intrinsic-value and the time-value.","Select_your_underlying_asset":"Wybierz aktywa bazowe","Last_Digit_Prediction":"Przewidywanie ostatniej cyfry","{JAPAN_ONLY}As_the_exercise_deadline_approaches,_the_price_of_an_in-the-money_binary_option_will_move_towards_the_payout_amount_":"As the exercise deadline approaches, the price of an in-the-money binary option will move towards the payout amount.","Try_adding_more_letters_or_numbers_":"Dodaj więcej liter i cyfr.","US_Tech_100_Index":"Indeks US Tech 100","Sep":"Wrzesień","{JAPAN_ONLY}The_price_of_a_binary_option_is_affected_by_not_only_the_change_in_the_underlying_asset_price,_but_also_the_change_in_remaining_time_to_the_exercise_point_":"The price of a binary option is affected by not only the change in the underlying asset price, but also the change in remaining time to the exercise point.","Jakarta_Index":"Indeks dżakarcki","Purchase_Price":"Cena zakupu","UK_Smart_Index":"Inteligentny indeks brytyjski","{JAPAN_ONLY}Knowledge_Test":"Knowledge Test","days":"dni","Never":"Nigdy","Name":"Nazwisko","Save_as_PNG":"Zapisz jako PNG","New_Zealand_Index":"Indeks nowozelandzki","{JAPAN_ONLY}The_Exercise_Price_is_the_level_at_which_the_option_buyer_has_the_right_to_trade_the_underlying,_and_is_also_used_for_binary_options_to_determine_whether_the_buyer_should_receive_a_payout_":"The Exercise Price is the level at which the option buyer has the right to trade the underlying, and is also used for binary options to determine whether the buyer should receive a payout.","{JAPAN_ONLY}If_you_buy_a_currency_binary_put_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_receive_a_payout_1,000_yen_from_the_seller_of_the_option_":"If you buy a currency binary put option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will receive a payout 1,000 yen from the seller of the option.","Major_Pairs":"Główne pary","Su":"niedziela","Please_enter_a_number_between_[_1]_":"Proszę wpisać liczbę z przedziału [_1].","Marketing_Project_Manager":"Kierownik projektów marketingowych","{JAPAN_ONLY}For_a_put_option,_if_the_underlying_asset_price_is_lower_than_the_option_exercise_price,_it_is_known_as_an_out-of-the-money_option_":"For a put option, if the underlying asset price is lower than the option exercise price, it is known as an out-of-the-money option.","Jump_To":"Przejdź do","{JAPAN_ONLY}For_an_individual_investor,_profits_and_losses_from_OTC_currency_options_traing_cannot_be_combined_with_profits_and_losses_from_margin_FX_and_securities-related_OTC_options_":"For an individual investor, profits and losses from OTC currency options traing cannot be combined with profits and losses from margin FX and securities-related OTC options.","loading___":"ładowanie...","Accounting":"Rachunkowość","French_Index":"Indeks francuski","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Po kliknięciu przycisku „Ok” handlowanie na portalu nie będzie możliwe aż do wybranej daty.","Spot_Time":"Czas spot","Closes":"Zamknięcie","{JAPAN_ONLY}If_the_exercise_prices_and_exercise_times_are_the_same_for_an_American_style_and_European_style_option,_then_the_American_style_option_will_have_a_higher_price_":"If the exercise prices and exercise times are the same for an American style and European style option, then the American style option will have a higher price.","To":"Do","Istanbul_Index":"Indeks stambulski","Reference_ID":"ID referencyjne","{JAPAN_ONLY}There_are_two_types_of_option_delivery:_One_requires_exchanging_the_underlying_asset,_and_the_other_requires_a_payment_which_depends_on_the_difference_between_the_fair_market_price_and_the_exercise_price__A_Binary_Option_is_the_second_type_where_if_the_fair_market_price_meets_certain_conditions_with_respect_to_the_exercise_price,_then_an_agreed_fixed_amount_will_be_paid_to_the_option_buyer_":"There are two types of option delivery: One requires exchanging the underlying asset, and the other requires a payment which depends on the difference between the fair market price and the exercise price. A Binary Option is the second type where if the fair market price meets certain conditions with respect to the exercise price, then an agreed fixed amount will be paid to the option buyer.","Administrative_Executive":"Starszy specjalista ds. administracyjnych","Tuesday":"Wtorek","Sorry,_this_feature_is_not_available_":"Przepraszamy, wybrana funkcja jest niedostępna.","Select_market":"Wybierz rynek","High_barrier":"Wysoki limit","Closed":"Zamknięte","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Musisz zaakceptować regulamin, aby otworzyć konto.","Mar":"Marzec","{JAPAN_ONLY}The_time-value_of_an_option_represents_the_expected_value_of_the_option_at_the_exercise_point,_and_may_be_positive,_even_when_the_intrinsic-value_is_zero_":"The time-value of an option represents the expected value of the option at the exercise point, and may be positive, even when the intrinsic-value is zero.","Dec":"Grudzień","Portuguese_Index":"Indeks portugalski","{JAPAN_ONLY}For_a_call_option,_if_the_price_of_the_underlying_asset_is_higher_than_the_option_exercise_price,_it_is_know_as_an_in-the-money_option_":"For a call option, if the price of the underlying asset is higher than the option exercise price, it is know as an in-the-money option.","higher":"wyższa","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Wpłać na swoje konto [_3] wirtualne pieniądze w kwocie: [_2] [_1]","Jan":"Styczeń","Monday":"Poniedziałek","Royal_Dutch_Shell":"Royal Dutch Shell plc","differs":"różni się","Current":"Obecne","Predict_the_direction<br_/>and_purchase":"Oszacuj kierunek zmian<br />i kup","Oil/AUD":"Ropa/AUD","Self-Employed":"Samozatrudnienie","Estimated_Net_Worth":"Szacowana wartość netto","{JAPAN_ONLY}It_is_possible_to_use_two_binary_options_to_make_a_profit_if_the_asset_price_settles_inbetween_the_two_strikes__It_is_also_possible_to_buy_a_single_range_option_that_will_achieve_the_same_result_":"It is possible to use two binary options to make a profit if the asset price settles inbetween the two strikes. It is also possible to buy a single range option that will achieve the same result.","{JAPAN_ONLY}A_binary_option_which_is_in-the-money_will_have_a_higher_value_than_an_option_that_is_out-of-the-money_because_there_will_be_a_higher_probability_of_receiving_the_payout_amount_":"A binary option which is in-the-money will have a higher value than an option that is out-of-the-money because there will be a higher probability of receiving the payout amount.","{JAPAN_ONLY}When_buying_a_vanilla_call_option,_the_break-even_price_at_the_exercise_point_is_the_strike_price_plus_the_option_price_paid_in_units_of_the_underlying_":"When buying a vanilla call option, the break-even price at the exercise point is the strike price plus the option price paid in units of the underlying.","Binary_options_or_other_financial_derivatives_trading_frequency":"Częstotliwość handlowania opcjami binarnymi lub innymi instrumentami pochodnymi","Action":"Czynności","French_Smart_Index":"Inteligentny indeks francuski","Customer_Support":"Obsługa klienta","Ford_Motor_Comapny":"Ford Motor Company","{JAPAN_ONLY}If_you_sell_a_currency_binary_call_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_need_to_payout_1,000_yen_to_the_buyer_of_the_option_":"If you sell a currency binary call option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will need to payout 1,000 yen to the buyer of the option.","comma":"przecinek","minutes":"min","Last_Used":"Ostatnio używane","Oil/GBP":"Ropa/GBP","Indian_50_Index":"Indeks indyjski 50","Wall_Street_Index":"Indeks Wall Street","Kuwait_Index":"Indeks kuwejcki","This_contract_has_LOST":"Ten kontrakt PRZEGRAŁ.","Net_Annual_Income":"Roczny dochód netto","40_transactions_or_more_in_the_past_12_months":"Co najmniej 40 transakcji w ciągu ostatnich 12 miesięcy","Previous":"Poprzedni","Euro_150_Index":"Indeks Euro 150","Investments_&_Dividends":"Inwestycje i dywidenda","Stocks_trading_frequency":"Częstość handlowania akcjami","Your_withdrawal_limit_is_[_1]_[_2]_":"Twój limit wypłat wynosi [_2] [_1].","Failed_to_update_trade_description_":"Nie udało się uaktualnić opisu transakcji.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Proszę wpisać liczbę większą lub równą [_1].","Bear_Market_Index":"Indeks bessy","Stocks":"Akcje","not_available":"niedostępne","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"Usługi pośredników płatności są obecnie niedostępne w Twoim kraju.","Buy":"Kup","{JAPAN_ONLY}A_bought_or_sold_binary_option_may_be_closed-out_before_exercise_time_by_selling_or_buying-back_the_option,_or_alternatively_by_cancelling_":"A bought or sold binary option may be closed-out before exercise time by selling or buying-back the option, or alternatively by cancelling.","{JAPAN_ONLY}In_case_of_the_right_to_sell_the_underlying_asset_(put_option),_when_the_underlying_asset_price_rises,_the_option_price_will_increase_":"In case of the right to sell the underlying asset (put option), when the underlying asset price rises, the option price will increase.","Exclude_time_cannot_be_for_more_than_5_years_":"Czas wyłączenia nie może być dłuższy niż 5 lat.","Next":"Następny","Friday":"piątek","Your_account_has_no_trading_activity_":"NA Twoim koncie nie odnotowano żadnej aktywności handlowej.","Your_trading_statistics_since_[_1]_":"Twoje statystyki handlowe od [_1].","Your_settings_have_been_updated_successfully_":"Twoje ustawienia zostały uaktualnione.","Your_password_cannot_be_the_same_as_your_email":"Hasło nie może być takie samo jak adres e-mail","Please_select_a_valid_date":"Proszę wybrać poprawną datę","{JAPAN_ONLY}Price_of_the_option,_the_price_of_the_underlying_asset,_price_fluctuation_rate_of_the_underlying_assets,_the_time_until_the_exercise_date,_subject_to_any_of_the_impact_of_interest_rates_":"Price of the option, the price of the underlying asset, price fluctuation rate of the underlying assets, the time until the exercise date, subject to any of the impact of interest rates.","Walkthrough_Guide":"Przewodnik ogólny","Shanghai_Index":"Indeks szanghajski","verification_token":"token weryfikacyjny","points":"punkty","{JAPAN_ONLY}For_both_call_and_put_options,_if_the_underlying_asset_price_is_the_same_as_the_exercise_price,_it_is_known_as_an_at-the-money_option_":"For both call and put options, if the underlying asset price is the same as the exercise price, it is known as an at-the-money option.","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Aby uwierzytelnić konto, proszę przesłać do [_1] drogą e-mailową dokumenty wymienione poniżej","Contract_Expiry":"Wygaśnięcie kontraktu","December":"Grudzień","Quality_Assurance":"Zapewnianie jakości","Primary":"Podstawowy","Revoke_access":"Zablokowanie dostępu","Saudi_Arabia_Index":"Indeks Arabii Saudyjskiej","{JAPAN_ONLY}The_seller_of_an_option_should_receive_the_option_premium_from_the_buyer,_even_if_the_buyer_waives_the_right_to_exercise_the_option_":"The seller of an option should receive the option premium from the buyer, even if the buyer waives the right to exercise the option.","Try_adding_more_numbers_":"Dodaj więcej cyfr.","Password_is_weak":"Słabe hasło","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Jesteś obecnie zalogowany/a do konta z wirtualnymi pieniędzmi ([_2]).","Higher/Lower":"Wyższy/niższy","Stake":"Stawka","{JAPAN_ONLY}In_case_of_the_right_to_buy_the_underlying_asset_(call_option),_when_the_underlying_asset_price_falls,_the_option_price_will_increase_":"In case of the right to buy the underlying asset (call option), when the underlying asset price falls, the option price will increase.","Amount_per_point":"Kwota na punkt","Date_and_Time":"Data i godzina transakcji","Total_Profit/Loss":"Całkowity zysk/ całkowita strata","Sorry,_an_error_occurred_while_processing_your_request_":"Przepraszamy, podczas przetwarzania Twojego żądania wystąpił błąd.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Pokazuje maksymalną kwotę gotówki, jaką możesz mieć na koncie. Po osiągnięciu maksimum poprosimy Cię o wypłacenie środków.","Jun":"Czerwiec","Confirm":"Potwierdź","Back":"Poprzedni","Balance":"Saldo","Statement":"Stan konta","ends_between":"kończy się pomiędzy","Japanese_Smart_Index":"Inteligentny indeks japoński","Your_account_has_no_Login/Logout_activity_":"Na Twoim koncie nie odnotowano żadnej aktywności związanej z logowaniem/wylogowywaniem.","{JAPAN_ONLY}Delta_refers_to__a_percentage_change_of_the_option_price_with_respect_to_the_change_in_the_underlying_asset_price_":"Delta refers to  a percentage change of the option price with respect to the change in the underlying asset price.","{JAPAN_ONLY}If_you_buy_a_currency_binary_call_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_receive_a_payout_1,000_yen_from_the_seller_of_the_option_":"If you buy a currency binary call option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will receive a payout 1,000 yen from the seller of the option.","Select_your_trade_type":"Wybierz rodzaj zakładu","asian_down":"azjatyckie w dół","Exit_Spot_Time":"Czas punktu wyjściowego","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"W chwili obecnej nie jesteśmy w stanie przesyłać cen na żywo. Aby cieszyć się na żywo strumieniową transmisją cen, spróbuj ponownie odświeżyć stronę, a jeśli problem nadal występuje, spróbuj skorzystać z innej przeglądarki","Low_barrier":"Niski limit","{JAPAN_ONLY}Option_prices_depend_on_the_spot_price,_the_time_to_expiry,_the_volatility_of_the_spot_rate_and_interest_rates_":"Option prices depend on the spot price, the time to expiry, the volatility of the spot rate and interest rates.","Commodities_trading_experience":"Doświadczenie w handlowaniu towarami","{JAPAN_ONLY}For_an_individual_investor,_all_profits_from_OTC_currency_options_trading_are_tax-free_":"For an individual investor, all profits from OTC currency options trading are tax-free.","Minor_Pairs":"Mniej ważne pary","Spreads":"Spready","Contract_ID":"Identyfikator kontraktu","Only_[_1]_are_allowed_":"Dozwolone są tylko [_1].","Virtual_Account":"Konto wirtualne","{JAPAN_ONLY}Section_3:_Outline":"Section 3: Outline","Our_site_does_not_charge_any_transfer_fees_":"Nie pobieramy żadnych opłat za przelewy środków.","Daily_Reset_Indices":"Codzienne zerowanie wskaźników","Deposit":"Wpłata","French_Stocks":"Akcje francuskie","Please_input_a_valid_date":"Wpisz poprawną datę","years":"lat(a)","Sunday":"Niedziela","Explanation":"Wyjaśnienie","This_contract_has_WON":"Ten kontrakt WYGRAŁ","{JAPAN_ONLY}The_particular_details_of_binary_options_are_all_the_same,_no_matter_which_broking_company_you_trade_with_":"The particular details of binary options are all the same, no matter which broking company you trade with.","{JAPAN_ONLY}For_a_plain_vanilla_option,_as_the_time_to_the_exercise_point_shortens,_the_price_of_the_option_will_decrease_":"For a plain vanilla option, as the time to the exercise point shortens, the price of the option will decrease.","Please_wait_<br_/>Your_request_is_being_processed_":"Prosimy o cierpliwość.<br />Twoja prośba jest właśnie przetwarzana.","Irish_Index":"Indeks irlandzki","{JAPAN_ONLY}Section_2:_Method":"Section 2: Method","{JAPAN_ONLY}Please_complete_the_following_questions_":"Please complete the following questions.","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Twoje konta [_1] są niedostępne. W przypadku jakichkolwiek pytań prosimy o kontakt z [_2].","Volatility_Indices":"Zmienne wskaźniki","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_ends_otside_low_and_high_values_of_Exercise_price_at_close_on_[_4]_":"[_1] [_2] payout if [_3] ends otside low and high values of Exercise price at close on [_4].","Belgian_Index":"Indeks belgijski","Palladium/USD":"Pallad/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Twój token wygasł. Kliknij <a class=\"pjaxload\" href=\"[_1]\">tutaj</a>, aby rozpocząć proces weryfikacyjny ponownie.","Remaining_Time":"Pozostały czas","Your_transaction_reference_number_is_[_1]":"Numer referencyjny Twojej transakcji to [_1]","January":"Styczeń","There_was_an_error":"Wystąpił błąd","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Format: rrrr-mm-dd (nie jest wymagany w przypadku kont wirtualnych)","Maximum_number_of_open_positions":"Maksymalna dzienna liczba otwartych pozycji","Start_Time":"Godzina rozpoczęcia","Exit_Level":"Poziom wyjściowy","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_2] [_1] zostało odjęte z Twojego konta wirtualnego [_3]","Please_submit_a_valid_[_1]_":"Podaj poprawny [_1].","Session_duration_limit_cannot_be_more_than_6_weeks_":"Limit czasu sesji nie może przekroczyć 6 tygodni.","Ends_In/Out":"Kończy się w/poza","Indices":"Wskaźniki","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"Kontrakty będą sprzedawane po obowiązującej cenie rynkowej po dotarciu wniosku na nasze serwery. Cena może różnić się od podanej ceny.","Maximum_aggregate_payouts_on_open_positions":"Maksymalne zagregowane wypłaty dla pozycji otwartych","UK_Index":"Indeks brytyjski","Credit/Debit":"Winien/Ma","End_Time":"Zakończenie","There_was_a_problem_accessing_the_server_":"Wystąpił błąd podczas uzyskiwania dostępu do serwera.","{JAPAN_ONLY}In_general_a_binary_option_price_will_not_exceed_the_payout_amount_":"In general a binary option price will not exceed the payout amount.","{JAPAN_ONLY}If_an_option_buyer_wishes_to_exercise_the_option_rights,_the_seller_may_still_reject_the_deal_":"If an option buyer wishes to exercise the option rights, the seller may still reject the deal.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Sprawdź pocztę e-mail, aby odzyskać token potrzebny do zresetowania hasła.","year":"rok","German_Index":"Indeks niemiecki","Brazilian_Index":"Indeks brazylijski","Finance":"Finanse","Graphic_Designers":"Graficy","November":"Listopad","South_African_Index":"Indeks południowoafryk.","Contract":"Kontrakt","Keep_track_of_your_authorised_applications_":"Obserwuj swoje zatwierdzone aplikacje.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Wpisz datę odległą o co najmniej 6 miesięcy od dziś.","$100,000_-_$500,000":"100 000 $ – 500 000 $","Zoom":"Powiększ","{JAPAN_ONLY}About_OTC_currency_for_binary_options_trading,_summarizes_the_profit_and_loss_result_of_all_transactions_that_have_been_made_between_the_customer,_to_publish_the_information_in_the_company's_home_page,_at_any_time_while_the_customer_is_doing_the_transaction_before_the_start,_or_the_transaction,_the_information_Make_sure,_for_that_you're_willing_to_trade_under_the_calm_judgment,_we_are_committed_to_a_variety_of_environmental_improvement_":"About OTC currency for binary options trading, summarizes the profit and loss result of all transactions that have been made between the customer, to publish the information in the company's home page, at any time while the customer is doing the transaction before the start, or the transaction, the information Make sure, for that you're willing to trade under the calm judgment, we are committed to a variety of environmental improvement.","Your_changes_have_been_updated_":"Twoje zmiany zostały wprowadzone.","Ms":"Pani","May":"Maj","Profit":"Zysk","Exclude_time_must_be_after_today_":"Czas wyłączenia musi zaczynać się jutro lub później.","Rise/Fall":"Wzrost/spadek","Total_Cost":"Całkowity koszt","{JAPAN_ONLY}The_test_is_unavailable_now,_test_can_only_be_taken_again_on_next_business_day_with_respect_of_most_recent_test_":"The test is unavailable now, test can only be taken again on next business day with respect of most recent test.","Touch/No_Touch":"Osiągnie","Invalid_date_of_birth_":"Nieprawidłowa data urodzenia.","Sell_at_market":"Sprzedawaj na rynku","{JAPAN_ONLY}In_contrast_to_other_types_of_FX_options,_short_positions_in_FX_Binary_Options_cannot_be_closed-out_as_they_are_not_subject_to_loss-cut_regulations_":"In contrast to other types of FX options, short positions in FX Binary Options cannot be closed-out as they are not subject to loss-cut regulations.","Date_(GMT)":"Data (GMT)","Maximum_daily_turnover":"Maksymalny dzienny obrót","You_have_sold_this_contract_at_[_1]_[_2]":"Sprzedano ten kontrakt po cenie [_2] [_1]","Last_Digit_Stats":"Statystyki ostatniej cyfry","Permissions":"Pozwolenia","Compliance_Executive":"Starszy specjalista ds. zgodności","Settles":"Rozliczenie","Stocks_trading_experience":"Doświadczenie w handlowaniu akcjami","{JAPAN_ONLY}Option_prices_are_normally_dependant_on_elements_such_as_the_underlying_asset_price,_the_exercise_price,_the_length_of_time_until_the_exercise_point,_volatility,_and_interest_rates__Apart_from_the_fixed_exercise_price,_all_other_elements_are_changing_constantly,_so_an_understanding_of_the_relationships_between_each_element_and_changes_in_the_options_price_is_necessary_for_the_management_of_options_trading_risk_":"Option prices are normally dependant on elements such as the underlying asset price, the exercise price, the length of time until the exercise point, volatility, and interest rates. Apart from the fixed exercise price, all other elements are changing constantly, so an understanding of the relationships between each element and changes in the options price is necessary for the management of options trading risk.","Item":"Element","Month":"Miesiąc","Successful":"Zakończono powodzeniem","Unlock_Cashier":"Odblokuj sekcję Kasjer","Middle_East":"Środkowy Wschód","Pension":"Emerytura","Proofreader":"Korektor","Low_barrier_offset":"Ustawienie niskiego limitu"};
texts_json['DE'] = {"Accounts_And_Payments_Executive":"Buchhaltungs- & Zahlungsverkehrsleiter","Prices":"Kurse","Stop_Loss_Level":"Stop Loss Höhe","Please_select":"Bitte wählen Sie","This_contract_won":"Dieser Vertrag gewann","Oil/EUR":"Öl/EUR","Spot":"Kassakurs","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Ihr Auftrag [_1] [_2] von [_3] an [_4] zu überweisen, wurde erfolgreich bearbeitet.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Sie haben bereits den Gegenwert von [_1] [_2]  abgehoben, der sich in den letzten [_3] Tagen angesammelt hat.","Payout":"Auszahlung","Period":"Zeitraum","stays_between":"bleibt zwischen","Verification_Token":"Verifikationstoken","Deposit_of":"Einzahlung in Höhe von","odd":"ungleich","Wednesday":"Mittwoch","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Stellt das maximale Volumen an Kontrakten dar, die Sie an einem einzelnen Börsentag erwerben können.","Margin_FX":"Margen FX","month":"Monat","Minimum_of_[_1]_characters_required_":"Mindestens [_1] Zeichen sind erforderlich.","In/Out":"Innerhalb/Ausserhalb","Industry_of_Employment":"Beschäftigungsbranche","Human_Resource_Executive":"Personalmanager","Opens":"Öffnet","Exit_Spot":"Schlusskurs","Potential_Payout":"Mögliche Auszahlung","Bull_Market_Index":"Wall Street Index","Points":"Punkte","Score":"Punktzahl","touches":"berührt","Secondary":"Sekundäre/r","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Ihr Auszahlungslimit beträgt  [_1] [_2] (oder Gegenwert in anderer Währung).","Marketing_Executives":"Marketingleiter","No_Live_price_update":"Keine Live Kursaktualisierung","Please_select_a_payment_agent":"Bitte wählen Sie einen Zahlungsagent aus","Real_Account":"Echtes Konto","Europe/Africa":"Europa/Afrika","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- Eine gescannte Kopie einer Abrechnung öffentlicher Versorgungsbetriebe oder eines Bankkontoauszuges (nicht älter als 3 Monate).","Spanish_Index":"Spanischer Index","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Es darf ein zusätzliches Passwort verwendet werden, um den Zugang zum Kassensabschnitt zu beschränken.","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Ihr Konto ist vollständig authentifiziert und Ihr Abhebelimit wurde angehoben.","Swedish_Index":"Schwedischer Index","Binary_options_or_other_financial_derivatives_trading_experience":"Erfahrung mit Binären Optionen oder Handel mit anderen Finanzderivaten","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Ihr Passwort wurde erfolgreich zurückgesetzt. Bitte loggen Sie mit Ihrem neuen Passwort in Ihr Konto ein.","Less_than_$100,000":"Weniger als 100.000 $","Upcoming_Events":"Bevorstehende Events","minimum_available_duration":"kürzeste vorhandene Dauer","Now":"Jetzt","Construction":"Aufbau","Norwegian_Index":"Norwegischer Index","Korean_Index":"Koreanischer Index","Number_of_ticks":"Anzahl der Ticks","asian_up":"Asiatisch hoch","Entry_Level":"Einstiegshöhe","Asians":"Asiaten","Save_as_PDF":"Als PDF speichern","Contract_Confirmation":"Vertragsbestätigung","numbers":"Zahlen","View_your_statement":"Ihre Abrechnung ansehen","Delete":"Löschen","Profit/Loss_(points)":"Gewinn/Verlust (Punkte)","spread_down":"Spread tief","Continuous_Indices":"Laufende Indizes","Quality_Assurance_Engineer":"Qualitätssicherungsingenieur","Information_Technology":"Informationstechnologie","Digits":"Ziffern","Quantitative_Developer":"Quantitativer Entwickler","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"Derzeit lehnen wir die Eröffnung von Konten für Einwohner dieses Landes ab.","Australian_Index":"Australischer Index","0-5_transactions_in_the_past_12_months":"0-5 Transaktionen in den letzten 12 Monaten","Start_time":"Startzeit","Americas":"Amerika","Japanese_Index":"Japanischer Index","Salaried_Employee":"Abhängig Beschäftigte/r","There_was_some_invalid_character_in_an_input_field_":"Es ist ein ungültiges Zeichen in einem Eingabefeld vorhanden.","matches":"gleich","Long":"Lang","is_required__Current_spread":"ist erforderlich. Aktueller Spread","Less_than_$25,000":"Weniger als 25.000 $","Mr":"Herr","Volatility_25_Index":"Smart Indizes","1-2_years":"1-2 Jahre","March":"März","(Bejing/CST_-8_hours)":"(Peking/CST -8 Stunden)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] hat seine [_2] aktualisiert. Wenn Sie auf OK klicken, bestätigen Sie, dass Sie die aktualisierten [_2] zur Kenntnis genommen haben.","hyphen":"Trennungsstrich","Invalid_amount,_maximum_is":"Ungültiger Betrag, das Maximum ist","Week_of":"Woche von","Entry_Spot":"Startkurs","You_should_enter_between_[_1]_characters_":"Sie müssen zwischen [_1] Zeichen eingeben.","spread_up":"Spread hoch","Contract_is_not_started_yet":"Kontrakt ist noch nicht gestartet","Indicative":"Indikativ","Dutch_Index":"Niederländischer Index","Volatility_100_Index":"Smart Indizes","Metals":"Metalle","We":"Mi","Please_enter_a_number_between_0_and_[_1]":"Bitte geben Sie eine Zahl zwischen 0 und [_1] ein","Quantitative_Analyst":"Quantitativer Analyst","Level_of_Education":"Ausbildungsgrad","New_token_created_":"Neuer Token generiert.","even":"gleich","Authorise_your_account_":"Autorisieren Sie Ihr Konto.","Education":"Ausbildung","Contract_Sold":"Kontrakt verkauft","Gaming_Account":"Spielkonto","July":"Juli","June":"Juni","Thursday":"Donnerstag","Smart_Indices":"Smart Indizes","Your_details_have_been_updated_":"Ihre Angaben wurden aktualisiert.","Over_$1,000,000":"Über $1.000.000","Financial_Assessment":"Finanzielle Beurteilung","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Ihr [_1] Konto ist nicht vorhanden. Bei Fragen hierzu setzen Sie sich bitte mit [_2] in Verbindung.","Password_is_very_strong":"Passwort ist sehr stark","Both_the_above":"Beide obige","password":"Passwort","Stop-type":"Stopp-Art","Commodities_trading_frequency":"Rohstoffe Handelshäufigkeit","Transfer_to":"Überweisung an","Price":"Kurs","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Daher beträgt Ihre derzeitige maximale Sofortabhebung (vorausgesetzt Ihr Konto hat ein ausreichendes Guthaben) [_1] [_2].","ticks":"Ticks","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Wenn Sie auf 'Ok' klicken, werden Sie bis zum ausgewählten Datum vom Handel auf dieser Site ausgeschlossen.","Questions":"Fragen","and":"und","months":"Monate","Potential_Profit":"Möglicher Gewinn","over":"über","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Die Finanzhandelsdienste, die diese Site enthält, eignen sich nur für Kunden, die einen Verlust ihres gesamten investierten Geldes verkraften können und die die Risiken erkennen, die mit dem Erwerb von Finanzverträgen im Zusammenhang stehen und damit Erfahrung haben. Transaktionen mit Finanzkontrakten beinhalten ein hohes Risiko. Wenn erworbene Kontrakte wertlos auslaufen, geht Ihre gesamte Investition, die aus der Kontraktprämie besteht, verloren.","Sale_Date":"Verkaufsdatum","Exercise_period":"Ausübungszeitraum","February":"Februar","Exclude_time_cannot_be_less_than_6_months_":"Die Ausschlusszeit darf nicht kürzer als 6 Monate sein.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Ihr [_1] Tage Abhebelimit beträgt derzeit EUR [_2] [_3] (oder Gegenwert in einer anderen Währung).","Incyte_Corpoartion":"Incyte Corporation","Your_current_balance_is":"Ihr aktuelles Guthaben beträgt","Singapore_Index":"Singapur Index","Duration":"Laufzeit","This_contract_lost":"Dieser Kontrakt verlor","Indices_trading_frequency":"Indizes Handelshäufigkeit","Other_financial_instruments_trading_frequency":"Handelshäufigkeit von anderen Finanzinstrumenten","Password_is_strong":"Passwort ist stark","Stop_Profit_Level":"Stop Profit Höhe","Try_adding_more_letters_":"Versuchen Sie mehr Buchstaben hinzuzufügen.","Egypt_Index":"Ägypten Index","Net_profit":"Nettogewinn","Verification_code_format_incorrect_":"Format des Verifikationscodes falsch.","There_was_a_problem_accessing_the_server_during_purchase_":"Während des Kaufs ist ein Problem beim Zugriff auf den Server aufgetreten.","Adjust_trade_parameters":"Anpassen von Handelsparametern","Dutch_Stocks":"Niederländische Aktien","Over_$500,001":"Über $ 500.001","Th":"Do","Oct":"Okt","Even/Odd":"Gerade/ungerade","Barrier_offset":"Schwellenverschiebung","This_feature_is_not_relevant_to_virtual-money_accounts_":"Diese Funktion ist für virtuelle Geldkonten nicht relevant","Password_should_have_lower_and_uppercase_letters_with_numbers_":"Das Passwort muss Klein- und Großbuchstaben sowie Zahlen enthalten.","Step":"Schritt","Next_Day":"Nächster Tag","Applications":"Anwendungen","Save_as_CSV":"Als CSV speichern","Internal_Auditor":"Interner Revisor","Loss":"Verlust","Other":"Sonstiges","Health":"Befinden","Dutch_Smart_Index":"Niederländischer Smart Index","letters":"Buchstaben","under":"unter","Silver/USD":"Silber/USD","m":"M","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Letzte Stellen Statistik der letzten [_1] Ticks von [_2]","Energy":"Energie","Over_3_years":"Über 3 Jahre","From":"Von","does_not_touch":"erreicht nicht","hour":"Stunde","View":"Ansehen","Sorry,_an_error_occurred_while_processing_your_account_":"Es tut uns leid, bei der Bearbeitung Ihres Kontos ist ein Fehler aufgetreten.","An_error_occured_":"Es ist ein Fehler aufgetreten.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Daher ist Ihr aktuelles sofortiges Maximum für eine Abhebung (sofern Ihr Konto über ausreichend Guthaben verfügt) EUR [_1] [_2] (oder Gegenwert in einer anderen Währung).","Russian_10_Index":"Russischer 10 Index","New_Password":"Neues Passwort","Trading_Limits":"Handelslimits","German_Smart_Index":"Deutscher Smart Index","Details":"Angaben","Login_History":"Login-Verlauf","Invalid_amount,_minimum_is":"Ungültiger Betrag, das Minimum ist","Technip_oil_equipment_and_services":"Technip Oil Equipment and Services","minute":"Minute","Please_deposit_before_transfer_to_client_":"Bitte einzahlen, bevor Sie an den Kunden überweisen.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Bitte befolgen Sie dieses Muster: 3 Zahlen, ein Bindestrich, gefolgt von 4 Zahlen.","Password_Reset":"Passwort Rücksetzung","Maximum_account_cash_balance":"Maximales Kontoguthaben","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Ihr Konto ist vollständig authentifiziert. Ihre [_1] Handelslimits sind hier ersichtlich","Bombay_Index":"Mumbai Index","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Bitte bestätigen Sie die Transaktionsdaten, um den Transfer zu vervollständigen:","Lock_Cashier":"Kasse blockieren","seconds":"Sekunden","Matches/Differs":"Gleich/Verschieden","Select_your_market":"Wählen Sie Ihren Markt","apostrophe":"Apostroph","Canadian_Index":"Kanadischer Index","Finish":"Beenden","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"Das Passwort muss mindestens 1 Zahl, 1 Großbuchstaben und 1 Kleinbuchstaben enthalten.","Roche_Holding_Ag-Genusschein":"Roche Holding Ag-Genussschein","Oil/USD":"Öl/USD","False":"Falsch","Up/Down":"Auf/Ab","Human_Resources":"Personalabteilung","Mrs":"Frau","Profit_Table":"Gewinntabelle","Purchase":"Kauf","Tourism":"Tourismus","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Ihre Kasse ist auf Ihren Antrag hin gesperrt - um Sie zu entsperren, geben Sie bitte das Passwort ein.","Invalid_email_address":"Falsche E-Mail Adresse","Please_enter_an_integer_value":"Bitte geben Sie einen ganzzahligen Wert ein","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Leider steht diese Funktion nur für virtuelle Konten zur Verfügung.","Investment_Account":"Investmentkonto","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Sie sind nicht befugt, eine Auszahlung über einen Zahlungsagent zu tätigen.","Quantitative_Analysis":"Quantitative Analyse","Miss":"Verpasst","Please_check_your_email_for_the_value_of_this_token":"Bitte überprüfen Sie für den Wert dieses Token Ihren E-Mail Eingang","Forex_trading_experience":"Devisenhandelserfahrung","Amount":"Betrag","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Die Höchstzahl an Token ([_1]) wurde erreicht.","Global_Customer_Service_Representatives":"Globale Kundendienstmitarbeiter","Withdrawal_Limits":"Abhebungslimits","Print_chart":"Chart drucken","Please_try_again_":"Bitte versuchen Sie es erneut.","Your_transaction_reference_is":"Ihre Überweisungsreferenz lautet","Save_as_SVG":"Als SVG speichern","You_have_already_withdrawn_[_1]_[_2]_":"Sie haben bereits [_1] [_2] abgehoben.","Profit/Loss":"Gewinn/Verlust","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Bitte tragen Sie im nachfolgenden Formular die Login ID und den Betrag ein, den Sie Ihrem Kunden überweisen möchten:","Password_does_not_match_":"Passwort stimmt nicht überein.","Commodities":"Rohstoffe","Transfer_to_Login_ID":"Wechsel zur Login ID","Update":"Aktualisieren","Volatility_75_Index":"Smart Indizes","goes_outside":"geht außerhalb","Chart":"Diagramm","High_Barrier":"Hohe Schwelle","Date_of_Birth":"Geburtsdatum","space":"Bereich","Portuguese_Smart_Index":"Portugiesischer Smart Index","Saturday":"Samstag","Never_Used":"Nie verwendet","Volatility_50_Index":"Smart Indizes","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Stellt die maximalen Gesamtauszahlungen ausstehender Verträge Ihres Portfolios dar. Wenn das Maximum erreicht ist, können Sie keine zusätzlichen Verträge erwerben, ohne zunächst bestehende Positionen zu schließen.","Description":"Beschreibung","Sell":"Verkaufen","October":"Oktober","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Sie sind derzeit in Ihr Echtgeldkonto bei [_1] (2%) eingeloggt.","Terms_&_Conditions":"Allgemeine Geschäftsbedingungen","Only_2_decimal_points_are_allowed_":"Es sind nur 2 Dezimalstellen erlaubt.","period":"Zeitraum","Password_score_is:_[_1]__Passing_score_is:_20_":"Passwort Punktzahl ist: [_1]. Mindestpunktzahl ist: 20.","Stays_In/Goes_Out":"Bleibt in/Geht außerhalb","Note":"Anmerkung","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Stellt die maximale Anzahl an ausstehenden Verträgen Ihres Portfolios dar. Jede Linie Ihres Portfolios steht für eine offene Position. Wenn das Maximum erreicht wird, können Sie keine neuen Positionen öffnen, ohne zuvor eine bereits bestehende Position zu schließen.","Italian_30_Index":"Italienischer 30 Index","Password_is_not_strong_enough_":"Passwort ist nicht stark genug.","Asset":"Kapital","Duerr_AG":"Dürr AG","Swiss_Smart_Index":"Schweizer Smart Index","0-1_year":"0-1 Jahre","Contract_Information":"Kontraktinformation","Translator":"Übersetzer","Sorry,_account_opening_is_unavailable_":"Leider ist die Kontoeröffnung nicht möglich.","Anti-Fraud_Officer":"Betrugsbekämpfungsbeauftragter","Barrier":"Schwelle","Current_Level":"Aktuelle Höhe","Password_is_moderate":"Passwort ist moderat","Failed_to_reset_password__[_1],_please_retry_":"Das Zurücksetzen des Passworts ist fehlgeschlagen. [_1], bitte erneut versuchen.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Ihr Kunde wird eine E-Mail Benachrichtigung erhalten, in der er/sie darüber informiert wird, dass die Überweisung bearbeitet wurde.","Low_Barrier":"Untere Schwelle","Previous_Day":"Vorheriger Tag","NZDCHF":"NZD/CHF","Senior_Perl_Developer":"Leitender Perl-Entwickler","IP_Address":"IP-Adresse","Tu":"Di","$100,000_-_$250,000":"$100.000 - $250.000","Senior_Front-End_Developer":"Leitender Frontend-Entwickler","Sale_Price":"Verkaufskurs","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Geben Sie die Schwelle für die Differenz zum Kassakurs an. Wenn Sie +0,005 eingeben, erwerben Sie einen Kontrakt mit einer 0,005 höheren Schwelle als der Startkurs. Der Startkurs ist der nächste Tick nachdem Ihr Auftrag eingegangen ist","Social_Media_Executive":"Leitender Angestellter für Soziale Medien","Short":"Kurz","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Bevor Sie fortfahren, bestätigen Sie bitte das Geschäft in Ihrem Auszug.","Reset_Password":"Passwort zurücksetzen","Year":"Jahr","Other_financial_instruments_trading_experience":"Handelserfahrung mit anderen Finanzinstrumenten","Forex_trading_frequency":"Devisenhandelshäufigkeit","Purchase_Time":"Kaufuhrzeit","Day":"Tag","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- Eine gescannte Kopie Ihres Reisepasses, gültigen Führerscheins (vorläufig oder endgültig) oder Personalausweises, auf der Ihr Name und das Geburtsdatum erkennbar sind.","$250,000_-_$1,000,000":"$250.000-$1.000.000","Old_password_is_wrong_":"Altes Passwort ist falsch.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Ihr Auftrag, [_1] [_2] von Ihrem Konto [_3] auf das Konto des Zahlungsagent [_4] zu überweisen, wurde erfolgreich bearbeitet.","Trading_and_Withdrawal_Limits":"Handels- und Abhebelimits","High_barrier_offset":"Hohe Schwellenverschiebung","Are_you_sure_that_you_want_to_permanently_delete_token":"Sind Sie sicher, dass Sie den Token endgültig löschen möchten?","Open":"Offen","ends_outside":"endet außerhalb","You_did_not_change_anything_":"Sie haben nichts geändert.","Russian_Regular_Index":"Russischer Regulärindex","Over/Under":"Über/Unter","The_two_passwords_that_you_entered_do_not_match_":"Die beiden Passwörter, die Sie eingegeben haben, stimmen nicht überein.","Failed":"Fehlgeschlagen","You_have_not_granted_access_to_any_apps_":"Sie haben keinen Zugriff auf Apps gewährt.","Stop-loss":"Stop-Loss","This_field_is_required_":"Dieses Feld ist erforderlich.","Return":"Rendite","Tertiary":"Tertiär","$25,000_-_$100,000":"$25.000 - $100.000","Swiss_Index":"Schweizerischer Index","AP_Ordinary":"AP Allgemein","Indices_trading_experience":"Indizes Handelserfahrung","6-10_transactions_in_the_past_12_months":"6-10 Transaktionen in den letzten 12 Monaten","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Wenn Sie auf \"Abschicken\" klicken, wird der Betrag von Ihrem Konto abgebucht und auf Ihr Kundenkonto überwiesen.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"Minuten","True":"Wahr","day":"Tag","Internal_Audit":"Interne Prüfung","Save_as_JPEG":"Als JPEG speichern","Platinum/USD":"Platin/USD","Income_Source":"Einkommensquelle","hours":"Stunden","second":"Sekunde","Belgian_Stocks":"Belgische Aktien","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Sie haben bereits den Gegenwert von [_1] [_2] abgehoben.","Date":"Datum","Asia/Oceania":"Asien/Ozeanien","Italian_Index":"Italienischer Index","Waiting_for_entry_tick_":"Warten auf den Eingangstick.","lower":"niedriger","Confirm_New_Password":"Neues Passwort bestätigen","Country_Manager":"Ländermanager","Select_your_underlying_asset":"Wählen Sie Ihren Basiswert aus","AUDZAR":"AUD/ZAR","Last_Digit_Prediction":"Voraussage der Letzten Stelle","Try_adding_more_letters_or_numbers_":"Versuchen Sie mehr Buchstaben oder Zahlen hinzuzufügen.","Purchase_Price":"Kaufpreis","UK_Smart_Index":"GB Smart Index","days":"Tage","{JAPAN_ONLY}Prices_for_currency_options_are_calculated_relative_the_value_of_theunderlying_spot_price,_and_are_dependant_on_multiple_factors_which_may_vary_":"{JAPAN ONLY}Price of OTC currency option is the calculated value based on multiple elements and is determined by relative trading basically.","Never":"Nie","Save_as_PNG":"Als PNG speichern","New_Zealand_Index":"Neuseeland Index","Solvay_chemicals":"Solvay Chemicals","Major_Pairs":"Wichtigste Paare","Su":"So","Please_enter_a_number_between_[_1]_":"Bitte geben Sie eine Zahl zwischen [_1] ein.","Marketing_Project_Manager":"Marketing Projektmanager","Jump_To":"Springen zu","loading___":"wird geladen...","Accounting":"Buchhaltung","French_Index":"Französischer Index","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Wenn Sie auf 'Ok' klicken, werden Sie bis zum ausgewählten Datum vom Handel auf dieser Site ausgeschlossen.","Spot_Time":"Kassa-Zeit","Closes":"Schließt","To":"An","Reference_ID":"Referenznr.","Administrative_Executive":"Verwaltungsleiter","Tuesday":"Dienstag","Sorry,_this_feature_is_not_available_":"Leider ist diese Funktion nicht vorhanden.","Select_market":"Wählen Sie den Markt","High_barrier":"Hohe Schwelle","Closed":"Geschlossen","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Sie müssen die Geschäftsbedingungen akzeptieren, um ein Konto eröffnen zu können.","USDZAR":"USD/ZAR","Mar":"Mär","Dec":"Dez","Portuguese_Index":"Portugiesischer Index","higher":"höher","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Zahlen Sie [_1] [_2] virtuelles Geld auf Ihr Konto [_3] ein","Monday":"Montag","differs":"unterschiedlich","Current":"Derzeit","Predict_the_direction<br_/>and_purchase":"Sagen Sie die Richtung voraus<br />und kaufen Sie","Oil/AUD":"Öl/AUD","Self-Employed":"Selbstständig","Estimated_Net_Worth":"Geschätzter Nettowert","Binary_options_or_other_financial_derivatives_trading_frequency":"Handelshäufigkeit mit Binären Optionen oder anderen Finanzderivaten","Action":"Handlung","French_Smart_Index":"Französischer Smart Index","Customer_Support":"Kundendienst","Ford_Motor_Comapny":"Ford Motor Company","comma":"Komma","minutes":"Minuten","Last_Used":"Zuletzt verwendet","Oil/GBP":"Öl/GBP","Indian_50_Index":"Indischer 50 Index","This_contract_has_LOST":"Dieser Kontrakt hat VERLOREN","Net_Annual_Income":"Nettojahreseinkommen","40_transactions_or_more_in_the_past_12_months":"40 Transaktionen, oder mehr, in den letzten 12 Monaten","Previous":"Vorige","Investments_&_Dividends":"Investitionen & Dividenden","Stocks_trading_frequency":"Aktienhandelshäufigkeit","Your_withdrawal_limit_is_[_1]_[_2]_":"Ihr Abhebelimit beträgt  [_1] [_2].","Failed_to_update_trade_description_":"Aktualisierung der Kontraktbeschreibung fehlgeschlagen.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Bitte geben Sie eine Zahl größer oder gleich groß wie [_1] ein.","Bear_Market_Index":"Belgischer Smart Index","Stocks":"Aktien","not_available":"nicht vorhanden","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"In Ihrem Land ist derzeit kein Zahlungsagent vorhanden.","Buy":"Kaufen","Exclude_time_cannot_be_for_more_than_5_years_":"Die Ausschlusszeit darf nicht länger als 5 Jahre sein.","Next":"Weiter","Friday":"Freitag","Your_account_has_no_trading_activity_":"Ihr Konto hat keine Handelsaktivität.","Your_trading_statistics_since_[_1]_":"Ihre Trading-Statistiken seit [_1].","Your_settings_have_been_updated_successfully_":"Ihre Einstellungen wurden erfolgreich aktualisiert.","Your_password_cannot_be_the_same_as_your_email":"Ihr Passwort kann nicht wie Ihre E-Mail Adresse lauten","Please_select_a_valid_date":"Bitte wählen Sie ein gültiges Datum aus","Walkthrough_Guide":"Komplettleitfaden","verification_token":"Verifikationstoken","points":"Punkte","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Um Ihr Konto zu authentifizieren, übersenden Sie uns bitte per E-Mail gescannte Kopien von Folgendem an [_1]","Contract_Expiry":"Kontraktauslauf","December":"Dezember","Quality_Assurance":"Qualitätssicherung","Primary":"Primär","Revoke_access":"Zugang widerrufen","Saudi_Arabia_Index":"Saudi Arabien Index","Try_adding_more_numbers_":"Versuchen Sie, mehr Zahlen hinzufügen.","Password_is_weak":"Passwort ist schwach","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Sie sind derzeit in Ihr virtuelles Geld Konto (2%) eingeloggt.","Higher/Lower":"Höher/Tiefer","Stake":"Einsatz","Amount_per_point":"Betrag je Punkt","Date_and_Time":"Datum und Zeit","Total_Profit/Loss":"Gesamter Gewinn/Verlust","Sorry,_an_error_occurred_while_processing_your_request_":"Es tut uns leid, bei der Bearbeitung Ihrer Anfrage ist ein Fehler aufgetreten.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Stellt den maximalen Bargeldbetrag dar, den Sie auf Ihrem Konto haben dürfen. Wenn das Maximum erreicht wird, werden Sie gebeten, Gelder abzuheben.","Confirm":"Bestätigen","Back":"Zurück","Balance":"Guthaben","Statement":"Abrechnung","Contract_/_Temporary_/_Part_Time":"Vertrag / Befristet / Teilzeit","ends_between":"schließt zwischen","Japanese_Smart_Index":"Japanischer Smart Index","Your_account_has_no_Login/Logout_activity_":"Ihr Konto hat keine Anmelde- und Abmeldeaktivität.","Select_your_trade_type":"Wählen Sie Ihren Trade-Typ aus","asian_down":"asiatisches Tief","Exit_Spot_Time":"Schlusskurs","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Wir können zu diesem Zeitpunkt keine Kurse live anzeigen. Zur Ansicht der Echtzeitanzeige der Kurse sollten Sie diese Seite über den Browser aktualisieren. Wenn das Problem nach wiederholten Aktualisierungen der Seite weiter besteht, sollten Sie einen anderen Browser ausprobieren","Low_barrier":"Untere Schwelle","Commodities_trading_experience":"Rohstoff Handelserfahrung","Forex":"Devisenhandel","Minor_Pairs":"Untergeordnete Paare","Contract_ID":"Kontrakt ID","Only_[_1]_are_allowed_":"Es sind nur [_1] erlaubt.","Virtual_Account":"Virtuelles Konto","Our_site_does_not_charge_any_transfer_fees_":"Unsere Site berechnet keine Überweisungsgebühren.","Daily_Reset_Indices":"Täglich zurückgesetzte Indizes","Deposit":"Einzahlung","French_Stocks":"Französische Aktien","Please_input_a_valid_date":"Bitte geben Sie ein gültiges Datum ein","years":"Jahre","Sunday":"Sonntag","Explanation":"Erläuterung","This_contract_has_WON":"Dieser Kontrakt hat GEWONNEN","Please_wait_<br_/>Your_request_is_being_processed_":"Bitte warten Sie.<br />Ihre Anfrage wird bearbeitet.","Irish_Index":"Irischer Index","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Ihre [_1] Konten sind nicht vorhanden. Bei Fragen hierzu setzen Sie sich bitte mit [_2] in Verbindung.","Volatility_Indices":"Volatilität Indizes","Belgian_Index":"Belgischer Index","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Ihr Token ist abgelaufen. Bitte klicken Sie <a class=\"pjaxload\" href=\"[_1]\">hier</a>, um den Verfikationsprozess zu wiederholen.","Remaining_Time":"Verbleibende Zeit","Your_transaction_reference_number_is_[_1]":"Ihre Überweisungsnummer ist [_1]","January":"Januar","There_was_an_error":"Es ist ein Fehler aufgetreten","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Format: jjjj-mm-tt (bei virtuellen Konten nicht erforderlich)","Maximum_number_of_open_positions":"Maximale Anzahl offener Positionen","Start_Time":"Startzeit","Exit_Level":"Ausstiegshöhe","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] wurden Ihrem virtuellen Geldkonto [_3] gutgeschrieben","Please_submit_a_valid_[_1]_":"Bitte übermitteln Sie eine gültige [_1].","Session_duration_limit_cannot_be_more_than_6_weeks_":"Die Sitzungsdauer kann nicht mehr als 6 Wochen betragen.","Ends_In/Out":"Endet innerhalb/außerhalb","Indices":"Indizes","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"Der Kontrakt wird, sobald der Auftrag von unseren Servern empfangen wurde, zum dann geltenden Marktkurs verkauft. Dieser Kurs kann von den angegebenen Kursen abweichen.","Maximum_aggregate_payouts_on_open_positions":"Maximale Gesamtauszahlungen auf offene Positionen","UK_Index":"GB Index","Credit/Debit":"Gutschrift/Lastschrift","End_Time":"Endzeit","There_was_a_problem_accessing_the_server_":"Es gab ein Problem beim Zugriff auf den Server.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Bitte überprüfen Sie Ihren E-Mail Eingang, um den Token, der für die Zurücksetzung Ihres Passworts nötig ist, abzurufen.","year":"Jahr","German_Index":"Deutscher Index","Brazilian_Index":"Brasilianischer Index","Finance":"Finanzen","Graphic_Designers":"Grafikdesigner","South_African_Index":"Südafrikanischer Index","Contract":"Kontrakt","Keep_track_of_your_authorised_applications_":"Verfolgen Sie Ihre genehmigten Anwendungen nach.","Please_enter_a_valid_amount_":"Bitte geben Sie einen gültigen Betrag ein.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Bitte geben Sie ein Datum ein, das mindestens 6 Monate in der Zukunft liegt.","$100,000_-_$500,000":"$100.000 - $500.000","Your_changes_have_been_updated_":"Ihre Änderungen wurden aktualisiert.","Ms":"Frl.","May":"Mai","Profit":"Rendite","Exclude_time_must_be_after_today_":"Die Ausschlusszeit muss nach dem heutigen Tag beginnen.","Rise/Fall":"Steigen/Fallen","Total_Cost":"Gesamtkosten","Touch/No_Touch":"Erreicht","Invalid_date_of_birth_":"Falsches Geburtsdatum.","Sell_at_market":"Zum Börsenkurs verkaufen","Date_(GMT)":"Datum (GMT)","Maximum_daily_turnover":"Maximaler Tagesumsatz","Targeting_short-term_profits":"Auf kurzfristige Gewinne gerichtet","You_have_sold_this_contract_at_[_1]_[_2]":"Sie haben diesen Kontrakt für [_1] [_2] verkauft","Commbank_(Australia)":"Commbank (Australien)","Last_Digit_Stats":"Statistiken der Letzten Stelle","Permissions":"Berechtigungen","Compliance_Executive":"Compliancebeauftragter","Settles":"Begleicht","Stocks_trading_experience":"Aktienhandelserfahrung","Item":"Posten","Month":"Monat","Successful":"Erfolgreich","Unlock_Cashier":"Kasse entsperren","Middle_East":"Mittlerer Osten","Pension":"Rente/Pension","Proofreader":"Korrektor","Low_barrier_offset":"Verschiebung der unteren Schwelle"};
texts_json['JA'] = {"eBay_Inc_":"eBay Inc.（イーベイ）","Accounts_And_Payments_Executive":"顧客・支払担当者","{JAPAN_ONLY}If_you_sell_a_currency_binary_option_at_a_price_of_500_yen,_and_the_judgment_price_meets_the_conditions_so_you_need_to_payout_1,000_yen,_then_your_profit_will_be_minus_500_yen_after_subtracting_the_500_yen_that_was_received_as_a_fee_from_the_option_buyer_":"ペイアウト1,000円のバイナリーコールオプションを500円で売却取引し、判定の結果、権利行使条件が満たされた場合には、売り手は買い手に対するペイアウトとして1,000円を支払わなければならず、したがって売り手の損益は、買い手から受け取った500円と差し引き500円の損失となる。","{JAPAN_ONLY}The_price_of_OTC_binary_options_of_the_same_conditions,_(sometimes)_the_price_varies_depending_on_transactions_dealers_handling_financial_instruments_business_":"同一条件の店頭バイナリーオプションの価格は、取扱金融商品取引業者により価格が異なる（場合がある）。","Prices":"価格","Stop_Loss_Level":"損切りレベル","Please_select":"選択して下さい","This_contract_won":"このトレードは勝ち判定","MasterCard_Inc_":"MasterCard Inc.（マスターカード）","Spot":"スポット","ASML_Holding":"ASMLホールディング","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"[_3]から[_4]へのご送金[_1] [_2]リクエストが正常に処理されました。","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"直近[_3]日間に累計[_1] [_2] と同等の金額を既に出金されています。","Payout":"ペイアウト","Nike_Inc_":"Nike Inc.（ナイキ）","Bouygues_heavy_construction":"Bouygues 建設重機","McDonald's_Corporation":"McDonald's Corporation（マクドナルド）","Unilever_plc":"Unilever plc（ユニリーバ英）","{JAPAN_ONLY}A_binary_option_which_is_out-of-the-money_will_have_a_lower_price_than_an_option_which_is_in-the-money_because_the_probability_of_receiving_the_payout_amount_is_lower_":"アウトオブザマネーのバイナリーオプションは、ペイアウトを受け取る確率が低いため、インザマネーのバイナリーオプションよりも価格が低い。","Period":"期間","stays_between":"STAY-IN","WESFARMERS_LIMITED":"WESFARMERS LIMITED（ウェスファーマーズ）","Verification_Token":"認証コード","Deposit_of":"Xのご入金","odd":"奇数","Pfizer_Inc_":"Pfizer Inc.（ファイザー）","{JAPAN_ONLY}Because_option_prices_are_determined_by_the_probability_of_being_exercised,_it_cannot_be_said_that_cheaper_options_have_any_natural_advantage_over_expensive_options_":"権利行使により利益が得られる確率を踏まえれば、一概にオプション価格が安いものが有利とはいえない。","Wednesday":"水曜日","{JAPAN_ONLY}An_option_holder_must_buy_(_or_sell_)_the_underlying_asset_at_a_predetermined_price_within_a_specified_period_(_or_at_a_specific_time_)_":"オプションとは、一定の期間内（又は特定の期日）に、あらかじめ定めた価格によって原資産を買い取る（又は売り渡す）ことができる権利をいい、オプションの所有者は、一定の期間内（又は特定の期日）には、あらかじめ定めた価格によって原資産を必ず買い取らなければ（又は売り渡さなければ）ならない。","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"購入可能な１日あたりのトレードの総額を示します。","Director":"取締役","Dubai_Index":"ドバイ インデックス","Margin_FX":"外国為替証拠金取引","month":"ヶ月","Fitbit_Inc_":"Fitbit Inc.（フィビット）","SolarCity_Corporation":"SolarCity Corporation（ソーラーシティ）","{JAPAN_ONLY}Unless_special_arrangements_are_made,_cooling-off_will_not_be_available_after_OTC_binary_options_trading_contract_has_been_made_":"特別の取り決めがなされる場合を除き、店頭バイナリーオプション取引契約成立（約定）後においてクーリングオフを行うことはできない。","Cisco_Systems_Inc_":"Cisco Systems Inc.（シスコシステムズ）","Minimum_of_[_1]_characters_required_":"[_1]文字以上でご入力ください。","In/Out":"レンジ","Industry_of_Employment":"雇用産業","Human_Resource_Executive":"人材管理","AXA":"AXA（アクサ）","{JAPAN_ONLY}If_the_buyer_of_an_option_does_not_exercise_the_option_rights,_there_will_be_no_fee_payable_to_the_option_seller_":"オプションの買い手は、権利行使をしなかった場合には、オプションの売り手にオプション料を支払わない。","Opens":"開場時間","Exit_Spot":"終値","Potential_Payout":"ペイアウト","{JAPAN_ONLY}If_the_buyer_of_an_option_waives_his_right_to_exercise,_a_transaction_in_the_underlying_asset_will_not_be_dealt_between_the_seller_and_the_buyer_":"オプションの買い手は、権利を放棄することができる。放棄した場合には、オプションの売り手との間での原資産の売買は成立しない。","Bull_Market_Index":"ブルマーケットインデックス","{JAPAN_ONLY}If_you_sell_a_currency_binary_put_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_need_to_payout_1,000_yen_to_the_buyer_of_the_option_":"権利行使価格１ドル100円、ペイアウト1,000円のドル円のプットバイナリーオプションの購入代金500円を受け取り、判定レートが１ドル９９円となり権利行使が行われ、1,000円のペイアウトを支払った。","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_stays_between_low_and_high_values_of_Exercise_price_through_close_on_[_4]_":"[_3]が[_4]まで常に上限バリアと下限バリアの範囲内に留まった場合、[_1] [_2]のペイアウトをお受け取りいただけます。","{JAPAN_ONLY}The_seller_of_a_vanilla_option_can_not_choose_whether_to_exercise_the_option_or_not__His_profit_is_limited_to_the_price_received_for_the_option,_whereas_his_potential_loss_is_unlimited_and_could_be_substantial_":"プレーンオプションの売り手は、利益額はオプション料に限定される一方、原資産価格と権利行使価格の差が損失となるので、原資産価格が無限大とすれば、その損失額も無限大となる。","Points":"ポイント","Score":"スコア","Belgacom":"Belgacom（ベルガコム）","touches":"タッチ","Secondary":"セカンダリー","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"お客様のご出金限度額は [_1] [_2] です。 (または同等の他通貨)","Roche_Holding_AG":"Roche Holding AG（ロシュ ホールディング）","{JAPAN_ONLY}As_the_time_to_the_exercise_point_shortens,_the_time-value_of_a_plain_vanilla_option_decreases_":"時間的価値は、オプションの権利行使期限までの時間が短くなるほど減少する。","{JAPAN_ONLY}Options_are_said_to_be_leveraged_products_because_in_the_case_of_large_moves_in_the_underlying_asset_price,_the_values_of_the_options_can_increase_by_large_amounts_compared_to_the_price_paid_for_the_option_":"オプションのレバレッジ効果により、買い手はオプション料に比べ数倍の利益が得られる可能性があるが損失はオプション料に限られ、逆に売り手は利益がオプション料に限られるが損失はオプション料の数倍となる可能性がある。","GoPro_Inc_":"GoPro Inc.（ゴープロ）","{JAPAN_ONLY}The_buyer_of_a_vanilla_option_can_choose_whether_to_exercise_the_option_or_not__His_loss_is_limited_to_the_price_paid_for_the_option,_whereas_his_potential_profit_is_unlimited_":"プレーンオプションの買い手は、自分に不利なときには権利放棄するので、買い手の最大損失額はオプション料、利益額は原資産価格と権利行使価格の差からオプション料を引いた額となり、原資産価格が無限大ならば、利益も無限大となる。","Marketing_Executives":"マーケティング担当役員","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_touches_Exercise_price_through_close_on_[_4]_":"[_3]が[_4]までに権利行使価格に達した場合、[_1] [_2]のペイアウトをお受け取りいただけます。","No_Live_price_update":"最新価格の更新がありません","Please_select_a_payment_agent":"決済サービスを選択してください。","{JAPAN_ONLY}Even_if_all_details_of_the_binary_options_match_perfectly,_there_may_still_be_differences_in_the_prices_shown_by_different_broking_companies_":"同一条件の店頭バイナリーオプションの価格は、取扱金融商品取引業者により価格が異なる（場合がある）。","Real_Account":"リアル口座番号","Europe/Africa":"ヨーロッパ・アフリカ","3M_Company":"3M Company（スリーエム）","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"公共料金の請求書または銀行明細書をスキャンしたコピー（発行３ヶ月以内のものに限ります）。","30-50_million_JPY":"3,000〜5,000万円","VISA_Inc_":"VISA Inc.（ビザ）","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"入出金へのアクセスを制限するために、追加パスワードを使用することができます。","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"お客様のご口座はアップグレード済みですので、ご出金制限が引き上げられました。","Shenzhen_300_Index":"深セン 300インデックス","Binary_options_or_other_financial_derivatives_trading_experience":"バイナリーオプションまたはその他金融デリバティブ取引のご経験","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"お客様パスワードの再設定完了いたしました。新しいパスワードで口座にログインして下さい。","Less_than_$100,000":"$100,000未満","{JAPAN_ONLY}The_price_of_a_vanilla_call_option_will_be_lower_when_price_of_the_underlying_asset_is_low,_but_the_price_of_the_put_option_will_be_higher_when_the_price_of_the_underlying_asset_is_low_":"コールオプションの価格は原資産の金利が低くなると下がるが、プットオプションの価格は、原資産の金利が低くなると上がる。","Jul":"７月","Upcoming_Events":"祝祭日","minimum_available_duration":"最短取引期間","Construction":"設営","{JAPAN_ONLY}For_an_out-of-the-money_option,_the_further_away_from_the_underlying_asset_price_that_the_option_exercise_price_is,_the_lower_the_price_of_the_option_will_be_":"アウトオブザマネーのオプションでは、原資産価格が権利行使価格から離れるほど、オプション価格は低くなる。","Vallourec_SA":"Vallourec SA（バローレック）","{JAPAN_ONLY}The_Black-Scholes_model_is_widely_used_to_calculate_theoretical_option_prices_":"オプション価格の理論式として、ブラック・ショールズ・モデルが広く用いられている。","{JAPAN_ONLY}It_is_possible_to_use_two_binary_options_to_make_a_profit_if_the_asset_price_settles_outside_the_two_strikes__It_is_also_possible_to_buy_a_single_range_option_that_will_achieve_the_same_result_":"２つのオプションを用い、権利行使価格の高いバイナリーコールオプションと権利行使価格の低いバイナリープットオプションを取得すれば、判定レートが２つのオプションの権利行使価格で作られた価格帯の外となった場合に収益が得られ、判定レートが所定の価格帯の外であった場合にペイアウトとなるレンジバイナリーオプションに似た投資を行うことができる。","Citigroup_Inc_":"Citigroup Inc.（シティグループ）","Deutsche_Telekom_AG":"Deutsche Telekom AG（ドイツテレコム）","Number_of_ticks":"Tickの総数","asian_up":"Asian アップ","ArcelorMittal_steel":"ArcelorMittal steel（アルセロール ミタル）","Volkswagen_AG":"Volkswagen AG（フォルクスワーゲン）","Entry_Level":"エントリーレベル","{JAPAN_ONLY}For_a_currency_binary_option_which_has_the_underlying_exchange_rate_of_dollars_against_yen,_the_right_to_receive_a_payout_if_the_yen_becomes_weaker_is_known_as_a_dollar-put_binary_option_":"通貨バイナリーオプションのうち、例えばドル円を原資産とし、円安になればペイアウトを受け取る権利は、ドル円のバイナリープットオプションと呼ぶ。","September":"９月","Save_as_PDF":"PDFへ保存","Tesco_plc":"Tesco plc（テスコ）","{JAPAN_ONLY}Dear_customer,_you_are_not_allowed_to_take_knowledge_test_until_[_1]_\\nLast_test_taken_at_[_2]_":"｛日本限定｝知識確認テストの受験は1日1度のみとなっておりますので、[_1]以降に再受験して下さい。前回のテスト受験日[_2].","Contract_Confirmation":"トレード確定","numbers":"数字","Toyota_Motor_Corporation":"トヨタ自動車株式会社","View_your_statement":"取引履歴を表示","CBS_Corporation":"CBSコーポレーション","{JAPAN_ONLY}Sorry,_you_have_failed_the_test,_please_try_again_after_24_hours_":"残念ながら、合格点に達しませんでした。翌日以降（または24時間以降）に再受験して下さい。","Merck_&_Co__Inc_":"Merck & Co. Inc.（メルク）","Moet_Hennessy_Louis_Vuitton":"Moet Hennessy Louis Vuitton（モエ ヘネシー・ルイ ヴィトン）","TPG_Telecom_Limited":"TPG Telecom Limited（TPGテレコム）","Delete":"消去","{JAPAN_ONLY}Binary_options_have_lower_risk_than_vanilla_options_for_option_sellers,_because_with_binary_options_the_maximum_loss_is_fixed_":"バイナリーオプションは、売り手の損失が限定されており、プレーンオプションに比べ、ローリスクハイリターンな取引といえる。","Profit/Loss_(points)":"損益（ポイント）","3-5_million_JPY":"300〜500万円","spread_down":"スプレッド ダウン","Electronic_Arts_Inc_":"Electronic Arts Inc.（エレクトロニック アーツ）","Continuous_Indices":"連続インデックス","Quality_Assurance_Engineer":"品質保証(QA)エンジニア","{JAPAN_ONLY}The_exit_price_is_important_in_binary_options__In_case_of_handling_the_OTC_currency-related_binary_options_trading_for_private_individuals,_the_broker_company_must_perform_inspections_of_the_exit_prices_which_have_been_used_for_determining_option_payout,_and_must_check_whether_there_is_an_error_in_the_data_in_cases_where_that_the_company_has_used_rated_data_provided_by_third_company_":"バイナリーオプション取引では、判定価格が重要である。個人向け店頭通貨関連バイナリーオプション取引を取り扱う場合には、自社が決定する判定価格について、ミスや作為的な操作が行われていないか自ら点検するほか、第三者の提供するレートデータを用いる場合でも、データに誤りがないか点検している。","Sohu_com_Inc_":"Sohu.com Inc.（ソフ ドットコム）","Information_Technology":"情報技術","Digits":"数字","AstraZeneca_plc":"AstraZeneca plc（アストラゼネカ）","Quantitative_Developer":"計量開発者","{JAPAN_ONLY}Historical_volatility_is_a_prediction_of_the_future_rate_of_change_in_the_underlying_asset_":"ヒストリカルボラティリティとは、原資産に対する将来の変動率を予測したボラティリティのことである。","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"現在当社ではこの国の居住者からの口座開設を承ることができません。","Browser":"ブラウザ","China_Mobile_Limited":"China Mobile Limited（チャイナ モバイル）","Australian_Index":"オーストラリア インデックス","Login_ID":"ログインID","0-5_transactions_in_the_past_12_months":"過去12ヶ月で0-5のお取引","Start_time":"開始時間","Rio_Tinto_plc":"Rio Tinto plc（リオ・ティント）","{JAPAN_ONLY}Congratulations,_you_have_pass_the_test,_our_Customer_Support_will_contact_you_shortly_":"おめでとうございます。テストに合格されましたので、カスタマーサポートよりメールにて口座開設の次のステップについてご連絡させていただきます。","Americas":"南米","Salaried_Employee":"サラリーマン","Peugeot_S_A_":"Peugeot S.A.（プジョー）","Less_than_1_million_JPY":"100万円未満","Deutsche_Bank_AG":"Deutsche Bank AG（ドイツ銀行）","The_Boeing_Company":"The Boeing Company（ボーイング）","There_was_some_invalid_character_in_an_input_field_":"入力された文字に使用できない文字が含まれています。","SUNCORP_GROUP_LIMITED":"SUNCORP GROUP LIMITED（サンコープグループ）","matches":"マッチ","Long":"ロング","is_required__Current_spread":"のご入金が必要です。現在のスプレッド","Less_than_$25,000":"$25,000未満","Volatility_25_Index":"ボラティリティ25指数","1-2_years":"1-2年","{JAPAN_ONLY}The_price_of_an_option_can_be_affected_by_the_underlying_asset_price,_by_the_volatility_rate_of_the_underlying_asset,_or_by_the_time_remaining_to_the_exercise_time_":"オプションの価格は、原資産の価格、原資産の価格変動率、権利行使期限までの時間、金利のいずれの影響を受ける。","Vivendi":"Vivendi（ビベンディ）","March":"３月","Yandex_N_V_":"Yandex N.V.（ヤンデックス）","(Bejing/CST_-8_hours)":"(北京/CST -8時間)","{JAPAN_ONLY}When_buying_a_vanilla_put_option,_the_break-even_price_at_the_exercise_point_is_the_strike_price_minus_the_option_price_paid_in_units_of_the_underlying_":"プットオプションの買いでは、権利行使価格に原資産1単位当たりのオプション料を減算した価格が損益分岐点である。","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1]が[_2]を更新しました。OKをクリックすることで、更新された[_2]を熟読され、同意されたことになります。","hyphen":"ハイフン","Invalid_amount,_maximum_is":"無効な値です。最大はXXXです。","US_Smart_Index":"アメリカ スマートインデックス","{JAPAN_ONLY}Knowledge_Test_Result":"知識確認テスト結果","Week_of":"週","Entry_Spot":"エントリー価格","You_should_enter_between_[_1]_characters_":"[_1]文字以内でご入力ください","Nov":"１１月","Ref_":"参照番号","spread_up":"スプレッド アップ","Orange":"Orange（オレンジ）","BNP_Paribas":"BNP Paribas（BNPパリバ）","Contract_is_not_started_yet":"トレードはまだ開始していません","Indicative":"気配","Accor_S_A_":"Accor S.A.（アコー）","Facebook_Inc_":"Facebook Inc.（フェイスブック）","{JAPAN_ONLY}Section_4:_Risk":"｛日本限定｝第四章：リスク","Volatility_100_Index":"ボラティリティ100指数","Metals":"金属関連","{JAPAN_ONLY}A_binary_option_price_cannot_exceed_the_payout_amount_":"バイナリーオプションの価格はペイアウト額を上回ることはない。","We":"水曜日","Please_enter_a_number_between_0_and_[_1]":"0から[_1]の数字を入力してください","Quantitative_Analyst":"計量分析者","Sun_Pharma":"Sun Pharma（サンファーマ）","Qantas_Airways_Limited":"Qantas Airways Limited（カンタス航空）","Level_of_Education":"能力レベル","New_token_created_":"新しいトークンが作成されました。","5-10_million_JPY":"500〜1,000万円","even":"もなお","Hedging":"ヘッジ","Starbucks_Corporation":"Starbucks Corporation（スターバックス）","Authorise_your_account_":"アカウント認証","Education":"お役立ち情報","Contract_Sold":"トレードが売却されました","{JAPAN_ONLY}A_Binary_Option_contains_the_right_for_the_buyer_to_receive_a_certain_fixed_amount_if_the_market_price_reaches_the_exercise_price_by_the_exercise_time,_but_it_does_not_contain_any_rights_to_sell_or_buy_the_underlying_asset_":"バイナリーオプションは、権利行使期日の原資産価格が権利行使価格に達した場合、あらかじめ定めた一定額のペイアウトを受け取ることのできる権利であり、対象となる原資産を売買する権利ではない。","Gaming_Account":"ゲームアカウント","July":"７月","June":"６月","Infosys_Ltd":"Infosys Ltd（インフォシス）","{JAPAN_ONLY}Although_customers_and_brokers_will_set_limits_on_customers_trading_losses,_even_if_those_losses_are_exceeded,_it_is_the_customer's_responsibility_to_close_the_position_and_so_mandatory_loss-cuts_will_not_be_executed_by_the_broker_company_":"各業者は顧客との取引に限度額を定めているが、顧客の一定期間の取引額や損失額、顧客が保有する建玉が基準を超えた場合であっても、顧客との取引を中断あるいは中止することはない。","Thursday":"木曜日","{JAPAN_ONLY}Units":"単位","Limit":"制限","Your_details_have_been_updated_":"お客様の詳細が更新されました。","No_experience":"ご経験がない","GDF_Suez":"GDFスエズ","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_does_not_touch_Exercise_price_through_close_on_[_4]_":"[_3]が[_4]までに権利行使価格に達しなかった場合、[_1][_2]のペイアウトをお受け取りいただけます。","Over_$1,000,000":"$1,000,000以上","Financial_Assessment":"財務評価","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"お客様のご口座[_1]はご利用いただけません。ご不明な点がございましたら[_2]までご連絡下さい。","Password_is_very_strong":"パスワード強度は最強です","Morgan_Stanley":"Morgan Stanley（モルガン スタンレー）","ANZ_Banking_Group_Ltd":"ANZ Banking Group Ltd（ANZ銀行グループ）","{JAPAN_ONLY}The_payout_is_the_amount_that_the_option_seller_must_pay_to_the_buyer_if_the_buyer_exercises_his_right_when_the_conditions_for_a_payout_have_been_satisfied_":"ペイアウトとは、バイナリーオプションにおいて、あらかじめ定められた権利行使条件を満たし、権利行使が行われた結果、オプションの売り手が買い手にあらかじめ定めた金銭を支払うことをいい、支払われる額をペイアウト額という。","{JAPAN_ONLY}To_compensate_for_any_rise_in_the_price_of_an_underlying_asset_that_you_intend_to_buy_in_future,_you_should_buy_a_call_option_":"将来取得する予定の原資産の値上がりを補うため、原資産のコールオプションを取得した。","{JAPAN_ONLY}Short_positions_in_FX_Binary_Options_must_be_covered_by_initial_margin_and_any_further_losses_must_be_covered_by_further_margin_deposits_":"通貨関連バイナリーオプションのショートポジションは、あらかじめ必要証拠金を業者に預託して取引を行い、取引成立後に証拠金が不足した場合には追加証拠金を業者に預託する必要がある。","TripAdvisor_Inc_":"TripAdvisor Inc.（トリップアドバイザー）","1-3_years":"1〜3年","Both_the_above":"上記の両方","HDFC_Bank_Ltd":"HDFC銀行","HSBC_Holdings_plc":"HSBCホールディングス","Twitter_Inc_":"Twitter Inc.（ツイッター）","password":"パスワード","Stop-type":"ストップタイプ","1-3_million_JPY":"100〜300万円","{JAPAN_ONLY}If_you_believe_the_underlying_asset_price_will_move_by_a_large_amount_in_either_direction,_you_can_benefit_by_buying_both_a_call_and_a_put_option,_with_the_exercise_prices_set_above_and_below_the_current_underlying_price_":"原資産価格が大きく騰落することを予測し、上昇、下落、いずれの方向に動いても利益を得るため、原資産価格より権利行使価格が高いコールオプションと原資産価格より権利行使価格が低いプットオプションの２つのオプションを合わせて取得した。","Bharti_Airtel":"Bharti Airtel（バーティ エアテル）","Commodities_trading_frequency":"コモデティ取引頻度","Price":"価格","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"そのため、現在即座にご出金いただける最高額（ただし、口座残高が不足していない場合）は[_1] [_2]です。","{JAPAN_ONLY}Even_though_losses_in_binary_options_are_limited,_it_is_still_necessary_to_take_care_not_to_engage_in_excessive_speculative_trading_and_to_moderate_your_transactions_volume_":"バイナリーオプションは損失が限定的であるが、投資者自身の資産などを踏まえ、過度の投機的な取引とならぬよう、節度ある取引を心がける必要がある。","TELSTRA_CORPORATION_LIMITED":"TELSTRA CORPORATION LIMITED（テルストラ）","ticks":"Tick","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"'Ok'をクリックすると、選択した日付までこのサイトでのトレードができなくなります。","Questions":"問題","and":"かつ","Apr":"４月","Danone":"Danone（ダノン）","months":"ヶ月","Potential_Profit":"期待利益","over":"オーバー","Reliance_Industries_Ltd":"Reliance Industries Ltd（リライアンス・インダストリーズ）","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"当社における金融トレードは、投資された資金が全て失われる可能性があることをご理解出来る方、及び金融トレードにおけるあらゆるリスクを熟知されご経験されている方に対してのみ適切なサービスになります。金融トレードの売買は高いリスクを伴います。もし購入したトレードが負け判定となった場合は、購入価格も含め投資された資金が全て失われる可能性があります。","Random":"ランダム","Sale_Date":"決済日時","Nocturnes":"２１時リセット指数","{JAPAN_ONLY}The_Exit_Price_is_the_price_that_is_observed_at_the_judgment_time,_and_is_used_to_determine_whether_a_payout_should_be_made_":"判定レートとは、権利行使時点の原資産価格であり、権利行使価格と比較し、ペイアウトの有無を判断するための価格をいう。","Exercise_period":"権利行使期間","February":"２月","Prudential_plc":"Prudential plc（PRU）","AB_Inbev":"AB Inbev（アンハイザー・ブッシュ・インベブ）","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_goes_ouside_of_low_and_high_values_of_Exercise_price_through_close_on_[_4]_":"[_3]が[_4]までに権利行使価格の値の上限バリアと下限バリアの範囲外にでた場合、[_1] [_2]のペイアウトをお受け取りいただけます。","Exclude_time_cannot_be_less_than_6_months_":"5ヶ月以下の除外時間を設定することはできません。","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"お客様の[_1]日の出金限度額は現在[_2] [_3]です。（または同等の他通貨）","Copywriter":"コピーライター","Incyte_Corpoartion":"Incyte Corpoartion（インサイト）","Compass_Group_plc":"Compass Group plc（コンパスグループ）","Your_current_balance_is":"お客様の現在の残高はxxxです。","Univar_Inc_":"Univar Inc.（ユニバー）","Singapore_Index":"シンガポール インデックス","Duration":"取引期間","This_contract_lost":"このトレードは負け判定","Metro_AG":"Metro AG（メトロ）","Indices_trading_frequency":"インデックス取引の頻度","{JAPAN_ONLY}A__Net_Settlement_type_of_option_is_one_where_the_underlying_asset_does_not_include_yen,_but_the_option_fee_and_settlement_are_paid_in_yen;_it_therefore_requires_some_definition_of_how_the_settlement_amounts_will_be_calculated_and_converted_to_yen_":"円以外の通貨ペアを原資産とする差金決済型の通貨オプションであって、オプション料や権利行使時の決済が円により行われるものは、対象とする通貨ペアによる決済額を算出し、円転のための計算をして金額を確定する仕組みとなっている。","American_Airlines_Group_Inc_":"American Airlines Group Inc.（アメリカン エアラインズ グループ）","Other_financial_instruments_trading_frequency":"その他金融商品取引の頻度","Password_is_strong":"パスワード強度は強です","Stop_Profit_Level":"利益ストップレベル","Try_adding_more_letters_":"文字をさらに追加してみてください。","Egypt_Index":"エジプト インデックス","Tata_Motors":"Tata Motors（タタ モーターズ）","Net_profit":"純利益","Status":"金融資産","Santos_LimitedStar_Stock":"Santos Limited Star Stock","Verification_code_format_incorrect_":"認証コードの形式が不適切です。","There_was_a_problem_accessing_the_server_during_purchase_":"購入時にサーバーアクセスのエラーが発生がしました。","JP_Morgan_Chase_&_Co_":"JP Morgan Chase & Co.（JPモルガン・チェース）","Pernod_Ricard":"Pernod Ricard（ペルノ・リカール）","Adjust_trade_parameters":"取引期間を選択して頂き購入希望ロット数を入力して下さい。","Others":"その他","Dutch_Stocks":"オランダ株式","Over_$500,001":"$500,001以上","Th":"木曜日","Oct":"１０月","GOOGLE_INC__A_DL":"GOOGLE INC. A DL（グーグル）","{JAPAN_ONLY}For_a_currency_binary_option_with_the_underlying_exchange_rate_of_dollars_against_yen,_the_right_to_receive_a_payout_if_the_yen_becomes_stronger_is_known_as_a_dollar-put_binary_option_":"通貨バイナリーオプションのうち、例えばドル円を原資産とし、円高になればペイアウトを受け取る権利は、ドル円のバイナリープットオプションと呼ぶ。","Even/Odd":"偶数/奇数","Barrier_offset":"追加バリア値","Over_5_years":"6年以上","Micron_Technology_Inc_":"Micron Technology Inc.（マイクロン テクノロジー）","This_feature_is_not_relevant_to_virtual-money_accounts_":"この機能は、デモ口座ではご利用頂けません。","Password_should_have_lower_and_uppercase_letters_with_numbers_":"パスワードは大文字と小文字を含む英字と数字を組み合わせる必要があります。","Step":"ステップ","Next_Day":"翌日","{JAPAN_ONLY}A_Currency_Option_confers_the_right_to_sell_one_currency_in_exchange_for_another_currency_as_the_underlying_asset__For_example,_the_right_to_sell_Yen_and_buy_Dollars_is_known_as_a_Yen_Put_/_Dollar_Call_Option,_or_just_Yen_Put_for_short;_and_the_opposite_right_to_buy_Yen_and_sell_Dollar_is_called_a_Yen_Call_/_Dollar_Put_Option,_or_just_Yen_Call_for_short_":"通貨オプションとは、通貨を原資産とし、一方の通貨を売って、他方の通貨を買う権利である。たとえば円とドルをペアとする場合、円を売ってドルを買うものを、円プット／ドルコールオプション、略してドルコールオプションと呼び、ドルを売って円を買うものを、円コール／ドルプットオプション、略してドルプットオプションと呼ぶ。","BHP_Billiton_Ltd":"BHP Billiton Ltd（BHBビリトン）","Applications":"アプリケーション","Save_as_CSV":"CSVへ保存","Internal_Auditor":"内部監査","{JAPAN_ONLY}If_implied_volatility_increases_then_the_prices_of_both_call_and_put_types_of_plain_vanilla_options_will_increase_":"オプションの価値は、ボラティリティが上昇すれば、コールオプションもプットオプションも共に上昇する。","Loss":"損益","Mo":"月曜日","Vodafone":"Vodafone（ボーダフォン）","Other":"その他","Health":"健全性","Dutch_Smart_Index":"オランダ スマートインデックス","Applied_Materials_Inc_":"Applied Materials Inc.（アプライド マテリアルズ）","American_Express_Company":"American Express Company（アメリカン エキスプレス）","letters":"文字","under":"未満","ORIGIN_ENERGY_LIMITED":"ORIGIN ENERGY LIMITED（オリジンエナジー）","m":"男性","Tesla_Motors_Inc_":"Tesla Motors Inc.（テスラモーターズ）","{JAPAN_ONLY}In_OTC_currency_binary_options_trading,_if_the_exchange_rate_during_the_trading_period_moves_by_more_than_expected_in_one_direction,_and_there_are_no_longer_any_exercise_prices_which_can_continue_to_trade,_it_is_possible_under_certain_conditions_to_add_further_exercise_prices__However,_even_when_further_exercise_price_have_been_added,_the_prices_of_the_original_options_will_not_be_affected_":"店頭通貨バイナリーオプション取引では、取引期間中の為替レートが一方向に想定以上に動き、アットザマネー周辺で適切な取引が継続できる権利行使価格が無くなった場合には、途中で権利行使価格を追加することがある。ただし、権利行使価格が追加された場合であっても、それまで利用した権利行使価格は引き続き取引を行い、またその取引価格が、権利行使価格の追加の影響を受けることはない。","E_I_du_Pont_de_Nemours_&_company":"E.I du Pont de Nemours & company（デュポン）","Groupon_Inc_":"Groupon Inc.（グルーポン）","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"[_2]の最新[_1] tickの下一桁統計","Energy":"エネルギー関連","MACQUARIE_GROUP_LIMITED":"MACQUARIE GROUP LIMITED（マッコリー グループ）","Over_3_years":"3年以上","From":"開始","does_not_touch":"ノータッチ","hour":"時間","Credit_Agricole":"Credit Agricole（クレディ・アグリコル）","Time_Warner_Inc_":"Time Warner Inc.（タイムワーナー）","View":"表示","Wells_Fargo_&_Company":"Wells Fargo & Company（ウェルズ・ファーゴ）","Sorry,_an_error_occurred_while_processing_your_account_":"申し訳ございませんが、処理中にエラーが発生しました。","British_American_Tobacco":"ブリティッシュ・アメリカン・タバコ","An_error_occured_":"エラーが発生しました","Sandisk_Corporation":"Sandisk Corporation（サンディスク）","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"そのため、現在即座にご出金いただける金額（ただし、ご口座残高が不足していない場合）は[_1] [_2]です。（または同等の他通貨）","Yahoo!_Inc_":"Yahoo! Inc.（ヤフー）","{JAPAN_ONLY}If_you_buy_a_currency_binary_option_at_a_price_of_500_yen,_and_the_judgment_price_meets_the_conditions_so_you_receive_a_payout_of_1,000_yen,_then_your_profit_can_be_calculated_500_yen_after_subtracting_the_500_yen_that_was_paid_as_a_fee_to_the_option_seller_":"ペイアウト1,000円のバイナリーコールオプションを500円で購入し、判定の結果、権利行使条件が満たされた場合には、買い手は売り手からペイアウトとして1,000円を受け取り、したがって買い手の損益は、売り手に支払った500円のオプション料を差し引き500円の利益となる。","Russian_10_Index":"ロシア 10インデックス","New_Password":"新しいパスワード","Trading_Limits":"トレードの上限について","German_Smart_Index":"ドイツ スマートインデックス","WOODSIDE_PETROLEUM_LIMITED":"WOODSIDE PETROLEUM LIMITED（WPL）","{JAPAN_ONLY}Price_of_OTC_currency_option_is_the_calculated_value_based_on_multiple_elements_and_is_determined_by_relative_trading_basically_":"店頭通貨オプションの価格は、複数の要素に基づく計算値であり、基本的には相対取引で価格は決定される。","Details":"お客様基本情報","Login_History":"ログイン履歴","{JAPAN_ONLY}Unlike_a_plain_vanilla_option,_an_in-the-money_binary_option_will_have_a_lower_price,_the_further_away_it_is_from_the_exercise_point_":"バイナリーオプションの場合、プレーンオプションとは異なり、インザマネーのときには、残存期間が長くなるほど、オプション価格は低くなる。","Invalid_amount,_minimum_is":"無効な値です。最小","Technip_oil_equipment_and_services":"Technip（ 石油設備とサービス）","minute":"分","The_Goldman_Sachs_Group_Inc_":"ゴールドマン サックス グループ","{JAPAN_ONLY}Section_5:_Calculation":"｛日本限定｝第5章：算出","Public_worker":"公務員","Please_deposit_before_transfer_to_client_":"お客様へ送金される前にご入金をしてください。","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"ハイフンを入れて半角で入力してください","WOOLWORTHS_LIMITED":"WOOLWORTHS LIMITED（ウールワース）","Password_Reset":"パスワード再設定","{JAPAN_ONLY}If_you_believe_the_underlying_asset_price_will_be_only_moderately_volatile,_you_could_still_benefit_by_buying_both_a_call_and_put_option_with_exercise_prices_that_are_above_and_below_the_exercise_price_":"原資産価格の騰落幅が小さいと予測し、上昇、下落、いずれの方向に動いても利益を得るため、原資産価格より権利行使価格が高いコールオプションと原資産価格より権利行使価が低いプットオプションの２つのオプションを合わせて付与した。","Maximum_account_cash_balance":"口座預託額の上限額","August":"８月","Renault":"Renault（ルノー）","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"お客様のご口座のアップグレードが完了しました。ご口座[_1]のご利用上限の内容をこちらからご確認頂けます。","{JAPAN_ONLY}For_a_call_option,_if_the_price_of_the_underlying_asset_is_higher_than_the_option_exercise_price,_it_is_know_as_an_out-of-the-money_option_":"コールオプションにおいて、原資産の価格が権利行使価格を上回っている状態をアウトオブザマネーという。","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"送金を完了するために、取引明細をご確認ください。","Euro_50_Smart_Index":"ユーロ50スマートインデックス","US_Tech_Composite_Index":"米ハイテク指数","Lock_Cashier":"入出金をロック","{JAPAN_ONLY}Options_may_be_European_or_American_style_of_exercise,_and_those_which_can_be_exercised_at_only_one_expiry_time_are_the_European_style_options_":"オプション取引にはヨ－ロピアンタイプとアメリカンタイプがあり、権利行使期間の満期時だけに権利行使できるものをヨーロピアンタイプという。","Sa":"土曜日","Anglo_American_plc":"Anglo American plc（アングロ アメリカン）","seconds":"秒","{JAPAN_ONLY}The_maximum_loss_for_the_buyer_of_an_option_is_the_price_paid,_and_the_maximium_loss_for_the_option_seller_will_be_the_payout_amount_minus_the_opion_price_he_received_":"バイナリーオプションの買い手の最大損失額はオプション料であり、売り手の最大損失額はペイアウト額からオプション料を差し引いた額となる。","{JAPAN_ONLY}A_binary_call_option_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_decline_to_below_the_strike_price_by_the_judgment_time_":"判定時刻に、原資産価格が権利行使価格よりも下落していると予測し、バイナリーコールオプションを購入した。","Matches/Differs":"マッチ/アンマッチ","Bt_Group_plc":"Bt Group plc（BTグループ）","Select_your_market":"取引市場を選択","apostrophe":"アポストロフィ","Canadian_Index":"カナダ インデックス","Finish":"完了","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"数字、大文字、小文字を各1字以上含めるようにしてください。","False":"誤","Up/Down":"ラダー","Wal-Mart_Stores_Inc_":"Wal-Mart Stores Inc.（ウォルマート）","Human_Resources":"人事","Profit_Table":"取引明細","Purchase":"購入","{JAPAN_ONLY}There_are_some_types_of_Binary_Option,_such_as_Range_Binary_Options,_Touch_or_No-Touch_Binary_Options,_that_are_exceptions_to_the_general_rule_where_payment_is_made_at_a_known_exercise_time__For_these_types_of_option_a_payment_is_made_automatically_at_Exit_Time_when_certain_conditions_have_been_met_":"バイナリーオプションには、オプションの満期を権利行使時刻として定め、権利行使時刻に自動的に権利行使が行われ、オプションの買い手にペイアウトが支払われる一般的なバイナリーオプションのほか、レンジバイナリーオプション、タッチバイナリーオプション、ノータッチバイナリーオプションなどの複数の種類がある。","Tourism":"ご利用方法","10-30_million_JPY":"1,000〜3,000万円","{JAPAN_ONLY}There_are_many_types_of_Binary_Option,_including_some_such_as_Range_Binary_Options_and_Touch_or_No-Touch_Binary_Options_which_do_not_always_require_automatic_payment_at_Exercise_Time_and_which_will_be_settled_earlier_if_certain_conditions_have_been_met__However,_in_all_cases,_for_a_payment_to_be_required,_the_option_must_end_In_The_Money_":"バイナリーオプションには、単にオプションの満期を権利行使時刻として定め、権利行使時刻にインザマネーの場合に限り自動的に権利行使が行われ、オプションの買い手にペイアウトが支払われる、一般的な内容のもののほか、レンジバイナリーオプションやタッチバイナリーオプション、ノータッチバイナリーオプションなどの複数の種類がある。","Shenzhen_Index":"深センインデックス","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"お客様のキャッシャーはリクエストにより、ロックされました。 - 解除するにはパスワードをご入力ください。","Invalid_email_address":"無効なEメールアドレス","Capgemini_computer_services":"Capgemini computer services（キャップジェミニ）","Please_enter_an_integer_value":"半角で数値をご入力して下さい","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"申し訳ございません。この機能はデモ口座のみでご利用頂けます。","Caterpillar_Inc_":"Caterpillar Inc.（キャタピラー）","{JAPAN_ONLY}Price_of_call_option_will_be_lower_interest_rates_of_the_underlying_assets_is_low,_but_the_price_of_the_put_option,_go_up_when_the_interest_rates_of_the_underlying_assets_is_low_":"コールオプションの価格は原資産の金利が低くなると下がるが、プットオプションの価格は、原資産の金利が低くなると上がる。","Halliburton_Company":"Halliburton Company（ハリバートン）","Investment_Account":"投資口座","You_are_not_authorized_for_withdrawal_via_payment_agent_":"お客様は決済サービスでのご出金が許可されていません。","Quantitative_Analysis":"計量分析","Wall_Street_Smart_Index":"ウォールストリート スマートインデックス","Please_check_your_email_for_the_value_of_this_token":"Eメールアドレスをご確認下さい","Forex_trading_experience":"外国為替取引のご経験","{JAPAN_ONLY}It_cannot_be_said_that_binary_options_trading_is_unconditionally_advanteous_over_regular_spot_fx_trading,_because_investors_may_lose_all_of_their_investment_whereas_in_spot_fx_trading_there_will_still_be_some_value_in_the_trading_position_":"投資者に不利な方向に動いた場合には、バイナリーオプションが投資額を全額失うのに比べ、ＦＸは投資額の一部が残る場合があるので、一概にバイナリーオプションが有利とはいえない。","Amount":"金額","The_maximum_number_of_tokens_([_1])_has_been_reached_":"トークンの最大数([_1]) に達しました。","Westpac_Banking_Co_":"Westpac Banking Co.（ウエストパック銀行）","Global_Customer_Service_Representatives":"グローバル・カスタマーサポート担当","Withdrawal_Limits":"出金限度額","Print_chart":"チャートを印刷","Please_try_again_":"再びお試し下さい。","Las_Vegas_Sands_Corporation":"Las Vegas Sands Corporation（ラスベガ スサンズ）","Your_transaction_reference_is":"トレード参照番号：","Diageo_plc":"Diageo plc（ディアジオ）","Compliance":"コンプライアンス","Apple_Inc_":"Apple Inc.（アップル）","Glencore_Xstrat":"Glencore Xstrat（グレンコア・エクストラータ）","National_Australia_Bank_Ltd":"National Australia Bank Ltd（ナショナル・オーストラリア銀行）","Philip_Morris_International":"Philip Morris International（フィリップ・モリス）","Save_as_SVG":"SVGへ保存","You_have_already_withdrawn_[_1]_[_2]_":"既に[_1] [_2]を出金されています。","Profit/Loss":"損益","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"下記フォームにログインIDとご希望の送金額をご入力ださい。","Password_does_not_match_":"パスワードが一致しません。","Commodities":"コモディティ","MOMO_Inc_":"MOMO Inc.（モモ）","Thyssenkrupp_SS":"Thyssenkrupp SS（ティッセンクルップ）","Lloyds_Banking_Group_plc":"Lloyds Banking Group plc（ロイズ・バンキング・グループ）","Update":"更新","Fr":"金曜日","Volatility_75_Index":"ボラティリティ75指数","Air_Liquide":"Air Liquide（エア・リキード）","goes_outside":"BREAK-OUT","Chart":"チャート","High_Barrier":"上限バリア","Qihoo_360_Technology_Company_Limited":"Qihoo 360 Technology Company Limited（奇虎360）","Date_of_Birth":"生年月日","Self-employed":"自営業","space":"スペース","Portuguese_Smart_Index":"ポルトガル スマートインデックス","{JAPAN_ONLY}Option_prices_are_normally_dependant_on_elements_such_as_the_underlying_asset_price,_the_exercise_price,_the_length_of_time_until_the_exercise_point,_volatility,_and_interest_rates__However,_when_the_remaining_time_to_the_exercise_point_is_very_short,_there_is_no_need_to_consider_these_when_managing_option_trading_risk,_as_all_these_elements_are_constant_":"オプションの価格を形成する要素には原資産の価格、権利行使価格、権利行使期限までの期間の長さ、ボラティリティ、金利があるが、権利行使期限までの期間が短いオプションの場合、それぞれの要素はオプションの権利行使期限まで一定であるので、オプション取引のリスクを管理するときには、特に考慮する必要はない。","ASX_Limited":"ASX Limited（オーストラリア証券取引所）","Saturday":"土曜日","{JAPAN_ONLY}To_avoid_or_hedge_the_future_price_of_an_underlying_asset_which_you_hold,_you_should_buy_a_call_option_":"保有する原資産の今後の価格下落を回避（ヘッジ）するため、原資産のコールオプションを取得した。","Never_Used":"使用されることはありません。","Volatility_50_Index":"ボラティリティ50指数","{JAPAN_ONLY}In_Japan_there_are_defined_trading_periods_for_binary_options_must_be_2_hours_or_longer,_and_all_trades_must_be_conducted_at_the_start_of_each_trading_period_":"バイナリーオプションの取引期間（満期）は2時間以上であり、全ての取引は取引期間の開始時点で成立し、成立したポジションは、判定によってのみ決済となる。","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"資産情報ページ内に存在する未決済分トレードに対する払い戻し金額の最高総額を示します。最高総額を超えた場合、オープン中のトレードを閉じて頂くことで新たなトレードの購入が可能になります。","Description":"取引内容","Sell":"売却","Abu_Dhabi_Index":"アブダビ インデックス","{JAPAN_ONLY}Where_broking_companies_show_bid_and_offer_prices_for_purchasing_and_sell-back_of_positions,_these_prices_may_become_further_apart_the_nearer_you_are_to_the_exercise_time_":"次の文章のうち、金融商品の店頭取引の価格について、金融商品取引業者が買値と売値（又は買戻取価格、解約価格）の２つの価格をお客様に提示する場合、一般的には２つの価格には差（スプレッド）がある。このスプレッドはオプションの期限が近付くと広がる傾向がある。","Euro_50_Index":"ユーロ50インデックス","October":"１０月","Nokia_Corporation":"Nokia Corporation（ノキア）","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"現在リアルマネー口座[_1] ([_2])にログインしています。","Office_worker":"会社員","Rolls-Royce_Holdings_plc":"Rolls-Royce Holdings plc（ロールス ロイス ホールディングス）","Terms_&_Conditions":"利用規約","Only_2_decimal_points_are_allowed_":"小数点以下2桁のみご利用いただけます。","period":"期間","Password_score_is:_[_1]__Passing_score_is:_20_":"パスワードスコア：[_1]　合格スコア：20","Sony_Corporation":"Sony Corporation（ソニー）","Standard_Chartered_plc":"Standard Chartered plc（スタンダードチャータード銀行）","Stays_In/Goes_Out":"STAY-IN/BREAK-OUT","Note":"注意","Under_Armour_Inc_":"Under Armour Inc.（アンダーアーマー）","{JAPAN_ONLY}A_Currency_Binary_Option_is_one_where_there_is_a_target_for_a_particular_currency_pair,_so_a_strike_price_for_the_exchange_rate_is_agreed,_and_a_payout_will_be_due_if_the_judgment_price_meets_the_conditions_of_being_over_or_under_the_target_strike_price,_depending_on_the_option_type,_by_the_exercise_time_":"通貨バイナリーオプションは、通貨ペアを対象とし、通貨ペアの交換レートを権利行使価格として、権利行使時点の両通貨のレートが権利行使価格を上回るか、下回るかにより、権利行使によるペイアウトの有無を判定し、決済するオプションである。たとえば、ドル円のコールバイナリーオプションは、ドルを基準とし、権利行使価格に対して判定価格がドル高＝円安となればペイアウトとなり、判定価格がドル安＝円高となればペイアウトは発生しない。","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"未決済分のトレード総数を示し、各行を１件分の未決済分のオープン中のポジションとしてカウントします。最高件数を超えた場合、オープン中のトレードを閉じて頂くことで新たなトレードの購入が可能になります。","Password_is_not_strong_enough_":"パスワード強度が十分ではありません。","{JAPAN_ONLY}Using_binary_options_for_hedging_a_position_in_the_underlying_asset_means_that_only_part_of_the_loss_or_gain_can_be_hedged,_because_the_payout_amount_is_fixed_":"ペイアウトは固定されているので、バイナリーオプションを利用したヘッジは、ヘッジ対象資産の損失の一部を補うものとして行う必要がある。","Asset":"取引対象","{JAPAN_ONLY}A_binary_put_option_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_decline_to_below_the_strike_price_by_the_judgment_time_":"判定時刻に、原資産価格が権利行使価格よりも下落していると予測し、バイナリープットオプションを購入した。","Swiss_Smart_Index":"スイス スマートインデックス","Airbus_Group":"Airbus Group（エアバスグループ）","{JAPAN_ONLY}As_the_expected_volatility_of_the_underlying_asset_increases,_a_plain_vanilla_option_price_will_move_higher_":"原資産の予測される価格変動率が高いほど、オプションの価格は高くなる。","0-1_year":"0~1年","Unilever":"Unilever（ユニリーバ）","Contract_Information":"お取引情報","{JAPAN_ONLY}If_the_probablility_of_a_payout_is_50%_then_when_the_potential_payout_is_less_than_100%_of_the_price_paid_for_the_option,_the_expected_return_on_the_investment_will_be_less_than_100%_":"ペイアウトを受け取る確率が50％、投資額に対するペイアウトの倍率が2倍を下回る場合の期待収益率は1倍を下回り、予測回収額は投資額を下回る。","Translator":"翻訳者","{JAPAN_ONLY}A_modified_version_of_the_Black-Scholes_model_is_widely_used_to_calculate_the_theoretical_prices_of_binary_options_":"バイナリーオプションの理論価格計算には、ブラック・ショールズ・モデルを修正した計算モデルが広く用いられている。","Sorry,_account_opening_is_unavailable_":"申し訳ございませんが、口座開設をご利用いただけません。","Maruti_Suzuki":"Maruti Suzuki（マルチ スズキ）","Anti-Fraud_Officer":"不正対策局","Barrier":"バリア","Current_Level":"現在のレベル","Password_is_moderate":"パスワード強度は中です","Failed_to_reset_password__[_1],_please_retry_":"パスワードの再設定に失敗しました。[_1]、再度お試しください。","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"あなたのクライアントに送金が処理されたことをお知らせする通知メールが届きます。","Low_Barrier":"下限バリア","Previous_Day":"前日","NZDCHF":"NZD CHF","Senior_Perl_Developer":"シニアPerl開発者","IP_Address":"IPアドレス","Tu":"木曜日","Senior_Front-End_Developer":"シニアフロントエンド開発者","Sale_Price":"決済価格","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"スポット価格に差異を付加する目的でバリア値を設定しましょう。もしバリア値として+0.005を設定した場合はスポット価格より0.005高値のバリアが設定されたトレードを購入することになります。尚、スポット価格は注文を受けた次のTickが採用されます。","Social_Media_Executive":"ソーシャルメディア管理者","Short":"ショート","{JAPAN_ONLY}In_general_the_price_of_a_binary_option_will_be_lower_than_the_price_of_a_plain_vanilla_option_because_the_payout_amount_is_fixed_":"一般的には、バイナリーオプションの価格は、ペイアウト額が固定されるので、プレーンオプションの価格と比べて低くなる。","{JAPAN_ONLY}Section_1:_Structure":"｛日本限定｝第一章：構成","Please_confirm_the_trade_on_your_statement_before_proceeding_":"続行する前に、お客様の取引明細書をご確認ください。","{JAPAN_ONLY}For_an_in-the-money_option,_the_further_away_from_the_underlying_asset_price_that_the_option_exercise_price_is,_the_lower_the_price_of_the_option_will_be_":"インザマネーのオプションでは、原資産価格が権利行使価格から離れるほど、オプション価格は低くなる。","Reset_Password":"パスワード再設定","Token":"トークン","{JAPAN_ONLY}Dear_customer,_you've_already_completed_the_knowledge_test,_please_proceed_to_next_step_":"｛日本限定｝\nお客様へ\n既に知識テストが完了しています。次のステップへお進みください。","Year":"年","Hewlett-Packard_Company":"Hewlett-Packard Company（HP）","Other_financial_instruments_trading_experience":"その他金融商品取引のご経験","Forex_trading_frequency":"外国為替取引の頻度","{JAPAN_ONLY}Regarding_to_the_OTC_price_of_financial_instruments,_in_case_that_financial_instruments_business_operator_suggests_both_of__bid_and_ask_price_(or_trading_price_and_cancellation_price),_generally_there_is_a_difference_of_them__This_option_will_be_wider_as_the_expiration_approaches_":"次の文章のうち、金融商品の店頭取引の価格について、金融商品取引業者が買値と売値（又は買戻取価格、解約価格）の２つの価格をお客様に提示する場合、一般的には２つの価格には差（スプレッド）がある。このスプレッドはオプションの期限が近付くと広がる傾向がある。","Purchase_Time":"購入時間","Day":"日","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"氏名と生年月日が表示されているパスポートか運転免許証、または住民基本台帳カードをスキャンしたコピー","Illumina_Inc_":"Illumina Inc.（イルミナ）","Old_password_is_wrong_":"旧パスワードの値が不正です。","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"お客様のご口座[_3]から決済サービス[_4]口座へ[_1] [_2]の出金リクエストが正常に処理されました。","Orica_Limited":"Orica Limited（オリカ）","DevOps_Manager":"DevOps マネージャー","Trading_and_Withdrawal_Limits":"トレード及びご出金限度額","Housewife_/_Househusband":"主婦/主夫","SABMiller_plc":"SABMiller plc（SABミラー）","FERRARI_N_V_COM":"FERRARI N V COM（フェラーリ）","High_barrier_offset":"上限追加バリア値","{JAPAN_ONLY}Implied_volatility_is_a_prediction_of_the_future_rate_of_change_in_the_underlying_asset_":"インプライドボラティリティとは、原資産に対する将来の変動率を予測したボラティリティのことである。","ICICI_Bank_Ltd":"ICICI銀行","{JAPAN_ONLY}For_a_put_option,_if_the_underlying_asset_price_is_higher_than_the_option_exercise_price,_it_is_known_as_an_in-the-money_option_":"プットオプションにおいて、原資産の価格が権利行使価格を上回っている状態をインザマネーという。","Aug":"８月","Amcor_Ltd":"Amcor Ltd（アムコー）","Are_you_sure_that_you_want_to_permanently_delete_token":"トークンを完全に削除してもよろしいですか？","Siemens_Aktiengesellschaft":"Siemens Aktiengesellschaft（シーメンス）","ends_outside":"レンジ外で終了","You_did_not_change_anything_":"変更はありません。","{JAPAN_ONLY}Even_if_the_option_is_exercise_or_not_exercised,_the_original_option_premium_remains_with_the_option_seller_":"権利行使期限が到来し、権利行使が行われないオプションは消滅するが、売り手が受け取ったオプション料はそのまま売り手のものとなる。","Russian_Regular_Index":"ロシア レギュラー インデックス","Over/Under":"以上/以下","{JAPAN_ONLY}If_the_underlying_asset_price_is_100_yen,_the_exercise_price_is_80_yen,_and_the_call_option_price_is_45_yen,_then_it_can_be_said_that_the_option's_intrinsic-value_is_20_yen,_and_its_time-value_is_25_yen_":"原資産価格100円、権利行使価格80円、オプション価格45円のときのコールオプションの本源的価値と時間的価値は本源的価値＝20円、時間的価値＝25円である。","{JAPAN_ONLY}If_the_exercise_period_passes_without_the_option_being_exercised_by_the_buyer,_the_option_premium_received_by_the_seller_will_be_the_profit_made_on_the_trade_":"権利行使期限が到来し、権利行使が行われないオプションは消滅するため、所有するオプションは価値がなくなる。","Feb":"２月","{JAPAN_ONLY}A_binary_call_options_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_rise_above_the_strike_price_by_the_judgment_time_":"判定時刻に、原資産価格が権利行使価格よりも下落していると予測し、バイナリーコールオプションを売却取引した。","The_two_passwords_that_you_entered_do_not_match_":"ご入力頂いた各パスワードが合致しません。","Failed":"失敗しました","You_have_not_granted_access_to_any_apps_":"アプリケーションへのアクセス権限がありません。","{JAPAN_ONLY}A_binary_put_options_buyer_will_benefit_from_a_correct_prediction_that_the_asset_price_will_rise_above_the_strike_price_by_the_judgment_time_":"判定時刻に、原資産価格が権利行使価格よりも上昇していると予測し、バイナリープットオプションを購入した。","Stop-loss":"損切り","{JAPAN_ONLY}As_the_exercise_deadline_approaches,_the_price_of_an_out-of-the-money_binary_option_will_move_towards_zero_":"権利行使期限が近づくにつれて、アウトオブザマネーのバイナリーオプションの価格はゼロに近づく。","This_field_is_required_":"この項目は必須です。","Return":"リターン率","Marketing":"マーケティング","{JAPAN_ONLY}A_Covered_option_position_is_where_you_hold_an_offsetting_position_in_the_underlying_asset_":"カバ－ド・オプションとはオプションの売りポジションをカバ－するような原資産を保有し、オプションを売ることである。","Tertiary":"第三の","Carrefour":"Carrefour（カノフール）","Swiss_Index":"スイス インデックス","Indices_trading_experience":"インデックス取引のご経験","6-10_transactions_in_the_past_12_months":"過去12ヶ月で6~10のお取引","Deutsche_Lufthansa":"Deutsche Lufthansa（ルフトハンザ）","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"一旦「送信」ボタンをクリックされますと、資金はお客様の口座から出金され、お客様の顧客の口座に送金されます。","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"%ctx(最短期間, 例： 最短 15 秒）分","True":"正","day":"日","Chevron_Co_":"Chevron Co.（シェブロン）","Internal_Audit":"内部監査","Save_as_JPEG":"JPEGへ保存","{JAPAN_ONLY}Take_knowledge_test":"知識確認テストを受ける","Platinum/USD":"白金/USD","Michelin":"Michelin（ミシュラン）","Income_Source":"オープンソース","hours":"時間","Euro_100_Index":"ユーロ100インデックス","second":"秒","Belgian_Stocks":"ベルギー株式","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"[_1] [_2] と同等の金額を既に出金されています。","Date":"日付","Asia/Oceania":"アジア・オセアニア","Waiting_for_entry_tick_":"エントリーTickを検出中です・・・","lower":"LOW","Confirm_New_Password":"新しいパスワードを確認","Country_Manager":"カントリーマネージャー","AbbVie_Inc_":"AbbVie Inc.（アッヴィ）","April":"４月","{JAPAN_ONLY}An_option_price_is_the_sum_of_the_intrinsic-value_and_the_time-value_":"オプション価格は本源的価値に時間的価値を加えた値である。","Daimler_AG":"Daimler AG（ダイムラー）","ICAG_(British_Airways)":"ICAG (ブリティッシュ・エアウェイズ)","VF_Corporation":"VF Corporation（VF）","Select_your_underlying_asset":"原資産を選択してください","Last_Digit_Prediction":"下一桁の予想数字","{JAPAN_ONLY}As_the_exercise_deadline_approaches,_the_price_of_an_in-the-money_binary_option_will_move_towards_the_payout_amount_":"権利行使期限が近づくにつれて、インザマネーのバイナリーオプションの価格は、ペイアウトの金額に近づく。","Beiersdorf_AG_O_N":"Beiersdorf AG O.N（バイヤスドルフ）","Bayer_AG":"Bayer AG（バイエル）","Commerzbank":"Commerzbank（コルメツ銀行）","Delta_Air_Lines_Inc_":"Delta Air Lines Inc.（デルタ エアライン）","Try_adding_more_letters_or_numbers_":"さらに文字と数字を追加してみてください。","General_Electric_Company":"General Electric Company（ゼネラル・エレクトリック）","US_Tech_100_Index":"米ハイテク100指数","Sep":"９月","Safran":"Safran（サフラン）","Centrica_plc":"Centrica plc（セントリカ）","{JAPAN_ONLY}The_price_of_a_binary_option_is_affected_by_not_only_the_change_in_the_underlying_asset_price,_but_also_the_change_in_remaining_time_to_the_exercise_point_":"バイナリーオプションの価格は、原資産価格の変化の影響を受けるとともに、権利行使期限までの残存時間の変化の影響も受ける。","Jakarta_Index":"ジャカルタ インデックス","Purchase_Price":"購入価格","UK_Smart_Index":"英国スマートインデックス","{JAPAN_ONLY}Knowledge_Test":"知識確認テスト","days":"日","{JAPAN_ONLY}Prices_for_currency_options_are_calculated_relative_the_value_of_theunderlying_spot_price,_and_are_dependant_on_multiple_factors_which_may_vary_":"店頭通貨オプションの価格は、複数の要素に基づく計算値であり、基本的には相対取引で価格は決定される。","Never":"決してありません","Name":"お名前","Save_as_PNG":"PNGへ保存","Piraeus_Bank_SA":"Piraeus Bank SA（ピレウス銀行）","New_Zealand_Index":"ニュージーランド インデックス","{JAPAN_ONLY}The_Exercise_Price_is_the_level_at_which_the_option_buyer_has_the_right_to_trade_the_underlying,_and_is_also_used_for_binary_options_to_determine_whether_the_buyer_should_receive_a_payout_":"権利行使価格とは、権利行使により原資産を購入または売却する価格であり、バイナリーオプションの場合には、ペイアウトの発生の有無を判断する基準価格である。","Electricite_de_France":"Electricite de France（フランス電力）","{JAPAN_ONLY}If_you_buy_a_currency_binary_put_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_receive_a_payout_1,000_yen_from_the_seller_of_the_option_":"権利行使価格１ドル100円、ペイアウト1,000円のドル円のプットバイナリーオプションを500円で購入し、判定レートが１ドル９９円となり権利行使が行われ、1,000円のペイアウトを受け取った。","Solvay_chemicals":"Solvay chemicals（ソルベイ）","Major_Pairs":"主要ペア","Su":"日曜日","Please_enter_a_number_between_[_1]_":"[_1]の間の数字を入力してください。","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_is_strictly_lower_than_Exercise_price_at_close_on_[_4]_":"[_3]が[_4]の時点で権利行使価格未満であった場合、[_1] [_2]のペイアウトをお受け取りいただけます。","Marketing_Project_Manager":"マーケティングプロジェクトマネージャー","{JAPAN_ONLY}For_a_put_option,_if_the_underlying_asset_price_is_lower_than_the_option_exercise_price,_it_is_known_as_an_out-of-the-money_option_":"プットオプションにおいて、原資産の価格が権利行使価格を下回っている状態をアウトオブザマネーという。","Jump_To":"Xへ移動する","{JAPAN_ONLY}For_an_individual_investor,_profits_and_losses_from_OTC_currency_options_traing_cannot_be_combined_with_profits_and_losses_from_margin_FX_and_securities-related_OTC_options_":"個人投資者の場合、通貨関連店頭オプション取引の損益は、ＦＸや有価証券関連店頭オプションの損益と通算することができない。","loading___":"読み込み中","Amazon_Corporation":"Amazon Corporation（アマゾン）","Accounting":"会計","{JAPAN_ONLY}BUY_price_per_unit":"単位ごとの価格を購入","Sina_Corporation":"Sina Corporation（シナ コープ）","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"\"Ok\"をクリックすると、選択した日付までこのサイトでのトレードができなくなります。","Essilor_International":"Essilor International（エシロール・インターナショナル）","Spot_Time":"スポットタイム","Heineken":"Heineken（ハイネケン）","Over_100_million_JPY":"1億を超える","Closes":"閉場時間","{JAPAN_ONLY}If_the_exercise_prices_and_exercise_times_are_the_same_for_an_American_style_and_European_style_option,_then_the_American_style_option_will_have_a_higher_price_":"権利行使価格、権利行使期間が同一のヨーロピアンタイプとアメリカンタイプのオプションでは、アメリカンタイプの方がオプション価格は高い。","To":"終了","Istanbul_Index":"イスタンブール インデックス","Reference_ID":"参照 ID","{JAPAN_ONLY}There_are_two_types_of_option_delivery:_One_requires_exchanging_the_underlying_asset,_and_the_other_requires_a_payment_which_depends_on_the_difference_between_the_fair_market_price_and_the_exercise_price__A_Binary_Option_is_the_second_type_where_if_the_fair_market_price_meets_certain_conditions_with_respect_to_the_exercise_price,_then_an_agreed_fixed_amount_will_be_paid_to_the_option_buyer_":"オプションには、権利行使によって、実際に原資産を受け渡すものと、原資産の時価と権利行使価格の差額を授受するものがある。このうち、原資産の時価と権利行使価格が一定の条件を満たした場合には一定の金銭を支払うものをバイナリーオプションと呼ぶ。","Imperial_Tobacco_Group_plc":"Imperial Tobacco Group plc（インペリアル タバコ）","Administrative_Executive":"部門管理者","Tuesday":"火曜日","Sorry,_this_feature_is_not_available_":"申し訳ございませんが、この機能はご利用いただけません。","Select_market":"取引市場を選択","High_barrier":"上限バリア","Closed":"終了","50-100_million_JPY":"5,000万円〜1億円","You_must_accept_the_terms_and_conditions_to_open_an_account_":"ご口座を開設されるにあたりご利用規約に承諾しなければなりません。","Mar":"３月","Allianz_SE":"Allianz SE（アリアンツ）","{JAPAN_ONLY}The_time-value_of_an_option_represents_the_expected_value_of_the_option_at_the_exercise_point,_and_may_be_positive,_even_when_the_intrinsic-value_is_zero_":"時間的価値は、オプションの残存期間を対象とした、将来の期待値であり、本源的価値がゼロであっても時間的価値はプラスとなる。","Dec":"１２月","Gemalto_cyber_security":"Gemalto cyber security（ジェムアルト）","Novartis_AG":"Novartis AG（ノバルティス）","General_Motors_Company":"General Motors Company（ゼネラルモーターズ）","Portuguese_Index":"ポルトガル インデックス","{JAPAN_ONLY}For_a_call_option,_if_the_price_of_the_underlying_asset_is_higher_than_the_option_exercise_price,_it_is_know_as_an_in-the-money_option_":"コールオプションにおいて、原資産の価格が権利行使価格を上回っている状態をインザマネーという。","higher":"HIGH","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"[_1] [_2]のバーチャルマネーをアカウント[_3]へ入金する","Jan":"１月","Monday":"月曜日","Royal_Dutch_Shell":"Royal Dutch Shell（ロイヤルダッチシェル）","differs":"アンマッチ","Current":"現在","Predict_the_direction<br_/>and_purchase":"方向性<br />を予測して購入","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_is_strictly_higher_or_equal_than_Exercise_price_at_close__on_[_4]_":"[_3]が[_4]の時点で権利行使価格以上であった場合、[_1] [_2]のペイアウトをお受け取りいただけます。","Self-Employed":"自営業","AIRBUS_GROUP_SE":"AIRBUS GROUP SE（エアバス グループ）","Estimated_Net_Worth":"推定純資産","{JAPAN_ONLY}It_is_possible_to_use_two_binary_options_to_make_a_profit_if_the_asset_price_settles_inbetween_the_two_strikes__It_is_also_possible_to_buy_a_single_range_option_that_will_achieve_the_same_result_":"２つのオプションを用い、権利行使価格の高いバイナリープットオプションと権利行使価格の低いバイナリーコールオプションを取得すれば、判定レートが２つのオプションの権利行使価格の間となった場合に収益が得られ、判定レートが所定の価格帯の中であった場合にペイアウトとなるレンジバイナリーオプションに似た投資を行うことができる。","Student":"学生","{JAPAN_ONLY}A_binary_option_which_is_in-the-money_will_have_a_higher_value_than_an_option_that_is_out-of-the-money_because_there_will_be_a_higher_probability_of_receiving_the_payout_amount_":"インザマネーのバイナリーオプションは、ペイアウトを受け取る確率が高いため、アウトオブザマネーのバイナリーオプションよりも価格が高い。","{JAPAN_ONLY}When_buying_a_vanilla_call_option,_the_break-even_price_at_the_exercise_point_is_the_strike_price_plus_the_option_price_paid_in_units_of_the_underlying_":"コールオプションの買いでは、権利行使価格に原資産１単位当たりのオプション料を加算した価格が損益分岐点である。","Binary_options_or_other_financial_derivatives_trading_frequency":"バイナリーオプションまたはその他金融デリバティブ取引の頻度","Virgin_America_Inc_":"Virgin America Inc.（ヴァージン アメリカ）","Action":"売買","French_Smart_Index":"フランス スマートインデックス","Customer_Support":"カスタマーサポート","Ford_Motor_Comapny":"Ford Motor Comapny（フォード モーター）","{JAPAN_ONLY}If_you_sell_a_currency_binary_call_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_need_to_payout_1,000_yen_to_the_buyer_of_the_option_":"権利行使価格１ドル100円、ペイアウト1,000円のドル円のコールバイナリーオプションの購入代金500円を受け取り、判定レートが１ドル９９円となり権利行使が行われ、1,000円のペイアウトを支払った。","comma":"読点","minutes":"分","Last_Used":"最後に使用した","Indian_50_Index":"インド50指数","Wall_Street_Index":"ウォールストリート インデックス","Kuwait_Index":"クウェート インデックス","Less_than_6_months":"6ヶ月未満","This_contract_has_LOST":"このトレードは負け判定です","Gilead_Sciensec_Inc_":"Gilead Sciensec Inc.（ギリアド サイエンシズ）","Net_Annual_Income":"年間純収入","40_transactions_or_more_in_the_past_12_months":"過去12ヶ月で40以上のお取引","Previous":"戻る","Kering":"Kering（ケリング）","Euro_150_Index":"ユーロ150インデックス","Investments_&_Dividends":"投資と配当","Stocks_trading_frequency":"株式取引の頻度","Your_withdrawal_limit_is_[_1]_[_2]_":"お客様の出金限度額は[_1] [_2]です。","Failed_to_update_trade_description_":"トレード内容の更新ができませんでした。","Please_enter_a_number_greater_or_equal_to_[_1]_":"[_1]以上の数字を入力してください。","Bear_Market_Index":"ベアマーケットインデックス","RIO_TINTO_LIMITED":"RIO TINTO LIMITED（リオ ティント）","Barclays_plc":"Barclays plc（バークレイズ）","Stocks":"株式","not_available":"利用不可","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"その決済サービスは、お客様のお住まいの国では現在ご利用いただけません。","Buy":"購入","PepsiCo_Inc_":"PepsiCo Inc.（ペプシコ）","{JAPAN_ONLY}A_bought_or_sold_binary_option_may_be_closed-out_before_exercise_time_by_selling_or_buying-back_the_option,_or_alternatively_by_cancelling_":"購入したバイナリーオプションは、反対売買（又は解約）により、判定時刻より前に決済することができる。","Bank_of_America_Corporation":"Bank of America Corporation（バンク オブ アメリカ）","{JAPAN_ONLY}In_case_of_the_right_to_sell_the_underlying_asset_(put_option),_when_the_underlying_asset_price_rises,_the_option_price_will_increase_":"原資産を売る権利（プットオプション）の場合、原資産価格が上昇すると、オプションの価格は高くなる。","Exclude_time_cannot_be_for_more_than_5_years_":"6年以上の除外期間は設定することはできません。","Next":"次","Friday":"金曜日","Your_account_has_no_trading_activity_":"お客様の口座に取引アクティビティはありません","Your_trading_statistics_since_[_1]_":"[_1]からのお取引統計情報","Your_settings_have_been_updated_successfully_":"設定が正しく更新されました。","Your_password_cannot_be_the_same_as_your_email":"パスワードはEメールと同じものにはできません。","Please_select_a_valid_date":"有効な日付を選択してください","{JAPAN_ONLY}Price_of_the_option,_the_price_of_the_underlying_asset,_price_fluctuation_rate_of_the_underlying_assets,_the_time_until_the_exercise_date,_subject_to_any_of_the_impact_of_interest_rates_":"店頭バイナリーオプション取引の場合、金融商品取引業者等が破たんすると、オプションの条件がインザマネーになっていたとしても権利行使が行えない可能性がある。","Walkthrough_Guide":"チュートリアルガイド","National_Grid_plc":"National Grid plc（NG）","Unemployed":"無職","Puma_Biotechnology_Inc_":"Puma Biotechnology Inc.（プーマ バイオテクノロジー）","Schneider_Electric":"Schneider Electric（シュナイダーエレクトリック）","Shanghai_Index":"上海インデックス","verification_token":"認証コード","BG_Group_plc":"BG Group plc（BGグループ）","points":"ポイント","{JAPAN_ONLY}For_both_call_and_put_options,_if_the_underlying_asset_price_is_the_same_as_the_exercise_price,_it_is_known_as_an_at-the-money_option_":"コールオプション、プットオプション共に、原資産の価格が権利行使価格と同じ状態をアットザマネーという。","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"お客様の口座を認証いただくには、[_1]へメールを送信してください。","ALUMINA_LIMITED":"ALUMINA LIMITED（アルミナ）","Contract_Expiry":"取引終了","December":"１２月","Quality_Assurance":"品質保証","Primary":"主要","Revoke_access":"アクセス権の取消","Saudi_Arabia_Index":"サウジアラビア インデックス","{JAPAN_ONLY}The_seller_of_an_option_should_receive_the_option_premium_from_the_buyer,_even_if_the_buyer_waives_the_right_to_exercise_the_option_":"オプションの売り手は、買い手が権利行使を放棄した場合でも、買い手からオプション料を受け取ることができる。","Try_adding_more_numbers_":"さらに数字を追加してみてください。","Password_is_weak":"パスワード強度は弱です","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"現在デモ口座([_2])にログインしています。","Higher/Lower":"HIGH/LOW","Stake":"購入価格","Ctrip_com_International_Ltd_":"Ctrip.com International Ltd.（シートリップ）","GlaxoSmithKline_plc":"GlaxoSmithKline plc（グラクソ・スミスクライン）","{JAPAN_ONLY}In_case_of_the_right_to_buy_the_underlying_asset_(call_option),_when_the_underlying_asset_price_falls,_the_option_price_will_increase_":"原資産を買う権利（コールオプション）の場合、原資産価格が下落すると、オプションの価格は高くなる。","Amount_per_point":"ポイントごとの金額","Date_and_Time":"日時","The_Coca-Cola_Company":"The Coca-Cola Company（ザ コカ・コーラカンパニー）","Total_Profit/Loss":"合計　損益","L'Oreal":"L'Oreal（ロレアル）","Sorry,_an_error_occurred_while_processing_your_request_":"申し訳ございませんが、リクエスト処理中にエラーが発生しました。","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"ご口座で保有可能なご口座残高の最高金額を示します。最高金額を超えた場合はご出金をお願いいたします。","Alpha_Bank_S_A_":"Alpha Bank S.A.（アルファ銀行）","NetEase_Inc_":"NetEase Inc.（ネットイーズ）","Jun":"６月","Confirm":"決定","Carnival_plc":"Carnival plc（カーニバル）","Back":"戻る","Balance":"残高","Statement":"取引履歴","Contract_/_Temporary_/_Part_Time":"契約/臨時/パートタイム","ends_between":"範囲内で終了","Japanese_Smart_Index":"日本 スマートインデックス","Your_account_has_no_Login/Logout_activity_":"お客様のご口座はログイン/ログアウトのアクティビティはございません。","{JAPAN_ONLY}Delta_refers_to__a_percentage_change_of_the_option_price_with_respect_to_the_change_in_the_underlying_asset_price_":"デルタとは、原資産価格の変化に対するオプション価値の変動割合をいう。","{JAPAN_ONLY}If_you_buy_a_currency_binary_call_option_at_a_price_of_500_yen,_with_an_underlying_of_dollar_against_yen,_the_payout_is_1,000_yen,_and_the_strike_price_is_100,_then_if_the_judgment_price_at_exercise_time_is_99,_you_will_receive_a_payout_1,000_yen_from_the_seller_of_the_option_":"権利行使価格１ドル100円、ペイアウト1,000円のドル円のコールバイナリーオプションを500円で購入し、判定レートが１ドル９９円となり権利行使が行われ、1,000円のペイアウトを受け取った。","Select_your_trade_type":"取引タイプを選択してください","Exit_Spot_Time":"終了レート時間","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"現在、価格情報を更新することはできません。価格情報を更新したい場合は、このページを更新して下さい。状況が改善されない場合は、他のブラウザをお試しください。","Pearson_plc":"Pearson plc（ピアソン）","Oracle":"Oracle（オラクル）","Low_barrier":"下限バリア","{JAPAN_ONLY}Option_prices_depend_on_the_spot_price,_the_time_to_expiry,_the_volatility_of_the_spot_rate_and_interest_rates_":"店頭バイナリーオプション取引の場合、金融商品取引業者等が破たんすると、オプションの条件がインザマネーになっていたとしても権利行使が行えない可能性がある。","Commodities_trading_experience":"コモディティ取引のご経験","Forex":"外国為替","{JAPAN_ONLY}For_an_individual_investor,_all_profits_from_OTC_currency_options_trading_are_tax-free_":"個人投資者の場合、通貨関連店頭オプション取引の利益は全て非課税である。","Minor_Pairs":"マイナーペア","Spreads":"スプレッド","Contract_ID":"トレード ID","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_ends_on_or_between_low_and_high_values_of_Exercise_price_at_close_on_[_4]_":"[_3]が[_4]までに権利行使価格の値で終了または上限バリアと下限バリアの範囲内で終了した場合、[_1] [_2]のペイアウトをお受け取りいただけます。","Only_[_1]_are_allowed_":"[_1]のみご利用いただけます。","Virtual_Account":"デモ口座番号","{JAPAN_ONLY}Section_3:_Outline":"｛日本限定｝第三章：概要","Our_site_does_not_charge_any_transfer_fees_":"当サイトはご入金、及びご出金時に手数料を請求することはありません。","Daily_Reset_Indices":"デイリーリセットインデックス","Deposit":"入金","French_Stocks":"フランス株式","Netflix_Inc_":"Netflix Inc.（ネットフリックス）","Please_input_a_valid_date":"有効な日にちを入力して下さい。","years":"年","Sunday":"日曜日","Explanation":"取引概要","This_contract_has_WON":"このトレードは勝ち判定です","{JAPAN_ONLY}SELL_price__per_unit":"単位ごとの価格を売却","{JAPAN_ONLY}The_particular_details_of_binary_options_are_all_the_same,_no_matter_which_broking_company_you_trade_with_":"店頭バイナリーオプションの金融商品としての内容は、取扱金融商品取引業者が異なっても同じである。","{JAPAN_ONLY}For_a_plain_vanilla_option,_as_the_time_to_the_exercise_point_shortens,_the_price_of_the_option_will_decrease_":"権利行使期限までの残り時間が短くなるほど、オプションの価格は低くなる。","Please_wait_<br_/>Your_request_is_being_processed_":"少々お待ち下さい。<br />リクエストを処理中です。","{JAPAN_ONLY}Section_2:_Method":"｛日本限定｝第二章：メソッド","6_months_to_1_year":"6ヶ月から1年","{JAPAN_ONLY}Please_complete_the_following_questions_":"知識確認テスト用ディスクレーマー \n \n・この知識確認テストは、法令で義務付けられており、当社がお客様の事を知り、お客様がバイナリーオプション取引を行うことに適した投資者がどうかを判断したうえで、お客様との取引を開始するためのものです。 \n・バイナリーオプション投資を的確に行うにはオプション取引などデリバティブ取引に関わる知識や経験が必要です。 \n・本テストはオプション取引に関わる基礎的な知識の有無を確認する目的で行われます。 \n・本テストの結果により適正と判断し、取引を開始する場合は、その後当社との間に取引上のトラブルが生じたとしても、オプション取引に関わる知識が不足していたにも関わらず当社が取引を認めたことを訴因とはしないことに同意いただくものとします。 \n・問題の複写を禁止します。また、第三者に漏えいしないことに同意いただくものとします。","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"お客様のご口座[_1]はご利用いただけません。ご不明な点がございましたら[_2]までご連絡下さい。","Volatility_Indices":"ボラティリティ指数","{JAPAN_ONLY}[_1]_[_2]_payout_if_[_3]_ends_otside_low_and_high_values_of_Exercise_price_at_close_on_[_4]_":"[_3]が[_4]の時点で権利行使価格値の上限バリアと下限バリア外で終了した場合、[_1] [_2]のペイアウトをお受け取りいただけます。","Belgian_Index":"ベルギー インデックス","Palladium/USD":"パラジウム/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"認証コードの有効期限が切れています。再度、<a class=\"pjaxload\" href=\"[_1]\">「最初からやり直し」</a> をクリックして認証コードを発行して下さい。","Remaining_Time":"残り時間","Your_transaction_reference_number_is_[_1]":"決済の参照番号は[_1]です","January":"１月","There_was_an_error":"エラーが発生しました","Groupe_Bruxelles_Lambert":"Groupe Bruxelles Lambert（グループ・ブリュッセル・ランバート）","American_International_Group_Inc_":"アメリカンインターショナルグループ Inc.","Targeting_medium-term_/_long-term_profits":"中期利益/長期利益を目標にする","The_Home_Depot_Inc_":"The Home Depot Inc.（ホーム デポ）","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"形式：年月日（デモ口座の方はご必要ありません）","Maximum_number_of_open_positions":"最大保有ポジション","Start_Time":"開始時間","Manchester_United_plc":"Manchester United plc（マンチェスター ユナイテッド）","Exit_Level":"判定レベル","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2]がデモ口座[_3]に付与されました","Please_submit_a_valid_[_1]_":"有効な[_1]をご提出ください。","Session_duration_limit_cannot_be_more_than_6_weeks_":"セッション期間制限は7週間以上に設定できません。","Ends_In/Out":"END-IN/END-OUT","Workday_Inc_":"Workday Inc.（ワークデイ）","Indices":"インデックス","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"当社のサーバでリクエストが受理された場合、その時点での市場価格でトレードを売ることができます。この価格は表示価格と異なる場合があります。","Maximum_aggregate_payouts_on_open_positions":"オープン中ポジションに対する払い戻し金額の最高総額","Credit/Debit":"支払/受取","End_Time":"終了時間","There_was_a_problem_accessing_the_server_":"サーバーアクセスにエラーが発生しました。","{JAPAN_ONLY}In_general_a_binary_option_price_will_not_exceed_the_payout_amount_":"一般的には、インザマネーのバイナリーオプションの価格は、ペイアウト額を上回ることはない。","{JAPAN_ONLY}If_an_option_buyer_wishes_to_exercise_the_option_rights,_the_seller_may_still_reject_the_deal_":"オプションの売り手は、買い手が権利を行使した場合には、その決済を拒否することができる。","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"パスワードの再設定に認証コードが必要となりますので、メールをご確認ください。","year":"年","Brazilian_Index":"ブラジル インデックス","Finance":"金融","Google_Inc_":"Google Inc.（グーグル）","Graphic_Designers":"グラフィックデデザイナー","Administrator":"管理者","November":"１１月","ExxonMobil":"ExxonMobil（エクソンモービル）","South_African_Index":"南アフリカインデックス","Contract":"トレード","Keep_track_of_your_authorised_applications_":"認証済みアプリケーションを引き続き追跡してください。","Please_enter_a_valid_amount_":"有効な値をご入力して下さい。","Please_enter_a_date_that_is_at_least_6_months_from_now_":"現在から最低６ヶ月先の日付を入力して下さい。","Zoom":"ズーム","{JAPAN_ONLY}About_OTC_currency_for_binary_options_trading,_summarizes_the_profit_and_loss_result_of_all_transactions_that_have_been_made_between_the_customer,_to_publish_the_information_in_the_company's_home_page,_at_any_time_while_the_customer_is_doing_the_transaction_before_the_start,_or_the_transaction,_the_information_Make_sure,_for_that_you're_willing_to_trade_under_the_calm_judgment,_we_are_committed_to_a_variety_of_environmental_improvement_":"店頭通貨バイナリーオプション取引については、顧客との間で行われた全取引の損益結果をまとめ、自社のホームページにおいて情報を公開し、顧客が取引開始前、あるいは取引を行っている間いつでも、その情報を確認し、冷静な判断の下にお取引いただけるための、様々な環境整備に努めている。","Your_changes_have_been_updated_":"変更が更新されました。","May":"５月","Profit":"利益","Exclude_time_must_be_after_today_":"制限時間は明日以降として設定して下さい。","Rise/Fall":"アップ/ダウン","Vipshop_Holdings_Limited":"Vipshop Holdings Limited（ビショップ ホールディングス）","Total_Cost":"合計投資額","Tata_Steels":"Tata Steels（タタ スチール）","{JAPAN_ONLY}The_test_is_unavailable_now,_test_can_only_be_taken_again_on_next_business_day_with_respect_of_most_recent_test_":"｛日本限定｝現在テストを受験いただけません。前回のテストの翌営業日に再度受験いただけます。","Touch/No_Touch":"タッチ","Baidu_Inc_":"百度株式会社（バイドゥ）","Hang_Seng_China":"Hang Seng China（ハンセン中国）","Invalid_date_of_birth_":"生年月日が無効です。","Sell_at_market":"売却","{JAPAN_ONLY}In_contrast_to_other_types_of_FX_options,_short_positions_in_FX_Binary_Options_cannot_be_closed-out_as_they_are_not_subject_to_loss-cut_regulations_":"通貨関連バイナリーオプションのショートポジションは、他の通貨関連オプションのショートポジションとは異なり、ロスカット規制の対象となる金融商品ではないため、ロスカットされることはない。","Intel":"Intel（インテル）","Date_(GMT)":"日付 (GMT)","Alcoa_Inc_":"Alcoa Inc.（アルコア）","Maximum_daily_turnover":"１日あたりのトレード購入可能金額","Targeting_short-term_profits":"短期利益を目標にする","You_have_sold_this_contract_at_[_1]_[_2]":"[_1] [_2]でこのトレードを売却しました","3-5_years":"3〜5年","Commbank_(Australia)":"Commbank （オーストラリア・コモンウェルス銀行）","Royal_Dutch_Shell_plc":"Royal Dutch Shell plc（ロイヤル・ダッチ・シェル）","Cie_de_Saint-Gobain":"Cie de Saint-Gobain（サンゴバン）","Foreign_currency_deposit":"外貨預金","Last_Digit_Stats":"下一桁ステータス","Permissions":"アクセス許可","Compliance_Executive":"コンプライアンス・エグゼクティブ","Settles":"約定時間","f":"女性","Stocks_trading_experience":"株式取引のご経験","{JAPAN_ONLY}Option_prices_are_normally_dependant_on_elements_such_as_the_underlying_asset_price,_the_exercise_price,_the_length_of_time_until_the_exercise_point,_volatility,_and_interest_rates__Apart_from_the_fixed_exercise_price,_all_other_elements_are_changing_constantly,_so_an_understanding_of_the_relationships_between_each_element_and_changes_in_the_options_price_is_necessary_for_the_management_of_options_trading_risk_":"オプションの価格を形成する要素には原資産の価格、権利行使価格、権利行使期限までの期間の長さ、ボラティリティ、金利があるが、権利行使価格を除き、他の要素は刻々と変化し、オプションの価格も変化する。したがってオプション取引のリスクを管理していくためには、それぞれの要素の変化とオプション価格の変化の関係を理解する必要がある。","Item":"項目","Month":"ヶ月","Successful":"成功しました","SANOFI":"SANOFI（サノフィ）","Unlock_Cashier":"入出金ロック解除","Middle_East":"中東","Reckitt_Benckiser_Group_plc":"Reckitt Benckiser Group plc（レキット・ベンキーザーグループ）","Pension":"年金","Proofreader":"校正者","Low_barrier_offset":"下限追加バリア値"};
texts_json['AR'] = {"Accounts_And_Payments_Executive":"الحسابات والمدفوعات التنفيذية","Prices":"أسعار","Stop_Loss_Level":"مستوى وقف الخسارة","Please_select":"يرجى اختيار","This_contract_won":"هذا العقد رابح","Oil/EUR":"نفط/يورو","Spot":"السعر","US_Index":"مؤشر الولايات المتحدة","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"تم معالجة طلبك لتحويل [_1] [_2] من [_3] إلى [_4] بنجاح.","Payout":"العائد","EUR/CAD":"يورو/دولار كندي","Period":"فترة","stays_between":"يبقى بين","NZD/JPY":"دولار نيوزيلندي/الين الياباني","Deposit_of":"إيداع","odd":"فردي","Pfizer_Inc_":".Pfizer Inc","Wednesday":"الأربعاء","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"يمثل الحد الأقصى لحجم العقود التي بإمكانك أن تشتريها في أي يوم تداول.","Dubai_Index":"مؤشر دبي","month":"شهر","XPD/GBP":"بالاديوم/جني استرليني","Minimum_of_[_1]_characters_required_":"الحد الأدنى المطلوب [_1] حرفا.","In/Out":"داخل/خارج","Industry_of_Employment":"مجال العمل","Human_Resource_Executive":"تنفيذي الموارد البشرية","Opens":"يفتح","Exit_Spot":"سعر الخروج","Potential_Payout":"المردودات المحتملة","GBP/NZD":"الجنيه الاسترليني/دولار نيوزيلاندي","Points":"نقاط","USD/JPY":"الدولار الأمريكي/الين الياباني","Gold/AUD":"ذهب/دولار استرالي","touches":"يصل إلى","Secondary":"ثانوي","AUD/CHF":"أسترالي/الفرنك السويسري","Marketing_Executives":"مديري التسويق","No_Live_price_update":"لا يوجد تحديث مباشر للأسعار","Please_select_a_payment_agent":"يرجى اختيار وكيل دفع","Real_Account":"حساب حقيقي","Europe/Africa":"أوروبا/أفريقيا","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"- صورة ضوئية من فاتورة خدمات أو كشف حساب بنكي (يجب ألا يكون قد مضى عليها أكثر من ثلاثة أشهر).","30-50_million_JPY":"30 - 50 مليون ين","USD/CNY":"دولار أمريكي/اليوان الصيني","Ok":"حسنا","Spanish_Index":"مؤشر أسبانى","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"يمكن استخدام كلمة مرور إضافية لحظر الوصول لصفحة الصراف.","USD/IDR":"دولار أمريكي/روبية أندونيسي","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"تم توثيق حسابك بالكامل وحد السحب الخاص بك تم رفعه.","Swedish_Index":"مؤشر سويدى","GBP_Index":"مؤشر الاسترليني","Binary_options_or_other_financial_derivatives_trading_experience":"الخيارات الثنائية أو غيرها من خبرات تداول المشتقات المالية","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"تم إعادة تعيين كلمة المرور الخاصة بك بنجاح. يرجى أن تسجل الدخول لحسابك باستخدام كلمة مرورك الجديدة.","Less_than_$100,000":"أقل من 100,000 دولار","Jul":"يوليو","Upcoming_Events":"الأحداث القادمة","minimum_available_duration":"أقل مدة زمنية متاحة","AUD/DKK":"دولار أسترالي/كرون دانماركي","Gold/EUR":"ذهب/يورو","USD/CAD":"دولار أمريكي/دولار كندي","Now":"الآن","Construction":"الإنشاءات","EUR/MXN":"يورو/بيزو مكسيكي","Norwegian_Index":"مؤشر نرويجي","EUR/PLN":"يورو/زلوتي بولندا","Korean_Index":"مؤشر كورى","Number_of_ticks":"عدد الحركات","asian_up":"صعود آسيوي","Entry_Level":"مستوى الدخول","GBP/AUD":"الجنيه الاسترليني/دولار أسترالي","Asians":"آسيوي","September":"سبتمبر","Save_as_PDF":"الحفظ كملف PDF","Contract_Confirmation":"تأكيد العقد","numbers":"أرقام","View_your_statement":"اطلع على كشف الحساب الخاص بك","Merck_&_Co__Inc_":".Merck & Co. Inc","XAG/AUD":"فضة/دولار استرالي","Delete":"أحذف","Profit/Loss_(points)":"الربح/الخسارة (نقاط)","3-5_million_JPY":"3 - 5 مليون ين","spread_down":"السبريد لأسفل","GBP/KRW":"الجنيه الاسترليني/الوون الكوري","AUD_Index":"مؤشر الاسترالي","Continuous_Indices":"مؤشرات مستمرة","Quality_Assurance_Engineer":"مهندس ضمان الجودة","AUD/SGD":"أسترالي/دولار سنغافوري","Information_Technology":"تكنولوجيا المعلومات","Digits":"الأرقام","Quantitative_Developer":"مطور كمي","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"لا نقبل حسابات المقيمين في هذا البلد في الوقت الحالي.","Browser":"المتصفح","Australian_Index":"مؤشر أستراليا","NZD/USD":"دولار نيوزيلندي/ دولار أمريكي","Login_ID":"معرف تسجيل الدخول","0-5_transactions_in_the_past_12_months":"0 - 5 معاملات خلال الـ 12 شهرا الماضية","Start_time":"وقت البدء","Americas":"الأمريكتين","Japanese_Index":"مؤشر ياباني","Salaried_Employee":"موظف بأجر","Deutsche_Bank_AG":"البنك الألمانى","matches":"يماثل","Long":"طويل","USD/BRL":"دولار أمريكي/ريال برازيلي","is_required__Current_spread":"مطلوب. السبريد الحالي","AUD/SAR":"أسترالي/ ريال سعودي","Less_than_$25,000":"أقل من 25,000 دولار","Mr":"السيد","1-2_years":"1 - 2 سنوات","XAG/EUR":"فضة/يورو","March":"مارس","(Bejing/CST_-8_hours)":"(توقيت بكين ينقص 8 ساعات عن التوقيت المركزى)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] قامت بتحديث 2% الخاصة بها. بالنقر فوق موافق، فأنت تؤكد أنك قرأت ووافقت على 2% المحدثة.","hyphen":"واصلة","Smart_FX":"FX الذكية","AUD/INR":"دولار أسترالي/روبية هندية","GBP/NOK":"الجنيه الاسترليني/كرونة نرويجية","Invalid_amount,_maximum_is":"قيمة غير صالحة، الحد الأقصى هو","US_Smart_Index":"المؤشر الذكي للولايات المتحدة","Week_of":"أسبوع","Entry_Spot":"سعر الدخول","You_should_enter_between_[_1]_characters_":"يجب أن تدخل بين [_1] حرفا.","Nov":"نوفمبر","Ref_":"مرجع","spread_up":"السبريد لأعلى","Contract_is_not_started_yet":"لم يتم بدء العقد حتى الآن","Indicative":"ارشادي","Dutch_Index":"مؤشر هولندي","EUR/BRL":"يورو/ ريال برازيلي","Metals":"معادن","EUR/INR":"يورو/الروبية الهندية","We":"الأسبوع","EUR/HKD":"يورو/دولار هونج كونج","Please_enter_a_number_between_0_and_[_1]":"يرجى إدخال رقم بين 0 و [_1]","Quantitative_Analyst":"محلل كمي","Level_of_Education":"مستوى التعليم","New_token_created_":"تم إنشاء رمز مميز جديد.","5-10_million_JPY":"5 - 10 مليون ين","even":"زوجي","Authorise_your_account_":"السماح للحساب الخاص بك.","Education":"تعلم","Contract_Sold":"بيع العقد","Gaming_Account":"حساب الألعاب","July":"يوليو","June":"يونيو","Thursday":"الخميس","EUR/AUD":"يورو/دولار أسترالي","Limit":"حد","Smart_Indices":"المؤشرات الذكية","Your_details_have_been_updated_":"تم تحديث التفاصيل الخاصة بك.","Over_$1,000,000":"أكثر من 1,000,000 دولار","Financial_Assessment":"التقييم المالي","Password_is_very_strong":"كلمة المرور قوية جداً","USD_Index":"مؤشر الدولار الأمريكي","USD/MXN":"دولار أمريكي/بيزو مكسيكي","1-3_years":"1 - 3 سنوات","GBP/DKK":"الجنيه الاسترليني/كرونة دانمركية","password":"كلمة المرور","Stop-type":"نوع الوقف","AUD/JPY":"دولار أسترالي/ ين ياباني","GBP/IDR":"الجنيه الاسترليني/روبية أندونيسي","1-3_million_JPY":"1 - 3 مليون ين","Commodities_trading_frequency":"معدل تداول السلع","Transfer_to":"النقل إلى","Price":"سعر","ticks":"حركات","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"عندما تضغط \"موافق\" سوف تستثنى من التداول على الموقع حتى التاريخ المحدد.","Questions":"الأسئلة","and":"و","Apr":"أبريل","months":"شهور","Potential_Profit":"الربح المحتمل","over":"فوق","CHF/JPY":"الفرنك السويسري/ الين الياباني","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"خدمات التداول المالي الواردة في هذا الموقع مناسبة فقط للعملاء القادرين على تحمل خسارة جميع الأموال التي يستثمرونها والذين يفهمون المخاطر التي تنطوي على حيازة العقود المالية ولديهم خبرة عنها. معاملات العقود المالية تنطوي على درجة عالية من المخاطرة. إذا انتهت صلاحية العقود المشتراه بدون أي قيمة ستتحمل خسارة كامل استثماراتك والتي تتضمن قيمة العقد.","Random":"عشوائي","Sale_Date":"تاريخ البيع","Nocturnes":"مؤشرات ليلية","Exercise_period":"فترة العمل","February":"فبراير","Exclude_time_cannot_be_less_than_6_months_":"وقت الاستبعاد لا يمكن أن يكون أقل من 6 أشهر.","Copywriter":"المؤلف","Your_current_balance_is":"رصيدك الحالي هو","Singapore_Index":"مؤشر سنغافورة","Duration":"المدة","This_contract_lost":"هذا العقد خاسر","AUD/CNY":"الدولار الأسترالي/اليوان الصيني","Indices_trading_frequency":"معدل تداول المؤشرات","Other_financial_instruments_trading_frequency":"معدل التداول في الأدوات المالية الأخرى","AUD/USD":"دولار أسترالي/دولار","Password_is_strong":"كلمة المرور قوية","EUR_Index":"مؤشر يورو","Stop_Profit_Level":"مستوى وقف الربح","Try_adding_more_letters_":"حاول إضافة المزيد من الأحرف.","Egypt_Index":"مؤشر مصر","Net_profit":"صافي الربح","Status":"الحالة","There_was_a_problem_accessing_the_server_during_purchase_":"هناك مشكلة في الوصول إلى الخادم أثناء الشراء.","JP_Morgan_Chase_&_Co_":".JP Morgan Chase & Co","Adjust_trade_parameters":"ضبط معايير التداول","Dutch_Stocks":"الأسهم الهولندية","Over_$500,001":"أكثر من 500,001 دولار","Th":"الخميس","Oct":"أكتوبر","Even/Odd":"متساو/غير متجانس","Barrier_offset":"حاجز تعويض","EUR/JPY":"اليورو/الين الياباني","Gold/USD":"ذهب/دولار","Password_should_have_lower_and_uppercase_letters_with_numbers_":"يجب أن يكون لكلمة المرور أحرف تحتية واحرف علية مع أرقام.","Step":"خطوة","Next_Day":"اليوم التالي","EUR/SAR":"يورو/ريال سعودي","Applications":"تطبيقات","Save_as_CSV":"الحفظ كملف CSV","GBP/PLN":"الجنيه الاسترليني/زلوتي بولندا","Internal_Auditor":"مراجع حسابات داخلي","Loss":"خسارة","Mo":"الأثنين","Other":"آخر","Health":"الصحة","Dutch_Smart_Index":"مؤشر هولندا الذكي","AUD/KRW":"دولار أسترالي/الوون الكوري","Tick":"حركة","letters":"حروف","under":"تحت","Silver/USD":"فضة/دولار","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"آخر أرقام الإحصائيات لأحدث حركة % 1 في % 2","Energy":"طاقة","Over_3_years":"أكثر من 3 سنوات","From":"من","does_not_touch":"لا يصل إلى","hour":"ساعة","View":"شاهد","EUR/NOK":"يورو/الكرون النرويجي","Sorry,_an_error_occurred_while_processing_your_account_":"عفواً، حدث خطأ أثناء معالجة حسابك.","An_error_occured_":"حدث خطأ.","New_Password":"كلمة المرور الجديدة","Trading_Limits":"حدود التداول","German_Smart_Index":"مؤشر المانيا الذكي","Details":"التفاصيل","Login_History":"تاريخ تسجيل الدخول","Invalid_amount,_minimum_is":"قيمة غير صالحة، الحد الأدنى هو","minute":"دقيقة","Please_deposit_before_transfer_to_client_":"الرجاء إيداع قبل نقلها إلى العميل.","Password_Reset":"إعادة تعيين كلمة المرور","Maximum_account_cash_balance":"الحد الأقصى لرصيد الحساب النقدي","August":"أغسطس","EUR/CNY":"يورو/يوان صيني","Bombay_Index":"مؤشر بومباي","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"رجاء تأكيد تفاصيل المعاملة لأكمال التحويل:","Euro_50_Smart_Index":"مؤشر اليورو50 الذكي (Euro 50 Smart Index)","GBP/JPY":"الجنيه الاسترليني/الين الياباني","US_Tech_Composite_Index":"مؤشر ناسداك للتكنولوجيا الولايات المتحدة","Lock_Cashier":"قفل الصراف","Sa":"السبت","seconds":"ثوان","Matches/Differs":"يماثل/يختلف","Select_your_market":"اختر السوق الخاص بك","apostrophe":"فاصلة","Canadian_Index":"مؤشر الكندي","Finish":"إنهاء","Gold/GBP":"ذهب/جني استرليني","Oil/USD":"نفط/دولار","GBP/ZAR":"الجنيه الاسترليني/الراند الجنوب أفريقي","Up/Down":"فوق/تحت","Wal-Mart_Stores_Inc_":".Wal-Mart Stores Inc","Human_Resources":"الموارد البشرية","Mrs":"السيدة","Profit_Table":"جدول الأرباح","Purchase":"شراء","Tourism":"السياحة","10-30_million_JPY":"10 - 30 مليون ين","Shenzhen_Index":"مؤشر شنزن","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"قسم الصراف الخاص بك مغلقا بناءاً على طلبك - لفتحه، يرجى إدخال كلمة المرور.","Invalid_email_address":"عنوان البريد غير صحيح","Please_enter_an_integer_value":"رجاء إدخال قيمة عددية صحيحة","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"عفواً، هذة الخاصية متاحة للحسابات الافتراضية فقط.","Investment_Account":"حساب الاستثمار","GBP/AED":"الجنيه الاسترليني/درهم إماراتي","USD/SGD":"دولار أمريكي/دولار سنغافوري","You_are_not_authorized_for_withdrawal_via_payment_agent_":"غير مصرح لك بالسحب بواسطة وكيل دفع.","USD/KRW":"دولار أمريكي/ون كوريا الجنوبية","Quantitative_Analysis":"التحليل الكمي","Miss":"آنسة","Wall_Street_Smart_Index":"مؤشر وول ستريت الذكي","Please_check_your_email_for_the_value_of_this_token":"الرجاء التحقق من البريد الإلكتروني الخاص بك لقيمة الرمز المميز هذا","EUR/ZAR":"يورو/الراند الجنوب أفريقي","Forex_trading_experience":"خبرة تداول العملات الأجنبية","Amount":"مبلغ","The_maximum_number_of_tokens_([_1])_has_been_reached_":"لقد تم الوصول إلى الحد الأقصى لعدد الرموز المميزة ([_1]).","Westpac_Banking_Co_":".Westpac Banking Co","Global_Customer_Service_Representatives":"ممثلي خدمة العملاء العالمية","Withdrawal_Limits":"حدود السحب","Print_chart":"اطبع المخطط","Please_try_again_":"رجاء حاول مرة أخرى.","Your_transaction_reference_is":"الرقم المرجعي لمعاملتك هو","Compliance":"الامتثال","Save_as_SVG":"الحفظ كملف SVG","Profit/Loss":"الربح/الخسارة","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"يرجى ملء معرف تسجيل الدخول والمبلغ الذي ترغب في تحويله إلى عميلك في النموذج التالي:","Password_does_not_match_":"لا تطابق كلمة المرور.","Commodities":"السلع","Transfer_to_Login_ID":"التحويل إلى معرف تسجيل الدخول","Update":"حدث","Fr":"الجمعة","goes_outside":"يخرج عن","Chart":"رسم بياني","High_Barrier":"حاجز عالي","GBP/SAR":"الجنيه الاسترليني/ ريال سعودي","Date_of_Birth":"تاريخ الميلاد","space":"المسافة","Portuguese_Smart_Index":"مؤشر البرتغال الذكي","EUR/GBP":"اليورو/الجنيه الاسترليني","Saturday":"السبت","Never_Used":"لم تستخدم من قبل","USD/HKD":"دولار أمريكي/دولار هونغ كونغ","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"يمثل الحد الأقصى للعوائد الكلية على العقود المعلقة فى محفظتك. إذا تم الوصول للحد الأقصى لن يمكنك شراء عقود إضافية بدون قفل المعاملات الموجودة.","EUR/CZK":"يورو/كورونا تشيكية","Description":"الوصف","Sell":"بيع","Abu_Dhabi_Index":"مؤشر أبوظبي","Euro_50_Index":"مؤشر اليورو 50","October":"أكتوبر","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"أنت حاليا قمت بتسجيل الدخول إلى حساب المال الحقيقي الخاص بك مع % 1 (% 2).","Only_2_decimal_points_are_allowed_":"ويسمح فقط 2 النقاط العشرية.","Procter_&_Gamble_Co_":".Procter & Gamble Co","period":"فترة","Password_score_is:_[_1]__Passing_score_is:_20_":"نقاط كلمة المرور: [_1]. النقاط للإجتياز: 20.","Stays_In/Goes_Out":"يبقى بين/يخرج عن","Note":"ملاحظة","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"يمثل الحد الأقصى من العقود المعلقة فى محفظتك. كل سطر فى محفظتك يمثل معاملة مفتوحة. عندما يتم الوصول للحد الأقصى لن يعد بإمكانك أن تفتح معاملات جديدة دون أن تغلق معاملة موجودة أولاً.","Italian_30_Index":"مؤشر 30 الإيطالي","Password_is_not_strong_enough_":"كلمة السر ليست قوية بما يكفي.","Asset":"الأصول","Swiss_Smart_Index":"المؤشر الذكي السويسري","0-1_year":"0 - 1 سنة","AUD/HKD":"دولار أسترالي/دولار هونغ كونغ","Contract_Information":"معلومات العقد","EUR/USD":"اليورو/الدولار","Hong_Kong_Index":"مؤشر هونج كونج","Sorry,_account_opening_is_unavailable_":"عفوا، فتح الحساب غير متاح.","Anti-Fraud_Officer":"موظف لمكافحة الغش","Barrier":"حاجز","Current_Level":"المستوى الحالي","Password_is_moderate":"كلمة المرور متوسطة","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"سيتسلم عميلك إشعار إلكتروني ليعلمه أنه قد تم عمل التحويل.","Low_Barrier":"حاجز منخفض","Previous_Day":"اليوم السابق","Senior_Perl_Developer":"كبير مطوري بيرل","IP_Address":"عنوان IP","Tu":"الثلاثاء","Senior_Front-End_Developer":"كبير مطوري الفرنت-اند","Sale_Price":"سعر البيع","AUD/IDR":"دولار أسترالي/روبية أندونيسي","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"أدخل الحاجز بتحديد البعد بينه وبين سعر الإدخال. إذا أدخلت +0.005 فذلك يعنى أنك تشترى صفقة بحاجز أعلى من سعر الإدخال بـ 0.005. سعر الإدخال سيكون الحركة التالية بعد تسلم أمر الصفقة","GBP/CNY":"الجنيه الاسترليني/اليوان الصيني","Social_Media_Executive":"موظف وسائل الإعلام الاجتماعية","Short":"قصير","Please_confirm_the_trade_on_your_statement_before_proceeding_":"الرجاء التأكد من التداول بكشف حسابك قبل المتابعة.","Reset_Password":"اعادة تعيين كلمة السر","Token":"رمز","Year":"عام","Other_financial_instruments_trading_experience":"خبرة التداول في الأدوات المالية الأخرى","Forex_trading_frequency":"معدل تداول العملات الأجنبية","Purchase_Time":"وقت الشراء","Day":"يوم","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"- نسخة من جواز سفرك، أو نسخة من رخصة قيادة (مؤقته أو كاملة) أو بطاقة تحقيق شخصية، تحمل اسمك وتاريخ ميلادك.","Old_password_is_wrong_":"كلمة المرور القديمة غير صحيحة.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"تم معالجة  طلبك لسحب [_1] [_2] من حسابك [_3] لحساب وكيل الدفع [_4] بنجاح.","DevOps_Manager":"مدير ديفوبس","Trading_and_Withdrawal_Limits":"حدود التداول والسحب","High_barrier_offset":"بُعد الحاجز العالي","Aug":"أغسطس","Are_you_sure_that_you_want_to_permanently_delete_token":"هل أنت متأكد أنك تريد حذف الرمز المميز بشكل دائم","Open":"يفتح","EUR/KRW":"يورو/ الوون الكوري","ends_outside":"ينتهي خارج","You_did_not_change_anything_":"لم تغير أي شيء.","Russian_Regular_Index":"المؤشر الروسي المنتظم","Over/Under":"أكثر من/تحت","Feb":"فبراير","The_two_passwords_that_you_entered_do_not_match_":"كلمتى المرور اللذين قمت بإدخالهم لا يتطابقوا.","Failed":"فشل","Stop-loss":"وقف الخسارة","This_field_is_required_":"هذه الخانة مطلوبة.","Return":"عائد","Marketing":"التسويق","Tertiary":"تعليم عالي","Swiss_Index":"المؤشر السويسري","USD/SAR":"دولار أمريكي/ريال سعودي","AP_Ordinary":"AP العادية","Indices_trading_experience":"خبرة التداول بالمؤشرات","6-10_transactions_in_the_past_12_months":"6 - 10 معاملات خلال الـ 12 شهرا الماضية","Deutsche_Lufthansa":"لوفتهانزا","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"بمجرد النقر فوق الزر 'إرسال'، سوف تسحب من الحساب الخاص بك الأموال وتحويلها إلى حساب العميل الخاص بك.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"minimum duration, for example minimum 15 seconds)%ctx)دقيقة","day":"يوم","Chevron_Co_":".Chevron Co","Internal_Audit":"المراجعة الداخلية","Save_as_JPEG":"الحفظ كملف JPEG","AUD/CZK":"الدولار الأسترالي/ الكورونا التشيكية","Platinum/USD":"بلاتين/دولار","Income_Source":"مصدر الدخل","hours":"ساعات","Euro_100_Index":"مؤشر اليورو 100","second":"ثانية","GBP/INR":"الجنيه الاسترليني/الروبية الهندية","EUR/AED":"يورو/درهم إماراتي","Belgian_Stocks":"بورصات البلجيكية","Date":"تاريخ","Asia/Oceania":"آسيا/أوقيانوسيا","Italian_Index":"مؤشر إيطالي","lower":"أدنى","Confirm_New_Password":"تأكيد كلمة المرور الجديدة","Country_Manager":"مدير البلد","April":"أبريل","Select_your_underlying_asset":"اختر أصولك الأساسية","AUDZAR":"دولار أسترالي/الراند الجنوب أفريقي","GBP/SGD":"الجنيه الاسترليني/دولار سنغافوري","Last_Digit_Prediction":"التنبؤ بالرقم الأخير","GBP/CHF":"الجنيه الاسترليني/الفرنك السويسري","USD/DKK":"دولار أمريكي/كرونة دانمركية","Try_adding_more_letters_or_numbers_":"حاول إضافة المزيد من الأحرف أو الأرقام.","US_Tech_100_Index":"مؤشر الولايات المتحدة تك 100","AUD/AED":"أسترالي/درهم إماراتي","Sep":"سبتمبر","USD/AED":"دولار أمريكي/درهم إماراتي","Jakarta_Index":"مؤشر جاكرتا","Purchase_Price":"سعر الشراء","XPD/EUR":"بالاديوم/يورو","UK_Smart_Index":"مؤشر المملكة المتحدة (UK Smart Index)","days":"أيام","Never":"ابدأ","Name":"الإسم","Save_as_PNG":"الحفظ كملف PNG","New_Zealand_Index":"مؤشر نيوزيلندا","Major_Pairs":"الأزواج الرئيسية","Su":"الأحد","Please_enter_a_number_between_[_1]_":"الرجاء إدخال رقم بين % 1.","Marketing_Project_Manager":"مدير مشروع التسويق","GBP/CAD":"الجنيه الاسترليني/دولار كندي","Jump_To":"الانتقال إلى","loading___":"تحميل...","Accounting":"المحاسبة","French_Index":"مؤشر فرنسى","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"عندما تضغط \"موافق\" سوف تستبعد من التداول على الموقع حتى التاريخ المحدد.","EUR/SGD":"يورو/دولار سنغافوري","AUD/PLN":"أسترالي/زلوتي بولندا","Closes":"يغلق","To":"إلى","Reference_ID":"الرقم المرجعي","AUD/NOK":"دولار أسترالي/الكرون النرويجي","Administrative_Executive":"التنفيذي الإداري","Tuesday":"الثلاثاء","Sorry,_this_feature_is_not_available_":"عفوا، هذه الميزة غير متوفرة.","Select_market":"اختر السوق","High_barrier":"حاجز مرتفع","GBP/HKD":"الجنيه الاسترليني/دولار هونغ كونغ","Closed":"مغلق","50-100_million_JPY":"50 - 100 مليون ين","You_must_accept_the_terms_and_conditions_to_open_an_account_":"يجب أن تقبل الشروط والأحكام قبل أن تفتح حساب.","USDZAR":"دولار أمريكي/الراند الجنوب أفريقي","Mar":"مارس","Dec":"ديسمبر","Portuguese_Index":"مؤشر البرتغال","higher":"أعلى","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"إيداع ٪ 1 ٪ 2 الأموال الافتراضية إلى حسابك 3٪","Jan":"يناير","Monday":"الأثنين","differs":"يختلف","Current":"الحالية","Predict_the_direction<br_/>and_purchase":"توقع الاتجاه<br />وقم بالشراء","Oil/AUD":"نفط/دولار استرالي","Self-Employed":"يعمل لحسابه الخاص","GBP/BRL":"الجنيه الاسترليني/ريال برازيلي","Estimated_Net_Worth":"قيمة الثروة الصافية المقدرة","Binary_options_or_other_financial_derivatives_trading_frequency":"وتيرة تداول الخيارات الثنائية أو المشتقات المالية الأخرى","Action":"عمل","French_Smart_Index":"مؤشر الفرنسي الذكي(French Smart Index)","Customer_Support":"دعم العملاء","comma":"فاصلة","minutes":"دقائق","USD/CHF":"الدولار الأمريكي/الفرنك السويسري","Last_Used":"المستخدم أخيرا","AUD/MXN":"الدولار الأسترالي/بيزو مكسيكي","Oil/GBP":"نفط/جني استرليني","Indian_50_Index":"مؤشر 50 الهندى","Wall_Street_Index":"مؤشر وول ستريت","Net_Annual_Income":"صافي الدخل السنوي","40_transactions_or_more_in_the_past_12_months":"40 معاملة أو أكثر خلال الـ 12 شهرا الماضية","Previous":"سابق","EUR/IDR":"يورو/روبية أندونيسي","Euro_150_Index":"مؤشر يورو 150","Investments_&_Dividends":"الاستثمارات وتوزيعات الأرباح","Stocks_trading_frequency":"معدل تداول الأسهم","Failed_to_update_trade_description_":"فشل فى تحديث توصيف المعاملة التجارية.","Please_enter_a_number_greater_or_equal_to_[_1]_":"الرجاء إدخال رقم أكبر أو يساوي % 1.","Stocks":"الأسهم","not_available":"غير متاح","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"وسيلة وكلاء الدفع غير متاحة حاليا في بلدك.","Buy":"شراء","Exclude_time_cannot_be_for_more_than_5_years_":"وقت الإقصاء لا يمكن أن يكون لأكثر من 5 سنوات.","Next":"التالي","Friday":"الجمعة","Your_settings_have_been_updated_successfully_":"تم تحديث إعداداتك بنجاح.","Your_password_cannot_be_the_same_as_your_email":"كلمة السر لا يمكن أن تكون نفس البريد الإلكتروني الخاص بك","Please_select_a_valid_date":"يرجى اختيار تاريخ صحيح","Walkthrough_Guide":"الدليل المفصل","Shanghai_Index":"مؤشر شنغهاي","points":"نقاط","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"لتوثيق حسابك، يرجى إرسال ما يلي عبر البريد الإلكتروني إلى [_1]","Contract_Expiry":"انتهاء العقد","December":"ديسمبر","Quality_Assurance":"ضمان الجودة","Primary":"ابتدائي","XAG/GBP":"فضة/جني استرليني","Saudi_Arabia_Index":"مؤشر السعودية","Try_adding_more_numbers_":"حاول إضافة مزيد من الأرقام.","Password_is_weak":"كلمة المرور ضعيفة","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"أنت حاليا قمت بتسجيل الدخول الى حساب أموالك الافتراضية ([_2]).","Higher/Lower":"أعلى/أسفل","Stake":"الحصة","GBP/MXN":"الجنيه الاسترليني/بيزو مكسيكي","Amount_per_point":"القيمة لكل نقطة","Date_and_Time":"التاريخ والوقت","USD/SEK":"دولار أمريكي/كرونة سويدية","Total_Profit/Loss":"إجمالي الربح/الخسارة","Sorry,_an_error_occurred_while_processing_your_request_":"عفواً، حدث خطأ أثناء معالجة طلبك.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"يمثل الحد الأقصى لمقدار النقد الذي تستطيع أن تحتفظ به فى حسابك.  إذا تم الوصول للحد الأقصى سيُطلب منك أن تسحب الأموال.","Jun":"يونيو","Confirm":"تأكيد","Back":"للخلف","Balance":"رصيد","Statement":"كشف الحساب","ends_between":"ينتهي بين","Japanese_Smart_Index":"مؤشر الياباني الذكي(Japanese Smart Index )","Select_your_trade_type":"اختر نوع تداولك","asian_down":"هبوط آسيوي","Exit_Spot_Time":"وقت سعر الخروج","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"لا نستطيع بث الأسعار بث مباشر في الوقت الحالي. لتتمتع بخدمة البث المباشر للأسعار جرب إعادة تحميل الصفحة، إذا حدث هذا الأمر بعد عدة محاولات جرب متصفح آخر","Low_barrier":"حاجز منخفض","Commodities_trading_experience":"خبرة تداول السلع","Forex":"الفوركس","Minor_Pairs":"الأزواج الثانوية","Spreads":"السبريد (الفروق)","Contract_ID":"معرف العقد","Only_[_1]_are_allowed_":"يسمح فقط بـ [_1].","Virtual_Account":"حساب افتراضي","USD/NOK":"دولار أمريكي/كرونة نرويجية","Our_site_does_not_charge_any_transfer_fees_":"موقعنا لا تفرض أي رسوم نقل.","Daily_Reset_Indices":"إعادة تعيين المؤشرات اليومية","Deposit":"إيداع","French_Stocks":"بورصات الفرنسية","Please_input_a_valid_date":"رجاء إدخال تاريخ صالح","years":"أعوام","Sunday":"الأحد","Explanation":"شرح","USD/PLN":"دولار/زلوتي بولندا","Please_wait_<br_/>Your_request_is_being_processed_":"يرجى الانتظار.<br />يتم معالجة طلبك.","Irish_Index":"مؤشر أيرلندي","AUD/NZD":"أسترالي/دولار نيوزيلاندي","6_months_to_1_year":"6 أشهر إلى سنة واحدة","Belgian_Index":"مؤشر بلجيكي","Palladium/USD":"بالاديوم/دولار","Remaining_Time":"الوقت المتبقي","Your_transaction_reference_number_is_[_1]":"الرقم المرجعي لمعاملتك هو [_1]","January":"يناير","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"تنسيق: yyyy-mm-dd (غير مطلوب لحسابات الأموال الافتراضية)","Maximum_number_of_open_positions":"الحد الأقصى لعدد المعاملات المفتوحة","Start_Time":"وقت البدء","Exit_Level":"مستوى الخروج","AUD/SEK":"أسترالي/كرونة سويدية","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":" تم إضافة [_1] [_2] لحساب أموالك الإفتراضي [_3]","Please_submit_a_valid_[_1]_":"برجاء تقديم [_1] صالح.","Session_duration_limit_cannot_be_more_than_6_weeks_":"الحد الأقصى لمدة الدورة لا يمكن أن يتجاوز 6 أسابيع.","Ends_In/Out":"ينتهي بين/خارج","XPD/AUD":"بالاديوم/دولار استرالي","Indices":"مؤشرات","EUR/NZD":"يورو/دولار نيوزيلاندي","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"سيتم بيع العقد بسعر السوق السائد عندما تتلقى خوادمنا الطلب. قد يختلف هذا السعر عن السعر المشار إليه.","Maximum_aggregate_payouts_on_open_positions":"الحد الأقصى لإجمالي عوائد المعاملات المفتوحة","UK_Index":"مؤشر المملكة المتحدة","Credit/Debit":"ائتمان/خصم","End_Time":"وقت النهاية","There_was_a_problem_accessing_the_server_":"حدثت مشكلة في التواصل مع الخادم.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"الرجاء التحقق من البريد الإلكتروني الخاص بك لاسترداد الرمز المميزالمطلوب إلى إعادة تعيين كلمة المرور الخاصة بك.","year":"عام","German_Index":"مؤشر ألماني","Brazilian_Index":"مؤشر برازيلى","Finance":"المالية","EUR/CHF":"يورو/فرنك سويسري","Graphic_Designers":"مصممو جرافيك","Administrator":"المسؤول","November":"نوفمبر","South_African_Index":"مؤشر جنوب أفريقيا","Contract":"عقد","Keep_track_of_your_authorised_applications_":"تتبع التطبيقات المعتمدة الخاصة بك.","Please_enter_a_valid_amount_":"رجاء إدخال مبلغ صالح.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"رجاء إدخال تاريخ بعد الآن بستة أشهر على الأقل.","Zoom":"ارتفاع حاد فى الأسعار","Your_changes_have_been_updated_":"تم تحديث التغييرات الخاصة بك.","Ms":"آنسة","May":"مايو","Profit":"أرباح","Exclude_time_must_be_after_today_":"يجب أن يكون وقت الاستبعاد بعد اليوم.","Rise/Fall":"الصعود/الهبوط","Total_Cost":"التكلفة الإجمالية","Touch/No_Touch":"الوصول/عدم الوصول","Hang_Seng_China":"هانغ سنغ الصين (Hang Seng China )","Invalid_date_of_birth_":"تاريخ الميلاد غير صحيح.","Sell_at_market":"قم بالبيع فى السوق","Maximum_daily_turnover":"الحد الأقصى لحجم التداول اليومي","3-5_years":"3 - 5 سنوات","Commbank_(Australia)":"Commbank (استراليا)","Last_Digit_Stats":"احصائيات الرقم الأخير","Permissions":"أذونات","Compliance_Executive":"موظف امتثال تنفيذي","Settles":"يستقر","Stocks_trading_experience":"خبرة تداول الأسهم","Item":"بند","Month":"شهر","Successful":"ناجح","Unlock_Cashier":"فتح الصراف","Middle_East":"الشرق الأوسط","Pension":"معاش","Proofreader":"مصحّح","Low_barrier_offset":"تحديد حاجز منخفض","USD/INR":"دولار أمريكي/الروبية الهندية","AUD/CAD":"أسترالي/كندي","GBP/USD":"الجنيه الاسترليني/الدولار"};
texts_json['ZH_CN'] = {"QBE_INSURANCE_GROUP_LIMITED":"昆士兰保险集团股份有限公司","eBay_Inc_":"电子海湾公司","Accounts_And_Payments_Executive":"账户与支付执行员","Prices":"价格","Stop_Loss_Level":"止损价位","Please_select":"请选择","This_contract_won":"此合约获利","MasterCard_Inc_":"万事达公司","Oil/EUR":"原油/欧元","Spot":"现价","US_Index":"美国指数","ASML_Holding":"阿斯麦公司","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"您从 [_3] 转账 [_1][_2] 到 [_4] 的请求已成功处理。","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"过去 [_3] 天里您已累计提取 [_1] [_2] 的等值。","AGL_Energy_Limited":"AGL能源公司","Payout":"赔付","Nike_Inc_":"耐克公司","EUR/CAD":"欧元/加元","Bouygues_heavy_construction":"布依格建筑","McDonald's_Corporation":"麦当劳公司","Unilever_plc":"联合利华公司","Period":"周期","Marks_&_Spencer_Group_plc":"玛莎百货集团","stays_between":"位于区间之内","WESFARMERS_LIMITED":"澳大利亚西农集团","NZD/JPY":"纽元/日元","Verification_Token":"验证令牌","Deposit_of":"存款","odd":"奇数","Pfizer_Inc_":"辉瑞公司","Wednesday":"星期三","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"表示任一既定交易日您可以买入的最大合约数量。","Dubai_Index":"迪拜指数","month":"月份","Fitbit_Inc_":"Fitbit公司","XPD/GBP":"钯价盎司/英镑","SolarCity_Corporation":"阳光城太阳能公司","JD_com_Inc_":"京东商城电子商务有限公司","Cisco_Systems_Inc_":"思科系统公司","Minimum_of_[_1]_characters_required_":"需至少[_1] 个字符。","In/Out":"“范围之内/之外”","Industry_of_Employment":"职业领域","Human_Resource_Executive":"人力资源执行","AXA":"法国安盛集团","Opens":"开盘","Exit_Spot":"退出现价","Potential_Payout":"可能的赔付额","Bull_Market_Index":"牛市指数","GBP/NZD":"英镑/新西兰元","Points":"点","Belgacom":"移动比利时","ITC_Ltd":"国际贸易中心有限公司","USD/JPY":"美元/日元","Gold/AUD":"黄金/澳元","Vinci":"法国万喜集团","touches":"触及","Secondary":"次要","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"您的取款限额为 [_1] [_2] (或其他货币的等值 ）。","Roche_Holding_AG":"罗氏制药公司","GoPro_Inc_":"GoPro公司","AUD/CHF":"澳元/瑞士法郎","Legrand_electrical_components_&_equipm":"罗格朗电器设备有限公司","Marketing_Executives":"市场执行","No_Live_price_update":"无实时价格更新","Please_select_a_payment_agent":"请选择支付代理","YY_Inc_":"欢聚时代公司","Real_Account":"真实账户","Coca-cola_Amatil_Limited":"可口可乐阿马提尔有限公司","Europe/Africa":"欧洲/非洲","3M_Company":"3M公司","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"水电煤账单或银行月结单扫描件（日期不得超过3个月）。","VISA_Inc_":"威士卡公司","USD/CNY":"美元/人民币","Ok":"确定","Spanish_Index":"西班牙指数","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"可使用额外密码来限制对收银台的访问。","USD/IDR":"美元/印度尼西亚卢比","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"您的账户已经得到完全验证，且您的取款限额已经取消。","Swedish_Index":"瑞典指数","GBP_Index":"英镑指数","Shenzhen_300_Index":"深圳300指数","Binary_options_or_other_financial_derivatives_trading_experience":"二元期权或其他金融衍生品交易经验","Aurizon_Holdings_Limited":"Aurizon控股公司","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"您的密码已成功重置。请用新密码登录您的账户。","Less_than_$100,000":"少于$100,000","Jul":"七月","Upcoming_Events":"未来事件","minimum_available_duration":"最短可用期限","AUD/DKK":"澳元/丹麦克朗","Gold/EUR":"黄金/欧元","USD/CAD":"美元/加元","Now":"现在","Construction":"建筑","Vallourec_SA":"瓦卢瑞克钢管公司","EUR/MXN":"欧元/墨西哥比索","Norwegian_Index":"挪威指数","EUR/PLN":"欧元/波兰兹罗提","Citigroup_Inc_":"花旗集团","Korean_Index":"韩国指数","Deutsche_Telekom_AG":"德国电信公司","Number_of_ticks":"跳动点数目","asian_up":"亚洲上涨","ArcelorMittal_steel":"安赛乐米塔尔钢铁公司","Volkswagen_AG":"大众集团","Entry_Level":"进场价位","GBP/AUD":"英镑/澳元","Asians":"亚洲期权","September":"九月","Save_as_PDF":"另存为PDF","Tesco_plc":"乐购公司","Contract_Confirmation":"合约确认","numbers":"号码","Toyota_Motor_Corporation":"丰田汽车公司","View_your_statement":"查看您的账单","CBS_Corporation":"哥伦比亚广播公司","Merck_&_Co__Inc_":"默克集团","XAG/AUD":"银价盎司/澳元","Moet_Hennessy_Louis_Vuitton":"酩悦·轩尼诗-路易·威登集团","TPG_Telecom_Limited":"TPG电讯有限公司","Delete":"删除","Sonic_Healthcare_Limited":"索尼克保健有限公司","Profit/Loss_(points)":"利润/亏损（点）","spread_down":"价差下跌","Electronic_Arts_Inc_":"美国艺电公司","GBP/KRW":"英镑/韩元","AUD_Index":"澳元指数","Continuous_Indices":"连续指数","Quality_Assurance_Engineer":"质量保证工程师","AUD/SGD":"澳元/新加坡元","Sohu_com_Inc_":"搜狐网络有限责任公司","Information_Technology":"信息技术","Digits":"数字期权","Spirax-Sarco_Engineering_plc":"斯派莎克工程公司","UCB":"比利时联合化工集团","AstraZeneca_plc":"阿斯利康公司","Quantitative_Developer":"量化开发员","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"目前不接受来自该国居民的账户。","Browser":"浏览器","China_Mobile_Limited":"中国移动有限公司","GBP/TRY":"英镑/土耳其里拉","Australian_Index":"澳大利亚指数","NZD/USD":"新西兰元/美元","Login_ID":"登录 ID","0-5_transactions_in_the_past_12_months":"过去12个月内0-5次交易","Start_time":"开始时间","Rio_Tinto_plc":"力拓","UBS_AG":"瑞银集团","Americas":"美洲","Japanese_Index":"日本指数","Salaried_Employee":"受薪雇员","Peugeot_S_A_":"标致股份有限公司","Deutsche_Bank_AG":"德意志银行","The_Boeing_Company":"波音公司","There_was_some_invalid_character_in_an_input_field_":"某字段的输入字符无效。","SUNCORP_GROUP_LIMITED":"新确集团有限公司","matches":"符合","Long":"长仓","USD/BRL":"美元/巴西雷亚尔","CAD/CHF":"加元/瑞士法郎","is_required__Current_spread":"必须。当前价差","AUD/SAR":"澳元/沙特阿拉伯里亚尔","Less_than_$25,000":"少于$25,000","Mr":"先生","Volatility_25_Index":"波动率25指数","1-2_years":"1-2 年","XAG/EUR":"银价盎司/欧元","Vivendi":"法国威望迪集团","March":"三月","GBP/SEK":"英镑/瑞典克朗","Yandex_N_V_":"俄罗斯搜索引擎公司Yandex N.V.","(Bejing/CST_-8_hours)":"（北京/CST -8 小时）","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1]已经更新了[_2]。通过点击OK键，您确认已经阅读并接受更新的[_2]条款和条件。","hyphen":"连字符","Smart_FX":"智能外汇","AUD/INR":"澳元/印度卢比","GBP/NOK":"英镑/挪威克朗","Invalid_amount,_maximum_is":"无效金额，最大金额是","US_Smart_Index":"美国智能指数","XPT/GBP":"铂价盎司/英镑","Week_of":"周","Entry_Spot":"入市现价","You_should_enter_between_[_1]_characters_":"您最多只能输入 [_1]  个字符。","Nov":"十一月","Ref_":"参考","spread_up":"价差上涨","Orange":"法国电信集团","BNP_Paribas":"法国巴黎银行","Contract_is_not_started_yet":"合约还未开始","QUALCOMM":"高通公司","Indicative":"指示性","Accor_S_A_":"雅高酒店","Facebook_Inc_":"Facebook","Dutch_Index":"荷兰指数","EUR/BRL":"欧元/巴西雷亚尔","Volatility_100_Index":"波动率100指数","Metals":"金属","EUR/INR":"欧元/印度卢比","We":"星期三","EUR/HKD":"欧元/港币","Please_enter_a_number_between_0_and_[_1]":"请输入0和[_1]之间的数字","AUD/ILS":"澳元/以色列新谢克尔","Quantitative_Analyst":"量化分析员","Sun_Pharma":"太阳制药","Qantas_Airways_Limited":"澳洲航空公司","Level_of_Education":"教育水平","New_token_created_":"已创建新口令牌。","even":"偶数","Starbucks_Corporation":"星巴克公司","Authorise_your_account_":"授权您的账户。","Potash_Corp_of_Saskatchewan_Inc_":"加拿大钾肥公司","Education":"教育","Contract_Sold":"售出合约","Gaming_Account":"博彩账户","EUR/TRY":"欧元/土耳其里拉","July":"七月","June":"六月","Vertex_Pharmaceuticals_Incorporated":"福泰制药公司","Aviva_plc":"英杰华集团","Infosys_Ltd":"印孚瑟斯有限公司","Thursday":"星期四","EUR/AUD":"欧元/澳元","Limit":"限额","Smart_Indices":"智能指数","Your_details_have_been_updated_":"您的个人信息已成功更新。","GDF_Suez":"苏伊士环能集团","Over_$1,000,000":"大于$1,000,000","Financial_Assessment":"金融评估","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"您的[_1] 账户不可用。如有任何问题，请联系[_2]。","Password_is_very_strong":"密码安全级别非常高","USD_Index":"美元指数","Morgan_Stanley":"摩根士丹利公司","ANZ_Banking_Group_Ltd":"澳新银行集团有限公司","USD/MXN":"美元/墨西哥比索","TripAdvisor_Inc_":"猫途鹰公司","HDFC_Bank_Ltd":"印度HDFC银行","GBP/DKK":"英镑/丹麦克朗","HSBC_Holdings_plc":"汇丰控股公司（HSBC Holding Plc）","Twitter_Inc_":"推特公司","password":"密码","Stop-type":"停止类型","AUD/JPY":"澳元/日元","GBP/IDR":"英镑/印度尼西亚卢比","Bharti_Airtel":"印度巴帝电信","Berkshire_Hathaway_Inc_":"伯克希尔哈撒韦公司","Commodities_trading_frequency":"大宗商品交易频率","Transfer_to":"转给","Price":"价格","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"因此，您当前可即时提取的最大金额（要求您的帐户有足够资金）为 [_1] [_2]。","TELSTRA_CORPORATION_LIMITED":"Telstra澳电讯公司","New_Oriental_Edu_&_Tech_Group_Inc_":"新东方教育科技集团","ticks":"跳动点","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"当您点选“Ok”后，您将被禁止在此网站交易，直到选定期限结束为止。","Teva_Pharmaceutical_Industries_Limited":"梯瓦制药工业有限公司","Questions":"问题","and":"以及","Apr":"四月","Danone":"达能集团","months":"月份","Potential_Profit":"潜在利润","over":"高于","Microsoft":"微软","Reliance_Industries_Ltd":"信实工业有限公司","CHF/JPY":"瑞士法郎/日圆","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"本网站包含的金融交易服务仅适合这样的客户：能够承受全部投入资金亏损的风险，了解购买金融合约的风险并具有相关经验。金融合约交易有很高的风险。如果购买的合约到期时一文不值，您将损失全部投资，包括合约费用。","Random":"随机","Sale_Date":"卖出日期","Nocturnes":"Nocturne指数","Exercise_period":"练习期间","February":"二月","Prudential_plc":"保诚集团","AB_Inbev":"安海斯-布希英博","Exclude_time_cannot_be_less_than_6_months_":"禁止时间不能少于6个月。","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"您的 [_1] 天取款限额目前为 [_2] [_3] （或其他货币的等值）。","EUR/ILS":"欧元/以色列新谢克尔","Copywriter":"文案","Incyte_Corpoartion":"因塞特医疗公司","Compass_Group_plc":"金巴斯集团","Your_current_balance_is":"您当前的余额为","Univar_Inc_":"尤尼威尔公司","Singapore_Index":"新加坡指数","Duration":"期限","This_contract_lost":"此合约亏损","Metro_AG":"麦德龙集团","Autohome_Inc_":"汽车之家有限公司","AUD/CNY":"澳元/人民币","Indices_trading_frequency":"指数交易频率","American_Airlines_Group_Inc_":"美国航空公司","Other_financial_instruments_trading_frequency":"其他金融工具交易频率","AUD/USD":"澳元/美元","Password_is_strong":"密码安全级别高","EUR_Index":"欧元指数","Stop_Profit_Level":"止盈价位","Try_adding_more_letters_":"试添加更多字母。","Egypt_Index":"埃及指数","Tata_Motors":"塔塔汽车公司","Net_profit":"净收益","Status":"统计","Santos_LimitedStar_Stock":"桑托斯股票","Verification_code_format_incorrect_":"验证码格式不正确。","There_was_a_problem_accessing_the_server_during_purchase_":"买入时服务器访问发生问题。","JP_Morgan_Chase_&_Co_":"摩根大通公司","Pernod_Ricard":"法国保乐力加集团","Adjust_trade_parameters":"调整交易参数","Dutch_Stocks":"荷兰股票","Over_$500,001":"大于$500,001","Th":"星期四","Oct":"十月","GOOGLE_INC__A_DL":"谷歌公司","United_Continental_Holdings_Inc_":"联合大陆控股公司","Even/Odd":"偶/奇","Barrier_offset":"障碍位移","EUR/JPY":"欧元/日元","BTC/USD":"比特币/美元","Micron_Technology_Inc_":"美光科技有限公司","This_feature_is_not_relevant_to_virtual-money_accounts_":"此功能不适用于虚拟资金账户。","Gold/USD":"黄金/美元","Password_should_have_lower_and_uppercase_letters_with_numbers_":"密码须包含大小写字母与数字。","Step":"步骤","Next_Day":"第二天","EUR/SAR":"欧元/沙特阿拉伯里亚尔","BHP_Billiton_Ltd":"必和必拓公司","Applications":"应用程序","Save_as_CSV":"另存为CSV","GBP/PLN":"英镑/波兰兹罗提","Internal_Auditor":"内部审计员","Loss":"亏损","Mo":"星期一","Vodafone":"沃达丰集团","Other":"其它","Health":"健康","Dutch_Smart_Index":"荷兰智能指数","AUD/KRW":"澳元/韩元","Tick":"跳动点","Applied_Materials_Inc_":"应用材料公司","American_Express_Company":"美国运通公司","letters":"信件","under":"低于","BMW":"宝马集团","ORIGIN_ENERGY_LIMITED":"起源能源公司","Silver/USD":"白银/美元","m":"月","Tesla_Motors_Inc_":"特斯拉汽车公司","E_I_du_Pont_de_Nemours_&_company":"杜邦公司","Groupon_Inc_":"高朋团购股份有限公司","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"显示 [_2] 最新 [_1] 跳点的最后统计数字","Energy":"能源","MACQUARIE_GROUP_LIMITED":"麦格理集团有限公司","Over_3_years":"3年以上","From":"来自","does_not_touch":"未触及","hour":"小时","Credit_Agricole":"法国农业信贷银行","Time_Warner_Inc_":"时代华纳公司","View":"查看","Wells_Fargo_&_Company":"富国银行","EUR/NOK":"欧元/挪威克朗","Sorry,_an_error_occurred_while_processing_your_account_":"对不起，您的账户处理发生错误。","British_American_Tobacco":"英美烟草","An_error_occured_":"发生错误。","Sandisk_Corporation":"闪迪公司","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"因此您当前的即时最高取款额（要求您的账户有充足资金）为[_1] [_2]（或其他等值货币）。","Yahoo!_Inc_":"雅虎公司","Russian_10_Index":"俄罗斯10指数","New_Password":"新密码","Trading_Limits":"交易限制","German_Smart_Index":"德国智能指数","WOODSIDE_PETROLEUM_LIMITED":"伍德赛德石油公司","Details":"详情","Login_History":"登录历史","Invalid_amount,_minimum_is":"无效金额，最小金额是","Technip_oil_equipment_and_services":"德希尼布石油器材服务公司","minute":"分钟","The_Goldman_Sachs_Group_Inc_":"高盛集团","Please_deposit_before_transfer_to_client_":"给客户转账前请先存款。","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"请按照以下格式填写：3个数字，1个短划线，加上4个数字。","WOOLWORTHS_LIMITED":"澳大利亚伍尔沃斯公司","Password_Reset":"重设密码","Maximum_account_cash_balance":"最大账户现金余额","August":"八月","Renault":"雷诺汽车","EUR/CNY":"欧元/人民币","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"您的账户已经通过验证。您可在此查看您的 [_1] 交易限额","Bombay_Index":"孟买指数","Mirvac_Group_Stapled":"Mirvac集团","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"请确认交易详情以完成转账：","Euro_50_Smart_Index":"欧洲 50 智能指数","GBP/JPY":"英镑/日元","US_Tech_Composite_Index":"美国技术综合指数","Lock_Cashier":"锁定收银台","Sa":"星期六","Anglo_American_plc":"英美资源集团","seconds":"秒","Alibaba_Group_Holding_Limited":"阿里巴巴集团控股有限公司","Matches/Differs":"符合/相差","Bt_Group_plc":"英国电信公司","Select_your_market":"选择市场","apostrophe":"撇号","Canadian_Index":"加拿大指数","Finish":"完成","Gold/GBP":"黄金/英镑","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"密码必须包含至少1 数字、1大写字母和1小写字母。","LinkedIn_Corporation":"领英公司","Roche_Holding_Ag-Genusschein":"罗氏公司","Oil/USD":"原油/美元","GBP/ZAR":"英镑/南非兰特","Up/Down":"涨/跌","Wal-Mart_Stores_Inc_":"沃尔玛百货有限公司","Human_Resources":"人力资源","SAP_SE":"SAP SE应用软件公司","Mrs":"女士","Profit_Table":"利润表","Purchase":"买入","Tourism":"旅游","Shenzhen_Index":"深圳指数","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"根据您的请求，您的收银台已被锁定 - 如需解除锁定，请输入密码。","Invalid_email_address":"无效的电子邮件地址","Capgemini_computer_services":"凯捷电脑服务","Please_enter_an_integer_value":"请输入整数","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"对不起，此功能仅适用虚拟账户。","Caterpillar_Inc_":"卡特彼勒有限公司","Halliburton_Company":"哈里伯顿公司","Investment_Account":"投资账户","GBP/AED":"英镑/阿联酋迪拉姆","USD/SGD":"美元/新加坡元","You_are_not_authorized_for_withdrawal_via_payment_agent_":"您无权通过付款代理取款。","USD/KRW":"美元/韩元","Quantitative_Analysis":"量化分析","Miss":"遗漏","Wall_Street_Smart_Index":"华尔街智能指数","Please_check_your_email_for_the_value_of_this_token":"请检查您的电邮领取此令牌号","EUR/ZAR":"欧元/南非兰特","Forex_trading_experience":"外汇交易经验","Amount":"金额","The_maximum_number_of_tokens_([_1])_has_been_reached_":"已达令牌 ([_1]) 最大限数。","Westpac_Banking_Co_":"西太平洋银行公司","Global_Customer_Service_Representatives":"客服代表","Withdrawal_Limits":"取款限额","Print_chart":"打印图表","Please_try_again_":"请重试。","Las_Vegas_Sands_Corporation":"拉斯維加斯金沙集团","Your_transaction_reference_is":"您的交易参考号是","Diageo_plc":"英国帝亚吉欧公司","Compliance":"法规遵从性","Apple_Inc_":"苹果公司","Glencore_Xstrat":"嘉能可超达","National_Australia_Bank_Ltd":"澳大利亚国民银行有限公司","Philip_Morris_International":"菲利普·莫里斯公司","Save_as_SVG":"另存为SVG","Keurig_Green_Mountain_Inc_":"绿山咖啡公司","You_have_already_withdrawn_[_1]_[_2]_":"您已提取[_1] [_2]。","Profit/Loss":"利润/亏损","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"请在下表中填写登录 ID 以及要转给客户的金额：","Password_does_not_match_":"密码不相符。","Commodities":"大宗商品","MOMO_Inc_":"陌陌科技有限公司","Transfer_to_Login_ID":"转给登录 ID","Thyssenkrupp_SS":"蒂森克虏伯股份公司","Lloyds_Banking_Group_plc":"劳埃德银行集团","Update":"更新","Fr":"星期五","PetroChina_Limited":"中国石油天然气股份有限公司","Volatility_75_Index":"波动率75指数","Air_Liquide":"液化空气集团","goes_outside":"处于区间之外","Chart":"图表","High_Barrier":"高障碍","Qihoo_360_Technology_Company_Limited":"奇虎360科技有限公司","GBP/SAR":"英镑/沙特阿拉伯里亚尔","Date_of_Birth":"出生日期","space":"空间","Portuguese_Smart_Index":"葡萄牙智能指数","EUR/GBP":"欧元/英镑","ASX_Limited":"ASX有限公司","Jumei_International_Holding_Limited":"聚美国际控股有限公司","Saturday":"周六","Never_Used":"从未使用过","Volatility_50_Index":"波动率50指数","USD/HKD":"美元/港币","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"显示您证券组合中未平仓合约的最大总赔付额。如果达到该最大值，那么您在购买更多合约之前需要对现有头寸进行平仓。","EUR/CZK":"欧元/捷克克朗","Description":"说明","Sell":"卖出","Abu_Dhabi_Index":"阿布达比指数","Euro_50_Index":"欧洲 50 指数","October":"十月","Nokia_Corporation":"诺基亚公司","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"您已登录您的 [_1]([_2])真实资金账户。","Rolls-Royce_Holdings_plc":"劳斯莱斯股份有限公司","Terms_&_Conditions":"条款和条件","Only_2_decimal_points_are_allowed_":"只允许 2 个小数位。","Procter_&_Gamble_Co_":"宝洁公司","period":"周期","Password_score_is:_[_1]__Passing_score_is:_20_":"密码积分是： [_1]。通过积分是: 20。","Sony_Corporation":"索尼公司","Standard_Chartered_plc":"渣打银行","Stays_In/Goes_Out":"“保持在范围之内/超出范围之外”","Note":"附注","Under_Armour_Inc_":"安德玛公司","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"表示您的投资组合中未平仓合约的最大数量。您投资组合中的每一行都算作是一个未平仓头寸。一旦达到该最大值，您在开设新头寸之前需要先结束一个现有头寸。","Italian_30_Index":"意大利30指数","Password_is_not_strong_enough_":"密码安全度不够。","Asset":"资产","Duerr_AG":"杜尔集团","Swiss_Smart_Index":"瑞士智能指数","Airbus_Group":"空中客车集团","0-1_year":"0-1 年","Unilever":"联合利华公司","AUD/HKD":"澳元/港币","Contract_Information":"合约信息","EUR/USD":"欧元/美元","EUR/RUB":"欧元/俄国卢布","Translator":"翻译","Hong_Kong_Index":"香港指数","STMicroelectronics_semiconductors":"意法半导体","Sorry,_account_opening_is_unavailable_":"对不起，不可开立账户。","Maruti_Suzuki":"玛鲁蒂铃木公司","Anti-Fraud_Officer":"反欺诈主任","Barrier":"障碍","Current_Level":"当前价位","Password_is_moderate":"密码安全级别中等","Failed_to_reset_password__[_1],_please_retry_":"无法重设密码。[_1]，请重试。","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"您的客户将收到电子邮件通知，告知其转账交易已处理。","Low_Barrier":"低障碍","Previous_Day":"前一天","NZDCHF":"纽元/瑞士法郎","Senior_Perl_Developer":"高级 (Perl) 程序员","IP_Address":"IP 地址","Tu":"星期二","Senior_Front-End_Developer":"高级前端程序员","Sale_Price":"卖出价格","AUD/IDR":"澳元/印度尼西亚卢比","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"请按与现货价格差额的形式输入障碍水平。如果您输入 +0.005 ，那么您将买入障碍水平比入市现价高 0.005 的合约。入市现价为收到您订单之后的下一个价格","GBP/CNY":"英镑/人民币","Social_Media_Executive":"社交媒体执行","Short":"短仓","Please_confirm_the_trade_on_your_statement_before_proceeding_":"继续执行之前，请在您的声明上确认此项交易。","Reset_Password":"重置密码","Token":"令牌","Year":"年","Hewlett-Packard_Company":"惠普科技股份有限公司","Other_financial_instruments_trading_experience":"其他金融工具交易体验","Forex_trading_frequency":"外汇交易频率","Purchase_Time":"买入时间","GPT_Group_Stapled":"GPT集团","Day":"天","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"显示您名字和出生日期的护照、驾照（临时或永久）或身份证的扫描件。","Illumina_Inc_":"Illumina公司","Old_password_is_wrong_":"旧密码不正确。","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"您从 [_3] 账户提取 [_1] [_2] 到支付代理 [_4]账户的请求已成功处理。","Fortescue_Metals_Group":"福蒂斯丘金属集团","Orica_Limited":"澳瑞凯公司","AT&T":"AT&T公司","DevOps_Manager":"DevOps 经理 / 团队领导","Trading_and_Withdrawal_Limits":"交易和取款限额","SABMiller_plc":"米勒啤酒集团","FERRARI_N_V_COM":"法拉利公司","High_barrier_offset":"高障碍位移","CSL_Ltd":"CSL有限公司","ICICI_Bank_Ltd":"印度工业信贷投资银行","Aug":"八月","Amcor_Ltd":"安姆科公司","Are_you_sure_that_you_want_to_permanently_delete_token":"确定要永久删除令牌吗","Open":"开盘","KBC_Groep":"KBC集团","EUR/KRW":"欧元/韩元","Siemens_Aktiengesellschaft":"德国西门子总部","ends_outside":"区间之外结束","You_did_not_change_anything_":"您没作任何更改。","Dialog_Semiconductor_plc":"戴乐格半导体公司","Russian_Regular_Index":"俄罗斯普通指数","Over/Under":"大于/小于","Feb":"二月","The_two_passwords_that_you_entered_do_not_match_":"两次输入的密码不一致。","Failed":"失败","You_have_not_granted_access_to_any_apps_":"您没有访问任何应用程序的权限。","Stop-loss":"止损","This_field_is_required_":"此字段为必填项。","Return":"回报","Marketing":"市场营销","Tertiary":"三级","Carrefour":"家乐福超市","Swiss_Index":"瑞士指数","USD/SAR":"美元/沙特阿拉伯里亚尔","AP_Ordinary":"AP 普通股票指数","Indices_trading_experience":"指数交易经验","Walgreens_Boots_Alliance_Inc_":"沃尔格林博兹联合公司","6-10_transactions_in_the_past_12_months":"过去12个月内6-10次交易","Deutsche_Lufthansa":"德国汉莎航空公司","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"一旦您点击“提交”按钮，资金将从您的账户转至客户的账户。","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"分钟","day":"天","Chevron_Co_":"雪佛兰公司","Internal_Audit":"内部审计","Save_as_JPEG":"另存为JPEG","AUD/CZK":"澳元/捷克克朗","Platinum/USD":"铂金/美元","Michelin":"米其林轮胎","GBP/ILS":"英镑/以色列新谢克尔","Income_Source":"收入来源","hours":"小时","King_Digital_Entertainment_plc":"金数位娱乐公司","Johnson_&_Johnson":"强生","Euro_100_Index":"欧洲100指数","second":"秒","GBP/INR":"英镑/印度卢比","EUR/AED":"欧元/阿联酋迪拉姆","Belgian_Stocks":"比利时股票","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"您已提取 [_1] [_2] 的等值。","Date":"日期","International_Consolidated_Airlines_Group_SA":"国际航空集团","Asia/Oceania":"亚洲/大洋洲","Italian_Index":"意大利指数","Waiting_for_entry_tick_":"正在等待进场跳动点。","TOTAL":"道达尔公司","Crown_Resorts_Limited":"皇冠度假酒店集团","lower":"低于","Confirm_New_Password":"确认新密码","Country_Manager":"区域经理","AbbVie_Inc_":"艾伯维公司","April":"四月","Daimler_AG":"戴姆勒股份公司","ICAG_(British_Airways)":"英国航空公司","VF_Corporation":"威富公司","E_ON_SE":"意昂集团","Select_your_underlying_asset":"选择基础资产","AUDZAR":"澳元兑南非兰特","GBP/SGD":"英镑/新加坡元","Last_Digit_Prediction":"最后数字的预测","Beiersdorf_AG_O_N":"拜尔斯道夫公司","Bayer_AG":"拜耳公司","Commerzbank":"德国商业银行","Delta_Air_Lines_Inc_":"达美航空公司","GBP/CHF":"英镑/瑞士法郎","USD/DKK":"美元/丹麦克朗","Try_adding_more_letters_or_numbers_":"请试添加字母或数字。","Al_Noor_Hospitals_Group_plc":"Al Noor 医院集团","SouFun_Holdings_Limited":"搜房网有限公司","General_Electric_Company":"通用电气公司","US_Tech_100_Index":"美国科技100指数","AUD/AED":"澳元/阿联酋迪拉姆","Sep":"九月","Safran":"赛峰","Centrica_plc":"森特理克公司","USD/AED":"美元/阿联酋迪拉姆","Jakarta_Index":"雅加达指数","Purchase_Price":"买入价格","XPD/EUR":"钯价盎司/欧元","UK_Smart_Index":"英国智能指数","XPT/EUR":"铂价盎司/欧元","days":"天","Never":"从未","Name":"姓名","Save_as_PNG":"另存为PNG","Piraeus_Bank_SA":"比雷埃夫斯银行","New_Zealand_Index":"新西兰指数","Electricite_de_France":"法国电力公司","Palo_Alto_Networks_Inc_":"帕洛阿尔托网络公司","Solvay_chemicals":"索尔维化学有限公司","Major_Pairs":"主要货币对","Su":"星期日","Please_enter_a_number_between_[_1]_":"请输入[_1]之间的数字。","Marketing_Project_Manager":"营销项目经理","GBP/CAD":"英镑/加元","Jump_To":"跳至","loading___":"加载中……","Amazon_Corporation":"亚马逊公司","Accounting":"会计","Sina_Corporation":"新浪公司","French_Index":"法国指数","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"当您点选“Ok”后，您将被禁止在此网站交易，直到选定期限结束为止。","Essilor_International":"依视路","Spot_Time":"现货时间","Cynapsus_Therapeutics":"Cynapsus Therapeutics制药公司","Heineken":"喜力","BP_plc":"英国石油公司","EUR/SGD":"欧元/新加坡元","AUD/PLN":"澳元/波兰兹罗提","Closes":"收盘","To":"到","Lend_Lease_Group_Stapled":"联盛集团","Istanbul_Index":"伊斯坦堡指数","Reference_ID":"参考编号","Imperial_Tobacco_Group_plc":"帝国烟草集团","AUD/NOK":"澳元/挪威克朗","Administrative_Executive":"行政管理执行员","Tuesday":"星期二","Sorry,_this_feature_is_not_available_":"对不起，此功能不可用。","Select_market":"选择市场","High_barrier":"高障碍","GBP/HKD":"英镑/港币","Closed":"收盘","You_must_accept_the_terms_and_conditions_to_open_an_account_":"您必须接受条款和条件才能开户。","USDZAR":"美元兑南非兰特","Mar":"三月","Allianz_SE":"安联SE","CAD/JPY":"加元/日元","Dec":"十二月","Gemalto_cyber_security":"金雅拓网络安全公司","US_S&P_100":"美国标普100指数","Novartis_AG":"诺华公司","General_Motors_Company":"通用汽车公司","Portuguese_Index":"葡萄牙指数","higher":"高于","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"将[_1] [_2]虚拟资金存入您的账户[_3]","Alstom_industrial_machinery":"阿尔斯通工业机械","Jan":"一月","Monday":"星期一","Royal_Dutch_Shell":"荷兰皇家壳牌公司","differs":"相差","USD/CZK":"美元/捷克克朗","Current":"当前","Predict_the_direction<br_/>and_purchase":"预测价格走向<br />并购入","Societe_Generale":"法国兴业银行","Oil/AUD":"原油/澳元","Self-Employed":"个体经营","AIRBUS_GROUP_SE":"空中客车集团","GBP/BRL":"英镑/巴西里尔","Estimated_Net_Worth":"估计净值","Binary_options_or_other_financial_derivatives_trading_frequency":"二元期权或其他金融衍生品交易频率","Virgin_America_Inc_":"维珍美国航空公司","Action":"操作","French_Smart_Index":"法国智能指数","Customer_Support":"客户支持","Ford_Motor_Comapny":"福特汽车公司","Youku_Tudou_Inc_":"优酷土豆股份有限公司","comma":"逗号","minutes":"分钟","USD/CHF":"美元/瑞士法郎","Last_Used":"上一次使用","AUD/MXN":"澳元/墨西哥比索","Oil/GBP":"原油/英镑","Indian_50_Index":"印度50指数","Wall_Street_Index":"华尔街指数","Kuwait_Index":"科威特指数","This_contract_has_LOST":"此合约输了","Gilead_Sciensec_Inc_":"吉利德科学公司","Net_Annual_Income":"年净收入","40_transactions_or_more_in_the_past_12_months":"过去12个月内40次交易或以上","Previous":"之前","Kering":"开云集团","EUR/IDR":"欧元/印度尼西亚卢比","Euro_150_Index":"欧洲150指数","Investments_&_Dividends":"投资与分红","Stocks_trading_frequency":"股票交易频率","Your_withdrawal_limit_is_[_1]_[_2]_":"您的取款限额是 [_1] [_2]。","Failed_to_update_trade_description_":"无法更新交易描述。","USD/RUB":"美元/俄国卢布","Please_enter_a_number_greater_or_equal_to_[_1]_":"请输入大于或等于[_1]的数字。","Bear_Market_Index":"熊市指数","RIO_TINTO_LIMITED":"力拓集团","Barclays_plc":"巴克莱银行","Stocks":"股票","not_available":"不可使用","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"您的国家无可用支付代理设施。","Buy":"买入","PepsiCo_Inc_":"百事公司","Bank_of_America_Corporation":"美国银行公司","Exclude_time_cannot_be_for_more_than_5_years_":"禁止时间不能超过5年。","Next":"下一页","Friday":"星期五","Your_account_has_no_trading_activity_":"您的账户无交易活动。","E-Commerce_China_Dangdang_Inc_":"当当网","EUR/SEK":"欧元/瑞典克朗","Your_trading_statistics_since_[_1]_":"您自 [_1] 至今的交易统计。","Your_settings_have_been_updated_successfully_":"您的设置已成功更新。","Your_password_cannot_be_the_same_as_your_email":"您的密码不可与电子邮件相同","Please_select_a_valid_date":"请选择ั有效日期","Walkthrough_Guide":"攻略指南","National_Grid_plc":"英国国家电网公司","Puma_Biotechnology_Inc_":"彪马生物技术公司","Schneider_Electric":"施耐德电气公司","USD/ILS":"美元/以色列新谢克尔","Shanghai_Index":"上海指数","verification_token":"验证令牌","BG_Group_plc":"英国天然气集团公司","points":"点","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"为验证您的账号，请将以下内容通过电子邮件发送到[_1]","ALUMINA_LIMITED":"氧化铝有限公司","Contract_Expiry":"合约到期日","December":"十二月","Quality_Assurance":"质量保证","Primary":"主要","XAG/GBP":"银价盎司/英镑","NEWS_CORPORATION_":"新闻集团","Revoke_access":"撤销访问权限","Saudi_Arabia_Index":"沙特阿拉伯指数","Try_adding_more_numbers_":"试添加更多数字。","Password_is_weak":"密码安全级别弱","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"您已登录您的虚拟资金账户([_2])。","Higher/Lower":"“高于/低于”","Stake":"投注资金","Ctrip_com_International_Ltd_":"携程旅行网","GlaxoSmithKline_plc":"葛兰素史克公司","GBP/MXN":"英镑/墨西哥比索","Amount_per_point":"每点之金额","Caltex_Australia_Limited":"澳大利亚加德士有限公司","Date_and_Time":"日期和时间","The_Coca-Cola_Company":"可口可乐","USD/SEK":"美元/瑞典克朗","Total_Profit/Loss":"利润/亏损合计","L'Oreal":"欧莱雅集团","Sorry,_an_error_occurred_while_processing_your_request_":"对不起，您的请求处理发生错误。","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"代表您的账户中可持有的最高现金额度。如果达到该最高额度，您将被要求提取资金。","Alpha_Bank_S_A_":"阿尔法银行","NetEase_Inc_":"网易公司","Jun":"六月","Confirm":"确认","Carnival_plc":"嘉年华公司","Back":"返回","Balance":"余额","Statement":"账单","ends_between":"区间之内结束","ServiceNow_Inc_":"ServiceNow Inc.云处理服务供应商","Japanese_Smart_Index":"日本智能指数","Your_account_has_no_Login/Logout_activity_":"您的账户无交易活动。","Select_your_trade_type":"选择交易类型","asian_down":"亚洲下跌","Exit_Spot_Time":"退出现价时间","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"目前，我们不能够串流实时价格。要获得价格的实时串流，请尝试刷新页面，如果多次尝试后此问题依然存在，请换一个浏览器","Pearson_plc":"皮尔森公司","Oracle":"甲骨文公司","Low_barrier":"低障碍","Commodities_trading_experience":"大宗商品交易经验","Forex":"外汇","Minor_Pairs":"次要货币对","Spreads":"价差","Contract_ID":"合约编号","BTC/EUR":"比特币/欧元","Only_[_1]_are_allowed_":"只允许 [_1] 。","Virtual_Account":"虚拟账户","USD/NOK":"美元/挪威克朗","Our_site_does_not_charge_any_transfer_fees_":"我们网站不收取任何转账费用。","Unibail-Rodamco_SE":"尤尼百-洛当科集团","PowerShares_QQQ":"PowerShares纳斯达克100指数ETF","Daily_Reset_Indices":"每日重置指数","Deposit":"存款","French_Stocks":"法国股票","Netflix_Inc_":"网飞公司","Please_input_a_valid_date":"请输入有效日期","years":"年","Sunday":"周日","Explanation":"说明","USD/PLN":"美元/波兰兹罗提","This_contract_has_WON":"此合约赢了","GBP/CZK":"英镑/捷克克朗","Please_wait_<br_/>Your_request_is_being_processed_":"请稍候。<br />您的请求正在处理中。","Irish_Index":"爱尔兰指数","AUD/NZD":"澳元/新西兰元","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"您的[_1]账户不可用。如有任何问题，请联系[_2]。","Volatility_Indices":"波动率指数","Belgian_Index":"比利时指数","Palladium/USD":"钯金/美元","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"您的令牌已过期。请点击<a class=\"pjaxload\" href=\"[_1]\">此处</a>重启验证程序。","Remaining_Time":"剩余时间","Your_transaction_reference_number_is_[_1]":"您的交易参考号是 [_1]","January":"一月","There_was_an_error":"出现错误","Groupe_Bruxelles_Lambert":"蓝博特布鲁塞尔集团","American_International_Group_Inc_":"美国国际集团","The_Home_Depot_Inc_":"家得宝公司","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"格式：年-月-日（虚拟资金账户不需要）","Maximum_number_of_open_positions":"最大未平仓头寸数目","Start_Time":"开始时间","Veolia_Environnement_water":"法国威立雅集团","Manchester_United_plc":"曼联集团","Publicis_media_agencies":"阳狮集团","Exit_Level":"退出价位","AUD/SEK":"澳元/瑞典克朗","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] 已记入您的虚拟资金账户[_3]","Please_submit_a_valid_[_1]_":"请提交有效的 [_1]。","Session_duration_limit_cannot_be_more_than_6_weeks_":"交易期持续时间限制不能大于 6周。","Ends_In/Out":"“范围之内/之外”收盘","XPD/AUD":"钯价盎司/澳元","Workday_Inc_":"工作日公司","Indices":"指数","EUR/NZD":"欧元/新西兰元","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"合约将在我们服务器收到请求时，以当时的市场价格卖出。此价格可能与报价有差异。","Maximum_aggregate_payouts_on_open_positions":"未平仓头寸的最大赔付总额","UK_Index":"英国指数","Credit/Debit":"借方/贷方","End_Time":"结束时间","There_was_a_problem_accessing_the_server_":"服务器访问发生问题。","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"请检查您的电邮领取重设密码所须的令牌号。","year":"年","German_Index":"德国指数","Brazilian_Index":"巴西指数","Finance":"金融","Google_Inc_":"谷歌公司","EUR/CHF":"欧元/瑞士法郎","Graphic_Designers":"平面设计师","Administrator":"管理员","November":"十一月","ExxonMobil":"埃克森美孚公司","South_African_Index":"南非指数","Contract":"合约","Keep_track_of_your_authorised_applications_":"跟踪您的授权应用程序。","Please_enter_a_valid_amount_":"请输入有效金额。","Please_enter_a_date_that_is_at_least_6_months_from_now_":"请输入至少6个月后的日期。","Zoom":"缩放","Your_changes_have_been_updated_":"您的更改已成功更新。","Ms":"女士","May":"五月","Profit":"利润","Exclude_time_must_be_after_today_":"禁止时间必须在今日之后。","Rise/Fall":"上涨/下跌","Vipshop_Holdings_Limited":"唯品会控股有限公司","XPT/AUD":"铂价盎司/澳元","Total_Cost":"成本总计","Tata_Steels":"塔塔钢铁公司","Touch/No_Touch":"触及/未触及","Baidu_Inc_":"百度公司","Hang_Seng_China":"恒生中国指数","Associated_British_foods_plc":"英国联合食品集团","Invalid_date_of_birth_":"出生日期无效。","Sell_at_market":"按市价卖出","Intel":"英特尔公司","Date_(GMT)":"日期 （格林尼治标准时间）","Alcoa_Inc_":"美国铝业公司","Maximum_daily_turnover":"最大日成交量","You_have_sold_this_contract_at_[_1]_[_2]":"您已经以 [_1] [_2] 卖出此合约","Commbank_(Australia)":"联邦银行（澳大利亚）","Royal_Dutch_Shell_plc":"荷兰皇家壳牌公司","Cie_de_Saint-Gobain":"圣戈班公司","Last_Digit_Stats":"最后数字的统计数据","Permissions":"权限","Compliance_Executive":"法律执行员","Settles":"结算","Stocks_trading_experience":"股票交易经验","Item":"项目","Month":"月份","Successful":"成功","Voya_Prime_Rate_Trust_":"荷兰国际最优惠利率信托","SANOFI":"赛诺菲","Unlock_Cashier":"解锁收银台","Middle_East":"中东","USD/TRY":"美元/土耳其里拉","Reckitt_Benckiser_Group_plc":"利洁时集团公司","Pension":"养老金","Proofreader":"校对员","Low_barrier_offset":"低障碍位移","USD/INR":"美元/印度卢比","AUD/CAD":"澳元/加元","GBP/USD":"英镑/美元"};
texts_json['VI'] = {"Accounts_And_Payments_Executive":"Chuyên Viên Kế Toán","Prices":"Giá","Stop_Loss_Level":"Mức Thua lỗ Tới hạn","Please_select":"Vui lòng chọn","This_contract_won":"Hợp đồng này đã thắng","Oil/EUR":"Dầu/Eur","Spot":"Giao ngay","US_Index":"Chỉ số Hoa Kỳ","ASML_Holding":"Tập đoàn ASML Holding","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"Yêu cầu chuyển [_1] [_2] từ [_3] sang [_4] đã được xử lý thành công.","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"Bạn đã rút số tiền tương đương với [_1] [_2] trong tổng số hơn [_3] ngày qua.","Payout":"Tiền thưởng","EUR/CAD":"Cặp đồng tiền EUR/CAD","Unilever_plc":"Tập đoàn Unilever","Period":"Giai đoạn","stays_between":"nằm giữa","NZD/JPY":"Cặp đồng tiền NZD/JPY","Verification_Token":"Mã Token Xác thực","Deposit_of":"Tiền gửi của","odd":"Số lẻ","Pfizer_Inc_":"Tập đoàn Pfizer Inc.","Wednesday":"Thứ Tư","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"Hiển thị số lượng hợp đồng tối đa bạn có thể mua trong ngày giao dịch.","Dubai_Index":"Chỉ số Dubai","month":"tháng","XPD/GBP":"Cặp tiền tệ XPD/GBP","Minimum_of_[_1]_characters_required_":"Tối thiểu [_1] các kí tự cần thiết.","In/Out":"Trong/Ngoài","Industry_of_Employment":"Ngành công nghiệp Tuyển dụng","Human_Resource_Executive":"Chuyên Viên Nhân Sự","AXA":"Tập đoàn AXA","Opens":"Mở","Exit_Spot":"Giá Giao ngay thoát ra","Potential_Payout":"Tiền thưởng Tiềm năng","Bull_Market_Index":"Chỉ số Thị trường Giá lên","GBP/NZD":"Cặp đồng tiền GBP/NZD","Points":"Điểm","Score":"Điểm số","Belgacom":"Tập đoàn viễn thông Belgacom (Vương quốc Bỉ)","ITC_Ltd":"Tập đoàn ITC","USD/JPY":"Cặp đồng tiền USD/JPY","Gold/AUD":"Vàng/AUD","Vinci":"Tập đoàn xây dựng Vinci","touches":"chạm","Secondary":"Thứ cấp","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Giới hạn rút tiền của bạn là [_1] [_2] (hoặc tương đương với đồng tiền khác).","AUD/CHF":"Cặp đồng tiền AUD/CHF","Marketing_Executives":"Chuyên Viên Marketing","No_Live_price_update":"Không cập nhật giá trực tiếp","Please_select_a_payment_agent":"Vui lòng chọn một đại lý thanh toán","Real_Account":"Tài khoản Thực","Europe/Africa":"Châu Âu/châu Phi","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"Bản scan hóa đơn điện nước hoặc bản sao kê ngân hàng (không quá 3 tháng).","USD/CNY":"Cặp đồng tiền USD/CNY","Ok":"OK","Spanish_Index":"Chỉ số Tây Ban Nha","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"Mật khẩu phụ có thể dùng để hạn chế truy cập vào khu thu ngân.","USD/IDR":"Cặp đồng tiền USD/IDR","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"Tài khoản của bạn được xác thực đầy đủ và mức giới hạn rút tiền của bạn đã được nâng lên.","Swedish_Index":"Chỉ số Thụy Điển","GBP_Index":"Chỉ số GBP","Shenzhen_300_Index":"Chỉ số Shenzhen 300","Binary_options_or_other_financial_derivatives_trading_experience":"Kinh nghiệm giao dịch quyền chọn Nhị phân hoặc phái sinh tài chính khác","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"Mật khẩu của bạn đã được thiết lập lại thành công. Vui lòng dùng mật khẩu mới đăng nhập vào tài khoản của bạn.","Less_than_$100,000":"Ít hơn $100,000","Jul":"Tháng Bảy","Upcoming_Events":"Sự kiện sắp diễn ra","minimum_available_duration":"khoảng thời gian có sẵn tối thiểu","AUD/DKK":"Cặp đồng tiền AUD/DKK","Gold/EUR":"Vàng/EUR","USD/CAD":"Cặp đồng tiền USD/CAD","Now":"Bây giờ","Construction":"Xây dựng","EUR/MXN":"Cặp đồng tiền EUR/MXN","Norwegian_Index":"Chỉ số Na Uy","EUR/PLN":"Cặp đồng tiền EUR/PLN","Korean_Index":"Chỉ số Hàn Quốc","Number_of_ticks":"Số điểm","asian_up":"lên kiểu châu Á","Entry_Level":"Mức ban đầu","GBP/AUD":"Cặp đồng tiền GBP/AUD","Asians":"Người châu Á","September":"Tháng Chín","Save_as_PDF":"Lưu theo định dạng PDF","Tesco_plc":"Tập đoàn Tesco","Contract_Confirmation":"Xác nhận Hợp đồng","numbers":"các số","View_your_statement":"Xem báo cáo của bạn","Merck_&_Co__Inc_":"Tập đoàn Merck & Co. Inc.","XAG/AUD":"Cặp tiền tệ XAG/AUD","Moet_Hennessy_Louis_Vuitton":"Công ty Moet Hennessy Louis Vuitton","Delete":"Xóa","Profit/Loss_(points)":"Lợi nhuận/Thua lỗ (điểm)","spread_down":"chênh lệch giảm","GBP/KRW":"Cặp đồng tiền GBP/KRW","AUD_Index":"Chỉ số AUD","Continuous_Indices":"Những chỉ số liên tiếp","Quality_Assurance_Engineer":"Kỹ sư Đảm bảo Chất lượng","AUD/SGD":"Cặp đồng tiền AUD/SGD","Information_Technology":"Công nghệ Thông tin","Digits":"Chữ số","UCB":"Tập đoàn UCB","AstraZeneca_plc":"Tập đoàn AstraZeneca plc","Quantitative_Developer":"Lập Trình viên Định lượng","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"Chúng tôi không nhận tại khoản của người dân tại nước này vào thời điểm này.","Browser":"Duyệt tìm","Australian_Index":"Chỉ số Úc","NZD/USD":"Cặp đồng tiền NZD/USD","Login_ID":"ID Đăng nhập","0-5_transactions_in_the_past_12_months":"0-5 giao dịch trong 12 tháng trước","Start_time":"Thời gian bắt đầu","Rio_Tinto_plc":"Tập đoàn Rio Tinto plc","Americas":"Châu Mỹ","Japanese_Index":"Chỉ số Nhật Bản","Salaried_Employee":"Nhân viên Hưởng lương","Deutsche_Bank_AG":"Ngân hàng Deutsche Bank AG","The_Boeing_Company":"Tập Đoàn Boeing","There_was_some_invalid_character_in_an_input_field_":"Có một vài ký tự không hợp lệ với dữ liệu nhập vào.","matches":"phù hợp","Long":"Dài","USD/BRL":"Cặp đồng tiền USD/BRL","is_required__Current_spread":"là bắt buộc. Giá chênh lệch hiện tại","AUD/SAR":"Cặp đồng tiền AUD/SAR","Less_than_$25,000":"Ít hơn $25,000","Mr":"Ngài","Volatility_25_Index":"Chỉ số Biến động 25","1-2_years":"1-2 năm","XAG/EUR":"Cặp tiền tệ XAG/EUR","Vivendi":"Tập đoàn viễn thông Vivendi","March":"Tháng Ba","GBP/SEK":"Cặp đồng tiền GBP/SEK","(Bejing/CST_-8_hours)":"(Bắc Kinh/CST -8 tiếng)","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1] vừa cập nhật [_2]. Bằng cách nhấn vào OK, bạn xác nhận rằng bạn đã đọc và chấp nhận bản cập nhật [_2].","hyphen":"dấu nối","Smart_FX":"Thị trường ngoại hối Thông minh","AUD/INR":"Cặp đồng tiền AUD/INR","GBP/NOK":"Cặp đồng tiền GBP/NOK","Invalid_amount,_maximum_is":"Số tiền không hợp lệ, tối đa là","US_Smart_Index":"Chỉ số thông minh Mỹ","XPT/GBP":"Cặp tiền tệ XPT/GBP","{JAPAN_ONLY}Knowledge_Test_Result":"{CHỈ DÀNH CHO THỊ TRƯỜNG NHẬT BẢN}Kết quả Bài Kiểm tra Kiến thức","Week_of":"Tuần của","Entry_Spot":"Giá khởi điểm","You_should_enter_between_[_1]_characters_":"Bạn nên nhập vào trong khoảng [_1] ký tự.","Nov":"Tháng Mười một","Ref_":"Tham khảo.","spread_up":"chênh lệch lên","Orange":"Cam","BNP_Paribas":"Ngân hàng BNP Paribas","Contract_is_not_started_yet":"Hợp đồng chưa được bắt đầu","Indicative":"Chỉ thị","Dutch_Index":"Chỉ số Hà Lan","EUR/BRL":"Cặp đồng tiền EUR/BRL","Volatility_100_Index":"Chỉ số Biến động 100","Metals":"Kim loại","EUR/INR":"Cặp đồng tiền EUR/INR","We":"Chúng tôi","EUR/HKD":"Cặp đồng tiền EUR/HKD","Please_enter_a_number_between_0_and_[_1]":"Vui lòng nhập một số giữa 0 và [_1]","Quantitative_Analyst":"Phân Tích Định Lượng","Level_of_Education":"Trình độ Học vấn","New_token_created_":"Token mới đã được tạo.","even":"đồng đều","Authorise_your_account_":"Quản lý tài khoản của bạn.","Education":"Giáo dục","Contract_Sold":"Hợp đồng đã được bán","Gaming_Account":"Tài khoản Cá cược","July":"Tháng Bảy","June":"Tháng Sáu","Infosys_Ltd":"Tập đoàn Infosys Ltd (Ấn Độ)","Thursday":"Thứ Năm","EUR/AUD":"Cặp đồng tiền EUR/AUD","Limit":"Giới hạn","Smart_Indices":"Chỉ số Thông minh","Your_details_have_been_updated_":"Thông tin chi tiết của bạn đã được cập nhật.","GDF_Suez":"Tập đoàn GDF Suez","Over_$1,000,000":"Trên $1,000,000","Financial_Assessment":"Đánh giá Tài chính","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"Tài khoản [_1] của bạn không có sẵn. Nếu bạn có bất cứ câu hỏi nào, vui lòng liên hệ với [_2].","Password_is_very_strong":"Mật khẩu rất mạnh","USD_Index":"Chỉ số đô la Mỹ","ANZ_Banking_Group_Ltd":"Tập đoàn tài chính ANZ","USD/MXN":"Cặp đồng tiền USD/MXN","HDFC_Bank_Ltd":"Ngân hàng HDFC","GBP/DKK":"Cặp đồng tiền GBP/DKK","HSBC_Holdings_plc":"Tập đoàn HSBC Holdings","password":"mật khẩu","Stop-type":"Loại - Tới hạn","AUD/JPY":"Tỷ giá giữa đồng Đô la Úc và đồng Yên Nhật","GBP/IDR":"Cặp đồng tiền GBP/IDR","Commodities_trading_frequency":"Tần suất giao dịch Hàng hóa","Transfer_to":"Chuyển tới","Price":"Giá","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"Vì vậy khoản tiền rút tối đa hiện giờ của bạn (nói tới tài khoản đang có tiền được rút) là [_1] [_2].","ticks":"giây","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Khi bạn nhấp vào \"OK\" bạn sẽ bị loại bỏ khỏi giao dịch trên trang web tới ngày được chọn.","IBM":"Tập đoàn IBM","Questions":"Câu hỏi","and":"và","Apr":"Tháng 4","Danone":"Công ty sữa Danone","months":"tháng","Potential_Profit":"Lợi nhuận Tiềm năng","over":"Vượt quá","Reliance_Industries_Ltd":"Công ty Reliance Industries","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"Các dịch vụ kinh doanh tài chính có trên trang web này chỉ thích hợp cho những khách hàng có khả năng chịu mất tất cả số tiền họ đầu tư và những người hiểu và có kinh nghiệm về các rủi ro liên quan trong việc mua lại các hợp đồng tài chính. Các giao dịch hợp đồng tài chính mang một mức độ rủi ro cao. Nếu hợp đồng được mua hết hạn trở nên vô giá trị, bạn sẽ bị mất tổng đầu tư của bạn, bao gồm phí bảo hiểm hợp đồng.","Random":"Ngẫu nhiên","Sale_Date":"Ngày Bán hàng","Nocturnes":"Dạ khúc","Exercise_period":"Thời hạn thực tập","February":"Tháng Hai","AB_Inbev":"Tập đoàn AB Inbev","Exclude_time_cannot_be_less_than_6_months_":"Thời gian loại trừ không thể ít hơn 6 tháng.","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"Hạn mức rút tiền ngày [_1] của bạn hiện là [_2] [_3] (hoặc tương đương với đồng tiền khác).","Copywriter":"Biên Soạn Quảng Cáo","Your_current_balance_is":"Số dư hiện tại của bạn là","Singapore_Index":"Chỉ số Singapore","Duration":"Khoảng thời gian","This_contract_lost":"Hợp đồng này đã bị lỗ","AUD/CNY":"Cặp đồng tiền AUD/CNY","Indices_trading_frequency":"Tần suất giao dịch Chỉ số","Other_financial_instruments_trading_frequency":"Tần suất giao dịch các công cụ tài chính khác","AUD/USD":"Cặp đồng tiền AUD/USD","Password_is_strong":"Mật khẩu đủ mạnh","EUR_Index":"Chỉ số EUR","Stop_Profit_Level":"Mức Lợi nhuận Tới hạn","Try_adding_more_letters_":"Hãy thử nhập thêm các chữ cái.","Egypt_Index":"Chỉ số Ai Cập","Net_profit":"Lợi nhuận thuần","Status":"Tình trạng","Verification_code_format_incorrect_":"Định dạng của mã xác thực không chính xác.","There_was_a_problem_accessing_the_server_during_purchase_":"Có lỗi trung cập vào máy chủ khi mua.","JP_Morgan_Chase_&_Co_":"Tập đoàn tài chính JP Morgan Chase & Co.","Pernod_Ricard":"Tập đoàn Pernod Ricard","Adjust_trade_parameters":"Điều giới hạn giao dịch","Dutch_Stocks":"Chứng khoán Hà Lan","Over_$500,001":"Trên $500,001","Oct":"Tháng Mười","Even/Odd":"Hòa vốn/ Số dư","Barrier_offset":"Bù đắp Rào cản","EUR/JPY":"Cặp đồng tiền EUR/JPY","This_feature_is_not_relevant_to_virtual-money_accounts_":"Đặc điểm này không liên quan tới tài khoản tiền ảo.","Gold/USD":"Vàng/ đô la Mỹ","Password_should_have_lower_and_uppercase_letters_with_numbers_":"Mật khẩu nên bao gồm cả chữ hoa, chữ thường và con số.","Step":"Bước","Next_Day":"Ngày tiếp theo","EUR/SAR":"Cặp đồng tiền EUR/SAR","BHP_Billiton_Ltd":"Công ty BHP Billiton","Applications":"Các ứng dụng","Save_as_CSV":"Lưu dưới dạng CSV","GBP/PLN":"Cặp đồng tiền GBP/PLN","Internal_Auditor":"Kiểm Toán viên Nội bộ","Loss":"Thất thoát","Vodafone":"Tập đoàn viễn thông Vodafone","Other":"Khác","Health":"Sức khỏe","Dutch_Smart_Index":"Chỉ số thông minh Hà Lan","AUD/KRW":"Cặp đồng tiền AUD/KRW","Tick":"Giây","letters":"các ký tự","under":"ở dưới","Silver/USD":"Cặp Bạc/ đô la Mỹ","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"Chữ số cuối cùng cho điểm [_1] gần nhất trên [_2]","Energy":"Năng lượng","Over_3_years":"Trên 3 năm","From":"Từ","does_not_touch":"không chạm","hour":"giờ","Credit_Agricole":"Ngân hàng Credit Agricole","View":"Xem","Wells_Fargo_&_Company":"Tập đoàn Wells Fargo & Company","EUR/NOK":"Cặp đồng tiền EUR/NOK","Sorry,_an_error_occurred_while_processing_your_account_":"Xin lỗi, Lỗi xảy ra trong khi đang xử lý tài khoản của bạn.","British_American_Tobacco":"Thuốc lá British American Tobacco","An_error_occured_":"Đã có lỗi xảy ra.","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"Vì vậy khoản tiền rút tối đa hiện giờ của bạn (tài khoản đang có tiền được rút) là [_1] [_2] (hoặc đồng tiền khác có giá trị tương đương).","Russian_10_Index":"Chỉ Số Nga 10","New_Password":"Mật khẩu mới","Trading_Limits":"Giới hạn Giao dịch","German_Smart_Index":"Chỉ số thông minh Đức","Details":"Chi tiết","Login_History":"Lịch sử Đăng nhập","Invalid_amount,_minimum_is":"Số tiền không hợp lệ, tối thiểu là","minute":"phút","Please_deposit_before_transfer_to_client_":"Vui lòng nạp tiền vào trước khi chuyển tới khách hàng.","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"Vui lòng tuân theo cấu trúc 3 số, dấu gạch ngang, tiếp theo là 4 số.","Password_Reset":"Thiết lập lại Mật khẩu","Maximum_account_cash_balance":"Số dư tài khoản tiền mặt tối đa","August":"Tháng 8","Renault":"Tập đoàn ô tô Renault","EUR/CNY":"Cặp đồng tiền EUR/CNY","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"Tài khoản của bạn hoàn toàn được xác thực. Bạn có thể xem hạn mức giao dịch [_1]của bạn ở đây","Bombay_Index":"Chỉ số Bombay","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"Xin vui lòng xác nhận chi tiết giao dịch để hoàn thành việc chuyển tiền:","Euro_50_Smart_Index":"Chỉ số thông minh 50 Euro","GBP/JPY":"Cặp đồng tiền GBP/JPY","US_Tech_Composite_Index":"Chỉ số US Tech Composite","Lock_Cashier":"Khóa quầy Thu ngân","Anglo_American_plc":"Công ty mỏ Anglo American plc","seconds":"giây","Matches/Differs":"Phù hợp/Khác","Select_your_market":"Chọn thị trường của bạn","apostrophe":"dấu móc lửng (')","Canadian_Index":"Chỉ số Canada","Finish":"Kết thúc","Gold/GBP":"Vàng/GBP","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"Mật khẩu phải chứa ít nhất 1 chữ số, 1 chữ cái viết hoa và 1 chữ cái viết thường.","LinkedIn_Corporation":"Tập Đoàn LinkedIn","Oil/USD":"Dầu/ đô la Mỹ","GBP/ZAR":"Cặp đồng tiền GBP/ZAR","False":"Sai","Up/Down":"Lên/Xuống","Wal-Mart_Stores_Inc_":"Tập đoàn bán lẻ đa quốc gia Wal-Mart Stores Inc.","Human_Resources":"Nhân Sự","Mrs":"Bà","Profit_Table":"Bảng Lợi nhuận","Purchase":"Mua","Tourism":"Ghé thăm","Shenzhen_Index":"Chỉ số Shenzhen","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"Thu ngân đã bị khóa theo yêu cầu của bạn - để mở khóa, vui lòng điền mật khẩu.","Invalid_email_address":"Địa chỉ email không hợp lệ","Please_enter_an_integer_value":"Vui lòng nhập giá trị số nguyên","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"Rất tiếc, tính năng này chỉ khả dụng với tài khoản tiền ảo.","Halliburton_Company":"Công Ty Halliburton","Investment_Account":"Tài khoản Đầu tư","GBP/AED":"Cặp đồng tiền GBP/AED","USD/SGD":"Cặp đồng tiền USD/SGD","You_are_not_authorized_for_withdrawal_via_payment_agent_":"Bạn không đượcquyền rút tiền qua đại lý thanh toán.","USD/KRW":"Cặp đồng tiền USD/KRW","Quantitative_Analysis":"Phân Tích Định Lượng","Miss":"Cô","Wall_Street_Smart_Index":"Chỉ số Thông minh phố Wall","Please_check_your_email_for_the_value_of_this_token":"Vui lòng kiểm tra email của bạn để biết giá trị của token này","EUR/ZAR":"Cặp đồng tiên EUR/ZAR","Forex_trading_experience":"Kinh nghiệm giao dịch Thị trường Ngoại hối","Amount":"Số tiền","The_maximum_number_of_tokens_([_1])_has_been_reached_":"Đã đạt đến độ dài tối đa của mã token ([_1]).","Westpac_Banking_Co_":"Tập đoàn tài chính Westpac Banking Co.","Global_Customer_Service_Representatives":"Đại Diện Dịch Vụ Chăm sóc Khách Hàng Toàn cầu","Withdrawal_Limits":"Giới hạn Rút tiền","Print_chart":"In biểu đồ","Please_try_again_":"Vui lòng thử lại.","Your_transaction_reference_is":"Tham chiếu giao dịch của bạn là","Diageo_plc":"Tập đoàn Diageo","Compliance":"Pháp Chế","Glencore_Xstrat":"Tập đoàn Glencore Xstrat","National_Australia_Bank_Ltd":"Ngân hàng quốc gia Australia","Philip_Morris_International":"Tập đoàn quốc tế Philip Morris International","Save_as_SVG":"Lưu theo định dạng SVG","You_have_already_withdrawn_[_1]_[_2]_":"Bạn vừa rút [_1] [_2].","Profit/Loss":"Lợi nhuận/Thua lỗ","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"Vui lòng điền tên Đăng nhập vá Số tiền bạn muốn chuyển cho Khách hàng của mình trong bản mẫu dưới đây:","Password_does_not_match_":"Mật khẩu không đúng.","Commodities":"Hàng hóa","Transfer_to_Login_ID":"Chuyển tới ID đăng nhập","Lloyds_Banking_Group_plc":"Tập đoàn tài chính Lloyds Banking Group plc","Update":"Cập nhật","Fr":"Thứ 6","Volatility_75_Index":"Chỉ số Biến động 75","Air_Liquide":"Công ty khí gas công nghiệp Air Liquide","goes_outside":"đi ra ngoài","Chart":"Biểu đồ","High_Barrier":"Rào cản Cao","GBP/SAR":"Cặp đồng tiền GBP/SAR","Date_of_Birth":"Ngày sinh","Self-employed":"Tự kinh doanh","space":"khoảng cách","Portuguese_Smart_Index":"Chỉ số thông minh Bồ Đào Nha","EUR/GBP":"Cặp đồng tiền EUR/GBP","Saturday":"Thứ Bảy","Never_Used":"Chưa bao giờ Sử dụng","Volatility_50_Index":"Chỉ số Biến động 50","USD/HKD":"Cặp đồng tiền USD/HKD","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"Thể hiện số tiền lãi tối đa trên hợp đồng nổi bật ở trong hồ sơ của bạn. Nếu lượng tối đa đã đạt được, bạn có thể sẽ không cần mua thêm hợp đồng không phải đóng trước vị thế đang tồn tại.","EUR/CZK":"Cặp đồng tiền EUR/CZK","Description":"Mô tả","Sell":"Bán","Abu_Dhabi_Index":"Chỉ số Abu Dhabi","Euro_50_Index":"Chỉ số 50 châu Âu","October":"Tháng Mười","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"Bạn vừa đăng nhập vào tài khoản tiền thực của bạn với [_1] ([_2]).","Terms_&_Conditions":"Điều khoản & Điều kiện","Only_2_decimal_points_are_allowed_":"Chỉ cho phép 2 số thập phân sau dấu phẩy.","Procter_&_Gamble_Co_":"Tập đoàn Procter & Gamble Co.","period":"giai đoạn","Password_score_is:_[_1]__Passing_score_is:_20_":"Độ mạnh của mật khẩu là: [_1]. Điểm vượt qua: 20.","Standard_Chartered_plc":"Ngân hàng Standard Chartered","Stays_In/Goes_Out":"Vẫn ở trong /Đi ra Ngoài","Note":"Chú ý","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"Hãy trình bày số hợp đồng xuất sắc tối đa có trong hồ sơ của bạn. Mỗi một dòng trong hồ sơ là một vị thế mở. Khi đã đạt đến mức tối đa, bạn sẽ không thể mở thêm vị thế mới mà không đóng các vị thế đang có trước.","Italian_30_Index":"Chỉ số 30 Italia","Password_is_not_strong_enough_":"Mật khẩu không đủ mạnh.","Asset":"Tài sản","Swiss_Smart_Index":"Chỉ số thông minh Thụy Sĩ","Airbus_Group":"Tập đoàn Airbus","0-1_year":"0-1 năm","Unilever":"Tập đoàn Unilever","AUD/HKD":"Cặp đồng tiền AUD/HKD","Contract_Information":"Thông tin của Hợp đồng","EUR/USD":"Cặp đồng tiền EUR/USD","Translator":"Phiên Dịch","Hong_Kong_Index":"Chỉ số Hồng Kông","Sorry,_account_opening_is_unavailable_":"Xin lỗi, việc mở tài khoản hiện đang không phục vụ.","Anti-Fraud_Officer":"Chống Gian Lận","Barrier":"Rào cản","Current_Level":"Mức Hiện tại","Password_is_moderate":"Mật khẩu trung bình","Failed_to_reset_password__[_1],_please_retry_":"Thiết lập lại mật khẩu thất bại. [_1], vui lòng thử lại.","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"Khách hàng của bạn sẽ nhận được một email thông báo với anh ấy rằng việc chuyển tiền đã được xử lý.","Low_Barrier":"Rào cản Thấp","Previous_Day":"Ngày trước","Senior_Perl_Developer":"Chuyên Viên Phát Triển Perl","IP_Address":"Địa chỉ IP","Senior_Front-End_Developer":"Lập Trình Viên Front-End có kinh nghiệm","Sale_Price":"Giá Bán hàng","AUD/IDR":"Cặp đồng tiền AUD/IDR","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"Nhập giá giới hạn khác với giá giao ngay. Nếu bạn nhập +0.005, bạn sẽ có thể mua được một hợp đồng với giá giới hạn cao hơn 0.005 so với giá giao ngay được nhập. GIá giao ngay được nhập sẽ là giá tiếp theo sau khi lệnh của bạn được nhận","GBP/CNY":"Cặp đồng tiền GBP/CNY","Social_Media_Executive":"Chuyên Viên Truyền Thông Xã Hội","Short":"Ngắn","Please_confirm_the_trade_on_your_statement_before_proceeding_":"Xin vui lòng xác nhận nội dung giao dịch của bạn trước khi xử lý.","Reset_Password":"Thiết lập lại Mật khẩu","Token":"Mã Token","Year":"Năm","Other_financial_instruments_trading_experience":"Kinh nghiệm giao dịch các công cụ tài chính khác","Forex_trading_frequency":"Tần suất giao dịch Thị trường ngoại hối","Purchase_Time":"Thời gian Mua","Day":"Ngày","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"-Một bản scan hộ chiếu, bằng lái xe (tạm thời hoặc chính thức), hoặc chứng minh nhân dân thể hiện tên và ngày sinh của bạn.","Old_password_is_wrong_":"Mật khẩu cũ không đúng.","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"Yêu cầu rút tiền [_1] [_2] từ tài khoản của bạn [_3] tới [_4] tài khoản Đại lý Thanh toán đã được xử lý thành công.","AT&T":"Tập đoàn viễn thông AT&T","DevOps_Manager":"Quản lý/ Trưởng phòng DevOps","Trading_and_Withdrawal_Limits":"Giới hạn Giao dịch và giới hạn Rút tiền","SABMiller_plc":"Tập đoàn đồ uống SABMiller plc","High_barrier_offset":"Bù đắp rào cản cao","ICICI_Bank_Ltd":"Ngân hàng ICICI","Aug":"Tháng 8","Are_you_sure_that_you_want_to_permanently_delete_token":"Bạn có chắc chắn muốn xóa vĩnh viễn token","Open":"Mở","KBC_Groep":"Tập đoàn KBC","EUR/KRW":"Cặp đồng tiền EUR/KRW","ends_outside":"kết thúc bên ngoài","You_did_not_change_anything_":"Bạn không thay đổi bất cứ nội dung nào.","Russian_Regular_Index":"Chỉ số Thông thường Nga","Over/Under":"Trên/Dưới","Feb":"Tháng Hai","The_two_passwords_that_you_entered_do_not_match_":"Hai mật khẩu bạn vừa nhập không khớp với nhau.","Failed":"Thất bại","You_have_not_granted_access_to_any_apps_":"Bạn không được phép truy cập bất kỳ một ứng dụng nào.","Stop-loss":"Thua lỗ -Tới hạn","This_field_is_required_":"Lĩnh vực này được yêu cầu.","Return":"Lợi nhuận","Marketing":"Tiếp Thị","Tertiary":"Bên thứ ba","Carrefour":"Tập đoàn Carrefour","Swiss_Index":"Chỉ số Thụy Sĩ","USD/SAR":"Cặp đồng tiền USD/SAR","AP_Ordinary":"AP thông thường","Indices_trading_experience":"Kinh nghiệm Giao dịch Chỉ số","6-10_transactions_in_the_past_12_months":"6-10 giao dịch trong 12 tháng trước","Deutsche_Lufthansa":"Tập đoàn Deutsche Lufthansa","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"Một khi bạn nhấp chuột vào nút \"Gửi yêu cầu\", tiền sẽ được rút khỏi tài khoản của bạn và được chuyển tới tài khoản của khách hàng của bạn.","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"tối thiểu","True":"Đúng","day":"ngày","Chevron_Co_":"Tập đoàn năng lượng Chevron Co.","Internal_Audit":"Kiểm toán Nội bộ","Save_as_JPEG":"Lưu dưới định dạng JPEG","AUD/CZK":"Cặp đồng tiền AUD/CZK","Platinum/USD":"Cặp Platinum/USD","Income_Source":"Nguồn Thu nhập","hours":"giờ","Johnson_&_Johnson":"Johnson và Johnson","Euro_100_Index":"Chỉ số 100 Euro","second":"giây","GBP/INR":"Cặp đồng tiền GBP/INR","EUR/AED":"Cặp đồng tiền EUR/AED","Belgian_Stocks":"Chứng khoán Bỉ","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"Bạn đã rút số tiền tương đương [_1] [_2].","Date":"Ngày","Asia/Oceania":"Châu Á/châu Đại Dương","Italian_Index":"Chỉ số Ý","Waiting_for_entry_tick_":"Vui lòng đợi cho đến phiên gia nhập.","TOTAL":"Tập đoàn TOTAL","lower":"thấp hơn","Confirm_New_Password":"Xác nhận Mật khẩu mới","Country_Manager":"Giám Đốc Khu Vực","April":"Tháng 4","Daimler_AG":"Tập đoàn ô tô Daimler AG","ICAG_(British_Airways)":"ICAG (Hãng hàng không Anh Quốc)","Select_your_underlying_asset":"Chọn tài sản cơ sở của bạn","AUDZAR":"Cặp đồng tiền AUD/ZAR","GBP/SGD":"Cặp đồng tiền GBP/SGD","Last_Digit_Prediction":"Dự đoán Chữ số Cuối cùng","GBP/CHF":"Cặp đồng tiền GBP/CHF","USD/DKK":"Cặp đồng tiền USD/DKK","Try_adding_more_letters_or_numbers_":"Hãy thử nhập thêm các chữ cái hoặc số.","General_Electric_Company":"Tập đoàn General Electric Company","US_Tech_100_Index":"Chỉ số US Tech 100","AUD/AED":"Cặp đồng tiền AUD/AED","Sep":"Tháng Chín","Safran":"Tập đoàn Safran","USD/AED":"Cặp đồng tiền USD/AED","Jakarta_Index":"Chỉ số Jakarta","Purchase_Price":"Giá Mua","XPD/EUR":"Cặp tiền tệ XPD/EUR","UK_Smart_Index":"Chỉ số thông minh Anh","XPT/EUR":"Cặp tiền tệ XPT/EUR","days":"ngày","Never":"Chưa bao giờ","Name":"Tên","Save_as_PNG":"Lưu theo định dạng PNG","New_Zealand_Index":"Chỉ số New Zealand","Electricite_de_France":"Tập đoàn Electricite de France (Pháp)","Major_Pairs":"Cặp tiền tệ chính","Please_enter_a_number_between_[_1]_":"Vui lòng nhập một số giữa [_1].","Marketing_Project_Manager":"Trưởng Phòng Dự Án Marketing","GBP/CAD":"Cặp đồng tiền GBP/CAD","Jump_To":"Nhảy đến","loading___":"đang tải...","Accounting":"Kế toán","French_Index":"Chỉ số chứng khoán Pháp","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"Khi bạn nhấp vào \"OK\" bạn sẽ bị loại bỏ khỏi giao dịch trên trang web tới ngày được chọn.","Essilor_International":"Tập đoàn quốc tế Essilor","Spot_Time":"Thời điểm làm giá","Heineken":"Nhãn hiệu Heineken","BP_plc":"Công ty đại chúng BP","EUR/SGD":"Cặp đồng tiền EUR/SGD","AUD/PLN":"Cặp đồng tiền AUD/PLN","Closes":"Kết thúc","To":"Để","Istanbul_Index":"Chỉ Số Istanbul","Reference_ID":"Tài khoản tham khảo","AUD/NOK":"Cặp đồng tiền AUD/NOK","Administrative_Executive":"Chuyên Viên Hành Chính","Tuesday":"Thứ Ba","Sorry,_this_feature_is_not_available_":"Xin lỗi, đặc tính này không có.","Select_market":"Chọn thị trường","High_barrier":"Rào cản cao","GBP/HKD":"Cặp đồng tiền GBP/HKD","Closed":"Đã đóng","You_must_accept_the_terms_and_conditions_to_open_an_account_":"Bạn phải chấp nhận các điều khoản và điều kiện để mở tài khoản.","USDZAR":"Cặp đồng tiền USD/ZAR","Mar":"Tháng Ba","Allianz_SE":"Nhà cung cấp dịch vụ tài chính Allianz SE","Dec":"Tháng 12","US_S&P_100":"Chỉ số chứng khoán Hoa Kỳ S&P 100","General_Motors_Company":"Tập đoàn General Motors","Portuguese_Index":"Chỉ số Bồ Đào Nha","higher":"cao hơn","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"Gửi [_1] [_2] tiền ảo vào tài khoản [_3] của bạn","Jan":"Tháng Một","Monday":"Thứ Hai","Royal_Dutch_Shell":"Tập đoàn Shell Hoàng Gia Hà Lan","differs":"Khác","USD/CZK":"Cặp đồng tiền USD/CZK","Current":"Tiền tệ","Predict_the_direction<br_/>and_purchase":"Dự đoán khuynh hướng<br />và trả giá","Societe_Generale":"Hãng Societe Generale","Oil/AUD":"Dầu/AUD","Self-Employed":"Tự kinh doanh","GBP/BRL":"Cặp đồng tiền GBP/BRL","Estimated_Net_Worth":"Giá trị Thực dự kiến","Binary_options_or_other_financial_derivatives_trading_frequency":"Mức độ thường xuyên của giao dịch quyền chọn Nhị phân hoặc các phái sinh tài chính khác","Action":"Hành động","French_Smart_Index":"Chỉ số Thông minh Pháp","Customer_Support":"Hỗ trợ Khách hàng","Ford_Motor_Comapny":"Ford Motor Company","comma":"dấu phẩy","minutes":"phút","USD/CHF":"Cặp đồng tiền USD/CHF","Last_Used":"Lần sử dụng cuối cùng","AUD/MXN":"Cặp đồng tiền AUD/MXN","Oil/GBP":"Dầu/GBP","Indian_50_Index":"Chỉ số Indian 50","Wall_Street_Index":"Chỉ số phố Wall","Kuwait_Index":"Chỉ Số Cô-oét","This_contract_has_LOST":"Hợp đồng này bị THUA LỖ","Net_Annual_Income":"Lợi nhuận Thuần Hàng năm","40_transactions_or_more_in_the_past_12_months":"40 giao dịch hoặc nhiều hơn nữa trong 12 tháng trước","Previous":"Trước","Kering":"Tập đoàn Kering","EUR/IDR":"Cặp đồng tiền EUR/IDR","Euro_150_Index":"Chỉ số 150 Euro","Investments_&_Dividends":"Đầu tư và Cổ tức","Stocks_trading_frequency":"Tần suất giao dịch Chứng khoán","Your_withdrawal_limit_is_[_1]_[_2]_":"Giới hạn rút tiền của bạn là [_1] [_2].","Failed_to_update_trade_description_":"Không thể cập nhật mô tả giao dịch.","Please_enter_a_number_greater_or_equal_to_[_1]_":"Vui lòng nhập một số lớn hơn hoặc bằng [_1].","Bear_Market_Index":"Chỉ số Thị trường Giá giảm","Barclays_plc":"Ngân hàng Barclays plc","Stocks":"Cổ phiếu","not_available":"không có sẵn","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"Các cơ sở đại lý thanh toán hiện không có trong đất nước của bạn.","Buy":"Mua","Exclude_time_cannot_be_for_more_than_5_years_":"Thời gian loại trừ không thể nhiều hơn 5 năm.","Next":"Tiếp theo","Friday":"Thứ Sáu","Your_account_has_no_trading_activity_":"Không có hoạt động giao dịch nào trên tài khoản của bạn.","EUR/SEK":"Cặp đồng tiền EUR/SEK","Your_trading_statistics_since_[_1]_":"Số liệu thống kê giao dịch của bạn kể từ [_1].","Your_settings_have_been_updated_successfully_":"Thiết lập của bạn đã được cập nhật thành công.","Your_password_cannot_be_the_same_as_your_email":"Mật khẩu của bạn không thể giống như mật khẩu email","Please_select_a_valid_date":"Vui lòng chọn một ngày hợp lệ","Walkthrough_Guide":"Hướng dẫn tổng quan","Schneider_Electric":"Tập đoàn năng lượng Schneider Electric","Shanghai_Index":"Chỉ số chứng khoán Thượng Hải","verification_token":"mã token xác minh","BG_Group_plc":"Tập đoàn BG","points":"điểm","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"Để xác thực tài khoản của bạn, vui lòng gửi email những giấy tờ sau tới [_1]","Contract_Expiry":"Hợp đồng đã hết hạn","December":"Tháng 12","Quality_Assurance":"Đảm bảo Chất Lượng","Primary":"Sơ cấp","XAG/GBP":"Cặp tiền tệ XAG/GBP","Revoke_access":"Hủy bỏ truy cập","Saudi_Arabia_Index":"Chỉ số Ả Rập","Try_adding_more_numbers_":"Hãy thử nhập thêm số.","Password_is_weak":"Mật khẩu yếu","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"Bạn vừa đăng nhập vào tài khoản tiền ảo của bạn ([_2]).","Higher/Lower":"Cao hơn/Thấp hơn","Stake":"Đơn vị vốn, cổ phiếu","GlaxoSmithKline_plc":"Tập đoàn dược phẩm GlaxoSmithKline","GBP/MXN":"Cặp đồng tiền GBP/MXN","Amount_per_point":"Số tiền trên mỗi điểm","Date_and_Time":"Ngày và Thời gian","The_Coca-Cola_Company":"Tập đoàn Coca-Cola","USD/SEK":"Cặp đồng tiền USD/SEK","Total_Profit/Loss":"Tổng Lợi nhuận/Thua lỗ","L'Oreal":"Tập đoàn L'Oreal","Sorry,_an_error_occurred_while_processing_your_request_":"Rất tiếc, đã xảy ra lỗi khi đang xử lý yêu cầu của bạn.","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"Hãy trình bày số tiền tối đa mà bạn có thể giữ trong tài khoản. Nếu đã đạt mức tối đa, bạn sẽ được yêu cầu rút tiền.","Jun":"Tháng Sáu","Confirm":"Xác nhận","Back":"Quay lại","Balance":"Số dư tài khoản","Statement":"Tuyên bố","ends_between":"kết thúc giữa","Japanese_Smart_Index":"Chỉ số thông minh Nhật Bản","Your_account_has_no_Login/Logout_activity_":"Không có hoạt động Đăng nhập/Đăng xuất nào trên tài khoản của bạn.","Select_your_trade_type":"Chọn loại giao dịch của bạn","asian_down":"xuống kiểu châu Á","Exit_Spot_Time":"Giá Giao ngay Thoát ra","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"Chúng tôi không thể dò giá trực tiếp tại thời điểm này. Để thấy được dòng giá hãy thử làm mới lại trang web, nếu bạn gặp vấn đề này sau khi làm thì hãy thử một trình duyệt khác","Low_barrier":"Rào cản Thấp","Commodities_trading_experience":"Kinh nghiệm giao dịch Hàng hóa","Forex":"Thị trường ngoại hối","Minor_Pairs":"Cặp tiền tệ thứ yếu","Spreads":"Giá chênh lệch","Contract_ID":"Mã Hợp đồng","Only_[_1]_are_allowed_":"Chỉ có [_1] được cho phép.","Virtual_Account":"Tài khoản Ảo","USD/NOK":"Cặp đồng tiền USD/NOK","Our_site_does_not_charge_any_transfer_fees_":"Trang web của chúng tôi không tính bất kì phí chuyển tiền nào.","Daily_Reset_Indices":"Các chỉ số được Thiết lập lại Hàng ngày","Deposit":"Gửi tiền","French_Stocks":"Chứng khoán Pháp","Please_input_a_valid_date":"Vui lòng nhập ngày hợp lệ","years":"năm","Sunday":"Chủ nhật","Explanation":"Giải thích","USD/PLN":"Cặp đồng tiền USD/PLN","This_contract_has_WON":"Hợp đồng này THẮNG","GBP/CZK":"Cặp đồng tiền GBP/CZK","Please_wait_<br_/>Your_request_is_being_processed_":"Vui lòng chờ. <br />Yêu cầu của bạn đang được xử lý.","Irish_Index":"Chỉ số Ailen","AUD/NZD":"Cặp đồng tiền AUD/NZD","{JAPAN_ONLY}Please_complete_the_following_questions_":"{CHỈ DÀNH CHO THỊ TRƯỜNG NHẬT BẢN}Vui lòng hoàn thành những câu hỏi sau đây.","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"Tài khoản [_1] của bạn không có sẵn. Nếu bạn có bất cứ câu hỏi nào, vui lòng liên hệ với [_2].","Volatility_Indices":"Chỉ số Biến động","Belgian_Index":"Chỉ số Bỉ","Palladium/USD":"Cặp Palladium/USD","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"Mã token của bạn đã hết hiệu lực. Xin vui lòng nhấp chuột vào <a class=\"pjaxload\" href=\"[_1]\">đây</a> để khởi động lại quá trình xác minh.","Remaining_Time":"Thời gian còn lại","Your_transaction_reference_number_is_[_1]":"Số tham khảo giao dịch của bạn là [_1]","January":"Tháng Một","There_was_an_error":"Đã có lỗi xảy ra","Groupe_Bruxelles_Lambert":"Tập đoàn Bruxelles Lambert","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"Định dạng: yyyy-mm-dd (không yêu cầu đối với các tài khoản tiền ảo)","Maximum_number_of_open_positions":"Số tối đa của vị thế mở","Start_Time":"Thời gian bắt đầu","Exit_Level":"Mức giá Thoát ra","AUD/SEK":"Cặp đồng tiền AUD/SEK","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":"[_1] [_2] vừa được cộng thêm vào tài khoản tiền Ảo [_3] của bạn","Please_submit_a_valid_[_1]_":"Vui lòng nhập một tài khoản [_1] hợp lệ.","Session_duration_limit_cannot_be_more_than_6_weeks_":"Giới hạn thời hạn phiên không thể nhiều hơn 6 tuần.","Ends_In/Out":"Kết thúc Trong/Ngoài","XPD/AUD":"Cặp tiền tệ XPD/AUD","Indices":"Chỉ số","EUR/NZD":"Cặp đồng tiền EUR/NZD","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"Hợp đồng sẽ được bán ở giá thị trường hiện hành khi máy chủ nhận được yêu cầu. Giá này có thể khác với giá đã được chỉ định.","Maximum_aggregate_payouts_on_open_positions":"Tập hợp tiền thưởng tối đa trên vị thế mở","UK_Index":"Chỉ số Anh quốc","Credit/Debit":"Tín dụng/Ghi nợ","End_Time":"Thời gian Kết thúc","There_was_a_problem_accessing_the_server_":"Có lỗi khi truy cập máy chủ.","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"Vui lòng kiểm tra email của bạn để tìm lại token được yêu cầu để thiết lập lại mật khẩu của bạn.","year":"năm","German_Index":"Chỉ số chứng khoán Đức","Brazilian_Index":"Chỉ số Brazil","Finance":"Tài chính","EUR/CHF":"Cặp đồng tiền EUR/CHF","Graphic_Designers":"Thiết Kế Đồ Họa","Administrator":"Hành Chính","November":"Tháng Mười một","ExxonMobil":"Tập đoàn ExxonMobil","South_African_Index":"Chỉ số chứng khoán Nam Phi","Contract":"Hợp đồng","Keep_track_of_your_authorised_applications_":"Theo dõi liên tục các ứng dụng được cho phép của bạn.","Please_enter_a_valid_amount_":"Vui lòng nhập số tiền hợp lệ.","Please_enter_a_date_that_is_at_least_6_months_from_now_":"Vui lòng nhập ngày ít nhất là 6 tháng kể từ bây giờ.","Zoom":"Phóng","Your_changes_have_been_updated_":"Những thay đổi của bạn đã được cập nhật.","Ms":"Cô","May":"Tháng Năm","Profit":"Lợi nhuận","Exclude_time_must_be_after_today_":"Thời gian loại trừ cần phải sau ngày hôm nay.","Rise/Fall":"Tăng/Giảm","XPT/AUD":"Cặp tiền tệ XPT/AUD","Total_Cost":"Tổng Chi phí","Touch/No_Touch":"Chạm/Không Chạm","Hang_Seng_China":"Hằng Sinh, Trung Quốc","Invalid_date_of_birth_":"Ngày sinh không hợp lệ.","Sell_at_market":"Bán tại thị trường","Date_(GMT)":"Ngày (GMT)","Maximum_daily_turnover":"Thu nhập hàng ngày tối đa","You_have_sold_this_contract_at_[_1]_[_2]":"Bạn đã bán hợp đồng này với mức [_1] [_2]","Commbank_(Australia)":"Commbank (Úc)","Royal_Dutch_Shell_plc":"Tập đoàn Shell Hoàng Gia Hà Lan","Cie_de_Saint-Gobain":"Tập đoàn Cie de Saint-Gobain","Last_Digit_Stats":"Dữ liệu Chữ số Cuối cùng","Permissions":"Quyền hạn","Compliance_Executive":"Chuyên Viên Pháp Chế","Settles":"Quyết toán","Stocks_trading_experience":"Kinh nghiệm giao dịch Chứng khoán","Item":"Hạng mục","Month":"Tháng","Successful":"Thành công","SANOFI":"Tập đoàn chăm sóc sức khỏe SANOFI","Unlock_Cashier":"Mở khóa Thu ngân","Middle_East":"Trung Đông","Reckitt_Benckiser_Group_plc":"Tập đoàn Reckitt Benckiser Group plc","Pension":"Tiền phụ cấp","Proofreader":"Kiểm tra và sửa nội dung","Low_barrier_offset":"Tấm chắn hàng rào thấp","ING":"Tập đoàn tài chính ING","USD/INR":"Cặp đồng tiền USD/INR","AUD/CAD":"Cặp đồng tiền AUD/CAD","GBP/USD":"Cặp đồng tiền GBP/USD"};
texts_json['ZH_TW'] = {"QBE_INSURANCE_GROUP_LIMITED":"昆士蘭聯保保險有限公司","eBay_Inc_":"電子灣拍賣網站","Accounts_And_Payments_Executive":"帳戶和付款執行員","Prices":"價格","Stop_Loss_Level":"止損價位","Please_select":"請選擇","This_contract_won":"此合約獲利","MasterCard_Inc_":"萬事達卡有限公司","Oil/EUR":"原油/歐元","Spot":"現價","US_Index":"美國指數","ASML_Holding":"阿斯麥公司","Your_request_to_transfer_[_1]_[_2]_from_[_3]_to_[_4]_has_been_successfully_processed_":"您從[_3] 轉帳[_1][_2] 到[_4] 的要求已成功處理。","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_in_aggregate_over_the_last_[_3]_days_":"過去 [_3] 天裡您已累計提取 [_1] [_2] 的等值。","AGL_Energy_Limited":"澳洲主要電力及瓦斯公司","Payout":"賠付","Nike_Inc_":"耐吉公司","EUR/CAD":"歐元/加元","Bouygues_heavy_construction":"布伊格集團","McDonald's_Corporation":"麥當勞公司","Unilever_plc":"聯合利華公司","Period":"週期","ADIDAS_AG":"阿迪達斯","Marks_&_Spencer_Group_plc":"馬莎百貨集團公司","stays_between":"位於區間之內","WESFARMERS_LIMITED":"西農有限公司","NZD/JPY":"紐元/日圓","Verification_Token":"驗證權杖","Deposit_of":"存款","odd":"奇數","Pfizer_Inc_":"輝瑞大藥廠","Wednesday":"星期三","Represents_the_maximum_volume_of_contracts_that_you_may_purchase_in_any_given_trading_day_":"表示任一指定交易日您可以買入的最大合約數量。","Dubai_Index":"迪拜指數","month":"月份","Fitbit_Inc_":"Fitbit 公司","XPD/GBP":"鈀金價盎司/英鎊","SolarCity_Corporation":"太陽城公司","JD_com_Inc_":"京東商城公司","Cisco_Systems_Inc_":"思科系統公司","Minimum_of_[_1]_characters_required_":"需至少[_1] 個字元。","In/Out":"「範圍之內/之外」","Industry_of_Employment":"職業領域","Human_Resource_Executive":"人力資源專員","AXA":"法國安盛集團","Opens":"開盤","Exit_Spot":"退出現價","Potential_Payout":"可能的賠付額","Bull_Market_Index":"牛市指數","GBP/NZD":"英鎊/紐西蘭元","Points":"點","Belgacom":"比利時電信","ITC_Ltd":"國際貿易中心有限公司","USD/JPY":"美元/日圓","Gold/AUD":"黃金/澳元","Vinci":"法國萬喜集團","touches":"觸及","Secondary":"次要","Your_withdrawal_limit_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"您的取款限額為 [_1] [_2]（或其他貨幣的等值）。","Roche_Holding_AG":"羅氏大藥廠","GoPro_Inc_":"GoPro 公司","AUD/CHF":"澳元/瑞士法郎","Legrand_electrical_components_&_equipm":"羅格朗電器配件公司","Marketing_Executives":"市場行銷專員","No_Live_price_update":"無即時價格更新","Please_select_a_payment_agent":"請選擇付款代理","YY_Inc_":"歡聚時代科技有限公司","Real_Account":"真實帳戶","Coca-cola_Amatil_Limited":"可口可樂阿馬提爾有限公司","Europe/Africa":"歐洲/非洲","3M_Company":"3M 公司","-_A_scanned_copy_of_a_utility_bill_or_bank_statement_(no_more_than_3_months_old)_":"水電煤帳單或銀行月結單掃描件（日期不得超過3個月）。","VISA_Inc_":"威士公司","USD/CNY":"美元/人民幣","Ok":"確定","Spanish_Index":"西班牙指數","An_additional_password_can_be_used_to_restrict_access_to_the_cashier_":"可使用額外密碼來限制對收銀台的存取。","USD/IDR":"美元/印度尼西亞盧比","Your_account_is_fully_authenticated_and_your_withdrawal_limits_have_been_lifted_":"您的帳戶已經得到完全驗證，且您的取款限額已經取消。","Swedish_Index":"瑞典指數","GBP_Index":"英鎊指數","Shenzhen_300_Index":"深圳300指數","Binary_options_or_other_financial_derivatives_trading_experience":"二元期權或其他金融衍生品交易經驗","Aurizon_Holdings_Limited":"Aurizon 控股有限公司","Your_password_has_been_successfully_reset__Please_log_into_your_account_using_your_new_password_":"您的密碼已成功重設。請用新密碼登入您的帳戶。","Less_than_$100,000":"少於$100,000","Jul":"七月","Upcoming_Events":"未來事件","minimum_available_duration":"最短可用期限","AUD/DKK":"澳元/丹麥克朗","Gold/EUR":"黃金/歐元","USD/CAD":"美元/加元","Now":"現在","Construction":"建構","Vallourec_SA":"瓦盧瑞克鋼管公司","EUR/MXN":"歐元/墨西哥披索","Norwegian_Index":"挪威指數","EUR/PLN":"歐元/波蘭茲羅提","Citigroup_Inc_":"花旗集團","Korean_Index":"韓國指數","Deutsche_Telekom_AG":"德國電信公司","Number_of_ticks":"跳動點數目","asian_up":"亞洲上漲","ArcelorMittal_steel":"阿塞洛米塔爾集團","Volkswagen_AG":"福斯汽車","Entry_Level":"進場價位","GBP/AUD":"英鎊/澳元","Asians":"亞洲期權","September":"九月","Save_as_PDF":"以PDF格式儲存","Tesco_plc":"特易購公司","Contract_Confirmation":"合約確認","numbers":"號碼","Toyota_Motor_Corporation":"豐田汽車公司","View_your_statement":"檢視您的帳單","CBS_Corporation":"哥倫比亞廣播公司","Merck_&_Co__Inc_":"默克集團","XAG/AUD":"銀價盎司/澳元","Moet_Hennessy_Louis_Vuitton":"酩悅·軒尼詩-路易·威登集團","TPG_Telecom_Limited":"TPG 電信有限公司","Delete":"刪除","Sonic_Healthcare_Limited":"索尼克保健品有限公司","Profit/Loss_(points)":"利潤/虧損(點)","spread_down":"價差下跌","Electronic_Arts_Inc_":"美商藝電","GBP/KRW":"英鎊/韓元","AUD_Index":"澳元指數","Continuous_Indices":"連續指數","Quality_Assurance_Engineer":"品質保證工程師","AUD/SGD":"澳元/新加坡元","Sohu_com_Inc_":"搜狐公司","Information_Technology":"資訊技術","Digits":"數字期權","Spirax-Sarco_Engineering_plc":"斯派瑞莎克工程公司","UCB":"比利時聯合化學集團","AstraZeneca_plc":"阿斯利康藥廠","Quantitative_Developer":"量化開發員","We_are_not_accepting_accounts_from_residents_of_this_country_at_the_present_time_":"目前不接受來自該國居民的帳戶。","Browser":"瀏覽","China_Mobile_Limited":"中國移動有限公司","GBP/TRY":"英鎊/土耳其里拉","Australian_Index":"澳大利亞指數","NZD/USD":"美元/丹麥克朗","Login_ID":"登入 ID","0-5_transactions_in_the_past_12_months":"過去12個月內0-5次交易","Start_time":"開始時間","Rio_Tinto_plc":"力拓集團","UBS_AG":"瑞銀集團","Americas":"美洲","Japanese_Index":"日本指數","Salaried_Employee":"支薪員工","Peugeot_S_A_":"標緻汽車","Deutsche_Bank_AG":"德意志銀行","The_Boeing_Company":"波音公司","There_was_some_invalid_character_in_an_input_field_":"某字欄的輸入字元無效。","SUNCORP_GROUP_LIMITED":"澳洲Suncorp集團","matches":"符合","Long":"長倉","USD/BRL":"美元/巴西雷亞爾","CAD/CHF":"加元/瑞士法郎","is_required__Current_spread":"為必要。目前價差","AUD/SAR":"澳元/沙特阿拉伯里亞爾","Less_than_$25,000":"少於$25,000","Mr":"先生","Volatility_25_Index":"波動率25指數","1-2_years":"1-2 年","XAG/EUR":"銀價盎司/歐元","Vivendi":"法國斐凡迪集團","March":"三月","GBP/SEK":"英鎊/瑞典克朗","Yandex_N_V_":"俄羅斯搜索引擎公司Yandex N.V.","(Bejing/CST_-8_hours)":"（北京/CST -8 小時）","[_1]_has_updated_its_[_2]__By_clicking_OK,_you_confirm_that_you_have_read_and_accepted_the_updated_[_2]_":"[_1]已經更新了其[_2]條款和條件。通過點選OK按鈕，您確定已經閱讀和接受此更新[_2]條款和條件。","hyphen":"連字號","Smart_FX":"智慧外匯","AUD/INR":"澳元/印度盧比","GBP/NOK":"英鎊/挪威克朗","Invalid_amount,_maximum_is":"無效金額，最大是","US_Smart_Index":"美國智慧指數","XPT/GBP":"白金價盎司/英鎊","Week_of":"週","Entry_Spot":"入市現價","You_should_enter_between_[_1]_characters_":"您最多只能輸入 [_1] 個字元。","Nov":"十一月","Ref_":"參考","spread_up":"價差上漲","Orange":"法國電信集團","BNP_Paribas":"法國巴黎銀行","Contract_is_not_started_yet":"合約尚未開始","QUALCOMM":"美國高通公司","Indicative":"指示性","Accor_S_A_":"雅高酒店","Facebook_Inc_":"臉書","Dutch_Index":"荷蘭指數","EUR/BRL":"歐元/巴西雷亞爾","Volatility_100_Index":"波動率100指數","Metals":"金屬","EUR/INR":"歐元/印度盧比","We":"星期三","EUR/HKD":"歐元/港幣","Please_enter_a_number_between_0_and_[_1]":"請輸入0和[_1]之間的數字","AUD/ILS":"澳元/以色列新錫克爾","Quantitative_Analyst":"量化分析員","Sun_Pharma":"太陽藥業","Qantas_Airways_Limited":"澳洲航空公司","Level_of_Education":"教育水平","New_token_created_":"已建立新權杖。","even":"偶數","Starbucks_Corporation":"星巴克公司","Authorise_your_account_":"入您的帳戶。","Potash_Corp_of_Saskatchewan_Inc_":"薩斯喀徹溫鉀肥公司","Education":"教育","Contract_Sold":"售出合約","Gaming_Account":"博彩帳戶","EUR/TRY":"歐元/土耳其里拉","July":"七月","June":"六月","Vertex_Pharmaceuticals_Incorporated":"福泰製藥公司","Aviva_plc":"英傑華集團","Infosys_Ltd":"印孚瑟斯有限公司","Thursday":"星期四","EUR/AUD":"歐元/澳元","Limit":"限額","Smart_Indices":"智慧指數","Your_details_have_been_updated_":"您的個人資訊已成功更新。","GDF_Suez":"法國天然氣蘇伊士集團","Over_$1,000,000":"大於$1,000,000","Financial_Assessment":"金融評估","Your_[_1]_account_is_unavailable__For_any_questions_please_contact_[_2]_":"您的[_1]帳戶不可用。如有任何問題，請聯繫[_2]。","Password_is_very_strong":"密碼安全度很高","USD_Index":"美元指數","Morgan_Stanley":"摩根士丹利","ANZ_Banking_Group_Ltd":"澳新銀行集團有限公司","USD/MXN":"美元/墨西哥披索","TripAdvisor_Inc_":"貓途鷹公司","HDFC_Bank_Ltd":"印度HDFC銀行","GBP/DKK":"英鎊/丹麥克朗","HSBC_Holdings_plc":"滙豐控股有限公司","Twitter_Inc_":"推特公司","password":"密碼","Stop-type":"停止類型","AUD/JPY":"澳元/日圓","GBP/IDR":"英鎊/印度尼西亞盧比","Bharti_Airtel":"巴帝電信","Berkshire_Hathaway_Inc_":"伯克希爾哈撒韋公司","Commodities_trading_frequency":"商品交易頻率","Transfer_to":"轉給","Price":"價格","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_":"因此您目前的即時最高取款額（要求您的帳戶有充足資金）為[_1] [_2]。","TELSTRA_CORPORATION_LIMITED":"澳大利亞電信公司","New_Oriental_Edu_&_Tech_Group_Inc_":"新東方教育科技集團","ticks":"跳動點","When_you_click_'Ok'_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"當您點選「Ok」後，您將被禁止在此網站交易，直到選定期限結束為止。","Teva_Pharmaceutical_Industries_Limited":"梯瓦製藥工業有限公司","Questions":"問題","and":"以及","Apr":"四月","Danone":"達能集團","months":"月份","Potential_Profit":"潛在利潤","over":"高於","Microsoft":"微軟公司","Reliance_Industries_Ltd":"信實工業有限公司","CHF/JPY":"瑞士法郎/日圓","The_financial_trading_services_contained_within_this_site_are_only_suitable_for_customers_who_are_able_to_bear_the_loss_of_all_the_money_they_invest_and_who_understand_and_have_experience_of_the_risk_involved_in_the_acquistion_of_financial_contracts__Transactions_in_financial_contracts_carry_a_high_degree_of_risk__If_purchased_contracts_expire_worthless,_you_will_suffer_a_total_loss_of_your_investment,_which_consists_of_the_contract_premium_":"本網站所涵蓋的金融交易服務僅適合這樣的客戶：能夠承受全部投入資金虧損的風險，了解購買金融合約所蘊含的風險並擁有相關的風險經歷。金融合約交易涉及很大的風險。如果所購買的合約到期時一文不值，您的投資將完全損失，其中還包括合約費用。","Random":"隨機","Sale_Date":"賣出日期","Nocturnes":"Nocturne指數","Exercise_period":"練習期間","February":"二月","Prudential_plc":"英國保誠保險集團","AB_Inbev":"安海斯-布希英博","Exclude_time_cannot_be_less_than_6_months_":"禁止時間不能少於6個月。","Your_[_1]_day_withdrawal_limit_is_currently_[_2]_[_3]_(or_equivalent_in_other_currency)_":"您的 [_1] 天取款限額目前為 [_2] [_3]（或其他貨幣的等值）。","EUR/ILS":"歐元/以色列新錫克爾","Copywriter":"文案","Incyte_Corpoartion":"英賽德藥學個股公司","Compass_Group_plc":"康帕斯集團有限公司","Your_current_balance_is":"您目前餘額有","Univar_Inc_":"尤尼威爾公司","Singapore_Index":"新加坡指數","Duration":"期限","This_contract_lost":"此合約虧損","Metro_AG":"麥德龍集團","Autohome_Inc_":"汽車之家","AUD/CNY":"澳元/人民幣","Indices_trading_frequency":"指數交易頻率","American_Airlines_Group_Inc_":"美國航空集團","Other_financial_instruments_trading_frequency":"其他金融工具交易頻率","AUD/USD":"澳元/美元","Password_is_strong":"密碼安全度高","EUR_Index":"歐元指數","Stop_Profit_Level":"止盈價位","Try_adding_more_letters_":"試新增更多字母。","Egypt_Index":"埃及指數","Tata_Motors":"塔塔汽車公司","Net_profit":"淨收益","Status":"狀況","Santos_LimitedStar_Stock":"桑托斯有限公司股票","Verification_code_format_incorrect_":"驗證碼格式不正確。","There_was_a_problem_accessing_the_server_during_purchase_":"買入時伺服器存取出了問題。","JP_Morgan_Chase_&_Co_":"摩根大通公司","Pernod_Ricard":"法國保樂力加集團","Adjust_trade_parameters":"調整交易參數","Dutch_Stocks":"荷蘭股票","Over_$500,001":"大於$500,001","Th":"星期四","Oct":"十月","GOOGLE_INC__A_DL":"谷歌公司","United_Continental_Holdings_Inc_":"聯合大陸控股公司","Even/Odd":"偶/奇","Barrier_offset":"障礙位移","EUR/JPY":"歐元/日圓","BTC/USD":"比特幣/美元","Micron_Technology_Inc_":"美光科技公司","This_feature_is_not_relevant_to_virtual-money_accounts_":"此功能不適用於虛擬資金帳戶。","Gold/USD":"黃金/美元","Password_should_have_lower_and_uppercase_letters_with_numbers_":"密碼須包含大小寫字母與數字。","Step":"步驟","Next_Day":"第二天","EUR/SAR":"歐元/沙特阿拉伯里亞爾","BHP_Billiton_Ltd":"必和必拓公司","Applications":"應用程式","Save_as_CSV":"以CSV格式儲存","GBP/PLN":"英鎊/波蘭茲羅提","Internal_Auditor":"內部審計員","Loss":"虧損","Mo":"星期一","Vodafone":"沃達豐集團","Other":"其它","Health":"健康","Dutch_Smart_Index":"荷蘭智慧指數","AUD/KRW":"澳元/韓元","Tick":"跳動點","Applied_Materials_Inc_":"應用材料公司","American_Express_Company":"美國運通公司","letters":"字母","under":"低於","BMW":"寶馬汽車","ORIGIN_ENERGY_LIMITED":"起源能源公司","Silver/USD":"白銀/美元","m":"月","Tesla_Motors_Inc_":"特斯拉汽車公司","E_I_du_Pont_de_Nemours_&_company":"杜邦公司","Groupon_Inc_":"酷朋公司","Last_digit_stats_for_the_latest_[_1]_ticks_on_[_2]":"顯示 [_2] 最新 [_1] 跳點之最後統計數字","Energy":"能源","MACQUARIE_GROUP_LIMITED":"麥格理集團","Over_3_years":"3年以上","From":"來自","does_not_touch":"未觸及","hour":"小時","Credit_Agricole":"法國農業信貸銀行","Time_Warner_Inc_":"時代華納公司","View":"檢視","Wells_Fargo_&_Company":"富國銀行","EUR/NOK":"歐元/挪威克朗","Sorry,_an_error_occurred_while_processing_your_account_":"對不起，在處理您的帳戶時出錯。","British_American_Tobacco":"英美菸草商務股份有限公司","An_error_occured_":"發生錯誤。","Sandisk_Corporation":"新帝科技公司","Therefore_your_current_immediate_maximum_withdrawal_(subject_to_your_account_having_sufficient_funds)_is_[_1]_[_2]_(or_equivalent_in_other_currency)_":"因此您目前的即時最高取款額（要求您的帳戶有充足資金）為 [_1] [_2]（或其他等值貨幣)。","Yahoo!_Inc_":"雅虎公司","Russian_10_Index":"俄羅斯10指數","New_Password":"新密碼","Trading_Limits":"交易限制","German_Smart_Index":"德國智慧指數","WOODSIDE_PETROLEUM_LIMITED":"伍德賽德石油公司","Details":"詳細資料","Login_History":"登入歷史","Invalid_amount,_minimum_is":"無效金額，最小是","Technip_oil_equipment_and_services":"德希尼布石油器材服務公司","minute":"分鐘","The_Goldman_Sachs_Group_Inc_":"高盛集團","Please_deposit_before_transfer_to_client_":"給客戶轉帳前請先存款。","Please_follow_the_pattern_3_numbers,_a_dash,_followed_by_4_numbers_":"請依照此模式:3個數字，一破折號，接着是4個數字。","WOOLWORTHS_LIMITED":"沃爾沃斯有限公司","Password_Reset":"重設密碼","Maximum_account_cash_balance":"最大帳戶現金餘額","August":"八月","Renault":"雷諾汽車","EUR/CNY":"歐元/人民幣","Your_account_is_fully_authenticated__You_can_view_your_[_1]trading_limits_here":"您的帳戶已經通過驗證。您可在此檢視您的 [_1] 交易限額","Bombay_Index":"孟買指數","Mirvac_Group_Stapled":"Mirvac 集團","Please_confirm_the_transaction_details_in_order_to_complete_the_transfer:":"請確認交易詳細資料以完成轉帳：","Euro_50_Smart_Index":"歐洲 50 智慧指數","GBP/JPY":"英鎊/日圓","US_Tech_Composite_Index":"美國科技綜合指數","Lock_Cashier":"鎖定收銀台","Sa":"星期六","Anglo_American_plc":"英美資源集團","seconds":"秒","Alibaba_Group_Holding_Limited":"阿里巴巴集團","Matches/Differs":"相符/差異","Bt_Group_plc":"英國電信公司","Select_your_market":"選擇您的市場","apostrophe":"單引號","Canadian_Index":"加拿大指數","Finish":"完成","Gold/GBP":"黃金/英鎊","Password_must_contains_at_least_1_digit,_1_uppercase_letter_and_1_lowercase_letter_":"密碼必須包含至少1數字、1大寫字母和1小寫字母。","LinkedIn_Corporation":"英創管理顧問股份有限公司","Roche_Holding_Ag-Genusschein":"羅氏大藥廠","Oil/USD":"原油/美元","GBP/ZAR":"英鎊/南非蘭特","Up/Down":"漲/跌","Wal-Mart_Stores_Inc_":"沃爾瑪百貨有限公司","Human_Resources":"人力資源","Mrs":"夫人","Profit_Table":"利潤表","Purchase":"買入","Tourism":"旅遊","Shenzhen_Index":"深圳指數","Your_cashier_is_locked_as_per_your_request_-_to_unlock_it,_please_enter_the_password_":"根據您的請求，您的收銀台已被鎖定- 如需解除鎖定，請輸入密碼。","Invalid_email_address":"無效的電子郵件地址","Capgemini_computer_services":"凱捷電腦服務公司","Please_enter_an_integer_value":"請輸入整數","Sorry,_this_feature_is_available_to_virtual_accounts_only_":"對不起，此功能僅適用虛擬帳戶。","Caterpillar_Inc_":"開拓重工公司","Halliburton_Company":"哈里伯頓公司","Investment_Account":"投資帳戶","GBP/AED":"英鎊/阿聯酋迪拉姆","USD/SGD":"美元/新加坡元","You_are_not_authorized_for_withdrawal_via_payment_agent_":"您未經授權通過付款代理取款。","USD/KRW":"美元/韓元","Quantitative_Analysis":"量化分析","Miss":"遺漏","Wall_Street_Smart_Index":"華爾街智慧指數","Please_check_your_email_for_the_value_of_this_token":"請檢查您的電郵領取此權杖編號","EUR/ZAR":"歐元/南非蘭特","Forex_trading_experience":"外匯交易經驗","Amount":"金額","The_maximum_number_of_tokens_([_1])_has_been_reached_":"已達權杖 ([_1]) 最大限數。","Westpac_Banking_Co_":"西太平洋銀行公司","Global_Customer_Service_Representatives":"全球客戶服務代表","Withdrawal_Limits":"取款限額","Print_chart":"列印圖表","Please_try_again_":"請重試。","Las_Vegas_Sands_Corporation":"拉斯維加斯金沙集團","Your_transaction_reference_is":"您的交易參考號是","Diageo_plc":"英國帝亞吉歐公司","Compliance":"法律事務","Apple_Inc_":"蘋果公司","Glencore_Xstrat":"嘉能可超達","National_Australia_Bank_Ltd":"澳大利亞國民銀行有限公司","Philip_Morris_International":"菲利普莫里斯股份有限公司","Save_as_SVG":"以SVG格式儲存","Keurig_Green_Mountain_Inc_":"綠山咖啡公司","You_have_already_withdrawn_[_1]_[_2]_":"您已提取 [_1] [_2]。","Profit/Loss":"利潤/虧損","Please_fill_in_the_Login_ID_and_Amount_you_wish_to_transfer_to_your_Client_in_the_form_below:":"請在下表中填寫登入ID 以及您希望轉給客戶的金額：","Password_does_not_match_":"密碼不相符。","Commodities":"商品","MOMO_Inc_":"陌陌科技公司","Transfer_to_Login_ID":"轉給登入 ID","Thyssenkrupp_SS":"蒂森克虜伯集團","Lloyds_Banking_Group_plc":"萊斯銀行集團","Update":"更新","Fr":"星期五","PetroChina_Limited":"中國石油天然氣公司","Volatility_75_Index":"波動率75指數","Air_Liquide":"法國液空集團","goes_outside":"處於區間之外","Chart":"圖表","High_Barrier":"高障礙","Qihoo_360_Technology_Company_Limited":"奇虎360科技公司","GBP/SAR":"英鎊/沙特阿拉伯里亞爾","Date_of_Birth":"出生日期","space":"空間","Portuguese_Smart_Index":"葡萄牙智慧指數","EUR/GBP":"歐元/英鎊","ASX_Limited":"ASX有限公司","Jumei_International_Holding_Limited":"聚美優品國際控股有限公司","Saturday":"星期六","Never_Used":"從未使用過","Volatility_50_Index":"波動率50指數","USD/HKD":"美元/港幣","Presents_the_maximum_aggregate_payouts_on_outstanding_contracts_in_your_portfolio__If_the_maximum_is_attained,_you_may_not_purchase_additional_contracts_without_first_closing_out_existing_positions_":"表示您證券組合中未平倉合約的最大總賠付額。如果達到該最大值，那麼您在購買更多合約之前需要先對現有頭寸進行平倉。","EUR/CZK":"歐元/捷克克朗","Description":"描述","Sell":"賣出","Abu_Dhabi_Index":"阿布達比指數","Euro_50_Index":"歐洲 50 指數","October":"十月","Nokia_Corporation":"諾基亞股份有限公司","You_are_currently_logged_in_to_your_real_money_account_with_[_1]_([_2])_":"您現已登入您的 [_1]([_2])真實資金帳戶。","Rolls-Royce_Holdings_plc":"勞斯萊斯集團","Terms_&_Conditions":"條款和條件","Only_2_decimal_points_are_allowed_":"只允許小數點后兩位。","Procter_&_Gamble_Co_":"寶鹼公司","period":"週期","Password_score_is:_[_1]__Passing_score_is:_20_":"密碼積分是: [_1]。通過積分是: 20。","Sony_Corporation":"索尼股份有限公司","Standard_Chartered_plc":"渣打銀行","Stays_In/Goes_Out":"「保持在範圍之內/超出範圍之外」","Note":"備註","Under_Armour_Inc_":"安特亞摩公司","Represents_the_maximum_number_of_outstanding_contracts_in_your_portfolio__Each_line_in_your_portfolio_counts_for_one_open_position__Once_the_maximum_is_reached,_you_will_not_be_able_to_open_new_positions_without_closing_an_existing_position_first_":"表示您的投資組合中未平倉合約的最大數量。您投資組合中的每一行都算作是一個未平倉頭寸。一旦達到該最大值，在開設新頭寸之前您需要先了結一個現有頭寸。","Italian_30_Index":"意大利 30 指數","Password_is_not_strong_enough_":"密碼安全度不夠。","Asset":"資產","Duerr_AG":"杜爾集團","Swiss_Smart_Index":"瑞士智慧指數","Airbus_Group":"空中巴士集團","0-1_year":"0-1 年","Unilever":"聯合利華公司","AUD/HKD":"澳元/港幣","Contract_Information":"合約確認","EUR/USD":"歐元/美元","EUR/RUB":"歐元/俄國盧布","Translator":"翻譯員","Hong_Kong_Index":"香港指數","STMicroelectronics_semiconductors":"意法半導體公司","Sorry,_account_opening_is_unavailable_":"對不起，不可開立帳號。","Maruti_Suzuki":"馬魯蒂鈴木公司","Anti-Fraud_Officer":"反欺詐專員","Barrier":"障礙","Current_Level":"目前價位","Password_is_moderate":"密碼安全級適中","Failed_to_reset_password__[_1],_please_retry_":"無法重設密碼。[_1]，請重試。","Your_Client_will_receive_an_email_notification_informing_him/her_that_the_transfer_has_been_processed_":"您的客戶將收到電子郵件通知，告知其轉帳交易已處理。","Low_Barrier":"低障礙","Previous_Day":"前一天","NZDCHF":"紐元/瑞士法郎","Senior_Perl_Developer":"高級 Perl 開發人員","IP_Address":"IP地址","Tu":"星期二","Senior_Front-End_Developer":"高級前端開發人員","Sale_Price":"賣出價格","AUD/IDR":"澳元/印度尼西亞盧比","Enter_the_barrier_in_terms_of_the_difference_from_the_spot_price__If_you_enter_+0_005,_then_you_will_be_purchasing_a_contract_with_a_barrier_0_005_higher_than_the_entry_spot__The_entry_spot_will_be_the_next_tick_after_your_order_has_been_received":"請按與現貨價格差額的形式輸入障礙水平。如果您輸入+0.005 ，那麼您將買入障礙水平比入市現價高0.005 的合約。入市現價為收到您訂單之後的下一個價格","GBP/CNY":"澳元/巴西雷亞爾","Social_Media_Executive":"社交媒體專員","Short":"短倉","Please_confirm_the_trade_on_your_statement_before_proceeding_":"繼續執行之前，請在您的聲明上確認此項交易。","Reset_Password":"重設密碼","Token":"權杖","Year":"年","Hewlett-Packard_Company":"惠普科技股份有限公司","Other_financial_instruments_trading_experience":"其它金融工具交易經驗","Forex_trading_frequency":"外匯交易頻率","Purchase_Time":"買入時間","GPT_Group_Stapled":"GPT 集團","Day":"天","-_A_scanned_copy_of_your_passport,_driving_licence_(provisional_or_full)_or_identity_card,_showing_your_name_and_date_of_birth_":"顯示您名字和出生日期的護照、駕照（臨時或永久）或身份證的掃描件。","Illumina_Inc_":"Illumina 公司","Old_password_is_wrong_":"舊密碼不正確。","Your_request_to_withdraw_[_1]_[_2]_from_your_account_[_3]_to_Payment_Agent_[_4]_account_has_been_successfully_processed_":"您從 [_3] 帳戶提取[_1] [_2] 到付款代理 [_4] 帳戶的要求已成功處理。","Fortescue_Metals_Group":"福斯科金屬集團","Orica_Limited":"澳瑞凯有限公司","AT&T":"AT&T公司","DevOps_Manager":"DevOps 經理","Trading_and_Withdrawal_Limits":"交易和取款限額","SABMiller_plc":"米勒啤酒集團","FERRARI_N_V_COM":"法拉利公司","High_barrier_offset":"高障礙位移","CSL_Ltd":"香港移動通訊有限公司","ICICI_Bank_Ltd":"印度工業信貸投資銀行","Aug":"八月","Amcor_Ltd":"安姆科有限公司","Are_you_sure_that_you_want_to_permanently_delete_token":"確定要永久刪除權杖嗎","Open":"開盤","KBC_Groep":"KBC集團","EUR/KRW":"歐元/韓元","Siemens_Aktiengesellschaft":"德國西門子總部","ends_outside":"區間之外結束","You_did_not_change_anything_":"您沒做任何更改。","Dialog_Semiconductor_plc":"德商戴樂格半導體有限公司","Russian_Regular_Index":"俄羅斯普通指數","Over/Under":"大於/小於","Feb":"二月","The_two_passwords_that_you_entered_do_not_match_":"兩次輸入的密碼不相符。","Failed":"失敗","You_have_not_granted_access_to_any_apps_":"您未獲權限存取任何應用程式。","Stop-loss":"止損","This_field_is_required_":"此為必填欄位。","Return":"回報","Marketing":"市場行銷","Tertiary":"三級","Carrefour":"家樂福超市","Swiss_Index":"瑞士指數","USD/SAR":"美元/沙特阿拉伯里亞爾","AP_Ordinary":"AP 普通股票指數","Indices_trading_experience":"指數交易經驗","Walgreens_Boots_Alliance_Inc_":"沃爾格林博姿聯合公司","6-10_transactions_in_the_past_12_months":"過去12個月內6-10次交易","Deutsche_Lufthansa":"德國漢莎航空","Once_you_click_the_'Submit'_button,_the_funds_will_be_withdrawn_from_your_account_and_transferred_to_your_Client's_account_":"一旦您點擊「送出」按鈕，資金將從您的帳戶取出並轉至您客戶的帳戶。","[ctx,minimum_duration,_for_example_minimum_15_seconds]min":"分鐘","day":"天","Chevron_Co_":"雪佛龍公司","Internal_Audit":"內部審計","Save_as_JPEG":"以JPEG格式儲存","AUD/CZK":"澳元/捷克克朗","Platinum/USD":"白金/美元","Michelin":"米其林輪胎","GBP/ILS":"英鎊/以色列新錫克爾","Income_Source":"收入來源","hours":"小時","King_Digital_Entertainment_plc":"金數位娛樂公司","Johnson_&_Johnson":"壯生","Euro_100_Index":"歐洲100指數","second":"秒","GBP/INR":"英鎊/印度盧比","EUR/AED":"歐元/阿聯酋迪拉姆","Belgian_Stocks":"比利時股票","You_have_already_withdrawn_the_equivalent_of_[_1]_[_2]_":"您已提取 [_1] [_2] 的等值。","Date":"日期","International_Consolidated_Airlines_Group_SA":"國際航空集團","Asia/Oceania":"亞洲/大洋洲","Italian_Index":"意大利指數","Waiting_for_entry_tick_":"等待買入價跳動。","TOTAL":"道達爾公司","Crown_Resorts_Limited":"皇冠度假村有限公司","lower":"低於","Confirm_New_Password":"確認新密碼","Country_Manager":"區域經理","AbbVie_Inc_":"艾伯維藥品有限公司","April":"四月","Daimler_AG":"戴姆勒股份公司","ICAG_(British_Airways)":"英國航空公司","VF_Corporation":"威富聯營股份有限公司","E_ON_SE":"德國E.ON SE公司","Select_your_underlying_asset":"選擇標的資產","AUDZAR":"澳元兌南非蘭特","GBP/SGD":"英鎊/新加坡元","Last_Digit_Prediction":"最後數字的預測","Beiersdorf_AG_O_N":"拜爾斯道夫公司","Bayer_AG":"拜耳公司","Commerzbank":"德國商業銀行","Delta_Air_Lines_Inc_":"達美航空股份有限公司","GBP/CHF":"英鎊/瑞士法郎","USD/DKK":"紐西蘭元/美元","Try_adding_more_letters_or_numbers_":"請試新增字母或數字。","Al_Noor_Hospitals_Group_plc":"阿諾爾醫院集團","SouFun_Holdings_Limited":"搜房網個股公司","General_Electric_Company":"通用電氣公司","US_Tech_100_Index":"美國科技100指數","AUD/AED":"澳元/阿聯酋迪拉姆","Sep":"九月","Safran":"賽峰","Centrica_plc":"英國電力公司","USD/AED":"美元/阿聯酋迪拉姆","Jakarta_Index":"雅加達指數","Purchase_Price":"買入價格","XPD/EUR":"鈀金價盎司/歐元","UK_Smart_Index":"英國智慧指數","XPT/EUR":"白金價盎司/歐元","days":"天","Never":"從未","Name":"姓名","Save_as_PNG":"以PNG格式儲存","Piraeus_Bank_SA":"彼里夫斯銀行","New_Zealand_Index":"紐西蘭指數","Electricite_de_France":"法國電力公司","Palo_Alto_Networks_Inc_":"帕洛爾托網路有限公司","Solvay_chemicals":"索爾維化學集團","Major_Pairs":"主要貨幣對","Su":"星期日","Please_enter_a_number_between_[_1]_":"請輸入[_1]之間的數字。","Marketing_Project_Manager":"市場行銷項目經理","GBP/CAD":"英鎊/加元","Jump_To":"跳至","loading___":"載入中……","Amazon_Corporation":"亞馬遜網路服務有限公司","Accounting":"會計","Sina_Corporation":"新浪網","French_Index":"法國指數","When_you_click_\"Ok\"_you_will_be_excluded_from_trading_on_the_site_until_the_selected_date_":"當您點選「Ok」後，您將被禁止在此網站交易，直到選定期限結束為止。","Essilor_International":"依視路","Spot_Time":"現貨時間","Cynapsus_Therapeutics":"Cynapsus Therapeutics 公司","Heineken":"海尼根","BP_plc":"英國石油公司","EUR/SGD":"歐元/新加坡元","AUD/PLN":"澳元/波蘭兹羅提","Closes":"收盤","To":"到","Lend_Lease_Group_Stapled":"聯盛集團","Istanbul_Index":"伊斯坦堡指數","Reference_ID":"身份參考號","Imperial_Tobacco_Group_plc":"帝國菸草公司","AUD/NOK":"澳元/挪威克朗","Administrative_Executive":"行政專員","Tuesday":"星期二","Sorry,_this_feature_is_not_available_":"對不起，此功能不可用。","Select_market":"選擇市場","High_barrier":"高障礙","GBP/HKD":"英鎊/港幣","Closed":"已收盤","You_must_accept_the_terms_and_conditions_to_open_an_account_":"您必須接受條款和條件才能開戶。","USDZAR":"美元兌南非蘭特","Mar":"三月","Allianz_SE":"安聯 SE","CAD/JPY":"加元/日圓","Dec":"十二月","Gemalto_cyber_security":"聯宏科技股份有限公司","US_S&P_100":"美國標普 100 指數","Novartis_AG":"諾華公司","General_Motors_Company":"通用汽車公司","Portuguese_Index":"葡萄牙指數","higher":"高於","Deposit_[_1]_[_2]_virtual_money_into_your_account_[_3]":"將 [_1] [_2] 虛擬資金存入您的帳戶[_3]","Alstom_industrial_machinery":"阿爾斯通工業機械公司","Jan":"一月","Monday":"星期一","Royal_Dutch_Shell":"荷蘭皇家殼牌公司","differs":"相差","USD/CZK":"美元/捷克克朗","Current":"目前","Predict_the_direction<br_/>and_purchase":"預測價格走向<br />並購入","Societe_Generale":"法國興業銀行","Oil/AUD":"原油/澳元","Self-Employed":"自雇者","AIRBUS_GROUP_SE":"空中巴士集團","GBP/BRL":"英鎊/巴西雷亞爾","Estimated_Net_Worth":"估計淨值","Binary_options_or_other_financial_derivatives_trading_frequency":"二元期權或其它金融衍生品交易頻率","Virgin_America_Inc_":"維珍美國航空","Action":"動作","French_Smart_Index":"法國智慧指數","Customer_Support":"客戶支援","Ford_Motor_Comapny":"福特汽車公司","Youku_Tudou_Inc_":"優酷土豆股份有限公司","comma":"逗號","minutes":"分鐘","USD/CHF":"美元/瑞士法郎","Last_Used":"最近一次使用","AUD/MXN":"澳元/墨西哥比索","Oil/GBP":"原油/英鎊","Indian_50_Index":"印度50 指數","Wall_Street_Index":"華爾街指數","Kuwait_Index":"科威特指數","This_contract_has_LOST":"此合約輸了","Gilead_Sciensec_Inc_":"吉利德科學公司","Net_Annual_Income":"年淨收入","40_transactions_or_more_in_the_past_12_months":"過去12個月內40次交易或以上","Previous":"之前","Kering":"開雲集團","EUR/IDR":"歐元/印度尼西亞盧比","Euro_150_Index":"歐洲150指數","Investments_&_Dividends":"投資與分紅","Stocks_trading_frequency":"股票交易頻率","Your_withdrawal_limit_is_[_1]_[_2]_":"您的取款限額是[_1] [_2]。","Failed_to_update_trade_description_":"無法更新交易描述。","USD/RUB":"美元/俄國盧布","Please_enter_a_number_greater_or_equal_to_[_1]_":"請輸入大於或相等於[_1]之數字。","Bear_Market_Index":"熊市指數","RIO_TINTO_LIMITED":"力拓集團","Barclays_plc":"巴克萊銀行","Stocks":"股票","not_available":"不可使用","The_Payment_Agent_facility_is_currently_not_available_in_your_country_":"目前您的國家無可用付款代理設施。","Buy":"買入","PepsiCo_Inc_":"百事國際集團","Bank_of_America_Corporation":"美國銀行","Exclude_time_cannot_be_for_more_than_5_years_":"禁止時間不能超過5年。","Next":"下一頁","Friday":"星期五","Your_account_has_no_trading_activity_":"您的帳號沒有交易活動。","E-Commerce_China_Dangdang_Inc_":"當當網公司","EUR/SEK":"歐元/瑞典克朗","Your_trading_statistics_since_[_1]_":"您自 [_1] 至今的交易統計。","Your_settings_have_been_updated_successfully_":"您的設定已成功更新。","Your_password_cannot_be_the_same_as_your_email":"您的密碼不可與電子郵件相同","Please_select_a_valid_date":"請選擇有效日期","Walkthrough_Guide":"攻略指南","National_Grid_plc":"國家電網公司","Puma_Biotechnology_Inc_":"彪馬生物科技有限公司","Schneider_Electric":"施耐德電氣公司","USD/ILS":"美元/以色列新錫克爾","Shanghai_Index":"上海指數","verification_token":"驗證權杖","BG_Group_plc":"英國石油天然氣集團公司","points":"點","To_authenticate_your_account,_kindly_email_the_following_to_[_1]":"為驗證您的帳號，請將以下通過電子郵件傳到[_1]","ALUMINA_LIMITED":"氧化鋁有限公司","Contract_Expiry":"合約已到期","December":"十二月","Quality_Assurance":"品質保證","Primary":"主要","XAG/GBP":"銀價盎司/英鎊","NEWS_CORPORATION_":"新聞集團","Revoke_access":"撤銷存取權限","Saudi_Arabia_Index":"沙地阿拉伯指數","Try_adding_more_numbers_":"試新增更多數字。","Password_is_weak":"密碼安全度低","You_are_currently_logged_in_to_your_virtual_money_account_([_2])_":"您現已登入您的虛擬資金帳戶([_2])。","Higher/Lower":"「高於/低於」","Stake":"投注資金","Ctrip_com_International_Ltd_":"攜程旅行網國際有限公司","GlaxoSmithKline_plc":"荷商葛蘭素史克藥廠","GBP/MXN":"英鎊/墨西哥披索","Amount_per_point":"每點之金額","Caltex_Australia_Limited":"加德士澳洲有限公司","Date_and_Time":"日期和時間","The_Coca-Cola_Company":"可口可樂","USD/SEK":"美元/瑞典克朗","Total_Profit/Loss":"利潤/虧損合計","L'Oreal":"歐萊雅集團","Sorry,_an_error_occurred_while_processing_your_request_":"對不起，在處理您的請求時發生錯誤。","Represents_the_maximum_amount_of_cash_that_you_may_hold_in_your_account___If_the_maximum_is_reached,_you_will_be_asked_to_withdraw_funds_":"表示您的帳戶中可持有的最高現金額。如果達到該最高額，將會要求您提取資金。","Alpha_Bank_S_A_":"阿爾法銀行","NetEase_Inc_":"網易公司","Jun":"六月","Confirm":"確認","Carnival_plc":"嘉年華遊輪集團","Back":"返回","Balance":"餘額","Statement":"帳單","ends_between":"區間之內結束","ServiceNow_Inc_":"ServiceNow 公司","Japanese_Smart_Index":"日本智慧指數","Your_account_has_no_Login/Logout_activity_":"您的帳戶沒有登入/登出活動。","Select_your_trade_type":"選取交易類型","asian_down":"亞洲下跌","Exit_Spot_Time":"退出現價時間","We_are_not_able_to_stream_live_prices_at_the_moment__To_enjoy_live_streaming_of_prices_try_refreshing_the_page,_if_you_get_this_issue_after_repeated_attempts_try_a_different_browser":"目前我們不能夠串流即時價格。要獲得價格的即時串流請試重新整理頁面，如果經過反复嘗試還是存在此問題，請換一個瀏覽器","Pearson_plc":"皮爾森集團","Oracle":"甲骨文公司","Low_barrier":"低障礙","Commodities_trading_experience":"商品交易經驗","Forex":"外匯","Minor_Pairs":"次要貨幣對","Spreads":"價差","Contract_ID":"合約編號","BTC/EUR":"比特幣/歐元","Only_[_1]_are_allowed_":"只允許 [_1] 。","Virtual_Account":"虛擬帳戶","USD/NOK":"美元/挪威克朗","Our_site_does_not_charge_any_transfer_fees_":"我們網站不收取任何轉帳費用。","Unibail-Rodamco_SE":"尤尼百-洛當科集團","Daily_Reset_Indices":"每日重置指數","Deposit":"存款","French_Stocks":"法國股票","Netflix_Inc_":"網飛公司","Please_input_a_valid_date":"請輸入有效日期","years":"年","Sunday":"星期日","Explanation":"說明","USD/PLN":"美元/波蘭茲羅提","This_contract_has_WON":"此合約贏了","GBP/CZK":"英鎊/捷克克朗","Please_wait_<br_/>Your_request_is_being_processed_":"請稍候。 <br />您的要求正在處理中。","Irish_Index":"愛爾蘭指數","AUD/NZD":"澳元/紐西蘭元","Your_[_1]_accounts_are_unavailable__For_any_questions_please_contact_[_2]_":"您的[_1]帳戶不可用。如有任何問題，請聯繫[_2]。","Volatility_Indices":"波動率指數","Belgian_Index":"比利時指數","Palladium/USD":"鈀金/美元","Your_token_has_expired__Please_click_<a_class=\"pjaxload\"_href=\"[_1]\">here</a>_to_restart_the_verification_process_":"您的權杖已過期。請點選<a class=\"pjaxload\" href=\"[_1]\">此處</a>重啟驗證程序。","Remaining_Time":"剩餘時間","Your_transaction_reference_number_is_[_1]":"您的交易號是 [_1]","January":"一月","There_was_an_error":"出現錯誤","Groupe_Bruxelles_Lambert":"藍博特布魯塞爾集團","American_International_Group_Inc_":"美國國際集團","The_Home_Depot_Inc_":"家得寶公司","Format:_yyyy-mm-dd_(not_required_for_virtual-money_accounts)":"格式:年-月-日(虛擬資金帳戶不需要)","Maximum_number_of_open_positions":"最大未平倉頭寸數目","Start_Time":"開始時間","Veolia_Environnement_water":"威立雅環境股份有限公司","Manchester_United_plc":"曼徹斯特聯隊","Publicis_media_agencies":"陽獅集團","Exit_Level":"退出價位","AUD/SEK":"澳元/瑞典克朗","[_1]_[_2]_has_been_credited_to_your_Virtual_money_account_[_3]":" [_1] [_2]已記入您的虛擬資金帳戶 [_3]","Please_submit_a_valid_[_1]_":"請提交有效的 [_1]。","Session_duration_limit_cannot_be_more_than_6_weeks_":"交易期持續時間限制不能大於6週。","Ends_In/Out":"收盤價在「範圍之內/之外」","XPD/AUD":"鈀金價盎司/澳元","Workday_Inc_":"工作日公司","Indices":"指數","EUR/NZD":"歐元/紐西蘭元","Contract_will_be_sold_at_the_prevailing_market_price_when_the_request_is_received_by_our_servers__This_price_may_differ_from_the_indicated_price_":"合約將在我們伺服器收到要求時以當時的市場價格賣出。此價格可能會與報價有差異。","Maximum_aggregate_payouts_on_open_positions":"未平倉頭寸的最大賠付總額","UK_Index":"英國指數","Credit/Debit":"借記/貸記","End_Time":"結束時間","There_was_a_problem_accessing_the_server_":"伺服器存取出了問題。","Please_check_your_email_to_retrieve_the_token_needed_to_reset_your_password_":"請檢查您的電郵領取重設密碼所需的權杖編號。","year":"年","German_Index":"德國指數","Brazilian_Index":"巴西指數","Finance":"金融","Google_Inc_":"谷歌","EUR/CHF":"歐元/瑞士法郎","Graphic_Designers":"平面設計師","Administrator":"管理員","November":"十一月","ExxonMobil":"埃克森美孚公司","South_African_Index":"南非指數","Contract":"合約","Keep_track_of_your_authorised_applications_":"跟蹤您的授權應用程式。","Please_enter_a_valid_amount_":"請輸入有效金額。","Please_enter_a_date_that_is_at_least_6_months_from_now_":"請輸入至少6個月後的日期。","Zoom":"縮放","Your_changes_have_been_updated_":"您的更改已成功更新。","Ms":"女士","May":"五月","Profit":"利潤","Exclude_time_must_be_after_today_":"禁止時間必須在今日之後。","Rise/Fall":"「上漲/下跌」合約","Vipshop_Holdings_Limited":"唯品會個股公司","XPT/AUD":"白金價盎司/澳元","Total_Cost":"成本總計","Tata_Steels":"塔塔鋼鐵公司","Touch/No_Touch":"觸及/未觸及","Baidu_Inc_":"百度公司","Hang_Seng_China":"恆生中國指數","Associated_British_foods_plc":"英國聯合食品公司","Invalid_date_of_birth_":"出生日期無效。","Sell_at_market":"按市價賣出","Intel":"英特爾公司","Date_(GMT)":"日期（格林尼治標準時間）","Alcoa_Inc_":"美國鋁業公司","Maximum_daily_turnover":"最大日成交量","You_have_sold_this_contract_at_[_1]_[_2]":"您已經以 [_1] [_2] 賣出此合約","Commbank_(Australia)":"聯邦銀行（澳大利亞）","Royal_Dutch_Shell_plc":"荷蘭皇家殼牌公司","Cie_de_Saint-Gobain":"聖戈班公司","Last_Digit_Stats":"最後數字的統計資料","Permissions":"權限","Compliance_Executive":"法務專員","Settles":"結算","Stocks_trading_experience":"股票交易經驗","Item":"項目","Month":"月份","Successful":"成功","Voya_Prime_Rate_Trust_":"荷蘭國際最優惠利率信託","SANOFI":"賽諾菲","Unlock_Cashier":"解鎖收銀台","Middle_East":"中東","USD/TRY":"美元/土耳其里拉","Reckitt_Benckiser_Group_plc":"利潔時集團公司","Pension":"退休金","Proofreader":"校對員","Low_barrier_offset":"低障礙位移","USD/INR":"美元/印度盧比","AUD/CAD":"澳元/加元","GBP/USD":"英鎊/美元"};
;var markets_list = ["forex","indices","stocks","commodities","volidx"]; var markets_json = {"commodities":{"submarkets":[{"instruments":[{"value":"frxXAUUSD","label":"Gold/USD"},{"value":"frxXPDUSD","label":"Palladium/USD"},{"value":"frxXPTUSD","label":"Platinum/USD"},{"value":"frxXAGUSD","label":"Silver/USD"}],"name":"metals","label":"Metals"},{"instruments":[{"value":"frxBROUSD","label":"Oil/USD"}],"name":"energy","label":"Energy"}],"label":"Commodities"},"volidx":{"submarkets":[{"instruments":[{"value":"R_100","label":"Volatility 100 Index"},{"value":"R_25","label":"Volatility 25 Index"},{"value":"R_50","label":"Volatility 50 Index"},{"value":"R_75","label":"Volatility 75 Index"}],"name":"random_index","label":"Continuous Indices"},{"instruments":[{"value":"RDBEAR","label":"Bear Market Index"},{"value":"RDBULL","label":"Bull Market Index"}],"name":"random_daily","label":"Daily Reset Indices"}],"label":"Volatility Indices"},"forex":{"submarkets":[{"instruments":[{"value":"frxAUDJPY","label":"AUD/JPY"},{"value":"frxAUDUSD","label":"AUD/USD"},{"value":"frxEURAUD","label":"EUR/AUD"},{"value":"frxEURCAD","label":"EUR/CAD"},{"value":"frxEURCHF","label":"EUR/CHF"},{"value":"frxEURGBP","label":"EUR/GBP"},{"value":"frxEURJPY","label":"EUR/JPY"},{"value":"frxEURUSD","label":"EUR/USD"},{"value":"frxGBPAUD","label":"GBP/AUD"},{"value":"frxGBPJPY","label":"GBP/JPY"},{"value":"frxGBPUSD","label":"GBP/USD"},{"value":"frxUSDCAD","label":"USD/CAD"},{"value":"frxUSDCHF","label":"USD/CHF"},{"value":"frxUSDJPY","label":"USD/JPY"}],"name":"major_pairs","label":"Major Pairs"},{"instruments":[{"value":"frxAUDCAD","label":"AUD/CAD"},{"value":"frxAUDCHF","label":"AUD/CHF"},{"value":"frxAUDNZD","label":"AUD/NZD"},{"value":"frxAUDPLN","label":"AUD/PLN"},{"value":"frxEURNZD","label":"EUR/NZD"},{"value":"frxGBPCAD","label":"GBP/CAD"},{"value":"frxGBPCHF","label":"GBP/CHF"},{"value":"frxGBPNOK","label":"GBP/NOK"},{"value":"frxGBPNZD","label":"GBP/NZD"},{"value":"frxGBPPLN","label":"GBP/PLN"},{"value":"frxNZDJPY","label":"NZD/JPY"},{"value":"frxNZDUSD","label":"NZD/USD"},{"value":"frxUSDMXN","label":"USD/MXN"},{"value":"frxUSDNOK","label":"USD/NOK"},{"value":"frxUSDPLN","label":"USD/PLN"},{"value":"frxUSDSEK","label":"USD/SEK"}],"name":"minor_pairs","label":"Minor Pairs"},{"instruments":[{"value":"WLDAUD","label":"AUD Index"},{"value":"WLDEUR","label":"EUR Index"},{"value":"WLDGBP","label":"GBP Index"},{"value":"WLDUSD","label":"USD Index"}],"name":"smart_fx","label":"Smart FX"}],"label":"Forex"},"stocks":{"submarkets":[{"instruments":[{"value":"BBABI","label":"AB Inbev"},{"value":"BBBELG","label":"Belgacom"},{"value":"BBGBLB","label":"Groupe Bruxelles Lambert"},{"value":"BBKBC","label":"KBC Groep"},{"value":"BBUCB","label":"UCB"}],"name":"belgium","label":"Belgian Stocks"},{"instruments":[{"value":"NAASML","label":"ASML Holding"},{"value":"NAHEIA","label":"Heineken"},{"value":"NAINGA","label":"ING"},{"value":"NARDSA","label":"Royal Dutch Shell"},{"value":"NAUNA","label":"Unilever"}],"name":"amsterdam","label":"Dutch Stocks"},{"instruments":[{"value":"FPCS","label":"AXA"},{"value":"FPAI","label":"Air Liquide"},{"value":"FPAIR","label":"Airbus Group"},{"value":"FPBNP","label":"BNP Paribas"},{"value":"FPCA","label":"Carrefour"},{"value":"FPSGO","label":"Cie de Saint-Gobain"},{"value":"FPACA","label":"Credit Agricole"},{"value":"FPBN","label":"Danone"},{"value":"FPEDF","label":"Electricite de France"},{"value":"FPEI","label":"Essilor International"},{"value":"FPGSZ","label":"GDF Suez"},{"value":"FPKER","label":"Kering"},{"value":"FPOR","label":"L'Oreal"},{"value":"FPMC","label":"Moet Hennessy Louis Vuitton"},{"value":"FPORA","label":"Orange"},{"value":"FPRI","label":"Pernod Ricard"},{"value":"FPRNO","label":"Renault"},{"value":"FPSAN","label":"SANOFI"},{"value":"FPSAF","label":"Safran"},{"value":"FPSU","label":"Schneider Electric"},{"value":"FPGLE","label":"Societe Generale"},{"value":"FPFP","label":"TOTAL"},{"value":"FPDG","label":"Vinci"},{"value":"FPVIV","label":"Vivendi"}],"name":"france","label":"French Stocks"}],"label":"Stocks"},"indices":{"submarkets":[{"instruments":[{"value":"AS51","label":"Australian Index"},{"value":"BSESENSEX30","label":"Bombay Index"},{"value":"HSI","label":"Hong Kong Index"},{"value":"JCI","label":"Jakarta Index"},{"value":"N225","label":"Japanese Index"},{"value":"STI","label":"Singapore Index"}],"name":"asia_oceania","label":"Asia/Oceania"},{"instruments":[{"value":"BFX","label":"Belgian Index"},{"value":"AEX","label":"Dutch Index"},{"value":"FCHI","label":"French Index"},{"value":"GDAXI","label":"German Index"},{"value":"ISEQ","label":"Irish Index"},{"value":"OBX","label":"Norwegian Index"},{"value":"TOP40","label":"South African Index"},{"value":"SSMI","label":"Swiss Index"}],"name":"europe_africa","label":"Europe/Africa"},{"instruments":[{"value":"SPC","label":"US Index"},{"value":"DJI","label":"Wall Street Index"}],"name":"americas","label":"Americas"},{"instruments":[],"name":"smart_index","label":"Smart Indices"},{"instruments":[{"value":"DFMGI","label":"Dubai Index"}],"name":"middle_east","label":"Middle East"}],"label":"Indices"}};;/**
 * Synopsis
 *
 * var p = new InPagePopup({content: 'popup content'});
 * p.attach('button.open-popup');
 * // and now $('button.open-popup').get(0).inpage_poup is a reference to p
 *
 */
var InPagePopup = function(conf) {
    if (!conf) conf = {};
    if (typeof conf != 'object') {
        conf = {content: conf};
    }
    this.element = null;
    this._container = null;
    this.width = conf.width || null;
    this.close_on_escape = typeof conf.close_on_escape == 'undefined' ? true : conf.close_on_escape;
    this.draggable = typeof conf.draggable == 'undefined' ? true : conf.draggable;
    this.drag_handle = conf.drag_handle || '.drag-handle';
    this.ajax_conf = conf.ajax_conf || null;
    this._content = conf.content || '';
};

/**
 * Update the configuations of the pipup, change the width,
 * set draggable or not, etc.
 */
InPagePopup.prototype.config = function(conf) {
    if (conf.width) this.width = conf.width;
    if (typeof conf.close_on_escape != 'undefined') this.close_on_escape = !!conf.close_on_escape;
    if (typeof conf.draggable != 'undefined') this.draggable = !!conf.draggable;
    if (conf.drag_handle) this.drag_handle = conf.drag_handle;
    if (conf.ajax_conf) this.ajax_conf = conf.ajax_conf;
};

/**
 * Get or set the contens of the popup.
 *
 * @param new_content: set the new content
 */
InPagePopup.prototype.content = function(new_content) {
    var me = this;
    if (typeof new_content == 'undefined') {
        if (this._container) {
            return $('.inpage_popup_content', me._container).html();
        }
        return this._content;
    }
    if (this._container) {
        $('.inpage_popup_content', me._container).html(_new_content);
    } else {
        this._content = new_content;
    }
    return this;
};

/**
 * Finds the contents of the popup from the specified element.
 */
InPagePopup.prototype.find_element_popup_content = function(element) {
    if (!element) throw new Error("failed to detect element contents. no element specified");
    var jqel = $(element);
    var num = jqel.length;
    for (i = 0; i < num; i++) {
        var el = jqel.get(i);
        var elid = $(el).attr('id');
        if (elid) {
            var content_id = elid + '-content';
            var contents = $('.inpage_popup_content#' + content_id);
            if (contents.length) {
                return contents.first();
            }
        }
    }
    return null;
};

InPagePopup.prototype._ajax_request = function(callback, errback) {
    conf = {};
    if (this.ajax_conf) conf = (typeof this.ajax_conf == 'function') ? this.ajax_conf() : this.ajax_conf;
    if (typeof conf != 'object') conf = {url : conf};
    if (callback) conf.success = callback;
    if (errback) conf.error = errback;
    $.ajax(conf);
    return this;
};

/**
 * fetch contents of the inpage popup via AJAX.
 * Paramters passed to callbacks are standard jQuery params, with the popup object itself in the end.
 *
 * @param show: show the popup after data is fetched or not.
 * @param before_show: callback to be called before showing the popup. used for processing server response.
 *                     If this method returns a string it is considered as the new contents of the popup.
 *                     If it returns false or throws an error, the popup is not going to be shown.
 * @param after_show: callback to be called after showing the popup.
 * @param errback: errback to be called when errors occurred fetching data
 */
InPagePopup.prototype.fetch_remote_content = function(show, before_show, after_show, errback) {
    var me = this;
    if (!errback) {
        errback = function(jqxhr, txt_status, err) {
            throw new Error("Failed to fetch contents of the popup: " + err);
        };
    }
    var run_callbacks = function (data, txt_status, jqxhr) {
        if (before_show) {
            data = before_show(data, txt_status, jqxhr, me);
            if (!data) return false;
        }
        me.content(data);
        if (show !== false) me.show();
        if (after_show) after_show(data, txt_status, jqxhr, me);
    };
    this._ajax_request(run_callbacks, errback);
    return this;
};

/**
 * Initialize the container, set the contents and return it.
 */
InPagePopup.prototype._init_container = function() {
    this.close();
    var me = this;
    var container = $('<div class="inpage_popup_container"><a class="close">x</a></div>');
    var content = this.element ? this.find_element_popup_content(this.element) : null;
    var jq_content = content ? content.clone() : null;
    if (!jq_content) jq_content = $('<div class="inpage_popup_content">' + this._content + '</div>');
    container.append(jq_content);
    container.hide();
    jq_content.show().removeClass('invisible');
    $(document.body).append(container);
    if (me.width) container.width(me.width);
    this._container = container;
    container.find('.close').on('click', function() { me.close(); });
    if (this.close_on_escape) {
        $(document).on('keydown', function(e) {
            if (e.which == 27) me.close();
        });
    }
    if (this.draggable) {
        handle = this.drag_handle;
        drag_opts = {};
        if ( $(handle, container).length ) {
            drag_opts['handle'] = handle;
        }
        container.draggable(drag_opts);
    }
    this.reposition();
    return container;
};

/**
 * Reposition the popup on the screen. by default uses the center of the screen.
 */
InPagePopup.prototype.reposition = function(x, y) {
    if (this._container) {
        var win_ = $(window);
        var container = this._container;
        if (typeof x == 'undefined') {
            x = Math.max(Math.floor((win_.width() - container.width()) / 2), 50) + win_.scrollLeft();
        }
        if (typeof y == 'undefined') {
            y = Math.max(Math.floor((win_.height() - container.height()) / 2), 50) + win_.scrollTop();
        }
        this._container.offset({left: x, top: y});
    }
    return this;
};

/**
 * Return the container of the popup.
 */
InPagePopup.prototype.container = function() {
    if (!this._container) this._init_container();
    return this._container;
};

InPagePopup.prototype.show = function() {
    this.container().show();
    return this;
};

InPagePopup.prototype.close = function() {
    if (this._container) {
        this._container.hide().remove();
    }
    this._container = null;
    return this;
};

/**
 * Attaches the inpage popup to the specified element.
 *
 * each element would have a new property of 'inpage_popup' which
 * will reference to this same popup.
 *
 * @param element: any jQuery selector, or DOM or jquery object
 */
InPagePopup.prototype.attach = function(element) {
    var me = this;
    this.detach();
    var jqel = $(element);
    if (!jqel.length) {
        throw new Error("Failed to attach inpage popup. no such element exists for: " + element);
    }
    this.element = jqel;
    this.element.on('click', function(e) { e.preventDefault(); me.show(); });
    jqel.each( function () { this.inpage_popup = me; });
    return this;
};

/**
 * Detach the popup from element.
 */
InPagePopup.prototype.detach = function() {
    var me = this;
    if (this.element) {
        this.element.off('click');
        this.element.each( function () { this.inpage_popup = null; } );
    }
    this.element = null;
    return this;
};
;var Markets = function(markets, market_symbols) { 
    this.all = [];
    var market_count = markets.length;
    while(market_count--) {
        var market_name = markets[market_count];
        var market_config = market_symbols[market_name];
        var market_obj = new Market(market_name, market_config['label'], market_config['submarkets']);
        this.all.push(market_obj);

    }
};

Markets.prototype = {
    each: function(callback) {
        var market_count = this.all.length;
        while(market_count--) {
            callback.call(this.all[market_count]);
        }
    },
    by_symbol: function(symbol) {
        var market_count = this.all.length;
        while(market_count--) {
            var found = this.all[market_count].by_symbol(symbol);
            if(found) {
                return found;
            }
        }
    },
    get: function(name) {
        var market_count = this.all.length;
        while(market_count--) {
            if(this.all[market_count].name == name) {
                return this.all[market_count];
            }
        }
    }
};

var Market = function(name, display_name, submarkets) {
    this.name = name;
    this.display_name = display_name;
    this.submarkets = [];
    this.all_submarkets = [];
    var submarket_count = submarkets.length;
    while(submarket_count--) {
        var submarket = submarkets[submarket_count];
        var submarket_obj = new SubMarket(submarket['name'], submarket['label'], submarket['instruments']);
        this.submarkets.push(submarket_obj);
        this.all_submarkets.push(submarket_obj);
    }
};

Market.prototype = {
    translated_display_name: function() {
        return text.localize(this.display_name);
    },
    by_symbol: function(symbol) {
        var count = this.submarkets.length;
        while(count--) {
            found = this.submarkets[count].by_symbol(symbol);
            if(found) {
                found['market'] = this;
                return found;
            }
        }
    },
    each: function(callback) {
        var count = this.all_submarkets.length;
        while(count--) {
            callback.call(this.all_submarkets[count]);
        }
    },
    get: function(name) {
        if(name.toUpperCase() == 'ALL') {
            return this.all_submarkets;
        }

        var count = this.submarkets.length;
        while(count--) {
            if(this.submarkets[count].name == name) {
                return this.submarkets[count];
            }
        }
    }
};

function localizeName() {
    return text.localize(this.name);
}

var SubMarket = function(name, display_name, underlyings) {
    this.name = name;
    this.display_name = display_name;
    this.underlyings = [];
    var underlying_count = underlyings.length;
    while(underlying_count--) {
        var underlying = underlyings[underlying_count];
        var underlying_object = {
            name: underlying['label'],
            symbol: underlying['value'],
            translated_display_name: localizeName
        };
        this.underlyings.push(underlying_object);
    }
};

SubMarket.prototype = {
    translated_display_name: function() {
        return text.localize(this.display_name);
    },
    each: function(callback) {
        var underlying_count = this.underlyings.length;
        while(underlying_count--) {
            callback.call(this.underlyings[underlying_count]);
        }
    },
    by_symbol: function(symbol) {
        var underlying_count = this.underlyings.length;
        while(underlying_count--) {
            if(this.underlyings[underlying_count].symbol == symbol) {
                return { submarket: this, underlying: this.underlyings[underlying_count] };
            }
        }

        return;
    },
};
;var MenuContent = (function () {
    var listeners_events = [];

    var that = {
        init: function (_menu_containers) {
            _menu_containers.filter(':not(.follow-default)').delegate('.tm-a,.tm-a-2', 'click', function (event) {
                event.preventDefault();

                var target = $(event.target);
                var tab_id = target.parents('li:first').attr('id');

                if (tab_id)
                {
                    var tab_container = target.parents('.tm-ul');

                    var selected_tab =
                        // find previously active tab
                        tab_container.find('.tm-a,.tm-a-2')
                        // remove previously active tab
                        .removeClass('a-active').end()
                        // unwrap previously active tab
                        .find('.menu-wrap-a .tm-a').unwrap().unwrap()
                        // go back to selected target
                        .end().end()
                        // set active class to it
                        .addClass('a-active')
                        // set active class to its parent as well
                        .parents('.tm-li').addClass('active').removeClass('hover').find('.tm-li-2').addClass('active').end()
                        // wrap it
                        .find('.tm-a').wrap('<span class="menu-wrap-a"><span class="menu-wrap-b"></span></span>').end()
                        // remove previously active parent
                        .siblings().removeClass('active').find('.tm-li-2').removeClass('active').end()
                        .end().end();

                    // replace span to a, to make it clickable for real
                    var span_tm_a = tab_container.find('span.tm-a');
                    span_tm_a.replaceWith('<a href="#" class="'+span_tm_a.attr('class')+'">'+span_tm_a.html()+'</a>');

                    var menu_li = selected_tab.parents('li');
                    var sub_menu_selected = menu_li.find('.tm-ul-2 .a-active');
                    var selected_tab_id = menu_li.attr('id');

                    if (!sub_menu_selected.length)
                    {
                        sub_menu_selected = menu_li.find('.tm-a-2:first').addClass('a-active');

                        if (sub_menu_selected.length)
                        {
                            selected_tab = sub_menu_selected;
                            selected_tab_id = sub_menu_selected.parents('li').attr('id');
                            selected_content = $('#'+selected_tab_id+'-content').removeClass('invisible');
                        }
                        else
                        {
                            selected_tab_id = menu_li.attr('id');
                        }
                    }

                    var selected_content = $('#'+selected_tab_id+'-content')
                        // show selected tab content
                        .removeClass('invisible')
                        // and hide the rest
                        .siblings(':not(.sticky)').addClass('invisible').end();

                    that.push_to_listeners({
                        'id': selected_tab_id,
                        'target': selected_tab,
                        'content': selected_content,
                        'menu': menu_li.parents('ul.tm-ul'),
                        'event': event
                    });
                }

                return false;
            });
        },
        push_to_listeners: function (info)
        {
            // push to listeners events
            for (var i=0; i<listeners_events.length; i++)
            {
                listeners_events[i](info);
            }
        },
        listen_click: function (callback)
        {
            if (typeof callback != 'function')
            {
                return false;
            }

            listeners_events.push(callback);
        },
        find_selected_tab: function (menu_id)
        {
            var menu = $('#'+menu_id);
            var selected_tab = menu.find('.a-active').parents('.tm-li');

            if (!selected_tab.length)
            {
                selected_tab = menu.find('.active');
            }

            return selected_tab;
        },
        is_tab_selected: function (tab)
        {
            return tab.hasClass('active');
        },
        hide_tab: function (tab)
        {
            tab.addClass('invisible').find('.menu-wrap-a .tm-a').unwrap().unwrap();
            $('#'+tab.attr('id')+'-content').addClass('invisible');
        },
        show_tab: function (tab)
        {
            tab.removeClass('invisible');
        },
        trigger: function (id)
        {
            var tab_id = id['tab_id'];
            var content_id = id['content_id'];

            if (!tab_id && typeof content_id != 'undefined') {
                var matched = content_id.match(/^(.+)-content$/);
                if (matched && matched[1]) {
                    tab_id = matched[1];
                }
            }

            if (!tab_id)
            {
                return false;
            }

            var tab_to_trigger = $('#'+tab_id);

            if (!tab_to_trigger.size() || tab_to_trigger.hasClass('invisible'))
            {
                return false;
            }
            else
            {
                var tab = tab_to_trigger.find('.tm-a');
                if (tab.size())
                {
                    return tab.trigger('click');
                }
                else
                {
                    return tab_to_trigger.find('.tm-a-2').trigger('click');
                }
            }
        }
    };

    return that;
})();
;(function () {
    'use strict';

    var oldOnError = window.onerror;
    window.jsErrors = [];

    window.onerror = function (errorMessage, url, line) {

        window.jsErrors.push(errorMessage); // todo: refactor to Binary.jsErrors later
        
        if (oldOnError) {
            oldOnError(errorMessage, url, line);
        }
    };
})();
;var text;
var clock_started = false;

var GTM = (function() {
    "use strict";

    var gtm_data_layer_info = function(data) {
        var data_layer_info = {
            language  : page.language(),
            pageTitle : page_title(),
            pjax      : page.is_loaded_by_pjax,
            url       : document.URL,
            event     : 'page_load',
            is_legacy : 'false',
        };
        if(page.client.is_logged_in) {
            data_layer_info['visitorID'] = page.client.loginid;
        }

        $.extend(true, data_layer_info, data);

        var event = data_layer_info.event;
        delete data_layer_info['event'];

        return {
            data : data_layer_info,
            event: event,
        };
    };

    var push_data_layer = function(data) {
        // follow the legacy method for not converted pages
        var legacy_pages = ['affiliate_signup', 'cashier', 'trade.cgi', 'payment'];
        var regex = new RegExp(legacy_pages.join('|'), 'i');
        if(regex.test(location.pathname)) {
            push_data_layer_legacy();
            return;
        }

        // new implementation (all pages except the above list)
        var info = gtm_data_layer_info(data && typeof(data) === 'object' ? data : null);
        dataLayer[0] = info.data;
        dataLayer.push(info.data);
        dataLayer.push({"event": info.event});
    };

    var page_title = function() {
        var t = /^.+[:-]\s*(.+)$/.exec(document.title);
        return t && t[1] ? t[1] : document.title;
    };

    // Legacy functions (To be removed once all pages use new implementation above)
    var gtm_data_layer_info_legacy = function() {
        var gtm_data_layer_info = [];
        $('.gtm_data_layer').each(function() {
            var gtm_params = {};
            var event_name = '';
            $(this).children().each(function() {
                var tag = $(this).attr("id");
                var value = $(this).html();

                if ($(this).attr("data-type") == "json") {
                    value = JSON.parse($(this).html());
                }

                if (tag == "event") {
                    event_name = value;
                } else {
                    gtm_params[tag] = value;
                }
            });
            gtm_params['url'] = document.URL;
            gtm_params['is_legacy'] = 'true';

            var entry = {};
            entry['params'] = gtm_params;
            entry['event'] = event_name;
            gtm_data_layer_info.push(entry);
        });

        return gtm_data_layer_info;
    };

    var push_data_layer_legacy = function() {
        var info = gtm_data_layer_info_legacy();
        for (var i=0;i<info.length;i++) {
            dataLayer[0] = info[i].params;

            dataLayer.push(info[i].params);
            dataLayer.push({"event": info[i].event});
        }
    };

    return {
        push_data_layer : push_data_layer
    };
}());

var User = function() {
    this.email =  $.cookie('email');
    var loginid_list = $.cookie('loginid_list');

    if(this.email === null || typeof this.email === "undefined") {
        this.is_logged_in = false;
    } else {
        this.is_logged_in = true;

        if(loginid_list !== null && typeof loginid_list !== "undefined") {
            var loginid_array = [];
            var loginids = loginid_list.split('+').sort();

            for (var i = 0; i < loginids.length; i++) {
                var real = false;
                var disabled = false;
                var items = loginids[i].split(':');
                if (items[1] == 'R') {
                    real = true;
                }
                if (items[2] == 'D') {
                    disabled = true;
                }

                var id_obj = { 'id':items[0], 'real':real, 'disabled':disabled };
                if (/MLT/.test(items[0])) {
                    id_obj['non_financial']= true;
                }
                if (/MF/.test(items[0])) {
                    id_obj['financial']= true;
                }
                loginid_array.push(id_obj);
            }

            this.loginid_array = loginid_array;
        }
    }
};

var Client = function() {
    this.loginid      =  $.cookie('loginid');
    this.residence    =  $.cookie('residence');
    this.is_logged_in = this.loginid && this.loginid.length > 0;
};

Client.prototype = {
    redirect_if_logout: function() {
        if(!this.is_logged_in) {
            window.location.href = page.url.url_for('login');
        }
        return !this.is_logged_in;
    },
    redirect_if_is_virtual: function(redirectPage) {
        var is_virtual = this.is_virtual();
        if(is_virtual) {
            window.location.href = page.url.url_for(redirectPage || '');
        }
        return is_virtual;
    },
    is_virtual: function() {
        return this.get_storage_value('is_virtual') === '1';
    },
    require_reality_check: function() {
        return this.get_storage_value('has_reality_check') === '1';
    },
    get_storage_value: function(key) {
        return LocalStore.get('client.' + key) || '';
    },
    set_storage_value: function(key, value) {
        return LocalStore.set('client.' + key, value);
    },
    check_storage_values: function(origin) {
        var is_ok = true;

        if(!this.get_storage_value('is_virtual') && TUser.get().hasOwnProperty('is_virtual')) {
            this.set_storage_value('is_virtual', TUser.get().is_virtual);
        }

        // currencies
        if(!this.get_storage_value('currencies')) {
            BinarySocket.send({
                'payout_currencies': 1,
                'passthrough': {
                    'handler': 'page.client',
                    'origin' : origin || ''
                }
            });
            is_ok = false;
        }

        // allowed markets
        if(this.is_logged_in) {
            if(
                !this.get_storage_value('is_virtual') &&
                !this.get_storage_value('allowed_markets') &&
                TUser.get().landing_company_name &&
                !this.get_storage_value('has_reality_check')
            ) {
                $('#topMenuStartBetting').addClass('invisible');
                BinarySocket.send({
                    'landing_company_details': TUser.get().landing_company_name,
                    'passthrough': {
                        'handler': 'page.client',
                        'origin' : origin || ''
                    }
                });
                is_ok = false;
            }
        }

        return is_ok;
    },
    response_payout_currencies: function(response) {
        if (!response.hasOwnProperty('error')) {
            this.set_storage_value('currencies', response.payout_currencies.join(','));
            if(response.echo_req.hasOwnProperty('passthrough') && response.echo_req.passthrough.origin === 'attributes.restore.currency') {
                BetForm.attributes.restore.currency();
            }
        }
    },
    response_landing_company_details: function(response) {
        if (!response.hasOwnProperty('error')) {
            var allowed_markets = response.landing_company_details.legal_allowed_markets;
            var company = response.landing_company_details.name;
            var has_reality_check = response.landing_company_details.has_reality_check;

            this.set_storage_value('allowed_markets', allowed_markets.length === 0 ? '' : allowed_markets.join(','));
            this.set_storage_value('landing_company_name', company);
            this.set_storage_value('has_reality_check', has_reality_check);

            page.header.menu.disable_not_allowed_markets();
            page.header.menu.register_dynamic_links();
            $('#topMenuStartBetting').removeClass('invisible');
        }
    },
    response_authorize: function(response) {
        TUser.set(response.authorize);
        this.set_storage_value('is_virtual', TUser.get().is_virtual);
        this.check_storage_values();
        page.contents.activate_by_client_type();
        page.contents.topbar_message_visibility();
    },
    clear_storage_values: function() {
        var that  = this;
        var items = ['currencies', 'allowed_markets', 'landing_company_name', 'is_virtual', 'has_reality_check'];
        items.forEach(function(item) {
            that.set_storage_value(item, '');
        });
        sessionStorage.setItem('currencies', '');
    },
    update_storage_values: function() {
        this.clear_storage_values();
        this.check_storage_values();
    },
};

var URL = function (url) { // jshint ignore:line
    this.is_valid = true;
    this.history_supported = window.history && window.history.pushState;
    if(typeof url !== 'undefined') {
        this.location = $('<a>', { href: decodeURIComponent(url) } )[0];
    } else {
        this.location = window.location;
    }
};

URL.prototype = {
    url_for: function(path, params, type) {
        var mid_path = '/';
        if(/.cgi/.test(path)) {
            if(type == 'cached') {
                mid_path = '/c/';
            } else {
                mid_path = '/d/';
            }
        }

        var url = "https://" + this.location.host + mid_path + path;
        if(params) {
            url += '?' + params;
            url += '&l=' + page.language();
        } else {
            url += '?l=' + page.language();
        }

        return url;
    },
    url_for_static: function(path) {
        if(!path) {
            path = '';
        }
        else if (path.length > 0 && path[0] === '/') {
            path = path.substr(1);
        }

        var staticHost = window.staticHost;
        if(!staticHost || staticHost.length === 0) {
            staticHost = $('script[src*="binary.min.js"]').attr('src');

            if(staticHost && staticHost.length > 0) {
                staticHost = staticHost.substr(0, staticHost.indexOf('/js/') + 1);
            }
            else {
                staticHost = 'https://static.binary.com/';
            }

            window.staticHost = staticHost;
        }

        return staticHost + path;
    },
    reset: function() {
        this.location = window.location;
        this._param_hash = undefined;
        this.is_valid = true;
        $(this).trigger("change", [ this ]);
    },
    invalidate: function() {
        this.is_valid = false;
    },
    update: function(url) {
        var state_info = { container: 'content', url: url, useClass: 'pjaxload' };
        if(this.history_supported) {
            history.pushState(state_info, '', url);
            this.reset();
        }
        this.is_valid = true;
    },
    param: function(name) {
        var param_hash= this.params_hash();
        return param_hash[name];
    },
    replaceQueryParam: function (param, newval, search) {
      var regex = new RegExp("([?;&])" + param + "[^&;]*[;&]?");
      var query = search.replace(regex, "$1").replace(/&$/, '');
      return (query.length > 2 ? query + "&" : "?") + (newval ? param + "=" + newval : '');
    },
    param_if_valid: function(name) {
        if(this.is_valid) {
           return this.param(name);
        }
        return;
    },
    path_matches: function(url) {
        //pathname is /d/page.cgi. Eliminate /d/ and /c/ from both urls.
        var this_pathname = this.location.pathname.replace(/\/[d|c]\//g, '');
        var url_pathname = url.location.pathname.replace(/\/[d|c]\//g, '');
        return (this_pathname == url_pathname || '/' + this_pathname == url_pathname);
    },
    params_hash_to_string: function(params) {
        var as_array = [];
        for(var p_key in params) if (params.hasOwnProperty(p_key)) {
            as_array.push(p_key + '=' + params[p_key]);
        }

        return as_array.join('&');
    },
    is_in: function(url) {
        if(this.path_matches(url)) {
            var this_params = this.params();
            var param_count = this_params.length;
            var match_count = 0;
            while(param_count--) {
                if(url.param(this_params[param_count][0]) == this_params[param_count][1]) {
                    match_count++;
                }
            }
            if(match_count == this_params.length) {
                return true;
            }
        }

        return false;
    },
    params_hash: function() {
        if(!this._param_hash) {
            this._param_hash = {};
            var params = this.params();
            var param = params.length;
            while(param--) {
                if(params[param][0]) {
                    this._param_hash[params[param][0]] = params[param][1];
                }
            }
        }
        return this._param_hash;
    },
    params: function() {
        var params = [];
        var parsed = this.location.search.substr(1).split('&');
        var p_l = parsed.length;
        while(p_l--) {
            var param = parsed[p_l].split('=');
            params.push(param);
        }
        return params;
    },
};

var Menu = function(url) {
    this.page_url = url;
    var that = this;
    $(this.page_url).on('change', function() { that.activate(); });
};

Menu.prototype = {
    on_unload: function() {
        this.reset();
    },
    activate: function() {
        $('#menu-top li').removeClass('active');
        this.hide_main_menu();

        var active = this.active_menu_top();
        var trading = $('#menu-top li:eq(4)');
        if(active) {
            active.addClass('active');
            if(trading.is(active)) {
                this.show_main_menu();
            }
        } else {
            var is_mojo_page = /^\/$|\/login|\/home|\/smart-indices|\/ad|\/open-source-projects|\/bulk-trader-facility|\/partners|\/payment-agent|\/about-us|\/group-information|\/group-history|\/careers|\/contact|\/terms-and-conditions|\/terms-and-conditions-jp|\/responsible-trading|\/us_patents|\/lost_password|\/realws|\/virtualws|\/open-positions|\/job-details|\/user-testing|\/japanws|\/maltainvestws$/.test(window.location.pathname);
            if(!is_mojo_page) {
                trading.addClass('active');
                this.show_main_menu();
            }
        }
    },
    show_main_menu: function() {
        $("#main-menu").removeClass('hidden');
        this.activate_main_menu();
    },
    hide_main_menu: function() {
        $("#main-menu").addClass('hidden');
    },
    activate_main_menu: function() {
        //First unset everything.
        $("#main-menu li.item").removeClass('active');
        $("#main-menu li.item").removeClass('hover');
        $("#main-menu li.sub_item a").removeClass('a-active');

        var active = this.active_main_menu();
        if(active.subitem) {
            active.subitem.addClass('a-active');
        }

        if(active.item) {
            active.item.addClass('active');
            active.item.addClass('hover');
        }

        this.on_mouse_hover(active.item);

        this.disable_not_allowed_markets();
    },
    disable_not_allowed_markets: function() {
        // enable only allowed markets
        var allowed_markets = page.client.get_storage_value('allowed_markets');
        if(!allowed_markets && page.client.is_logged_in) {
            if(TUser.get().hasOwnProperty('is_virtual') && !TUser.get().is_virtual) {
                $('#topMenuStartBetting').addClass('invisible');
            }
            return;
        }

        var markets_array = allowed_markets ? allowed_markets.split(',') : [];
        var sub_items = $('li#topMenuStartBetting ul.sub_items');
        sub_items.find('li').each(function () {
            var link_id = $(this).attr('id').split('_')[1];
            if(markets_array.indexOf(link_id) < 0 && page.client.is_logged_in && !page.client.is_virtual()) {
                var link = $(this).find('a');
                var link_text = link.text();
                var link_href = link.attr('href');
                link.replaceWith($('<span/>', {class: 'link disabled-link', text: link_text, link_url: link_href}));
            } else {
                var span = $(this).find('span');
                var span_text = span.text();
                var span_href = span.attr('link_url');
                span.replaceWith($('<a/>', {class: 'link', text: span_text, href: span_href}));
            }
        });
        $('#topMenuStartBetting').removeClass('invisible');
    },
    reset: function() {
        $("#main-menu .item").unbind();
        $("#main-menu").unbind();
    },
    on_mouse_hover: function(active_item) {
        $("#main-menu .item").on( 'mouseenter', function() {
            $("#main-menu li.item").removeClass('hover');
            $(this).addClass('hover');
        });

        $("#main-menu").on('mouseleave', function() {
            $("#main-menu li.item").removeClass('hover');
            if(active_item)
                active_item.addClass('hover');
        });
    },
    active_menu_top: function() {
        var active;
        var path = window.location.pathname;
        $('#menu-top li a').each(function() {
            if(path.indexOf(this.pathname) >= 0) {
                active = $(this).closest('li');
            }
        });

        return active;
    },
    active_main_menu: function() {
        var path = window.location.pathname;
        path = path.replace(/\/$/, "");
        path = decodeURIComponent(path);

        var item;
        var subitem;

        var that = this;
        //Is something selected in main items list
        $("#main-menu .items a").each(function () {
            var url = new URL($(this).attr('href'));
            if(url.is_in(that.page_url)) {
                item = $(this).closest('.item');
            }
        });

        $("#main-menu .sub_items a").each(function(){
            var link_href = $(this).attr('href');
            if (link_href) {
                var url = new URL(link_href);
                if(url.is_in(that.page_url)) {
                    item = $(this).closest('.item');
                    subitem = $(this);
                }
            }
        });

        return { item: item, subitem: subitem };
    },
    register_dynamic_links: function() {
        var stored_market = page.url.param('market') || LocalStore.get('bet_page.market') || 'forex';
        var allowed_markets = page.client.get_storage_value('allowed_markets');
        if(!allowed_markets && page.client.is_logged_in && !TUser.get().is_virtual) {
            return;
        }

        var markets_array = allowed_markets ? allowed_markets.split(',') : [];
        if(!TUser.get().is_virtual && markets_array.indexOf(stored_market) < 0) {
            stored_market = markets_array[0];
            LocalStore.set('bet_page.market', stored_market);
        }
        var start_trading = $('#topMenuStartBetting a:first');
        var trade_url = start_trading.attr("href");
        if(stored_market) {
            if(/market=/.test(trade_url)) {
                trade_url = trade_url.replace(/market=\w+/, 'market=' + stored_market);
            } else {
                trade_url += '&market=' + stored_market;
            }
            start_trading.attr("href", trade_url);

            $('#mobile-menu #topMenuStartBetting a.trading_link').attr('href', trade_url);
        }
    }
};

var Header = function(params) {
    this.user = params['user'];
    this.client = params['client'];
    this.settings = params['settings'];
    this.menu = new Menu(params['url']);
};

Header.prototype = {
    on_load: function() {
        this.show_or_hide_login_form();
        this.register_dynamic_links();
        this.simulate_input_placeholder_for_ie();
        this.logout_handler();
        if (isNotBackoffice()) {
          checkClientsCountry();
        }
    },
    on_unload: function() {
        this.menu.reset();
    },
    show_or_hide_login_form: function() {
        if (this.user.is_logged_in && this.client.is_logged_in) {
            var loginid_select = '';
            var loginid_array = this.user.loginid_array;
            for (var i=0;i<loginid_array.length;i++) {
                if (loginid_array[i].disabled) continue;

                var curr_loginid = loginid_array[i].id;
                var real = loginid_array[i].real;
                var selected = '';
                if (curr_loginid == this.client.loginid) {
                    selected = ' selected="selected" ';
                }

                var loginid_text;
                if (real) {
                    if(loginid_array[i].financial){
                        loginid_text = text.localize('Investment Account') + ' (' + curr_loginid + ')';
                    } else if(loginid_array[i].non_financial) {
                        loginid_text = text.localize('Gaming Account') + ' (' + curr_loginid + ')';
                    } else {
                        loginid_text = text.localize('Real Account') + ' (' + curr_loginid + ')';
                    }
                } else {
                    loginid_text = text.localize('Virtual Account') + ' (' + curr_loginid + ')';
                }

                loginid_select += '<option value="' + curr_loginid + '" ' + selected + '>' + loginid_text +  '</option>';
            }
            $("#client_loginid").html(loginid_select);
        }
    },
    simulate_input_placeholder_for_ie: function() {
        var test = document.createElement('input');
        if ('placeholder' in test)
            return;
        $('input[placeholder]').each(function() {
            var input = $(this);
            $(input).val(input.attr('placeholder'));
            $(input).focus(function() {
                if (input.val() == input.attr('placeholder')) {
                    input.val('');
                }
            });
            $(input).blur(function() {
                if (input.val() === '' || input.val() == input.attr('placeholder')) {
                    input.val(input.attr('placeholder'));
                }
            });
        });
    },
    register_dynamic_links: function() {
        var logged_in_url = page.url.url_for('');
        if(this.client.is_logged_in) {
            logged_in_url = page.url.url_for('user/my_accountws');
        }

        $('#logo').attr('href', logged_in_url).on('click', function(event) {
            event.preventDefault();
            load_with_pjax(logged_in_url);
        }).addClass('unbind_later');

        this.menu.register_dynamic_links();
    },
    start_clock_ws : function(){
        var that = this;

        function init(){
            clock_started = true;
            BinarySocket.send({ "time": 1,"passthrough":{"client_time" :  moment().valueOf()}});
        }
        that.run = function(){
            setInterval(init, 30000);
        };

        init();
        that.run();

        return;
    },
    time_counter : function(response){
        if(isNaN(response.echo_req.passthrough.client_time) || response.error){
            page.header.start_clock_ws();
            return;
        }
        var that = this;
        var clock_handle;
        var clock = $('#gmt-clock');
        var start_timestamp = response.time;
        var pass = response.echo_req.passthrough.client_time;

        that.client_time_at_response = moment().valueOf();
        that.server_time_at_response = ((start_timestamp * 1000) + (that.client_time_at_response - pass));
        var update_time = function() {
            window.time = moment(that.server_time_at_response + moment().valueOf() - that.client_time_at_response).utc();
            clock.html(window.time.format("YYYY-MM-DD HH:mm") + " GMT");
        };
        update_time();

        clearInterval(clock_handle);

        clock_handle = setInterval(update_time, 1000);
    },
    logout_handler : function(){
        $('a.logout').unbind('click').click(function(){
            BinarySocket.send({"logout": "1"});
        });
    },
    validate_cookies: function(){
        if (getCookieItem('login') && getCookieItem('loginid_list')){
            var accIds = $.cookie("loginid_list").split("+");
            var loginid = $.cookie("loginid");

            if(!client_form.is_loginid_valid(loginid)){
                BinarySocket.send({"logout": "1"});
            }

            for(var i=0;i<accIds.length;i++){
                if(!client_form.is_loginid_valid(accIds[i].split(":")[0])){
                    BinarySocket.send({"logout": "1"});
                }
            }
        }
    },
    do_logout : function(response){
        if("logout" in response && response.logout === 1){
            page.client.clear_storage_values();
            LocalStore.set('reality_check.ack', 0);
            var cookies = ['login', 'loginid', 'loginid_list', 'email', 'settings', 'reality_check', 'affiliate_token', 'affiliate_tracking', 'residence', 'allowed_markets'];
            var current_domain = ['.' + document.domain.split('.').slice(-2).join('.'), document.domain];
            var cookie_path = ['/'];
            if (window.location.pathname.split('/')[1] !== '') {
              cookie_path.push('/' + window.location.pathname.split('/')[1]);
            }
            var regex;

            cookies.map(function(c){
              regex = new RegExp(c);
              $.removeCookie(c, {path: cookie_path[0], domain: current_domain[0]});
              $.removeCookie(c);
              if (regex.test(document.cookie) && cookie_path[1]) {
                  $.removeCookie(c, {path: cookie_path[1], domain: current_domain[0]});
                  $.removeCookie(c, {path: cookie_path[1]});
              }
            });
            var redirectPage;
                redirectCheck = 1;
            if(response.echo_req.hasOwnProperty('passthrough') && response.echo_req.passthrough.hasOwnProperty('redirect')) {
                redirectPage = response.echo_req.passthrough.redirect;
                regex = new RegExp(redirectPage);
                if (regex.test(window.location.pathname)) {
                  redirectCheck = 0;
                }
            }
            else {
                redirectPage = ''; //redirect to homepage
            }
            if (redirectCheck) {
              window.location.href = page.url.url_for(redirectPage);
            }
        }
    },
};

var ToolTip = function() {
    this.tooltip = $('#tooltip');

    if (this.tooltip.length === 0) {
        this.tooltip = $('<div id="tooltip"></div>');
        this.tooltip.css('display', 'none')
            .appendTo('body');
    }

    this.showing = {};
    var that = this;
    $(window).resize(function() { that.resize_tooltip(); });
};

ToolTip.prototype = {
    attach: function() {
        var that = this;
        this.detach();

        var targets = $( '[rel~=tooltip]' ),
            target  = false,
            tip     = false,
            title   = false;

        targets.on('mouseenter', function(e) {
            tip = $(this).attr( 'title' );

            if( !tip || tip === '' )
                return false;

            that.showing.target = $(this);
            that.showing.tip = tip;

            that.showing.target.removeAttr( 'title' );

            that.tooltip.html(tip);
            that.resize_tooltip();
            that.reposition_tooltip_for(that.showing.target);
            that.show_tooltip($(this));
        });

        targets.on('mouseleave', function() {
            if(that.showing.target) {
                that.showing.target.attr( 'title', that.showing.tip );
            }
            that.hide_tooltip();
        });

        targets.on('click', function() {
            if(that.showing.target) {
                that.showing.target.attr( 'title', that.showing.tip );
            }
            that.hide_tooltip();
        });
    },
    detach: function() {
        $( '[rel~=tooltip]' ).off('mouseenter');
        $( '[rel~=tooltip]' ).off('mouseleave');
        this.tooltip.off('click');
    },
    show_tooltip: function(target) {
        this.tooltip.css({ display: ''});
        this.tooltip.zIndex(target.zIndex() + 100);
    },
    hide_tooltip: function(tooltip) {
        this.tooltip.html("");
        this.tooltip.css({ top: 0, left: 0, display: 'none'});
        this.tooltip.addClass('invisible');
    },
    resize_tooltip: function() {
        if( $( window ).width() < this.tooltip.outerWidth() * 1.5 )
            this.tooltip.css( 'max-width', $( window ).width() / 2 );
        else
            this.tooltip.css( 'max-width', 340 );
    },
    reposition_tooltip_for: function(target) {
        this.tooltip.removeClass('invisible');

        var pos_left = target.offset().left + ( target.outerWidth() / 2 ) - ( this.tooltip.outerWidth() / 2 ),
            pos_top = target.offset().top - (this.tooltip.outerHeight() + 10);

        this.tooltip.removeClass( 'left' );
        this.tooltip.removeClass( 'right' );
        this.tooltip.removeClass( 'top' );

        if( pos_left < 0 ) {
            pos_left = target.offset().left + target.outerWidth() / 2 - 20;
            this.tooltip.addClass( 'left' );
        }

        if( pos_left + this.tooltip.outerWidth() > $( window ).width() ) {
            pos_left = target.offset().left - this.tooltip.outerWidth() + target.outerWidth() / 2 + 20;
            this.tooltip.addClass( 'right' );
        }

        if( pos_top < 0 ) {
            pos_top  = target.offset().top + target.outerHeight() + 20;
            this.tooltip.addClass( 'top' );
        }

        this.tooltip.css( { left: pos_left, top: pos_top} );
    },
};

var Contents = function(client, user) {
    this.client = client;
    this.user = user;
    this.tooltip = new ToolTip();
};

Contents.prototype = {
    on_load: function() {
        this.activate_by_client_type();
        this.topbar_message_visibility();
        this.update_body_id();
        this.update_content_class();
        this.tooltip.attach();
        this.init_draggable();
    },
    on_unload: function() {
        this.tooltip.detach();
        if ($('.unbind_later').length > 0) {
            $('.unbind_later').off();
        }
    },
    activate_by_client_type: function() {
        $('.by_client_type').addClass('invisible');
        if(this.client.is_logged_in) {
            if(page.client.get_storage_value('is_virtual').length === 0) {
                return;
            }
            if(!page.client.is_virtual()) {
                $('.by_client_type.client_real').removeClass('invisible');
                $('.by_client_type.client_real').show();

                $('#topbar').addClass('dark-blue');
                $('#topbar').removeClass('orange');

                if (!/^CR/.test(this.client.loginid)) {
                    $('#payment-agent-section').addClass('invisible');
                    $('#payment-agent-section').hide();
                }

                if (!/^MF|MLT/.test(this.client.loginid)) {
                    $('#account-transfer-section').addClass('invisible');
                    $('#account-transfer-section').hide();
                }
            } else {
                $('.by_client_type.client_virtual').removeClass('invisible');
                $('.by_client_type.client_virtual').show();

                $('#topbar').addClass('orange');
                $('#topbar').removeClass('dark-blue');

                $('#account-transfer-section').addClass('invisible');
                $('#account-transfer-section').hide();
            }
        } else {
            $('.by_client_type.client_logged_out').removeClass('invisible');
            $('.by_client_type.client_logged_out').show();

            $('#topbar').removeClass('orange');
            $('#topbar').addClass('dark-blue');

            $('#account-transfer-section').addClass('invisible');
            $('#account-transfer-section').hide();
        }
    },
    update_body_id: function() {
        //This is required for our css to work.
        $('body').attr('id', '');
        $('body').attr('id', $('#body_id').html());
    },
    update_content_class: function() {
        //This is required for our css to work.
        $('#content').removeClass();
        $('#content').addClass($('#content_class').html());
    },
    init_draggable: function() {
        $('.draggable').draggable();
    },
    topbar_message_visibility: function() {
        if(this.client.is_logged_in) {
            if(page.client.get_storage_value('is_virtual').length === 0) {
                return;
            }
            var loginid_array = this.user.loginid_array;
            var c_config = page.settings.get('countries_list')[this.client.residence];

            if (page.client.is_virtual()) {
                var show_upgrade = true;
                if (localStorage.getItem('jp_test_allowed')) {
                    $('.virtual-upgrade-link').addClass('invisible');
                    $('.vr-japan-upgrade-link').addClass('invisible');
                    $('.vr-financial-upgrade-link').addClass('invisible');
                    show_upgrade = false;           // do not show upgrade for user that filled up form
                }
                for (var i=0;i<loginid_array.length;i++) {
                    if (loginid_array[i].real) {
                        $('.virtual-upgrade-link').addClass('invisible');
                        $('.vr-japan-upgrade-link').addClass('invisible');
                        $('.vr-financial-upgrade-link').addClass('invisible');
                        show_upgrade = false;
                        break;
                    }
                }
                if (show_upgrade) {
                    if (c_config && c_config['gaming_company'] == 'none' && c_config['financial_company'] == 'maltainvest') {
                        $('.vr-financial-upgrade-link').removeClass('invisible');
                        $('.virtual-upgrade-link').addClass('invisible');
                        $('.vr-japan-upgrade-link').addClass('invisible');
                    } else if (c_config && c_config['gaming_company'] == 'none' && c_config['financial_company'] == 'japan') {
                        $('.vr-japan-upgrade-link').removeClass('invisible');
                        $('.virtual-upgrade-link').addClass('invisible');
                        $('.vr-financial-upgrade-link').addClass('invisible');
                    } else {
                        $('.virtual-upgrade-link').removeClass('invisible');
                        $('.vr-japan-upgrade-link').addClass('invisible');
                        $('.vr-financial-upgrade-link').addClass('invisible');
                    }
                }
            } else {
                var show_financial = false;

                // also allow UK MLT client to open MF account
                if ( (c_config && c_config['financial_company'] == 'maltainvest') ||
                     (this.client.residence == 'gb' && /^MLT/.test(this.client.loginid)) )
                {
                    show_financial = true;
                    for (var j=0;j<loginid_array.length;j++) {
                        if (loginid_array[j].financial) {
                            show_financial = false;
                            break;
                        }
                    }
                }
                if (show_financial) {
                    $('.financial-upgrade-link').removeClass('invisible');
                } else {
                    $('.financial-upgrade-link').addClass('invisible');
                }
            }
        }
    },
};

var Page = function(config) {
    this.is_loaded_by_pjax = false;
    config = typeof config !== 'undefined' ? config : {};
    this.user = new User();
    this.client = new Client();
    this.url = new URL();
    this.settings = new InScriptStore(config['settings']);
    this.header = new Header({ user: this.user, client: this.client, settings: this.settings, url: this.url});
    this.contents = new Contents(this.client, this.user);
    onLoad.queue(GTM.push_data_layer);
};

Page.prototype = {
    language: function() {
        if ($('#language_select').length > 0) {
            return $('#language_select').attr('class').toUpperCase(); //Required as mojo still provides lower case lang codes and most of our system expects upper case.
        } else if(page.url.param('l')) {
            return page.url.param('l');
        } else {
            return 'EN';
        }
    },
    on_load: function() {
        this.url.reset();
        this.localize_for(this.language());
        this.header.on_load();
        this.on_change_language();
        this.on_change_loginid();
        this.record_affiliate_exposure();
        this.contents.on_load();
        this.on_click_acc_transfer();
        if(getCookieItem('login')){
            ViewBalance.init();
        } else {
            LocalStore.set('reality_check.ack', 0);
        }
        $('#current_width').val(get_container_width());//This should probably not be here.
    },
    on_unload: function() {
        this.header.on_unload();
        this.contents.on_unload();
    },
    on_change_language: function() {
        var that = this;
        $('#language_select').on('change', 'select', function() {
            var language = $(this).find('option:selected').attr('class');
            document.location = that.url_for_language(language);
        });
    },
    on_change_loginid: function() {
        var that = this;
        $('#client_loginid').on('change', function() {
            page.client.clear_storage_values();
            $('#loginid-switch-form').submit();
        });
    },
    on_click_acc_transfer: function() {
        $('#acc_transfer_submit').on('click', function() {
            var amount = $('#acc_transfer_amount').val();
            if (!/^[0-9]+\.?[0-9]{0,2}$/.test(amount) || amount < 0.1) {
                $('#invalid_amount').removeClass('invisible');
                $('#invalid_amount').show();
                return false;
            }
            $('#acc_transfer_submit').submit();
        });
    },

    localize_for: function(language) {
        text = texts[language];
        moment.locale(language.toLowerCase());
    },
    url_for_language: function(lang) {
        lang = lang.trim().toUpperCase();
        SessionStore.set('selected.language', lang);
        var loc = document.location; // quick access
        var qs = loc.search || '?';
        var url = loc.protocol + '//' + loc.host + loc.pathname;
        if (qs.indexOf('l=') >= 0) {
            url += qs.replace(/(\?|&)l=[A-Z_]{2,5}/, "$1l=" + lang);
        } else {
            if (qs.length > 1) {
                lang = '&l=' + lang;
            } else {
                lang = 'l=' + lang;
            }
            url += qs + lang;
        }
        return url;
    },
    record_affiliate_exposure: function() {
        var token = this.url.param('t');
        if (!token || token.length !== 32) {
            return false;
        }
        var token_length = token.length;
        var is_subsidiary = /\w{1}/.test(this.url.param('s'));

        var cookie_value = $.cookie('affiliate_tracking');
        if(cookie_value) {
            var cookie_token = JSON.parse(cookie_value);

            //Already exposed to some other affiliate.
            if (is_subsidiary && cookie_token && cookie_token["t"]) {
                return false;
            }
        }

        //Record the affiliate exposure. Overwrite existing cookie, if any.
        var cookie_hash = {};
        if (token_length === 32) {
            cookie_hash["t"] = token.toString();
        }
        if (is_subsidiary) {
            cookie_hash["s"] = "1";
        }

        $.cookie("affiliate_tracking", JSON.stringify(cookie_hash), {
            expires: 365, //expires in 365 days
            path: '/',
            domain: '.' + location.hostname.split('.').slice(-2).join('.')
        });
    }
};
;/* ************************************************************
Created: 20060120
Author:  Steve Moitozo <god at zilla dot us> -- geekwisdom.com
Description: This is a quick and dirty password quality meter
     written in JavaScript so that the password does
     not pass over the network.
License: MIT License (see below)
Modified: 20060620 - added MIT License
Modified: 20061111 - corrected regex for letters and numbers
                     Thanks to Zack Smith -- zacksmithdesign.com
---------------------------------------------------------------
Copyright (c) 2006 Steve Moitozo <god at zilla dot us>
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
   The above copyright notice and this permission notice shall
be included in all copies or substantial portions of the
Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.
---------------------------------------------------------------
Password Strength Factors and Weightings
password length:
level 0 (3 point): less than 4 characters
level 1 (6 points): between 5 and 7 characters
level 2 (12 points): between 8 and 15 characters
level 3 (18 points): 16 or more characters
letters:
level 0 (0 points): no letters
level 1 (5 points): all letters are lower case
level 2 (7 points): letters are mixed case
numbers:
level 0 (0 points): no numbers exist
level 1 (5 points): one number exists
level 1 (7 points): 3 or more numbers exists
special characters:
level 0 (0 points): no special characters
level 1 (5 points): one special character exists
level 2 (10 points): more than one special character exists
combinatons:
level 0 (1 points): letters and numbers exist
level 1 (1 points): mixed case letters
level 1 (2 points): letters, numbers and special characters
          exist
level 1 (2 points): mixed case letters, numbers and special
          characters exist
NOTE: Because I suck at regex the code might need work
NOTE: Instead of putting out all the logging information,
    the score, and the verdict it would be nicer to stretch
    a graphic as a method of presenting a visual strength
    guage.
************************************************************ */
function testPassword(passwd)
{
    var intScore   = 0;
    var strVerdict = "weak";
    var strLog     = "";

    // PASSWORD LENGTH
    if (passwd.length<5)                         // length 4 or less
    {
      intScore = (intScore+3);
      strLog   = strLog + "3 points for length (" + passwd.length + ")\n";
    }
    else if (passwd.length>4 && passwd.length<8) // length between 5 and 7
    {
      intScore = (intScore+6);
      strLog   = strLog + "6 points for length (" + passwd.length + ")\n";
    }
    else if (passwd.length>7 && passwd.length<16)// length between 8 and 15
    {
      intScore = (intScore+12);
      strLog   = strLog + "12 points for length (" + passwd.length + ")\n";
    }
    else if (passwd.length>15)                    // length 16 or more
    {
      intScore = (intScore+18);
      strLog   = strLog + "18 point for length (" + passwd.length + ")\n";
    }


    // LETTERS (Not exactly implemented as dictacted above because of my limited understanding of Regex)
    if (passwd.match(/[a-z]/))                              // [verified] at least one lower case letter
    {
      intScore = (intScore+1);
      strLog   = strLog + "1 point for at least one lower case char\n";
    }

    if (passwd.match(/[A-Z]/))                              // [verified] at least one upper case letter
    {
      intScore = (intScore+5);
      strLog   = strLog + "5 points for at least one upper case char\n";
    }

    // NUMBERS
    if (passwd.match(/\d+/))                                 // [verified] at least one number
    {
      intScore = (intScore+5);
      strLog   = strLog + "5 points for at least one number\n";
    }

    if (passwd.match(/(.*[0-9].*[0-9].*[0-9])/))             // [verified] at least three numbers
    {
      intScore = (intScore+5);
      strLog   = strLog + "5 points for at least three numbers\n";
    }


    // SPECIAL CHAR
    if (passwd.match(/.[!,@,#,$,%,^,&,*,?,_,~]/))            // [verified] at least one special character
    {
      intScore = (intScore+5);
      strLog   = strLog + "5 points for at least one special char\n";
    }

                   // [verified] at least two special characters
    if (passwd.match(/(.*[!,@,#,$,%,^,&,*,?,_,~].*[!,@,#,$,%,^,&,*,?,_,~])/))
    {
      intScore = (intScore+5);
      strLog   = strLog + "5 points for at least two special chars\n";
    }


    // COMBOS
    if (passwd.match(/([a-z].*[A-Z])|([A-Z].*[a-z])/))        // [verified] both upper and lower case
    {
      intScore = (intScore+2);
      strLog   = strLog + "2 combo points for upper and lower letters\n";
    }

    if (passwd.match(/([a-zA-Z])/) && passwd.match(/([0-9])/)) // [verified] both letters and numbers
    {
      intScore = (intScore+2);
      strLog   = strLog + "2 combo points for letters and numbers\n";
    }

                  // [verified] letters, numbers, and special characters
    if (passwd.match(/([a-zA-Z0-9].*[!,@,#,$,%,^,&,*,?,_,~])|([!,@,#,$,%,^,&,*,?,_,~].*[a-zA-Z0-9])/))
    {
      intScore = (intScore+2);
      strLog   = strLog + "2 combo points for letters, numbers and special chars\n";
    }


    if(intScore < 10)
    {
       strVerdict = text.localize("Password is weak");
    }
    else if (intScore > 9 && intScore < 20)
    {
       strVerdict = text.localize("Password is moderate");
    }
    else if (intScore > 19)
    {
       strVerdict = text.localize("Password is strong");
    }
    else
    {
       strVerdict = text.localize("Password is very strong");
    }

  var array = [intScore, strVerdict];
  return array;
}
;//For object shape coherence we create named objects to be inserted into the queue.
var URLPjaxQueueElement = function(exec_function, url) {
    this.method = exec_function;
    if(url) {
        this.url = new RegExp(url);
    } else {
        this.url = /.*/;
    }
};

URLPjaxQueueElement.prototype = {
    fire: function(in_url) {
        if(this.url.test(in_url)) {
            this.method();
        }
    }
};

var IDPjaxQueueElement = function(exec_function, id) {
    this.method = exec_function;
    this.sel = '#' + id;
};

IDPjaxQueueElement.prototype = {
    fire: function() {
        if($(this.sel).length > 0) {
            this.method();
        }
    }
};

var PjaxExecQueue = function () {
    this.url_exec_queue = [];
    this.id_exec_queue = [];
    this.fired = false;
    this.content = $('#content');
};

PjaxExecQueue.prototype = {
    queue: function (exec_function) {
        this.url_exec_queue.unshift(new URLPjaxQueueElement(exec_function));
    },
    queue_for_url: function (exec_function, url_pattern) {
        this.url_exec_queue.unshift(new URLPjaxQueueElement(exec_function, url_pattern));
    },
    queue_if_id_present: function(exec_function, id) {
        this.id_exec_queue.unshift(new IDPjaxQueueElement(exec_function, id));
    },
    fire: function () {
        if(!this.fired) {
            var match_loc = window.location.href;
            var i = this.url_exec_queue.length;
            while(i--) {
                this.url_exec_queue[i].fire(match_loc);
            }

            i = this.id_exec_queue.length;
            while(i--) {
                this.id_exec_queue[i].fire(match_loc);
            }
        }
        this.fired = true;
    },
    reset: function() {
        this.fired = false;
    },
    loading: function () {
        this.reset();
    },
    count: function () {
        return exec_queue.length;
    },
    show: function (for_url) {
        for (var i=0; i < exec_queue.length; i++) {
            if(for_url) {
                if(exec_queue[i].url.test(for_url)) {
                    console.log("" + exec_queue[i].method);
                }
            } else {
                console.log(exec_queue[i].url + " : " + exec_queue[i].method);
            }
        }
    }
};

var pjax_config_page = function(url, exec_functions) {
    var functions = exec_functions();
    if (functions.onLoad) onLoad.queue_for_url(functions.onLoad, url);
    if (functions.onUnload) onUnload.queue_for_url(functions.onUnload, url);
};

var pjax_config = function() {
    return {
        'container': 'content',
        'beforeSend': function() {
            onLoad.loading();
            onUnload.fire();
        },
        'complete': function() {
            page.is_loaded_by_pjax = true;
            onLoad.fire();
            onUnload.reset();
        },
        'error': function(event) {
            var error_text = SessionStore.get('errors.500');
            if(error_text) {
                $('#content').html(error_text);
            } else {
                $.get('/errors/500.html').always(function(content) {
                    var tmp = document.createElement('div');
                    tmp.innerHTML = content;
                    tmpNodes = tmp.getElementsByTagName('div');
                    for(var i=0,l=tmpNodes.length;i<l;i++){
                        if(tmpNodes[i].id == 'content') {
                            SessionStore.set('errors.500', tmpNodes[i].innerHTML);
                            $('#content').html(tmpNodes[i].innerHTML);
                            break;
                        }
                    }
                });
            }

            $('#server_clock').html('GMT Time: ' + moment(page.header.time_now).utc().format("YYYY-MM-DD HH:mm"));

        },
        'useClass': 'pjaxload',
    };
};

var init_pjax = function () {
    var document_location = document.URL;
    if(!/backoffice/.test(document_location)) { //No Pjax for backoffice.
        pjax.connect(pjax_config());
    }
};

var load_with_pjax = function(url) {
        if(page.url.is_in(new URL(url))) {
            return;
        }

        var config = pjax_config();
        config.url = url;
        config.update_url = url;
        config.history = true;
        pjax.invoke(config);
};

// Reduce duplication as required Auth is a common pattern
var pjax_config_page_require_auth = function(url, exec) {
    var redirect = function() {
        window.location.href = page.url.url_for('login');
    };

    var oldOnLoad = exec().onLoad;
    var newOnLoad = function() {
        if (!getCookieItem('login')) {
            redirect();
        } else {
            oldOnLoad();
        }
    };

    var newExecFn = function(){
        return {
            onLoad: newOnLoad,
            onUnload: exec().onUnload
        };
    };
    pjax_config_page(url, newExecFn);
};
;var SpotLight = function (){
    var that = {};

    that.spot_light_box = function () {
        var spot_light_box = $('#spot-light-box');
        if (!spot_light_box.size())
        {
            spot_light_box = $('<div id="spot-light-box" class="invisible"></div>').appendTo('body');
        }

        return spot_light_box;
    };

    that.cover_page = function () {
        var transparent_cover = $('#transparent-cover');
        if (!transparent_cover.size())
        {
            transparent_cover = $('<div id="transparent-cover"></div>').appendTo('body');
        }

        transparent_cover.removeClass('invisible');
    };
    that.uncover_page = function () {
        $('#transparent-cover').addClass('invisible');
    };

    that.show = function () {
        that.spot_light_box().removeClass('invisible');
        that.cover_page();
        that.activate_buttons();
    };
    that.hide = function () {
        that.spot_light_box().addClass('invisible');
        that.uncover_page();
    };

    that.set_content = function (content) {
        that.spot_light_box().get(0).innerHTML = content;
    };

    that.attach_click_event = function (selector, event) {
        that.spot_light_box().delegate(selector, 'click', event);
    };

    that.activate_buttons = function() {
        $('.close_button').on('click', function (event) {
            $(this).parents('.rbox-shadow-popup').toggleClass('invisible');
            $('#transparent-cover').toggleClass('invisible');
        });

        $('.no_button').on('click', function (event) {
            $(this).parents('.rbox-shadow-popup').toggleClass('invisible');
            $('#transparent-cover').toggleClass('invisible');
        });
    };

    return that;
}();
;var isStorageSupported = function(storage) {
    if(typeof storage === 'undefined') {
        return false;
    }

    var testKey = 'test';
    try {
        storage.setItem(testKey, '1');
        storage.removeItem(testKey);
        return true;
    } catch(e) {
        return false;
    }
};

var Store = function(storage) {
    this.storage = storage;
};

Store.prototype = {
      get: function(key) {
          return this.storage.getItem(key) ? this.storage.getItem(key) : undefined;
      },
      set: function(key, value) {
          if(typeof value != "undefined") {
              this.storage.setItem(key, value);
          }
      },
      remove: function(key) {
          this.storage.removeItem(key);
      },
      clear: function() {
          this.storage.clear();
      },
};

var InScriptStore = function(object) { 
    this.store = typeof object !== 'undefined' ? object : {};
};

InScriptStore.prototype = {
    get: function(key) {
        return this.store[key];
    },
    set: function(key, value) {
        this.store[key] = value;
    },
    remove:  function(key) {
        this.store[key] = undefined;
    },
    clear: function() {
        this.store = {};
    }
};

var CookieStorage = function (cookie_name) {
    this.initialized = false;
    this.cookie_name = cookie_name;
    this.domain = '.' + document.domain.split('.').slice(-2).join('.');
    this.expires = new Date('Thu, 1 Jan 2037 12:00:00 GMT');
    this.value = {};
};

CookieStorage.prototype = {
    read: function() {
        var cookie_value = $.cookie(this.cookie_name);
        try {
            this.value = cookie_value ? JSON.parse(cookie_value) : {};
        } catch (e) {
            this.value = {};
        }
        this.initialized = true;
    },
    get: function(key) {
        if (!this.initialized) this.read();
        return this.value[key];
    },
    set: function(key, value) {
        if (!this.initialized) this.read();
        this.value[key] = value;
        $.cookie(this.cookie_name, JSON.stringify(this.value), {
            expires: this.expires,
            path: '/',
            domain: this.domain,
        });
    }
};

var Localizable = function(hash) {
    this.texts = typeof hash !== 'undefined'? hash : {};
};

Localizable.prototype = {
    localize: function(text, params) {
        var index = text.replace(/[\s|.]/g, '_');
        return this.texts[index] || text;
    }
};
;// for IE (before 10) we use a jquery plugin called jQuery.XDomainRequest. Explained here,
//http://stackoverflow.com/questions/11487216/cors-with-jquery-and-xdomainrequest-in-ie8-9
//
$(function(){
    $(document).ajaxSuccess(function () {
        var contents = new Contents(page.client, page.user);
        contents.on_load();
    });
});

var onLoad = new PjaxExecQueue();
var onUnload = new PjaxExecQueue();

var SessionStore, LocalStore;
if (isStorageSupported(window.localStorage)) {
    LocalStore = new Store(window.localStorage);
}

if (isStorageSupported(window.sessionStorage)) {
    if (!LocalStore) {
        LocalStore = new Store(window.sessionStorage);
    }
    SessionStore = new Store(window.sessionStorage);
}

if (!SessionStore || !LocalStore) {
    if (!LocalStore) {
        LocalStore = new InScriptStore();
    }
    if (!SessionStore) {
        SessionStore = new InScriptStore();
    }
}

var Settings = new CookieStorage('settings');

var page = new Page(window.page_params);

onLoad.queue(function () {
    page.on_load();
});

onUnload.queue(function () {
    page.on_unload();
});

var bo_url;

//////////////////////////////////////////////////////////////
//Purpose: To solve cross domain logged out server problem.
//Return: Hostname for this page
//////////////////////////////////////////////////////////////
function changeUrlToSameDomain(url) {
    var re = new RegExp('^(http|https):\/\/[.a-zA-Z0-9-]+/');
    var server_name = window.location.protocol + '//' + window.location.hostname;
    var same_domain_url = url.replace(re, server_name + '/');
    return same_domain_url;
}

function formEffects() {
    var select_focus_event = function () {
        $(this)
            .addClass('focus')
            .siblings().addClass('focus')
            .parents('fieldset').addClass('focus');
    };
    var select_blur_event = function () {
        $(this)
            .removeClass('focus')
            .siblings().removeClass('focus')
            .parents('fieldset').removeClass('focus');
    };
    var input_focus_event = function () {
        $(this)
            .parent('div').addClass('focus')
            .parents('fieldset').addClass('focus');
    };
    var input_blur_event = function () {
        $(this)
            .parent('div').removeClass('focus')
            .parents('fieldset').removeClass('focus');
    };

    this.set = function (jqObject) {
        jqObject
            .delegate('select', 'focus', select_focus_event)
            .delegate('select', 'blur', select_blur_event);

        jqObject
            .delegate('input[type=text],input[type=password],textarea', 'focus', input_focus_event)
            .delegate('input[type=text],input[type=password],textarea', 'blur', input_blur_event);
    };
}

function add_click_effect_to_button() {
    var prefix = function (class_name) {
        var class_names = class_name.split(/\s+/);
        var _prefix = 'button';
        var cn = class_names.shift();

        while (cn) {
            if (cn && cn != _prefix && !cn.match(/-focus|-hover/)) {
                _prefix = cn;
                break;
            }
            cn = class_names.shift();
        }

        return _prefix;
    };

    var remove_button_class = function (button, class_name) {
        button.removeClass(class_name).children('.button').removeClass(class_name).end().parent('.button').removeClass(class_name);
    };
    var add_button_class = function (button, class_name) {
        button.addClass(class_name).children('.button').addClass(class_name).end().parent('.button').addClass(class_name);
    };

    $('#content,#popup')
        .delegate('.button', 'mousedown', function () {
            var class_name = prefix(this.className) + '-focus';
            add_button_class($(this), class_name);
        })
        .delegate('.button', 'mouseup', function () {
            var class_name = prefix(this.className) + '-focus';
            remove_button_class($(this), class_name);
        })
        .delegate('.button', 'mouseover', function () {
            var class_name = prefix(this.className) + '-hover';
            add_button_class($(this), class_name);
        })
        .delegate('.button', 'mouseout', function () {
            var class_name = prefix(this.className) + '-hover';
            remove_button_class($(this), class_name);
        });
}

var make_mobile_menu = function () {
    if ($('#mobile-menu-container').is(':visible')) {
        $('#mobile-menu').mmenu({
            position: 'right',
            zposition: 'front',
            slidingSubmenus: false,
            searchfield: true,
            onClick: {
                close: true
            },
        }, {
            selectedClass: 'active',
        });
    }
};

onLoad.queue(function () {
    $('.tm-ul > li').hover(
        function () {
            $(this).addClass('hover');
        },
        function () {
            $(this).removeClass('hover');
        }
    );

    MenuContent.init($('.content-tab-container').find('.tm-ul'));

    add_click_effect_to_button();
    make_mobile_menu();

    // attach the class to account form's div/fieldset for CSS visual effects
    var objFormEffect = new formEffects();
    objFormEffect.set($('form.formObject'));

    var i = window.location.href.split('#');
    if (i.length != 2) return;
    var o = document.getElementsByTagName('a');
    for (var t = 0; t < o.length; t++) {
        if (o[t].href.substr(o[t].href.length - i[1].length - 1) == '#' + i[1]) {
            o[t].click();
            break;
        }
    }

});

onLoad.queue(function () {
    attach_date_picker('.has-date-picker');
    attach_time_picker('.has-time-picker');
    attach_inpage_popup('.has-inpage-popup');
    attach_tabs('.has-tabs');
});

// LocalStorage can be used as a means of communication among
// different windows. The problem that is solved here is what
// happens if the user logs out or switches loginid in one
// window while keeping another window or tab open. This can
// lead to unintended trades. The solution is to load the
// account page in all windows after switching loginid or
// the home page after logout.

// onLoad.queue does not work on the home page.
// jQuery's ready function works always.
if (!/backoffice/.test(document.URL)) { // exclude BO
    $(document).ready(function () {
        // $.cookie is not always available.
        // So, fall back to a more basic solution.
        var match = document.cookie.match(/\bloginid=(\w+)/);
        match = match ? match[1] : '';
        $(window).on('storage', function (jq_event) {
            if (jq_event.originalEvent.key !== 'active_loginid') return;
            if (jq_event.originalEvent.newValue === match) return;
            if (jq_event.originalEvent.newValue === '') {
                // logged out
                location.href = page.url.url_for('home');
            } else {
                // loginid switch
                location.href = page.url.url_for('user/my_accountws?loginid=' + jq_event.originalEvent.newValue);
            }
        });

        LocalStore.set('active_loginid', match);
        var start_time;
        var time_now;
        var tabChanged = function() {
            if(clock_started === true){
                if (document.hidden || document.webkitHidden) {
                    start_time = moment().valueOf();
                    time_now = page.header.time_now;
                }else {
                    time_now = (time_now + (moment().valueOf() - start_time));
                    page.header.time_now = time_now;
                }
            }
        };

        if (typeof document.webkitHidden !== 'undefined') {
            if (document.addEventListener) {
                document.addEventListener("webkitvisibilitychange", tabChanged);
            }
        } else if (typeof document.hidden !== 'undefined') {
            if (document.addEventListener) {
                document.addEventListener("visibilitychange", tabChanged);
            }
        }

    });
}
;DatePicker = function(component_id, select_type) {
    this.component_id = component_id;
    this.select_type = (typeof select_type === "undefined") ? "date" : select_type;

    this.localizations = {};
    this.localizations.monthNames = [text.localize('January'), text.localize('February'), text.localize('March'), text.localize('April'), text.localize('May'), text.localize('June'),text.localize('July'), text.localize('August'), text.localize('September'), text.localize('October'), text.localize('November'), text.localize('December') ];

    this.localizations.monthNamesShort = [text.localize('Jan'), text.localize('Feb'), text.localize('Mar'), text.localize('Apr'), text.localize('May'), text.localize('Jun'), text.localize('Jul'), text.localize('Aug'), text.localize('Sep'), text.localize('Oct'), text.localize('Nov'), text.localize('Dec')];

    this.localizations.dayNames = [text.localize('Sunday'), text.localize('Monday'), text.localize('Tuesday'), text.localize('Wednesday'), text.localize('Thursday'), text.localize('Friday'), text.localize('Saturday')];

    this.localizations.nextText = text.localize('Next');
    this.localizations.prevText = text.localize('Previous');
};

DatePicker.prototype = {
    show: function(max_days) {
        this.create(this.config(max_days));
    },
    hide: function() {
        if($('#' + this.component_id + '.hasDatepicker').length > 0)
            $('#' + this.component_id).datepicker('destroy');
        $('#' + this.component_id).off('keydown');
    },
    create: function(config) {
        var that = this;
        $('#' + this.component_id).keydown(function(e) {
                if(e.which == 13) {
                    e.preventDefault();
                    e.stopPropagation();
                    if(that.select_type == "date") {
                        $(this).datepicker('setDate', $(this).val());
                    }
                    $(this).datepicker('hide');
                    $(this).blur();
                    $(that).trigger('enter_pressed');
                    return false;
                }
        }).datepicker(config);

        // Not possible to tell datepicker where to put it's
        // trigger calendar icon on the page, so we remove it
        // from the DOM and use our own one.
        $('button.ui-datepicker-trigger').remove();
    },
    config: function(max_days) {
        max_days = (typeof max_days == "undefined") ? 365 : max_days;
        var today = new Date();
        var next_year = new Date();
        next_year.setDate(today.getDate() + max_days);

        var config = {
            dateFormat: 'yy-mm-dd',
            monthNames: this.localizations.monthNames,
            monthNamesShort: this.localizations.monthNamesShort,
            dayNames: this.localizations.dayNames,
            nextText: this.localizations.nextText,
            prevText: this.localizations.prevText,
            minDate: today,
            maxDate: next_year,
        };

        var that = this;
        config.onSelect = function(date_text) {
            if(that.select_type == "diff") {
                var today = moment.utc();
                var selected_date = moment.utc(date_text + " 23:59:59");
                var duration  = selected_date.diff(today, 'days');
                $(this).val(duration);
                $(that).trigger("change", [ duration ]);
            } else if(that.select_type == "date") {
                $(this).val(date_text);
                $(that).trigger("change", [ date_text ]);
            }
        };

        return config;
    },
};
;DatePicker.SelectedDates = function(component_id, select_type) {
    this.component_id = component_id;
    this._super = new DatePicker(component_id, select_type);
    this.dates = [];

    var that = this;
    $(this._super).on('enter_pressed', function() {
        $(that).trigger('enter_pressed');
    });

    $(this._super).on('change', function(event, selected) {
        $(that).trigger('change', [ selected ]);
    });
};

DatePicker.SelectedDates.prototype = {
    show: function(dates) {
        this.dates = dates;
        this._super.create(this.config());
    },
    hide: function() {
        if($('#' + this.component_id + '.hasDatepicker').length > 0)
            $('#' + this.component_id).datepicker('destroy');
    },
    config: function() {
        var config = this._super.config();
        var that = this;
        config.beforeShowDay = function(date) {
            var lookup = moment.utc([ date.getFullYear(), date.getMonth(), date.getDate() ]).format("YYYY-MM-DD");
            if(that.dates.indexOf(lookup) >= 0) {
                return [1];
            }

            return [0];
        };

        config.beforeShow = function(input, inst) {
            return { defaultDate: $('#' + that.component_id).val()};
        };

        return config;
    },
//    handlers: function() {
//        var handlers = {};
//        var that = this;
//        if (that.all_days_selectable) {
//            handlers.beforeShowDay = function(date) {
//                return [1];
//            }
//        } else if(that.today_selectable) {
//            handlers.beforeShowDay = function(date) {
//                if(new Date().toDateString() == date.toDateString()) {
//                    return [1];
//                } else {
//                    return [that.isTradingDay(date)];
//                }
//            }
//        } else {
//            handlers.beforeShowDay = function(date) {
//                return [that.isTradingDay(date)];
//            }
//        };
//
//        handlers.beforeShow = function(input, inst) {
//            that.hideToday(inst);
//            return { defaultDate: $('#duration_amount').val()};
//        };
//    
//        handlers.onChangeMonthYear = function(year, month, inst) {
//            that.hideToday(inst);
//        };
//
//        return handlers;
//    },
//    isTradingDay: function(date) {
//        var year = date.getFullYear();
//        var underlying_symbol = this.underlying_symbol;
//        var form_name = this.form_name;
//
//        var cache_key = underlying_symbol + '-' + form_name;
//        varyy lookup = year + '-' + (date.getMonth()+1) + '-' + date.getDate();
//
//        if (typeof this.cache[cache_key] === 'undefined') {
//            var that = this;
//            $.ajax({
//                url: page.url.url_for('trade_get.cgi'),
//                data: { controller_action: 'trading_days',
//                        underlying_symbol: underlying_symbol,
//                        form_name: form_name
//                    },
//                success: function(trading_days) {
//                        that.cache[cache_key] = trading_days;
//                    },
//                dataType:'json',
//                async: false
//            });
//        }
//        return this.cache[cache_key][lookup];
//    },
//    hideToday: function(inst) {
//        window.setTimeout(function() {
//                $(inst.dpDiv).find('.ui-state-highlight').removeClass('ui-state-highlight');
//            }, 0);
//    },
//    localizations: function() {
//        var localizations = {};
//
//        localizations.monthNames = [text.localize('January'), text.localize('February'), text.localize('March'), text.localize('April'), text.localize('May'), text.localize('June'),text.localize('July'), text.localize('August'), text.localize('September'), text.localize('October'), text.localize('November'), text.localize('December') ];
//
//        localizations.monthNamesShort = [text.localize('Jan'), text.localize('Feb'), text.localize('Mar'), text.localize('Apr'), text.localize('May'), text.localize('Jun'), text.localize('Jul'), text.localize('Aug'), text.localize('Sep'), text.localize('Oct'), text.localize('Nov'), text.localize('Dec')];
//
//        localizations.dayNames = [text.localize('Sunday'), text.localize('Monday'), text.localize('Tuesday'), text.localize('Wednesday'), text.localize('Thursday'), text.localize('Friday'), text.localize('Saturday')];
//
//        localizations.nextText = text.localize('Next');
//        localizations.prevText = text.localize('Previous');
//
//        return localizations;
//    },
};
;TimePicker = function(component_id) {
    this.component_id = component_id;
};

TimePicker.prototype = {
    show: function(min_time, max_time) {
        var that = this;

        $('#' + this.component_id).keydown(function(e) {
                if(e.which == 13) {
                    e.preventDefault();
                    e.stopPropagation();
                    $(this).timepicker('setTime', $(this).val());
                    $(this).timepicker('hide');
                    $(this).blur();
                    $(that).trigger('enter_pressed');
                    return false;
                }
        }).timepicker(this.config(min_time, max_time));
    },
    hide: function() {
        if($('#' + this.component_id + '.hasTimepicker').length > 0)
            $('#' + this.component_id).timepicker('destroy');
        $('#' + this.component_id).off('keydown');
    },
    time_now: function() {
        return moment.utc(page.header.time_now);
    },
    config: function(min_time, max_time) {
        var that = this;
        min_time = moment.utc(min_time);
        max_time = moment.utc(max_time);
        var time_now = this.time_now();

        if(min_time.isBefore(time_now)) {
            min_time = this.time_now();
        }

        var config = {
            minTime: {hour: parseInt(min_time.hour()), minute: parseInt(min_time.minute())},
            maxTime: {hour: parseInt(max_time.hour()), minute: parseInt(max_time.minute())},
        };

        config.onSelect = function(time, inst) {
            if (!time.match(/^(:?[0-3]\d):(:?[0-5]\d):(:?[0-5]\d)$/)) {
                var invalid = time.match(/([a-z0-9]*):([a-z0-9]*):?([a-z0-9]*)?/);
                var hour = that.time_now().format("hh");
                var minute = that.time_now().format("mm");
                var second = that.time_now().format("ss");

                if (typeof invalid[1] !== 'undefined' && isFinite(invalid[1])) {
                    hour = parseInt(invalid[1]);
                    if(hour < 10) {
                        hour = "0" + hour;
                    }
                }
                if (typeof invalid[2] !== 'undefined' && isFinite(invalid[2])) {
                    minute = parseInt(invalid[2]);
                    if(parseInt(minute) < 10) {
                        minute = "0" + minute;
                    }
                }
                if (typeof invalid[3] !== 'undefined' && isFinite(invalid[3])) {
                    second = parseInt(invalid[3]);
                    if(second < 10) {
                        second = "0" + minute;
                    }
                }

                var new_time = moment(that.time_now().format("YYYY-MM-DD") + ' ' + hour +':'+minute+':'+second);
                $(this).val(new_time.format("HH:mm"));
                $(that).trigger('change', [new_time.format("HH:mm")]);
            } else {
                $(that).trigger('change', [time]);
            }
        };

        return config;
    },
};
;window._trackJs = {
    onError: function(payload, error) {

        function itemExistInList(item, list) {
            for (var i = 0; i < list.length; i++) {
                if (item.indexOf(list[i]) > -1) {
                    return true;
                }
            }
            return false;
        }

        var ignorableErrors = [
            // General script error, not actionable
            "[object Event]",
            // General script error, not actionable
            "Script error.",
            // error when user  interrupts script loading, nothing to fix
            "Error loading script",
            // an error caused by DealPly (http://www.dealply.com/) chrome extension
            "DealPly",
            // this error is reported when a post request returns error, i.e. html body
            // the details provided in this case are completely useless, thus discarded
            "Unexpected token <"
        ];

        if (itemExistInList(payload.message, ignorableErrors)) {
            return false;
        }

        payload.network = payload.network.filter(function(item) {

            // ignore random errors from Intercom
            if (item.statusCode === 403 && payload.message.indexOf("intercom") > -1) {
                return false;
            }

            return true;
        });

        return true;
    }
};

// if Track:js is already loaded, we need to initialize it
if (typeof trackJs !== 'undefined') trackJs.configure(window._trackJs);
;//
//
//
// This script contains various functions used by our forms.
// NOTE: Since you might not find reference to these functions within our javascripts you might delete some stuff from here without cleaning up forms.
//
function clearInputErrorField(id) {
    var errorfield = document.getElementById(id);
    if (errorfield) {
        // we need to create a brand new passage element and replace to the existing one.
        // IE6 does not treat null/empty string as empty innerHTML (which means it will appear at the IE browswer)
        var parentNode = errorfield.parentNode;
        if (parentNode) {
            var passage = document.createElement('p');
            passage.id = errorfield.id;
            passage.className = errorfield.className;
            parentNode.replaceChild(passage, errorfield);
            return passage;
        }
        return errorfield;
    }
}

function swithTabIfError(IsErrorFound)
{
    if (IsErrorFound)
    {
        $('.errorfield').each(function ()
        {
            if (this.innerHTML.length > 0)
            {
                MenuContent.trigger({
                    'content_id': $(this).parents('[id*=-content]').attr('id')
                });
            }
        });
        return 1;
    }
    else
    {
        return 0;
    }
}

;var Highchart = (function() {
  var initialized;
  // initiate the chart for the first time only, send it ticks or candles data
  function init_chart(options) {
      var data = [];
      var type = '';
      var start_time = '<div style="margin-bottom:3px;margin-left:10px;height:0;width:20px;border:0;border-bottom:2px;border-style:solid;border-color:#E98024;display:inline-block"></div> Start time ';
      var entry_spot = '<div style="margin-left:10px;display:inline-block;border:3px solid orange;border-radius:6px;width:4px;height:4px;"></div> Entry spot ';
      var exit_spot = '<div style="margin-left:10px;display:inline-block;background-color:orange;border-radius:6px;width:10px;height:10px;"></div> Exit spot ';
      var end_time = '<div style="margin-bottom: 3px;margin-left:10px;height:0;width:20px;border:0;border-bottom:2px;border-style:dashed;border-color:#E98024;display:inline-block"></div> End time ';
      var delay = '<span style="color:red">Charting for this underlying is delayed </span>';
      // options.history indicates line chart
      if(options.history){
        type = 'line';
        var history = options.history;
        var times = history.times;
        var prices = history.prices;
        var i;
        if (window.delayed) {
          for(i = 0; i < times.length; ++i) {
              data.push([times[i]*1000, prices[i]*1]);
          }
        } else if (window.min && window.max) {
          for(i = 0; i < times.length; ++i) {
            if (times[i] >= parseInt(window.min) && times[i] <= parseInt(window.max)) {
              // only display the first tick before entry spot and one tick after exit spot
              // as well as the set of ticks between them
              data.push([times[i]*1000, prices[i]*1]);
            }
          }
        }
      }
      // options.candles indicates candle chart
      if(options.candles) {
        type = 'candlestick';
        data = options.candles.map(function(c){
          return [c.epoch*1000, c.open*1, c.high*1, c.low*1, c.close*1];
        });
      }
      // underlying name displayed on top of the chart
      var title = options.title;
      // element where chart is to be displayed
      var el = document.getElementById('analysis_live_chart');

      var chartOptions = {
        chart: {
          type: 'line',
          renderTo: el,
          backgroundColor: null, /* make background transparent */
          height: 450
        },
        title:{
          text: title,
          style: { fontSize:'16px' }
        },
        credits:{
          enabled: false
        },
        tooltip: {
          xDateFormat:'%A, %b %e, %H:%M:%S GMT'
        },
        xAxis: {
          type: 'datetime',
          categories:null,
          startOnTick: false,
          endOnTick: false,
          // min indicates where to start displaying the chart
          min: window.min ? parseInt(window.min)*1000 : null,
          // max indicates where to stop displaying the chart
          max: window.max ? parseInt(window.max)*1000 : null,
          labels: { overflow:"justify", format:"{value:%H:%M:%S}" }
        },
        yAxis: {
          labels: { align: 'left', x: 0, y: -2 },
          title: ''
        },
        series: [{
          name: title,
          data: data,
          type: type,
          // zones are used to display color of the line
          zones: [{
              // make the line grey until it reaches entry_time or start_time if entry spot time is not yet known
              value: window.entry_time ? window.entry_time*1000 : window.start_time*1000,
              color: '#ccc'
          }, {
              // make the line default color until exit_time is reached
              value: window.exit_time*1000 || null,
              color: ''
          }, {
              // make the line grey again after trade ended
              color: '#ccc'
          }],
          zoneAxis: 'x'
        }],
        exporting: {enabled: false, enableImages: false},
        legend: {enabled: false},
        navigator: { enabled: true },
        plotOptions: {
          line: {
            marker: { radius: 2 }
          },
          candlestick: {
            lineColor: 'black',
            color: 'red',
            upColor: 'green',
            upLineColor: 'black',
            shadow: true
          },
        },
        rangeSelector: { enabled: false },
      };

      // display comma after every three digits instead of space
      Highcharts.setOptions({
        lang: {thousandsSep: ','}
      });

      // display a guide for clients to know how we are marking entry and exit spots
      if (options.history) {
        chartOptions.subtitle = {
          text: window.delayed ? delay + start_time + entry_spot + exit_spot + end_time : start_time + entry_spot + exit_spot + end_time,
          align: 'right',
          useHTML: true
        };
        chartOptions.tooltip.valueDecimals = options.history.prices[0].split('.')[1].length || 3;
      } else if (options.candles) {
        chartOptions.subtitle = {
          text: window.delayed ? delay + start_time + end_time : start_time + end_time,
          align: 'right',
          useHTML: true
        };
        chartOptions.tooltip.valueDecimals = options.candles[0].open.split('.')[1].length || 3;
      }

      if(!el) return;
      var chart = new Highcharts.Chart(chartOptions);
      initialized = true;

      // this is used to draw lines such as start and end times
      chart.addPlotLineX = function(chartOptions) {
        chart.xAxis[0].addPlotLine({
           value: chartOptions.value,
           id: chartOptions.id || chartOptions.value,
           label: {text: chartOptions.label || '', x: chartOptions.text_left ? -15 : 5},
           color: chartOptions.color || '#e98024',
           zIndex: 4,
           width: chartOptions.width || 2,
           dashStyle: chartOptions.dashStyle || 'Solid'
        });
        var subtitle = window.chart.subtitle.element;
        var subtitle_length = window.chart.subtitle.element.childNodes.length;
        if (window.is_sold) {
          var textnode = document.createTextNode(" Sell time ");
          for (i = 0; i < window.chart.subtitle.element.childNodes.length; i++) {
            if (/End time/.test(window.chart.subtitle.element.childNodes[i].nodeValue)) {
              var item = window.chart.subtitle.element.childNodes[i];
              window.chart.subtitle.element.replaceChild(textnode, item);
            }
          }
        }
      };

      // this is used to draw lines such as barrier
      chart.addPlotLineY = function(chartOptions) {
        chart.yAxis[0].addPlotLine({
          id: chartOptions.id || chartOptions.label,
          value: chartOptions.value,
          label: {text: chartOptions.label, align: 'center'},
          color: chartOptions.color || 'green',
          zIndex: 4,
          width: 2,
        });
      };

      el.chart = chart;

      return el.chart;
  }

  var start_time, purchase_time, now_time, end_time, entry_tick_time, is_sold, sell_time, sell_spot_time, is_expired, exit_tick_time, exitTime;

  // since these values are used in almost every function, make them easy to initialize
  function initialize_values(contract) {
    start_time      = parseInt(contract.date_start);
    purchase_time   = parseInt(contract.purchase_time);
    now_time        = parseInt(contract.current_spot_time);
    end_time        = parseInt(contract.date_expiry);
    entry_tick_time = parseInt(contract.entry_tick_time);
    is_sold         = contract.is_sold;
    sell_time       = parseInt(contract.sell_time);
    sell_spot_time  = parseInt(contract.sell_spot_time);
    is_expired      = contract.is_expired;
    exit_tick_time  = parseInt(contract.exit_tick_time);
    entry_spot      = contract.entry_spot;
    exitTime        = is_sold && sell_time < end_time ? sell_spot_time : end_time;
  }

  // use this instead of BinarySocket.send to avoid overriding the on-message function of trading page
  var socketSend = function(req) {
      if(!req) return;
      if(!req.hasOwnProperty('passthrough')) {
          req.passthrough = {};
      }
      // send dispatch_to to help socket.js forward the correct response back to here
      req.passthrough['dispatch_to'] = 'ViewChartWS';
      BinarySocket.send(req);
  };

  var dispatch = function(response) {
    if(response.echo_req.hasOwnProperty('passthrough') && response.echo_req.passthrough.dispatch_to === 'ViewChartWS') {
      var type = response.msg_type,
          error = response.error;
      var contract = window.contract;
      initialize_values(contract);
      if (type === 'contracts_for' && (!error || (error && error.code && error.code === 'InvalidSymbol'))) {
          if (response.contracts_for && response.contracts_for.feed_license && response.contracts_for.feed_license === 'delayed') {
            if (!window.contract.is_expired) {
              window.request.end = 'latest';
            }
            delete window.request.subscribe;
            window.delayed = true;
          } else {
            window.delayed = false;
          }
          if (!contract.entry_tick_time && window.delayed === false && contract.date_start && parseInt((window.time._i/1000)) >= parseInt(contract.date_start)) {
            show_error('', text.localize('Waiting for entry tick.'));
          } else {
            if (request.subscribe === 1) window.chart_subscribed = true;
            socketSend(window.request);
          }
      } else if ((type === 'history' || type === 'candles' || type === 'tick' || type === 'ohlc') && !error){
          window.responseID = response[type].id;
          // send view popup the response ID so view popup can forget the calls if it's closed before contract ends
          ViewPopupWS.storeSubscriptionID(window.responseID);
          var options  = { 'title' : contract.display_name };
          if (response.history || response.candles) {
            if (response.history) {
                window.tick_type = 'history';
                options.history = response.history;
                if (options.history.times.length === 0) {
                  show_error('missing');
                  return;
                }
                if (response.history.times) {
                  for (i = 0; i < response.history.times.length; i++) {
                      if (contract.entry_tick_time && parseInt(response.history.times[i]) === parseInt(contract.entry_tick_time)) {
                          // set the chart to display from the tick before entry_tick_time
                          window.min = parseInt(response.history.times[i-1]);
                          break;
                      } else if (contract.purchase_time && start_time > parseInt(contract.purchase_time) && (parseInt(response.history.times[i]) === parseInt(contract.purchase_time) || (parseInt(response.history.times[i]) < parseInt(contract.purchase_time) && parseInt(response.history.times[i+1]) > parseInt(contract.purchase_time)))) {
                          // set the chart to display from the tick before purchase_time
                          window.min = parseInt(response.history.times[i-1]);
                          break;
                      }
                  }
                  if (!window.min || window.min === '') {
                    window.min = response.history.times[0];
                  }
                }
                get_max_history(contract, response);
            } else if (response.candles) {
                window.tick_type = 'candles';
                options.candles = response.candles;
                if (options.candles.length === 0) {
                  show_error('missing');
                  return;
                }
                for (i = 0; i < response.candles.length; i++) {
                    if (contract.entry_tick_time && response.candles[i] && parseInt(response.candles[i].epoch) <= parseInt(contract.entry_tick_time) && response.candles[i+1].epoch > parseInt(contract.entry_tick_time)) {
                        // set the chart to display from the candle before entry_tick_time
                        window.min = response.candles[i-1].epoch;
                        break;
                    } else if (contract.purchase_time && response.candles[i] && parseInt(response.candles[i].epoch) <= parseInt(contract.purchase_time) && response.candles[i+1].epoch > parseInt(contract.purchase_time)) {
                        // set the chart to display from the candle before purchase_time
                        window.min = response.candles[i-1].epoch;
                        break;
                    }
                }
                get_max_candle(contract, response);
            }
            window.entry_time = entry_tick_time;
            // start_time and exit_time are used in displaying the color zones
            window.start_time = start_time;
            if (is_sold && sell_time && sell_time < end_time) {
              window.exit_time = sell_spot_time;
            } else if (exit_tick_time) {
              window.exit_time = exit_tick_time;
            } else {
              window.exit_time = end_time;
            }
            // only initialize chart if it hasn't already been initialized
            if (!window.chart && !initialized) {
              window.chart = init_chart(options);
              if(!window.chart) return;

              if (purchase_time !== start_time) draw_line_x(purchase_time, 'Purchase Time', '', '', '#7cb5ec');

              // second condition is used to make sure contracts that have purchase time
              // but are sold before the start time don't show start time
              if (!is_sold || (is_sold && sell_time && sell_time > start_time)) {
                draw_line_x(start_time);
              }

              var duration = calculate_granularity(end_time, now_time, purchase_time, start_time)[1];

              // show end time before contract ends if duration of contract is less than one day
              // second OR condition is used so we don't draw end time again if there is sell time before
              if (end_time - (start_time || purchase_time) <= 24*60*60 && (!is_sold || (is_sold && sell_time && sell_time >= end_time))) {
                draw_line_x(end_time, '', 'textLeft', 'Dash');
              }
              if (contract.barrier) {
                  window.chart.addPlotLineY({id: 'barrier', value: contract.barrier*1, label: 'Barrier (' + contract.barrier + ')'});
              } else if (contract.high_barrier && contract.low_barrier) {
                  window.chart.addPlotLineY({id: 'high_barrier', value: contract.high_barrier*1, label: 'High Barrier (' + contract.high_barrier + ')'});
                  window.chart.addPlotLineY({id: 'low_barrier', value: contract.low_barrier*1, label: 'Low Barrier (' + contract.low_barrier + ')'});
              }
            }
          } else if (response.tick || response.ohlc) {
            if (response.tick) {
              options.tick = response.tick;
            } else if (response.ohlc) {
              window.tick_type = 'candles';
              options.ohlc = response.ohlc;
            }
            if (!entry_tick_time) {
              update_barrier(options);
            }
            if (window.chart && window.chart.series) {
              update_chart(contract, options);
            }
          }
          if (window.entry_time) {
            select_entry_tick(window.entry_time);
            if (window.chart) {
              // now that we have the updated value of entry tick,
              // we have to update the color zones with the correct entry_tick_time value
              // instead of the vague start_time
              window.chart.series[0].zones[0].value = parseInt(window.entry_time)*1000;
              // force to redraw:
              window.chart.isDirty = true;
              window.chart.redraw();
            }
          }
          if (is_sold || is_expired) {
            if (sell_time && sell_time < end_time) {
              window.exit_time = sell_spot_time;
              window.is_sold = 'true';
              if (window.chart) window.chart.xAxis[0].setExtremes(window.min ? window.min*1000 : null, (sell_time*1 + 3)*1000);
            } else if (exit_tick_time) {
              window.exit_time = exit_tick_time;
            }
            if (window.chart) {
              // also update color zone of exit_time
              window.chart.series[0].zones[1].value = parseInt(window.exit_time)*1000;
              // force to redraw:
              window.chart.isDirty = true;
              window.chart.redraw();
            }
            end_contract(contract);
          }
      } else if (type === 'ticks_history' && error) {
          show_error('', error.message);
      }
    }
  };

  function show_chart(contract, update) {
      window.contract = contract;
      if (!update) {
        initialized = false;
      }
      if (!window.chart && (!window.chart_subscribed || window.chart_subscribed === '')) {
        request_data(window.contract);
      } else if (contract.entry_tick_time && window.chart) {
        select_entry_tick(contract.entry_tick_time);
        if (window.chart) {
          window.chart.series[0].zones[0].value = parseInt(contract.entry_tick_time)*1000;
          window.chart.isDirty = true;
          window.chart.redraw();
        }
      }
      if ((contract.sell_spot_time || contract.exit_tick_time) && window.chart) {
        if (contract.sell_time && contract.sell_time < contract.date_expiry) {
          window.exit_time = contract.sell_spot_time;
          window.is_sold = 'true';
          if (window.chart) window.chart.xAxis[0].setExtremes(window.min ? window.min*1000 : null, (contract.sell_time*1 + 3)*1000);
        } else if (contract.exit_tick_time) {
          window.exit_time = contract.exit_tick_time;
        }
        if (window.chart && window.exit_time) {
          // also update color zone of exit_time
          window.chart.series[0].zones[1].value = parseInt(window.exit_time)*1000;
          // force to redraw:
          window.chart.isDirty = true;
          window.chart.redraw();
        }
        end_contract(contract);
      }
      return;
  }

  function show_error(type, message) {
    var el = document.getElementById('analysis_live_chart');
    if(!el) return;
    if (type === 'missing') {
      el.innerHTML = '<p class="error-msg">' + text.localize('ticks history returned an empty array') + '</p>';
    } else {
      el.innerHTML = '<p class="error-msg">' + message + '</p>';
    }
  }

  function clear_values() {
    window.max = '';
    window.min = '';
    window.entry_time = '';
    window.exit_time = '';
    window.responseID = '';
    window.tick_type = '';
    window.start_time = '';
    window.chart = '';
    window.request = '';
    window.delayed = '';
    window.is_sold = '';
    window.chart_subscribed = '';
  }

  function request_data(contract) {
    initialize_values(contract);
    var calculateGranularity = calculate_granularity(exitTime, now_time, purchase_time, start_time);
    var granularity = calculateGranularity[0],
        duration    = calculateGranularity[1],
        margin      = 0; // time margin
    margin = granularity === 0 ? Math.max(300, 30*duration/(60*60) || 0) : 3*granularity;

    var request = {
      ticks_history: contract.underlying,
      start: ((purchase_time || start_time)*1 - margin).toFixed(0), /* load more ticks before start */
      end: end_time ? (end_time*1 + margin).toFixed(0) : 'latest',
      style: 'ticks',
      count: 4999, /* maximum number of ticks possible */
      adjust_start_time: 1
    };

    if (is_sold) {
      request.end = sell_spot_time ? (sell_spot_time*1 + margin).toFixed(0) : 'latest';
    }

    if(granularity !== 0) {
      request.granularity = granularity;
      request.style = 'candles';
    }

    if(!contract.is_expired && !contract.sell_spot_time && parseInt((window.time._i/1000)) < end_time && (!window.chart_subscribed || window.chart_subscribed === '')) {
        request.subscribe = 1;
    }

    window.request = request;
    var contracts_response = window.contracts_for;

    if (contracts_response && contracts_response.echo_req.contracts_for === contract.underlying) {
      if (contracts_response.contracts_for.feed_license === 'delayed') {
        if (!window.contract.is_expired) {
          window.request.end = 'latest';
        }
        delete window.request.subscribe;
        window.delayed = true;
      } else {
        window.delayed = false;
      }
      if (!contract.entry_tick_time && window.delayed === false && contract.date_start && parseInt((window.time._i/1000)) >= parseInt(contract.date_start)) {
        show_error('', text.localize('Waiting for entry tick.'));
      } else {
        if (request.subscribe === 1) window.chart_subscribed = true;
        socketSend(window.request);
      }
    } else {
      socketSend({'contracts_for': contract.underlying});
    }
  }

  function update_barrier(options) {
    if (window.chart) {
      if (window.contract.barrier) {
        var barrier;
        if (options.tick) {
          barrier = options.tick.quote;
        } else {
          barrier = window.contract.barrier;
        }
        window.chart.yAxis[0].removePlotLine('barrier');
        window.chart.addPlotLineY({id: 'barrier', value: barrier*1, label: 'Barrier (' + barrier + ')'});
      }
    }
    return;
  }

  // function to set an orange circle on the entry tick
  function select_entry_tick(value) {
    value = parseInt(value);
    if (value && window.tick_type === 'history' && window.chart) {
      var firstIndex = Object.keys(chart.series[0].data)[0];
      for (i = firstIndex; i < chart.series[0].data.length; i++) {
        if (value*1000 === chart.series[0].data[i].x) {
          chart.series[0].data[i].update({marker: {fillColor: '#fff', lineColor: 'orange', lineWidth: 3, radius: 4, states: {hover: {fillColor: '#fff', lineColor: 'orange', lineWidth: 3, radius: 4}}}});
          return;
        }
      }
    }
  }

  // function to set an orange circle on the exit tick
  function select_exit_tick(value) {
    value = parseInt(value);
    if (value && window.tick_type === 'history') {
      for (i = chart.series[0].data.length - 1; i >= 0; i--) {
        if (value*1000 === chart.series[0].data[i].x) {
          chart.series[0].data[i].update({marker: {fillColor: 'orange', lineColor: 'orange', lineWidth: 3, radius: 4, states: {hover: {fillColor: 'orange', lineColor: 'orange', lineWidth: 3, radius: 4}}}});
          return;
        }
      }
    }
  }

  // calculate where to display the maximum value of the x-axis of the chart for line chart
  function get_max_history(contract, response) {
    initialize_values(contract);
    var end;
    if (sell_spot_time && sell_time < end_time) {end = sell_spot_time;}
    else if (exit_tick_time) {end = exit_tick_time;}
    else {end = end_time;}
    if (response.history && response.history.times && (is_expired || is_sold)) {
      for (i = response.history.times.length; i >= 0; i--) {
          if (parseInt(response.history.times[i]) === parseInt(end)) {
              window.max = response.history.times[i+1];
              break;
          }
      }
    } else if (window.delayed) {
      if (parseInt(response.history.times[response.history.times.length - 1]) > start_time) {
        window.max = response.history.times[response.history.times.length - 1];
      } else {
        window.max = start_time;
      }
    } else {
      window.max = end_time.toString();
    }
    return;
  }

  // calculate where to display the maximum value of the x-axis of the chart for candle
  function get_max_candle(contract, response) {
    initialize_values(contract);
    if (sell_spot_time && sell_time < end_time) {end = sell_spot_time;}
    else {end = end_time;}
    if (contract.is_expired || contract.is_sold) {
      for (i = response.candles.length - 2; i >= 0; i--) {
          if (response.candles[i] && parseInt(response.candles[i].epoch) <= end && parseInt(response.candles[i+1].epoch) > end) {
              window.max = parseInt(response.candles[i+1].epoch);
              break;
          }
      }
    } else if (window.delayed) {
      if (parseInt(response.candles[response.candles.length - 1].epoch) > start_time) {
        window.max = parseInt(response.candles[response.candles.length - 1].epoch);
      } else {
        window.max = start_time;
      }
    } else {
      window.max = end_time;
    }
    return;
  }

  function draw_line_x(valueTime, labelName, textLeft, dash, color) {
    if(!window.chart) return;
    var req = {
      value : valueTime*1000
    };
    if (labelName && labelName !== '') req.label = labelName;
    if (textLeft === 'textLeft') req.text_left = true;
    if (dash && dash !== '') req.dashStyle = dash;
    if (color) req.color = color;
    window.chart.addPlotLineX(req);
  }

  // function to draw the last line needed and forget the streams
  // also sets the exit tick
  function end_contract(contract) {
    initialize_values(contract);
    if (window.chart) {
      if (exit_tick_time || is_expired || sell_time) {
        if (sell_time && sell_time < end_time) {
          window.is_sold = 'true';
          draw_line_x(sell_time, '', 'textLeft', 'Dash');
        } else if (sell_time && sell_time >= end_time) {
          draw_line_x(end_time, '', 'textLeft', 'Dash');
        }
      }
      if (sell_spot_time && sell_spot_time < end_time && sell_spot_time >= start_time) {
        select_exit_tick(sell_spot_time);
      } else if (exit_tick_time) {
        select_exit_tick(exit_tick_time);
      }
    }
    if (window.responseID) {
      BinarySocket.send({'forget':window.responseID});
    }
    if (sell_time) {
      clear_values();
    }
  }

  function calculate_granularity(end_time, now_time, purchase_time, start_time) {
    var duration = Math.min(end_time*1, now_time) - (purchase_time || start_time);
    var granularity = 0;
    if(duration <= 60*60) { granularity = 0; } // 1 hour
    else if(duration <= 2*60*60) { granularity = 120; } // 2 hours
    else if(duration <= 6*60*60) { granularity = 600; } // 6 hours
    else if(duration <= 24*60*60) { granularity = 900; } // 1 day
    else if(duration <= 24*5*60*60) { granularity = 3600; } // 5 days
    else if(duration <= 24*30*60*60) { granularity = 14400; } // 30 days
    else { granularity = 86400; } // more than 30 days
    window.granularity = granularity;
    return [granularity, duration];
  }

  // add the new data to the chart
  function update_chart(contract, options){
    initialize_values(contract);
    var granularity = calculate_granularity(exitTime, now_time, purchase_time, start_time)[0];
    var series = window.chart.series[0];
    var last = series.data[series.data.length - 1];
    if(granularity === 0) {
      window.chart.series[0].addPoint([options.tick.epoch*1000, options.tick.quote*1]);
    } else {
      var c = options.ohlc;
      var ohlc = [c.open_time*1000, c.open*1, c.high*1, c.low*1, c.close*1];

      if(last.x !== ohlc[0]) {
        series.addPoint(ohlc, true, true);
      }
      else {
        last.update(ohlc,true);
      }
    }
    if (last.x > end_time*1000 || last.x > sell_time*1000) {
      end_contract(contract);
    }
    return;
  }

  return {
    show_chart   : show_chart,
    dispatch     : dispatch,
    clear_values : clear_values
  };
}());
;var live_chart;
var chart_closed;
var ticks_array = [];


function updateLiveChart(config) {
    if (live_chart) {
        if (!chart_closed) {
            live_chart.close_chart();
        }
        live_chart = null;
    }

    if (config.resolution == 'tick') {
        live_chart = new LiveChartTick(config);
    } else {
        live_chart = new LiveChartOHLC(config);
    }
    live_chart.show_chart();
    chart_closed = false;
}

var LiveChart = function(config) {
    //Required for inheritence.
    if (!config) return;

    this.config = config;
    this.shift = false;
    if (!config.trade_visualization) {
        this.on_duration_change();
        this.highlight_duration();
    }
};

LiveChart.prototype = {
    show_chart: function() {
        $('.notice').hide();
        this.chart = new Highcharts.StockChart(this.chart_params());
        this.chart.showLoading();
    },
    close_chart: function() {
        $(".live_charts_stream_button").off('click');
        if (this.ev) {
            this.ev.close();
        }

        if (!chart_closed && live_chart) {
            if (this.chart) {
                this.chart.destroy();
            }
            chart_closed = true;
            live_chart = null;
        }
    },
    add_indicator: function(indicator) {
        this.config.add_indicator(indicator);
        indicator.paint(this);
    },
    remove_indicator: function(name) {
        var indicator = this.config.remove_indicator(name);
        if(indicator) {
            indicator.remove(this);
        }
    },
    exporting_menu: function() {
        var $self = this;
        var menuItems = [];

        var defaultOptions = Highcharts.getOptions();
        var defaultMenu = defaultOptions.exporting.buttons.contextButton.menuItems;
        for (var i=0; i<defaultMenu.length; i++) {
            menuItems.push(defaultMenu[i]);
        }

        return menuItems;
    },
    connect_to_stream: function() {
        var $self = this;
        var url = window.location.protocol + "//" + this.config.streaming_server;
        var end = this.config.to ? "/" + this.config.to : "";
        url += "/stream/ticks/" + this.config.symbol.symbol + "/" + this.config.from + end + "?adjust_start_time=1&with_trades=" + this.config.with_trades;
        if (this.config.resolution != 'tick') {
            url += "&ohlc=" + this.config.resolution;
        }
        this.ev = new EventSource(url, { withCredentials: true });
        this.ev.onmessage = function(msg) {
            $self.process_message(msg);
        };
        this.ev.onerror = function() { $self.ev.close(); };
    },
    process_contract: function(trade) {
        if (!this.tradeSeries) {
            this.tradeSeries = this.chart.addSeries({
                name: "Contracts",
                type: "flags",
                data: [],
                onSeries: 'primary_series',
                shape: "circlepin",
                includeInCSVExport: false,
            }, false, false);
        }
        var epoch = 1000 * parseInt(trade.start_time);
        var text = "Contract ID: " + trade.buy_id + "<br>" + trade.long_code;
        var color = "white";
        if (trade.is_sold) {
            if (trade.won) {
                text += "<br>Result: Won";
                color = "green";
            } else {
                text += "<br>Result: Lost";
                color = "red";
            }
        }
        var cpoint = {
            x: epoch,
            title: "C",
            fillColor: color,
            text: text
        };
        this.tradeSeries.addPoint(cpoint, false, false, false);
    },
    chart_params: function() {
        var $self = this;
        var chart_params = {
            chart: {
                height: this.config.renderHeight,
                renderTo: this.config.renderTo,
                events: {
                    load: function() { $self.connect_to_stream(); }
                }
            },
            credits: {
                enabled: false
            },
            exporting: {
                buttons: {
                    contextButton: {
                        menuItems: this.exporting_menu()
                    }
                },
                enabled: true
            },
            plotOptions: {
                series: {
                    dataGrouping: {
                        dateTimeLabelFormats: {
                            millisecond: ['%A, %b %e, %H:%M:%S.%L GMT', '%A, %b %e, %H:%M:%S.%L', '-%H:%M:%S.%L GMT'],
                            second: ['%A, %b %e, %H:%M:%S GMT', '%A, %b %e, %H:%M:%S', '-%H:%M:%S GMT'],
                            minute: ['%A, %b %e, %H:%M GMT', '%A, %b %e, %H:%M', '-%H:%M GMT'],
                            hour: ['%A, %b %e, %H:%M GMT', '%A, %b %e, %H:%M', '-%H:%M GMT'],
                            day: ['%A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
                            week: ['Week from %A, %b %e, %Y', '%A, %b %e', '-%A, %b %e, %Y'],
                            month: ['%B %Y', '%B', '-%B %Y'],
                            year: ['%Y', '%Y', '-%Y']
                        },
                        turboThreshold: 3000
                    },
                    marker: {
                        enabled: this.config.with_markers,
                        radius: 2,
                    },
                },
                candlestick: {
                    turboThreshold: 4000
                }
            },
            xAxis: {
                type: 'datetime',
                min: this.config.from * 1000,
            },
            yAxis: {
                opposite: false,
                labels: {
                    align: 'left',
                    x: 0,
                    formatter: function() { return this.value; }
                },
                title: {
                    text: null
                }
            },
            rangeSelector: {
                enabled: false,
            },
            title: {
                text: this.config.symbol.translated_display_name(),
            },
        };

        if (this.config.with_marker) {
            chart_params.plotOptions.line = {marker: {enabled: true}};
        }

        this.configure_series(chart_params);
        return chart_params;
    },
    process_message: function(message) {
        var data = JSON.parse(message.data);
        if (data.error) {
            this.ev.close();
            return;
        }
        if (data.notice) {
            $("#" + data.notice + "_notice").show();
            return;
        }
        if (!(data[0] instanceof Array)) {
            data = [ data ];
        }

        var data_length = data.length;
        for (var i = 0; i < data_length; i++) {
            this.process_data(data[i]);
        }

        if (data_length > 0 && this.spot) {
            this.config.repaint_indicators(this);
            this.chart.redraw();
            if (!this.navigator_initialized) {
                this.navigator_initialized = true;
                var xData = this.chart.series[0].xData;
                var xDataLen = xData.length;
                if (xDataLen) {
                    this.chart.xAxis[0].setExtremes(xData[0], xData[xDataLen - 1], true, false);
                }
            }
            this.chart.hideLoading();
            this.shift = this.config.shift == 1 ? true : false;
        }
    },
    highlight_duration: function() {
        $('#live_chart_duration').find('.live_charts_stream_button').each( function () {
            $(this).find('span').removeClass('current');
        });

         $('#live_chart_duration li[data-live=' + this.config.live + '] span').addClass('current');
    },
    on_duration_change: function() {
        var that = this;
        $(".live_charts_stream_button").on('click', function() {
            that.config.update({
                live: $(this).data("live"),
                update_url: 1
            });
            that.highlight_duration();
            updateLiveChart(that.config); //Will cause this object to unload.
            var duration_changed = jQuery.Event( "duration_change", { target: this, config: that.config } );
            $('#live_chart_duration').trigger(duration_changed);
        });
    }
};

function LiveChartTick(params) {
    LiveChart.call(this, params);
}

LiveChartTick.prototype = new LiveChart();

LiveChartTick.prototype.constructor = LiveChartTick;
LiveChartTick.prototype.configure_series = function(chart_params) {
        chart_params.chart.type = 'line';

        chart_params.xAxis.labels = { format: "{value:%H:%M:%S}" };
        chart_params.series = [{
            name: this.config.symbol.translated_display_name(),
            data: [],
            dataGrouping: {
                enabled: false
            },
            id: 'primary_series',
            tooltip: {
                xDateFormat: "%A, %b %e, %H:%M:%S GMT"
            },
            type: 'line'
        }];
};

LiveChartTick.prototype.process_data = function(point) {
    if (point[0] == 'tick') {
        var tick = {
            epoch: parseInt(point[1]),
            quote: parseFloat(point[2])
        };

        if (!this.chart) return;
        if (!this.chart.series) return;

        this.chart.series[0].addPoint(
            [tick.epoch * 1000, tick.quote], false, this.shift, false
        );
        this.spot = tick.quote;
        // for tick trade charting purposes
        if (tick.epoch > this.config.contract_start_time && ticks_array.length < this.config.how_many_ticks) {
                ticks_array.push(tick);
        }
    } else if (point[0] == 'contract') {
        this.process_contract(point[1]);
    }
};


function LiveChartOHLC(params) {
    LiveChart.call(this, params);
    this.candlestick = {};
    this.candlestick.period = this.config.resolution_seconds() * 1000;
}

LiveChartOHLC.prototype = new LiveChart();
LiveChartOHLC.prototype.constructor = LiveChartOHLC;

LiveChartOHLC.prototype.configure_series = function(chart_params) {
    chart_params.chart.type = 'candlestick';
    chart_params.series = [{
        name: this.config.symbol.translated_display_name(),
        data: [],
        color: 'red',
        upColor: 'green',
        id: 'primary_series',
        type: 'candlestick',
    }];
};

LiveChartOHLC.prototype.process_data = function(point) {
    var type = point.shift();
    if (type == 'ohlc') {
        this.process_ohlc(point);
    } else if (type == 'tick') {
        if (this.accept_ticks) {
                this.process_tick(point);
        }
    } else if (type == 'corp_action') {
        this.process_corp_action(point);
    } else if (type == 'contract') {
        this.process_contract(point[0]);
    }
};

LiveChartOHLC.prototype.process_corp_action = function(action) {
    if (!this.flagSeries) {
        this.flagSeries = this.chart.addSeries({
            name: "Events",
            type: "flags",
            data: [],
            shape: "flag"
        }, false, false);
    }

    var epoch = 1000 * parseInt(action[0].epoch);
    var text = action[0].description;
    var point = {
        x: epoch,
        title: "CA",
        text: text
    };

    this.flagSeries.addPoint(point, false, false, false);
};

LiveChartOHLC.prototype.process_ohlc = function(ohlc) {
    var epoch = parseInt(ohlc[0]);
    if (!this.chart) return;
    if (!this.chart.series) return;
    var ohlc_pt = {
        x:     epoch * 1000,
        open:  parseFloat(ohlc[1]),
        y:     parseFloat(ohlc[1]),
        high:  parseFloat(ohlc[2]),
        low:   parseFloat(ohlc[3]),
        close: parseFloat(ohlc[4])
    };
    this.chart.series[0].addPoint(ohlc_pt, false, false, false);
    this.spot = ohlc_pt.close;
    this.accept_ticks = true;
};

LiveChartOHLC.prototype.process_tick = function(tickInput) {
    var tick = {
        epoch: parseInt(tickInput[0]) * 1000,
        quote: parseFloat(tickInput[1]),
        squote: tickInput[1]
    };
    this.spot = tick.quote;

    if (!this.chart) return;
    if (!this.chart.series) return;

    var data = this.chart.series[0].options.data;
    if (data.length > 0 && data[data.length - 1].x > (tick.epoch - this.candlestick.period)) {
        var last_ohlc = data[data.length - 1];
        if (tick.quote != last_ohlc.close) {
            last_ohlc.close = tick.quote;
            if (last_ohlc.low > tick.quote)
                last_ohlc.low = tick.quote;
            if (last_ohlc.high < tick.quote)
                last_ohlc.high = tick.quote;

            this.chart.series[0].isDirty = true;
            this.chart.series[0].isDirtyData = true;
        }
    } else {
        /* add new Candlestick */
        var ohlc = {
            x:     tick.epoch,
            open:  tick.quote,
            y:     tick.quote,
            high:  tick.quote,
            low:   tick.quote,
            close: tick.quote
        };
        this.chart.series[0].addPoint(ohlc, false, false, false);
    }
};
;var LiveChartConfig = function(params) {
    params = params || {};
    this.renderTo = params['renderTo'] || 'live_chart_div';
    this.renderHeight = params['renderHeight'] || 450;
    this.shift = typeof params['shift'] !== 'undefined' ? params['shift'] : 1;
    this.with_trades = typeof params['with_trades'] !== 'undefined' ? params['with_trades'] : 1;
    this.streaming_server = page.settings.get('streaming_server');
    this.with_marker = typeof params['with_marker'] !== 'undefined' ? params['with_marker'] : 0;
    this.force_tick = typeof params['force_tick'] !== 'undefined' ? params['force_tick'] : 0;

    this.indicators = [];
    this.resolutions = {
        'tick': {seconds: 0, interval: 3600},
        '1m': {seconds: 60, interval: 86400},
        '5m': {seconds: 300, interval: 7*86400},
        '30m': {seconds: 1800, interval: 31*86400},
        '1h': {seconds: 3600, interval: 62*86400},
        '8h': {seconds: 8*3600, interval: 183*86400},
        '1d': {seconds: 86400, interval: 366*3*86400}
    };
    this.resolution = 'tick';
    this.with_markers = typeof params['with_markers'] !== 'undefined' ? params['with_markers'] : false;

    var res,
        symbol,
        hash = window.location.hash;

    res = hash.match(/^#([A-Za-z0-9_]+):(10min|1h|1d|1w|1m|3m|1y)$/);
    if (res) {
        symbol = markets.by_symbol(res[1]);
        if (symbol) {
            this.symbol = symbol.underlying;
            this.market = symbol.market;
            this.live = res[2];
        }
    } else {
        res = hash.match(/^#([A-Za-z0-9_]+):([0-9]+)-([0-9]+)$/);
        if (res) {
            symbol = markets.by_symbol(res[1]);
            if (symbol) {
                this.symbol = symbol.underlying;
                this.market = symbol.market;
                this.from = parseInt(res[2]);
                this.to = parseInt(res[3]);
                this.resolution = this.best_resolution(this.from, this.to);
            }
        } else {
            symbol = markets.by_symbol(params['symbol']) || markets.by_symbol(LocalStore.get('live_chart.symbol')) || markets.by_symbol('frxAUDJPY');
            this.symbol = symbol.underlying;
            this.market = symbol.market;
            var from = params['from'] || LocalStore.get('live_chart.from');
            var to = params['to'] || LocalStore.get('live_chart.to');
            if (from && to && from != 'null' && to != 'null') {
                this.from = from;
                this.to = to;
                this.resolution = this.best_resolution(this.from, this.to);
            } else {
                this.live = params['live'] || LocalStore.get('live_chart.live') || '10min';
            }
        }
    }

    if (this.live) {
        this.from = this.calculate_from(this.live);
        this.resolution = this.best_resolution(this.from, new Date().getTime()/1000);
    }
};

LiveChartConfig.prototype = {
    add_indicator: function(indicator) {
        this.indicators.push(indicator);
    },
    remove_indicator: function(name) {
        var deleted_indicator;
        var indicator = this.indicators.length;
        while(indicator--) {
            if(this.indicators[indicator].name == name) {
                deleted_indicator = this.indicators[indicator];
                this.indicators.splice(indicator, 1);
            }
        }
        return deleted_indicator;
    },
    has_indicator: function(name) {
        var indicator = this.indicators.length;
        while(indicator--) {
            if(this.indicators[indicator].name == name) {
                return true;
            }
        }
        return false;
    },
    repaint_indicators: function(chart) {
        var indicator = this.indicators.length;
        while(indicator--) {
            this.indicators[indicator].repaint(chart);
        }
    },
    calculate_from: function(len) {
        var now = new Date();
        var epoch = Math.floor(now.getTime() / 1000);
        var units = { min: 60, h: 3600, d: 86400, w: 86400 * 7, m: 86400 * 31, y: 86400 * 366 };
        var res = len.match(/^([0-9]+)([hdwmy]|min)$/);
        
        return res ? epoch - parseInt(res[1]) * units[res[2]] : undefined;
    },
    update: function(opts) {
        if (opts.interval) {
            var from = parseInt(opts.interval.from.getTime() / 1000);
            var to = parseInt(opts.interval.to.getTime() / 1000);
            var length = to - from;
            this.resolution = this.best_resolution(from, to);
            delete opts.interval;
            this.from = from;
            this.to = to;
            delete this.live;
        }
        if (opts.live) {
            delete this.to;
            LocalStore.remove('live_chart.to');
            LocalStore.remove('live_chart.from');
            this.from = this.calculate_from(opts.live);
            this.live = opts.live;
            LocalStore.set('live_chart.live', opts.live);
            this.resolution = this.best_resolution(this.from, new Date().getTime()/1000);
        }
        if (opts.symbol) {
            var symbol = markets.by_symbol(opts.symbol);
            if(symbol) {
                this.symbol = symbol.underlying;
                this.market = symbol.market;
                LocalStore.set('live_chart.symbol', symbol.symbol);
            }
        }

        if(opts.update_url) {
            var hash = "#";

            if (this.from && this.to) {
                hash += this.symbol.symbol + ":" + this.from + "-" + this.to;
            } else {
                hash += this.symbol.symbol + ":" + this.live;
            }

            var url = window.location.pathname + window.location.search + hash;
            page.url.update(url);
        }
        if(opts.shift) {
            this.shift = opts.shift;
        }
        if(opts.with_trades) {
            this.with_trades = opts.with_trades;
        }
        if(opts.with_markers) {
            this.with_markers = opts.with_markers;
        }
        if(opts.force_tick) {
            this.force_tick = opts.force_tick;
        }
    },
    best_resolution: function(from, to) {
        if(this.force_tick) {
            return 'tick';
        }
        var length = parseInt(to - from);
        for(var resolution in this.resolutions) {
            if (this.resolutions[resolution].interval >= length) {
                return resolution;
            }
        }
        return '1d';
    },
    resolution_seconds: function(resolution) {
        resolution = typeof resolution !== 'undefined' ? resolution : this.resolution;
        return this.resolutions[resolution]['seconds'];

    },
};

var configured_livechart = false;
var configure_livechart = function () {
    if(!configured_livechart) {
        Highcharts.setOptions({
            lang: {
                loading:      text.localize('loading...'),
                printChart:   text.localize('Print chart'),
                downloadJPEG: text.localize('Save as JPEG'),
                downloadPNG:  text.localize('Save as PNG'),
                downloadSVG:  text.localize('Save as SVG'),
                downloadPDF:  text.localize('Save as PDF'),
                downloadCSV:  text.localize('Save as CSV'),
                rangeSelectorFrom: text.localize('From'),
                rangeSelectorTo:   text.localize('To'),
                rangeSelectorZoom: text.localize('Zoom'),
                months: [
                    text.localize('January'), text.localize('February'), text.localize('March'), text.localize('April'), text.localize('May'), text.localize('June'),
                    text.localize('July'), text.localize('August'), text.localize('September'), text.localize('October'), text.localize('November'), text.localize('December')
                ],
                shortMonths: [
                    text.localize('Jan'), text.localize('Feb'), text.localize('Mar'), text.localize('Apr'), text.localize('May'), text.localize('Jun'),
                    text.localize('Jul'), text.localize('Aug'), text.localize('Sep'), text.localize('Oct'), text.localize('Nov'), text.localize('Dec')
                ],
                weekdays: [
                    text.localize('Sunday'), text.localize('Monday'), text.localize('Tuesday'), text.localize('Wednesday'),
                    text.localize('Thursday'), text.localize('Friday'), text.localize('Saturday')
                ],
            },
            navigator: {
                series: {
                    includeInCSVExport: false
                }
            }
        });
    }
    configured_livechart = true;
};
;function DateTimePicker(params) {
    var $self = this;
    this.date_inp = "#" + params.id + "_date";
    this.time_inp = "#" + params.id + "_time";
    this.minDateTime = params.minDateTime || new Date(2010, 1, 1);
    this.maxDateTime = params.maxDateTime || new Date();
    this.onChange = params.onChange || function() {};
    $(this.date_inp).datepicker({
        minDate: this.minDateTime,
        maxDate: this.maxDateTime,
        dateFormat: "yy-mm-dd",
        monthNames: [text.localize('January'), text.localize('February'), text.localize('March'), text.localize('April'), text.localize('May'), text.localize('June'),
                     text.localize('July'), text.localize('August'), text.localize('September'), text.localize('October'), text.localize('November'), text.localize('December') ],
        dayNamesShort: [text.localize('Su'), text.localize('Mo'), text.localize('Tu'), text.localize('We'),
                        text.localize('Th'), text.localize('Fr'), text.localize('Sa')],
                nextText: text.localize('Next'),
                prevText: text.localize('Previous'),
    });
    $(this.date_inp).change(function() {
        var date = $self.getDateTime();
        if (date < $self.minDateTime)
            $self.setDateTime($self.minDateTime);
        else if (date > $self.maxDateTime)
            $self.setDateTime($self.maxDateTime);
        $self.onChange($self.getDateTime());
    });
    $(this.time_inp).change(function() {
        if(!$(this).val().match(/^([01][0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/)) {
            $(this).val("00:00:00");
        }
        var date = $self.getDateTime();
        if (date < $self.minDateTime)
            $self.setDateTime($self.minDateTime);
        else if (date > $self.maxDateTime)
            $self.setDateTime($self.maxDateTime);
        $self.onChange($self.getDateTime());
    });
}

DateTimePicker.prototype = {
    getDateTime: function() {
        var date = $(this.date_inp).val().match(/^(\d\d\d\d)-(\d\d)-(\d\d)$/);
        if (!date) return null;
            var year = date[1], month = date[2], day = date[3];
        var time = $(this.time_inp).val().match(/^([01][0-9]|2[0-3]):([0-5]\d)(:([0-5]\d))?$/);
        var hour = 0, minute = 0, second = 0;
        if (time) {
            hour = time[1];
            minute = time[2];
            second = time[3] ? time[4] : 0;
        }
        return new Date(Date.UTC(year, month - 1, day, hour, minute, second));
    },
    setDateTime: function(date) {
        var dateStr = date.getUTCFullYear() + "-" + (date.getUTCMonth() + 1) + "-" + date.getUTCDate();
        $(this.date_inp).datepicker("setDate", dateStr);
        var hours = date.getUTCHours() || 0;
        if (hours < 10) hours = '0' + hours;
            var minutes = date.getUTCMinutes() || 0;
        if (minutes < 10) minutes = '0' + minutes;
            var seconds = date.getUTCSeconds() || 0;
        if (seconds < 10) seconds = '0' + seconds;
            $(this.time_inp).val(hours + ':' + minutes + ':' + seconds);
        this.onChange(this.getDateTime());
    },
    setMinDateTime: function(date) {
        this.minDateTime = date;
        if (this.getDateTime < date) {
            this.setDateTime(date);
        }
        $(this.date_inp).datepicker("option", "minDate", date);
    },
    setMaxDateTime: function(date) {
        this.maxDateTime = date;
        if (this.getDateTime > date) {
            this.setDateTime(date);
        }
        $(this.date_inp).datepicker("option", "maxDate", date);
    },
    clear: function() {
        $(this.date_inp).val("");
        $(this.time_inp).val("");
    }
};
;var LiveChartIndicator = {};
LiveChartIndicator['Barrier'] = function(params) {
    this.name = params['name'];
    this.value = typeof params['value'] !== 'object' ? parseFloat(params['value']) : params['value'];
    this.color = params['color'] || 'blue';
    this.width = params['width'] || 2;
    this.id = 'barrier_' + this.name;
    this.is_relative = /^[+-]/.test(params['value']);
    this.painted = false;
    this.label = params['label'] || '';
    this.axis = params['axis'] || 'y';
    this.nomargin = params['nomargin'] || false;
};


LiveChartIndicator['Barrier'].prototype = {
    remove: function(that) {
        if(!that.chart){
            return;
        }
        if (this.axis == 'y') {
            if(!that.chart.yAxis){
                return;
            }
            that.chart.yAxis[0].removePlotLine(this.id);
        } else {
            if(!that.chart.xAxis){
                return;
            }
            that.chart.xAxis[0].removePlotLine(this.id);
        }
    },
    repaint: function(that) {
        if (this.is_relative || !this.painted) {
            this.remove(that);
            this.paint(that);
            return true;
        }

        return false;
    },
    paint: function(that) {
        var value = this.value;
        if (this.is_relative) {
            if (that.spot) {
                value = that.spot + value;
            } else {
                return;
            }
        }

        var plot_option = { value: value, color: this.color, width: this.width, id: this.id };
        if (this.label) {
            if (this.axis == 'x') {
                if(this.nomargin) {
                    plot_option.label = {text: text.localize(this.label), verticalAlign: 'middle', textAlign: 'center' };
                } else {
                    plot_option.label = {text: text.localize(this.label), verticalAlign: 'middle', x: -10, textAlign: 'center' };
                }
            } else {
                plot_option.label = {text: text.localize(this.label), align: 'center'};
            }
        }
        if (!that.chart) {
            return;
        }
        if (this.axis == 'y') {
            if (!that.chart.yAxis) {
                return;
            }
            that.chart.yAxis[0].addPlotLine(plot_option);
        } else {
            if (!that.chart.xAxis) {
                return;
            }
            that.chart.xAxis[0].addPlotLine(plot_option);
        }
        this.painted = true;
    }
};
;/*
 * Make sure data js is loaded before this
 * else website will not work properly
 * objects texts_json, markets_list, markets_json
 * should be available
 */

// make texts object as Localizable
var texts = {};
for (var key in texts_json) {
    if (texts_json.hasOwnProperty(key)) {
        texts[key] = new Localizable(texts_json[key]);
    }
}

// make markets object
var markets = new Markets(markets_list, markets_json);
;init_pjax(); //Pjax-standalone will wait for on load event before attaching.
$(function() { onLoad.fire(); });
;// json to hold all the events loaded on trading page
var trade_event_bindings = {};

function confirm_popup_action() {

    $('.bom_confirm_popup_link').on('click', function (e){
        e.preventDefault();
        $.ajax({
            type: 'GET',
            url: this.href,
            data: 'ajax_only=1',
            success: function (html) {
                SpotLight.set_content(html);
                SpotLight.show();
            }
        });
    });
}

var hide_payment_agents = function() {
    var language = page.language();
    if(language == 'JA') {
        $('.payment_agent_methods').addClass('invisible');
    }
};

function get_login_page_url() {
    var params = '';
    try {
        var lang = page.language();
        if (!lang) {
            throw new Error("failed to detect page language");
        }
        params += '?l=' + lang;
    } catch (e) {
        console.log("error while getting page language. " + e);
    }
    return 'https://' + page.settings.get('domains')['private'] + '/login' + params;
}

onLoad.queue_for_url(confirm_popup_action, 'my_accountws|confirm_popup');
onLoad.queue_for_url(hide_payment_agents, 'cashier');

onLoad.queue_for_url(function() {
    $('div.further-info')
    .children('div').hide().end()
    .children('a').click(function() {
        $(this).siblings('div').toggle();
        return false;
    });
}, '/c/paymentagent_list');
;var trade_contract_back = function () {
    $('#find_another_contract').on('click', function (e) {
        if (page.url.history_supported) {
            e.preventDefault();
            window.history.back();
        }
    }).addClass('unbind_later');
};

var toggleStreaming = function() {
   if (document.hidden || document.webkitHidden) {
       BetForm.spot.clear();
       BetPrice.streaming.stop();
       BetPrice.order_form.hide_buy_button();
   } else {
       BetPrice.streaming.start();
   }
};

pjax_config_page('/trade.cgi', function() {
    return {
        onLoad: function() {
            page.client.check_storage_values();
            trade_contract_back();
            BetForm.init();
            BetAnalysis.register_actions();
            BetForm.restore();
            if (typeof document.webkitHidden !== 'undefined') {
                if (document.addEventListener) {
                    document.addEventListener("webkitvisibilitychange", toggleStreaming, false);
                }
            } else if (typeof document.hidden !== 'undefined') {
                if (document.addEventListener) {
                    document.addEventListener("visibilitychange", toggleStreaming);
                }
            }
            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "history") {
                            TradingAnalysis.digit_info().show_chart(response.echo_req.ticks_history, response.history.prices);
                            $('[name=underlying_symbol]').on('change', function(e){
                                $('[name=underlying]').val($('[name=underlying_symbol] option:selected').val());
                            });
                        } else if (response.msg_type === "active_symbols") {
                            Symbols.details(response);
                            var underlying = $('[name=underlying_symbol] option:selected').val() || $('#underlying option:selected').val();
                            var tick = $('[name=tick_count]').val() || 100;
                            TradingAnalysis.set_digit_info(TradingAnalysis.tab_last_digitws);
                            var request = JSON.parse('{"ticks_history":"'+ underlying +'",'+
                                                      '"end": "latest",'+
                                                      '"count": '+ tick +','+
                                                      '"subscribe": 1,'+
                                                      '"req_id": 2}');
                            BinarySocket.send(request);
                        } else if(response.msg_type === "tick"){
                            TradingAnalysis.digit_info().update_chart(response);
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });
        },
        onUnload: function() {
            BetForm.unregister_actions();
            BetPrice.deregister();
            BetPrice.clear_buy_results();
            BetPrice.streaming.stop();
            BetAnalysis.reset();
            if (typeof document.webkitHidden !== 'undefined') {
                document.removeEventListener("webkitvisibilitychange", toggleStreaming);
            } else if (typeof document.hidden !== 'undefined') {
                document.removeEventListener("visibilitychange", toggleStreaming);
            }
        }
    };
});

pjax_config_page('rise_fall_table', function() {
    var duration_amount;
    var duration_unit;
    return {
        onLoad: function() {
            var trading_time = new BetForm.TradingTime();
            var duration = new BetForm.Time.Duration(trading_time);
            trading_time.init();
            //Perform as if we are pricing R_100 bets.
            trading_time.underlying = function() {
                return 'R_100';
            };

            var selected_duration;
            //We dont want to read/pollute our betform durations.
            trading_time.value = function(value) {
                if(value) {
                    selected_duration = value;
                }

                if(!selected_duration) {
                    var duration = page.url.param('duration_amount');
                    var units = page.url.param('duration_units');
                    if(typeof duration_amount === 'undefined' || typeof duration_amount === 'undefined') {
                        var min_unit = this.min_unit();
                        duration = min_unit.min;
                        unit = min_unit.units;
                    }

                    selected_duration = duration + unit;
                }

                return selected_duration;
            };

            duration.init();
            duration.register();
            duration.update_ui();

            $('#atleast').on('change', function () {
                duration.update_units_select();
                duration.update_ui();
            }).addClass('unbind_later');

            $('#rise_fall_calculate').on('click', function (event) {
                event.preventDefault();
                var calculate_button = this;
                $(this).hide();
                $('#rise_fall_calculating').show();
                var form = $('form[name=rise_fall]').get(0);
                var url = page.url.url_for('resources/rise_fall_table', getFormParams(form));
                $('#rise_fall_prices_div').html('');
                $.ajax({
                    url: url,
                    data: {
                            ajax_only: 1,
                            prices_only:  1,
                        },
                }).done(function(response) {
                    $('#rise_fall_prices_div').html(response);
                    page.url.update(url);
                    $('#rise_fall_calculating').hide();
                    $('#rise_fall_calculate').show();
                });
            }).addClass('unbind_later');
        },
    };
});

pjax_config_page('openpositionsws|trade.cgi|statement|f_manager_statement|f_manager_history|' +
    'f_profit_table|profit_table|trading', function() {
    return {
        onLoad: function() {
            BetSell.register();
        },
        onUnload: function() {
            BetSell.cleanup();
        }
    };
});

pjax_config_page('chart_application', function () {
    return {
        onLoad: function () {
            load_chart_app();
        }
    };
});

pjax_config_page('trading', function () {
    return {
        onLoad: function(){TradePage.onLoad();},
        onUnload: function(){TradePage.onUnload();}
    };
});
;var BetAnalysis = function () {
    var tab_change_registered = false;
    var restored = false;
    return {
        reset: function(){
            restored = false;
            this.tab_live_chart.reset();
        },
        register_actions: function () {
            var that = this;
            if(tab_change_registered) {
                return;
            }

            tab_change_registered = true;
            MenuContent.listen_click(function (tab) {
                if (tab.menu.attr('id') == 'betsBottomPage') {
                    that.save(tab);

                    var id = tab.id;
                    var shown_some_tab = false;
                    if (id == 'tab_explanation') {
                        that.tab_explanation.render(tab);
                        shown_some_tab = true;
                    } else if(id == 'tab_last_digit') {
                        Symbols.getSymbols();
                        shown_some_tab = true;
                    } else if(id == 'tab_graph') {
                        that.tab_live_chart.render();
                        shown_some_tab = true;
                    }

                    if(!shown_some_tab) {
                        that.tab_explanation.render(tab);
                    }
                }

                return;
            });
        },
        save: function (tab) {
            SessionStore.set('bet_page.selected_analysis_tab', tab.id);
        },
        restore: function () {
            if(restored) {
                return;
            }
            this.show_tab(SessionStore.get('bet_page.selected_analysis_tab'));
            restored = true;
        },
        show_tab: function(tab) {
            if(!tab || !$('#' . tab)) {
                tab = 'tab_explanation';
            }

            if(!this.is_showing_tab(tab)) {
                MenuContent.trigger({
                    'tab_id': tab
                });
            }
        },
        is_showing_tab: function(tab) {
            return MenuContent.is_tab_selected($('#' + tab));
        },
        was_showing_tab: function(tab) {
            return (SessionStore.get('bet_page.selected_analysis_tab') == tab);
        },
        bet_type_changed: function(bet_type) {
            var saved_anaysis_tab = SessionStore.get('bet_page.selected_analysis_tab');
            if (this.is_showing_tab('tab_explanation')) {
                MenuContent.trigger({
                    'tab_id': saved_anaysis_tab
                });
            }
        },
        underlying_changed: function() {
            var saved_anaysis_tab = SessionStore.get('bet_page.selected_analysis_tab');

            if (this.is_showing_tab('tab_graph')) {
                MenuContent.trigger({
                    'tab_id': saved_anaysis_tab
                });
            }
        },
        duration_changed: function() {
            var saved_anaysis_tab = SessionStore.get('bet_page.selected_analysis_tab');

            if (this.is_showing_tab('tab_graph')) {
                MenuContent.trigger({
                    'tab_id': saved_anaysis_tab
                });
            }
        },
        get_price_data: function (form, div, id) {
            var that = this;
            var daily_prices_url = changeUrlToSameDomain(form.action);
            var daily_prices_params = $(form).serialize()+'&id='+Math.floor(Math.random()*83720);

            var go_button = div.find('span.button');
            go_button.addClass('invisible');
            go_button.after(getImageLink());

            $.ajax(ajax_loggedin({
                url     : daily_prices_url,
                async   : true,
                data    : daily_prices_params,
                success : function (texts) {
                    div.html(texts);
                    that.set_submit_event(id);
                },
            }));
        },
        set_submit_event: function(id) {
           var that = this;
           var div = $('#' + id + '-content');
           var submit_button = div.find('button[type=submit]');
           $(submit_button.closest('form')[0]).on('submit', function (e) {
                e.preventDefault();
                return false;
           });
           submit_button.on('click', function () {
               that.get_price_data($(this).closest('form')[0], div, id);
           });
        },
        tab_explanation: function() {
            return {
                render: function(tab) {
                    var that = this;
                    showLoadingImage(tab.content);
                    $.get(that.url(), function (texts) {
                        tab.content.html(texts);
                    });
                },
                url: function() {
                    var existing_link = $('#tab_explanation').find('a');
                    var url = existing_link.attr('href').replace(/form_name=\w+/,'form_name='+ BetForm.attributes.bet_type());
                    existing_link.attr('href', url);
                    return url;
                }
            };
        }(),
    };
}();
;BetAnalysis.Portfolio = (function() {

  var $portfolio;

  function init() {
    var user = new User();

    if (user.email && isJapanTrading()) {
      $('#tab_portfolio').removeClass('invisible');
    }

    var $container = $('#tab_portfolio-content');
    $portfolio = $portfolio || $('#portfolio');

    if ($portfolio &&
      (!$('#portfolio').parent().length ||
        $('#portfolio').parent().get(0).id !== 'tab_portfolio-content')) {
      $portfolio.detach();
      $container.append($portfolio);
    }
  }

  function show() {
    if (isJapanTrading()) {
      PortfolioWS.init();
    }

    return;
  }

  function hide() {
    if (isJapanTrading()) {
      PortfolioWS.onUnload();
    }

    return;
  }

  return {
    init: init,
    show: show,
    hide: hide,
  };
})();

;BetAnalysis.JapanInfo = function() {

    this.show = this.hide = function(){};
    
    if (isJapanTrading() && $('#all_prices').length) {
        $('#tab_japan_info').removeClass('invisible');
    } else {
        return;
    }

    var $container = $('#tab_japan_info-content');
    var $rows = {};
    var socket;

    if (!$container.length) {
        return;
    }

    var add_header = function() {
        var names = Contract.contractType()[Contract.form()];
        var ask, bid;
        for (var i = 0; i < Object.keys(names).length; i++) {
            var pos = contractTypeDisplayMapping(Object.keys(names)[i]);
            if (pos === 'top') {
                ask = names[Object.keys(names)[i]];
            } else if (pos === 'bottom') {
                bid = names[Object.keys(names)[i]];
            }
        }
        var $header = $('<div />', {
            'class': 'grd-parent grd-grid-12 grd-centered table-header grd-row-padding'
        }).append(
            $('<div />', {
                'class': 'grd-grid-4 center-aligned',
                'text': Content.localize().textExercisePeriod
            }),
            $('<div />', {
                'class': 'grd-grid-4 center-aligned',
                'text': ask
            }),
            $('<div />', {
                'class': 'grd-grid-4 center-aligned',
                'text': bid
            })
        );
        $container.append($header);
    };

    var add_row = function(barrier, id, ask, bid) {
        $rows[id] = $('<div />', {
            'class': 'grd-parent grd-grid-12 grd-centered table-body table-body-lines grd-row-paddingd',
        }).append(
            $('<div />', {
                'class': 'grd-grid-4 center-aligned',
                'text': barrier
            }),
            $('<div />', {
                'class': 'grd-grid-4 center-aligned ask',
                'text': ask
            }),
            $('<div />', {
                'class': 'grd-grid-4 center-aligned bid',
                'text': bid
            })
        );
        $container.append($rows[id]);
    };

    var update_ask = function(id, ask) {
        if (!$rows[id]) {
            return;
        }
        $rows[id].find('.ask').text(ask);
    };

    var update_bid = function(id, bid) {
        if (!$rows[id]) {
            return;
        }
        $rows[id].find('.bid').text(bid);
    };

    var clean = function() {
        $container.text('');
        $rows = {};
    };

    var request_prices = function() {
        var barriers1 = Periods.barriers1();
        var barriers2 = Periods.barriers2();

        var types = Contract.contractType()[Contract.form()];

        var period = $('#period').val();
        var p = period.match(/^\d+_(\d+)$/);

        var proposal = {
            'proposal': 1,
            'amount': 1000,
            'basis': 'payout',
            'currency': $('#currency').val(),
            'symbol': $('#underlying').val(),
            'date_expiry': p[1]
        };

        var id = 0;
        if (barriers2.length) {
            for (var i = 0; i < barriers2.length; i++) {
                for (var j = 0; j < barriers1.length; j++) {
                    id++;
                    add_row(barriers2[i] + ' - ' + barriers1[j], id);
                    for (var typeOfContract in types) {
                        if (types.hasOwnProperty(typeOfContract)) {
                            var req = $.extend({}, proposal, {
                                'barrier': barriers1[j],
                                'barrier2': barriers2[i],
                                'contract_type': typeOfContract,
                                'passthrough': {
                                    'form_id': 'japan_barriers',
                                    'id': id
                                }
                            });
                            socket.send(req);
                        }
                    }
                }
            }
        } else {
            for (var d = 0; d < barriers1.length; d++) {
                id++;
                add_row(barriers1[d], id);
                for (var typeOfContract2 in types) {
                    if (types.hasOwnProperty(typeOfContract2)) {
                        var req2 = $.extend({}, proposal, {
                            'barrier': barriers1[d],
                            'contract_type': typeOfContract2,
                            'passthrough': {
                                'form_id': 'japan_barriers',
                                'id': id
                            }
                        });
                        socket.send(req2);
                    }
                }
            }
        }
    };

    var processRes = function(res) {
        if (res.echo_req.passthrough.id && $rows[res.echo_req.passthrough.id]) {
            var position = contractTypeDisplayMapping(res.echo_req.contract_type);
            if (position === 'top') {
                update_ask(res.echo_req.passthrough.id, res.proposal ? res.proposal.ask_price : '-');
            } else if (position === 'bottom') {
                update_bid(res.echo_req.passthrough.id, res.proposal ? res.proposal.ask_price : '-');
            }
        }
    };

    this.show = function() {
        clean();
        add_header();
        if (typeof socket !== 'object' || socket.readyState !== 1) {
            socket = new BinarySocketClass();
            socket.init({
                onopen: function() {
                    request_prices();
                },
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        processRes(response);
                    }
                },

            });
        } else {
            request_prices();
        }

    };

    this.hide = function() {
        if (typeof socket === 'object') {
            socket.close();
        }
    };
};
;BetAnalysis.tab_live_chart = function () {
    var live_chart_initialized = false;
    var invoked_for_websocket  = false;
    return {
        reset: function() {
            if(typeof live_chart !== "undefined") {
                if(live_chart !== null) {
                    live_chart.close_chart();
                    live_chart = null;
                }
            }
        },
        render: function(calledForWebsocketTrading) {
            invoked_for_websocket = calledForWebsocketTrading || false;
            if (live_chart_initialized && $('#live_chart_div').length > 0) {
                this.update_live_chart();
            } else {
                this.get_live_chart();
            }
        },
        get_live_chart: function() {
            if (document.getElementById('underlying')){
                showHighchart();
            } else {
                var that = this;
                $.ajax(ajax_loggedin({
                    url     : '/d/trade_livechart.cgi?l=' + page.language(),
                    dataType: 'html',
                    success : function (data) {
                          that.set_live_chart(data);
                        },
                }));
            }
        },
        set_live_chart: function (data) {
            $('#trade_live_chart').html(data);
            var that = this;
            if(this.load_timer)
                return;

            showLoadingImage($('#live_chart_div'));
            //Waiting for Highcharts to get loaded.
            this.load_timer = setInterval(function(){
                if(typeof Highcharts !== "undefined") {
                    configure_livechart();
                    that.update_live_chart();
                    live_chart_initialized = true;
                    clearInterval(that.load_timer);
                    that.load_timer = undefined;
                }
            }, 80); //Its scientifically proven that humans cannot visualize what they see before 80ms.
        },
        update_live_chart: function () {
            if(this.update_chart_config()) {
                updateLiveChart(this.live_chart_config);
            }

            this.add_spot();
            var that = this;
            if (!invoked_for_websocket) {
                BetForm.barriers.each(function(barrier) { that.add_barrier(barrier); });
            }
        },
        update_chart_config: function() {
            var symbol = invoked_for_websocket ? sessionStorage.getItem('underlying') : BetForm.attributes.underlying();
            var live = SessionStore.get('live_chart_duration') || this.get_duration() || '10min';
            if(!this.live_chart_config) {
                this.live_chart_config = new LiveChartConfig({ renderTo: 'live_chart_div', symbol: symbol, live: live});
                return true;
            }

            var update = {};
            var update_config = false;
            if(this.live_chart_config.live != live) {
                update['live'] = live;
                update_config = true;
            }

            if(this.live_chart_config.symbol.symbol != symbol) {
                update['symbol'] = symbol;
                update_config = true;
            }

            if(update_config) {
                this.live_chart_config.update(update);
            }
            if (!live_chart) {
                update_config = true;
            }
            return update_config;
        },
        add_spot: function() {
            if(live_chart.config.has_indicator('spot')) {
                live_chart.remove_indicator('spot');
            }

            var barrier = new LiveChartIndicator.Barrier({ name: "spot", value: '+0', color: 'blue'});
            live_chart.add_indicator(barrier);
        },
        add_barrier: function(barrier) {
            if(live_chart.config.has_indicator(barrier.component_id)) {
                live_chart.remove_indicator(barrier.component_id);
            }

            barrier = new LiveChartIndicator.Barrier({ name: barrier.component_id, value: barrier.value(), color: 'green'});
            live_chart.add_indicator(barrier);
        },
        get_duration: function () {
            var duration_in_seconds = invoked_for_websocket ? '600' : BetForm.attributes.duration_seconds();
            return $('#live_chart_duration').find('#' + this.corrected_hours_to_chart(duration_in_seconds)).data('live');
        },
        corrected_hours_to_chart: function(chart_duration) {
            var hours, available_hours = [];
            $('.live_charts_stream_button').each(function(){
                available_hours.push(parseInt($(this).attr("id")));
            });
            available_hours.sort(function(a,b) { return a - b; });
            for(hours in available_hours) {
                if(chart_duration <= available_hours[hours]) {
                    return available_hours[hours];
                }
            }
            return 1;
        },
        get_duration_seconds: function (selected_duration) {
           var duration;
           if (selected_duration) {
               duration = selected_duration.replace(/[a-zA-Z]/g, '');
               var duration_unit = selected_duration.replace(/\d+/g, '');

               if(duration_unit == 'min') {
                   return duration * 60;
               } else if(duration_unit == 'h') {
                   return duration * 3600;
               } else if(duration_unit == 'd') {
                   return duration * 86400;
               } else if(duration_unit == 'w') {
                   return duration * 604800;
               } else if(duration_unit == 'm') {
                   return duration * 2592000;
               } else if(duration_unit == 'y') {
                   return duration * 31536000;
               }
           }
           return duration;
        },
        live_chart_config: undefined,
        load_timer: undefined,
    };
}();
;var BetForm = function () {
    return {
        init: function() {
            this.time = (typeof this.time === 'undefined') ? new BetForm.Time() : this.time;
            this.barriers = (typeof this.barriers === 'undefined') ? new BetForm.Barriers() : this.barriers;
            this.actions.init();
            this.actions.register();
        },
        unregister_actions: function() {
            this.actions.unregister();
        },
        restore: function () {
            var bet_type_tab = this.attributes.model.form_name();

            showLoadingImage($('#betInputBox'));
            MenuContent.trigger({
                'tab_id': bet_type_tab
            });
        },
        update_content: function (data, event) {
            var betInputBox = $('#betInputBox');
            betInputBox.get(0).innerHTML = '<div class="toggle-content">' + data + '</div>';
        },
        bom_gmt_time: function() {
            return moment.utc(page.header.time_now);
        },
        error_message: function () {
            BetPrice.error_handler();
        },
        actions: function() {
            var tab_change_registered = false;
            var betform_request = null;
            return {
                init: function() {
                    this.on_bet_type_change();
                },
                register: function() {
                    $(BetForm.spot).on('change', function(event, spot) {
                        BetForm.barriers.spot_changed(spot);
                    });

                    $(BetForm.time).on('change', function(event, time) {
                        SessionStore.remove('live_chart_duration');
                        BetForm.barriers.time_changed(time);
                        BetPrice.container().hide();
                    });


                    $(BetForm.barriers).on('change', function(event, barrier) {
                        BetPrice.container().hide();
                        BetAnalysis.tab_live_chart.render();
                    });


                    var that = this;

                    var when_enter_pressed = function() {
                        //This is required to avoid key bounce causing 3 different enter pressed event
                        if(!that.propagating_enter_pressed) {
                            that.propagating_enter_pressed = setInterval(function(){
                                BetPrice.get_price();
                                clearInterval(that.propagating_enter_pressed);
                                that.propagating_enter_pressed = undefined;
                            }, 100);
                        }
                    };

                    BetForm.attributes.form().on('keydown', function(e) {
                        if(e.which == 13) {
                            when_enter_pressed();
                        }
                    });

                    $(BetForm.time).on('enter_pressed', when_enter_pressed);
                },
                unregister: function() {
                    BetForm.attributes.form().off('keydown');
                    $('#bet_underlying').off('change');
                    $('#submarket').off('change');
                    $('#bet_currency').off('change');
                    $('#atleast').off('change');
                    $(BetForm.spot).off('change');
                    $(BetForm.time).off('change');
                    $(BetForm.time).off('enter_pressed');
                    $(BetForm.barriers).off('change');

                    BetForm.time.unregister();
                    BetForm.barriers.unregister();
                    BetForm.attributes.form().off('submit');
                },
                on_bet_type_change: function() {
                    var that = this;
                    if(tab_change_registered) {
                        return;
                    }

                    tab_change_registered = true;
                    MenuContent.listen_click(function (info) {
                        if (info.menu.attr('id') == 'betsTab') {
                            if(BetForm.attributes.model.form_name() != info.id) {
                                BetForm.attributes.model.form_name(info.id);
                                //If we are already seeing a form, i.e. we are switching forms
                                if(typeof BetForm.attributes.form_name() !== "undefined") {
                                    page.url.invalidate();
                                }
                            }
                            that.get_form_by_name(info.id);
                            BetAnalysis.bet_type_changed();
                        }
                    });
                },
                get_form_by_name: function(form_name) {
                    if(betform_request) {
                        betform_request.abort();
                    }

                    var that = this;
                    betform_request = $.ajax({
                            url     : this.form_url(form_name),
                            success : function (data) {
                                    that.unregister();
                                    BetForm.update_content(data);
                                    betform_request = null;
                                    BetForm.underlying_drop_down.init();
                                    BetForm.attributes.restore.all();
                                    that.on_form_load();
                                },
                    }).fail( function ( jqXHR, textStatus ) {
                        BetForm.error_message();
                    });
                },
                get_form_by_underlying: function (underlying) {
                    if(betform_request) {
                        betform_request.abort();
                    }

                    var that = this;
                    betform_request = $.ajax({
                        url     : this.form_url('', underlying),
                        success : function (data) {
                            that.unregister();
                            BetForm.update_content(data);
                            betform_request = null;
                            BetForm.underlying_drop_down.init();
                            BetForm.attributes.restore.all_but_underlying();
                            that.on_form_load();
                        }
                    }).fail( function ( jqXHR, textStatus ) {
                        BetForm.error_message();
                    });
                },
                on_form_load: function() {
                    this.correct_selected_tab();
                    BetPrice.clear_buy_results();
                    BetForm.time.init();
                    BetForm.barriers.init();

                    BetForm.amount.update_calculation_value();

                    this.show_or_hide_analysis_tabs();

                    this.on_form_submit();
                    this.on_underlying_change();
                    this.on_submarket_change();
                    this.on_amount_change();
                    this.on_amount_type_change();
                    this.on_other_input_change();

                    $('#bet_calculate').focus(); //Focus on the Get Prices button.
                    this.hide_sub_trade();

                    this.register();
                    if(!BetForm.attributes.no_bets()) {
                        BetPrice.get_price();
                    }
                    BetAnalysis.restore();
                },
                hide_sub_trade: function () {
                    var sub_trade_menu = $('#betsTab').children().find('.tm-ul-2');
                    var len = sub_trade_menu.length;
                    for (var i=0; i<len; i++) {
                        var sub_menu_child = sub_trade_menu.eq(i).children();
                        if(sub_menu_child.length == 1) {
                            sub_menu_child.hide();
                        }
                    }
                },
                on_underlying_change: function () {
                    var that = this;
                    if (MenuContent.is_tab_selected($('#tab_graph')) && document.getElementById('underlying')) {
                        setUnderlyingTime();
                    }
                    $('#bet_underlying').on('change', function (event) {
                        BetForm.attributes.model.underlying($(this).val());
                        that.update_for_underlying($(this).val());
                    }).addClass('unbind_later');
                },
                on_submarket_change: function () {
                    var that = this;
                    $('#submarket').on('change', function (event) {
                        BetForm.attributes.model.submarket(this.value);
                        BetForm.underlying_drop_down.update_for_submarket(this.value);
                        //If Underlying Changed because of submarket
                        if (BetForm.attributes.model.underlying() != BetForm.attributes.underlying()) {
                            BetForm.attributes.model.underlying(BetForm.attributes.underlying());
                            that.update_for_underlying(BetForm.attributes.underlying());
                        }
                    }).addClass('unbind_later');
                },
                update_for_underlying: function (underlying_symbol) {
                    BetPrice.streaming.stop();
                    BetForm.spot.clear();
                    this.get_form_by_underlying(underlying_symbol);
                    BetAnalysis.underlying_changed();
                },
                on_other_input_change: function () {
                    $('#bet_currency').on('change', function (event) {
                        BetForm.attributes.model.currency(this.value);
                        $('#bet_calculation_container').hide();
                    }).addClass('unbind_later');
                    $('#atleast').on('change', function () {
                        var selected = this.value;
                        BetForm.attributes.model.start_time(selected);
                        BetForm.time.update_for_start_time_change();
                        $('#bet_calculation_container').hide();
                    }).addClass('unbind_later');
                    $('#stop_type').on('change', function (e) {
                        var selected = $(this).val();
                        $('#stop_type_2').val(selected);
                        BetForm.attributes.model.stop_type(selected);
                        $('#bet_calculation_container').hide();
                    }).addClass('unbind_later');
                    $('#stop_profit').on('change', function (e) {
                        var target = $(this);
                        var selected = BetPrice.spread.validate_change(target);
                        target.val(selected);
                        BetForm.attributes.model.stop_profit(selected);
                        $('#bet_calculation_container').hide();
                    }).addClass('unbind_later');
                    $('#stop_loss').on('change', function (e) {
                        var target = $(this);
                        var selected = BetPrice.spread.validate_change(target);
                        target.val(selected);
                        BetForm.attributes.model.stop_loss(selected);
                        $('#bet_calculation_container').hide();
                    }).addClass('unbind_later');
                    $('#amount_per_point').on('change', function (e) {
                        var target = $(this);
                        var selected = BetPrice.spread.validate_change(target);
                        target.val(selected);
                        BetForm.attributes.model.amount_per_point(selected);
                        $('#bet_calculation_container').hide();
                    }).addClass('unbind_later');
                },
                on_form_submit: function() {
                    BetForm.attributes.form().on('submit', function (event) {
                        event.preventDefault();
                        BetPrice.clear_buy_results();
                        BetPrice.get_price();
                    }).addClass('unbind_later');
                },
                show_or_hide_analysis_tabs: function() {
                    var analysis_tab = BetForm.attributes.extratab();
                    if(analysis_tab == 'last_digit') {
                        // We should show exactly one of these
                        $('#tab_last_digit').removeClass("invisible");
                    } else {
                        // Hide them all if none selected
                        MenuContent.hide_tab($('#tab_last_digit'));
                        MenuContent.trigger({'tab_id': 'tab_explanation'});
                    }
                },
                on_amount_change: function() {
                    BetPrice.clear_buy_results();
                    $('input#amount', BetForm.attributes.form_selector()).on('keyup', BetForm.amount.keyup).addClass('unbind_later');
                    $('input#amount', BetForm.attributes.form_selector()).on('change', BetForm.amount.lost_focus).addClass('unbind_later');
                },
                on_amount_type_change: function() {
                    //Force recalculate minimumss and update price boxes
                    $('#amount_type').on('change', function() {
                        BetForm.amount.lost_focus();
                        BetForm.attributes.model.amount_type(this.value);
                    }).addClass('unbind_later');
                },
                correct_selected_tab: function() {
                    //Wrong tab selected? Select the right one.
                    //Whe wrong tab? Caching, we build the frame before we build the form and sometimes there is no formname attribute in the url.
                    var form_name = BetForm.attributes.form_name();
                    if($('#bets_tab_' + form_name).length > 0 && $('#bets_tab_' + form_name + '.active.tm-li').length === 0) {
                        $('#betsTab .active.tm-li').removeClass('active');
                        $('#bets_tab_' + form_name + '.tm-li').addClass('active');
                    }
                },
                form_url: function (form_name, underlying_symbol) {
                    var params = 'controller_action=bet_form';
                    var market = BetForm.attributes.model.market();
                    if(market != 'null') {
                        params += '&market=' + market;
                    }

                    form_name = form_name ? form_name : BetForm.attributes.model.form_name();
                    if (form_name) {
                        params += '&form_name=' + form_name;
                    }


                    underlying_symbol = underlying_symbol || BetForm.attributes.model.underlying();
                    if (underlying_symbol && markets.by_symbol(underlying_symbol).market.name == market) {
                        params += '&underlying_symbol=' + underlying_symbol;
                    }

                    var time = BetForm.attributes.model.time();
                    if(time) {
                        params += '&time=' + time;
                    }

                    var barrier_1 = BetForm.attributes.model.barrier_1();
                    if(barrier_1) {
                        params += '&H=' + barrier_1;
                    }

                    var barrier_2 = BetForm.attributes.model.barrier_2();
                    if(barrier_2) {
                        params += '&L=' + barrier_2;
                    }

                    var date_start = BetForm.attributes.model.start_time();
                    if(date_start) {
                        params += '&date_start=' + date_start;
                    }

                    var type = page.url.param_if_valid('type');
                    if(type) {
                        params += '&type=' + type;
                    }

                    var expiry_type = BetForm.attributes.model.expiry_type();
                    if (expiry_type) {
                        params += '&expiry_type=' + expiry_type;
                    }

                    var stop_profit = BetForm.attributes.model.stop_profit();
                    if (stop_profit) {
                        params += '&stop_profit=' + stop_profit;
                    }

                    var stop_loss = BetForm.attributes.model.stop_loss();
                    if (stop_loss) {
                        params += '&stop_loss=' + stop_loss;
                    }

                    var amount_per_point = BetForm.attributes.model.amount_per_point();
                    if (amount_per_point) {
                        params += '&amount_per_point=' + amount_per_point;
                    }

                    return page.url.url_for('trade_get.cgi', params);
               },
                disable: function (elements) {
                    var form_ = $(BetForm.attributes.form_selector());
                    form_.find('input[type="submit"]').each(function () {this.disabled = true;});
                    form_.find('button[type="submit"]').each(function () {this.disabled = true;});
                    if (elements) {
                        form_.find('input').each(function () {this.disabled = true;});
                        form_.find('select').each(function () {this.disabled = true;});
                        form_.find('textarea').each(function () {this.disabled = true;});
                        form_.find('button').each(function () {this.disabled = true;});
                    }
                },
                enable: function (elements) {
                    var form_ = $(BetForm.attributes.form_selector());
                    form_.find('input[type="submit"]').each(function () {this.disabled = false;});
                    form_.find('button[type="submit"]').each(function () {this.disabled = false;});
                    if (elements) {
                        form_.find('input').each(function () {this.disabled = false;});
                        form_.find('select').each(function () {this.disabled = false;});
                        form_.find('textarea').each(function () {this.disabled = false;});
                        form_.find('button').each(function () {this.disabled = false;});
                    }
                },
            };
        }(),
        spot: function() {
            var spots = [];
            return {
                update: function(spot) {
                    spots.push(spot);
                    if (spots.length >= 30) {
                        spots.shift();
                    }

                    this.show_spot(spot);
                    $('#spot_spark').sparkline(spots, this.spark_line_config);

                    $(this).trigger('change', [ spot ]);
                },
                show_spot: function(spot) {
                    var spot_container = $('#spot');
                    if(spot && parseFloat(spot) == spot) {
                        var pre_spot = spot;

                        var pre_spot_text = spot_container.text();
                        if (pre_spot_text) {
                            pre_spot = parseFloat(pre_spot_text);
                        }

                        price_moved(spot_container, pre_spot, spot);
                    }
                    spot_container.html(spot);
                },
                clear: function() {
                    this.clear_sparkline();
                    this.show_spot('');
                },
                clear_sparkline: function () {
                    spots = [];
                    $('#spot_spark').sparkline(spots, this.spark_line_config);
                },
                value: function() {
                    return parseFloat(spots[spots.length - 1]);
                },
                spark_line_config: {
                    type: 'line',
                    lineColor: '#606060',
                    fillColor: false,
                    spotColor: '#00f000',
                    minSpotColor: '#f00000',
                    maxSpotColor: '#0000f0',
                    highlightSpotColor: '#ffff00',
                    highlightLineColor: '#000000',
                    spotRadius: 1.25
                },
            };
        }(),
        underlying_drop_down: function() {
            var underlyings_info = [];
            return {
                init: function() {
                    underlyings_info = [];
                    $('#bet_underlying > option').each(function(){
                        var underlying = {};
                        underlying.className = $(this).attr('class');
                        underlying.value = $(this).val();
                        underlying.label = $(this).text();
                        underlyings_info.push(underlying);
                    });
                },
                has: function(underlying_symbol) {
                    for ( var index in underlyings_info ) {
                        if(underlyings_info[index].value == underlying_symbol) {
                            return true;
                        }
                    }

                    return false;
                },
                update_for_submarket: function (submarket) {
                    var index;

                    if (submarket) {
                        var old_value = $('#bet_underlying').val();
                        this.clear();
                        if ( submarket == 'all' ) {
                            var len = underlyings_info.length;
                            for ( index = 0; index < len; index++ ) {
                                this.add(underlyings_info[index]);
                            }
                        } else {
                            var regex_sub_market = new RegExp('\\b'+submarket+'\\b');
                            for ( index in underlyings_info ) {
                                if ( regex_sub_market.test(underlyings_info[index].className) ) {
                                    this.add(underlyings_info[index]);
                                }
                            }
                        }

                        //If nothing was selected try to select the default from backend.
                        if($('#bet_underlying').val() === null) {
                            $('#bet_underlying').val(old_value);
                        }
                    }

                    //If nothing was sent selected by the backend then select the first one.
                    if($('#bet_underlying').val() === null) {
                        $('#bet_underlying').val($('#bet_underlying option:eq(0)').val());
                    }
                },
                clear: function() {
                    $('#bet_underlying option').remove();
                },
                add: function(underlying_info) {
                    var option = this.create_option(underlying_info);
                    var drop_down = document.getElementById("bet_underlying");
                    try {
                        // for IE version less than 8
                        drop_down.add(option, drop_down.options[null]);
                    } catch (e) {
                        drop_down.add(option, null);
                    }
                },
                create_option: function(underlying_info) {
                    var selected_underlying = BetForm.attributes.model.underlying();
                    var option = document.createElement("option");

                    option.className = underlying_info.className;
                    option.value = underlying_info.value;

                    if ( selected_underlying && selected_underlying == underlying_info.value) {
                        option.selected = "selected";
                    }

                    option.text = underlying_info.label;

                    return option;
                }
            };
        }(),
        amount: function() {
            return {
                payout_min:    1,
                payout_max:    100000,
                payout_err:    undefined,
                stake_min:    0.5,
                stake_max:    100000,
                stake_err:    undefined,
                calculation_value: undefined,
                keyup: function(event) {
                    var me = BetForm.amount;
                    me.update_calculation_value();
                    BetForm.attributes.model.amount(me.calculation_value);
                    BetPrice.order_form.update();
                    //No need to panic unless the user actually entered a ','(188).
                    if(event.keyCode == 188) {
                        var amount = $(this).val();
                        $(this).val(amount.replace(',', '.'));
                    }
                },
                lost_focus: function(event) {
                    var me = BetForm.amount;
                    me.update_calculation_value();
                    BetForm.attributes.model.amount(me.calculation_value);
                    BetPrice.order_form.update();
                    $('#amount').val(me.calculation_value);
                },
                update_calculation_value: function() {
                    var amount = BetForm.attributes.amount();
                    if ( this.valid(amount) ) {
                        this.calculation_value = amount;
                    }
                },
                valid: function(amount) {
                    if (isNaN(amount)) {
                        return false;
                    }
                    return true;
                },
                update_settings: function() {
                    this.stake_min = parseFloat($('#staking_context #stake_min').html());
                    this.stake_max = parseFloat($('#staking_context #stake_max').html());
                    this.stake_err = $('#staking_context #stake_err').html();
                    this.payout_min = parseFloat($('#staking_context #payout_min').html());
                    this.payout_max = parseFloat($('#staking_context #payout_max').html());
                    this.payout_err = $('#staking_context #payout_err').html();
                },
            };
        }(),
    };
}();
;BetForm.attributes = function() {
    var selected_settings = {};
    return {
            form: function() {
                return $('form[name=form0]');
            },
            expiry_type: function() {
                return $('[name=expiry_type]', this.form_selector()).val();
            },
            expiry_time: function() {
                return $('[name=expiry_time]', this.form_selector()).val();
            },
            expiry_date: function() {
                return $('[name=expiry_date]', this.form_selector()).val();
            },
            no_bets: function() {
                return ($('#no_bets').length > 0);
            },
            form_selector: function() {
                return $('form[name=form0]').get(0);
            },
            form_name: function() {
                return $('[name=form_name]', this.form_selector()).val();
            },
            bet_type: function() {
                return LocalStore.get('bet_page.form_name');
            },
            prediction: function() {
                return $('[name=prediction]', this.form_selector()).val();
            },
            market: function() {
                return $('[name=market]', this.form_selector()).val();
            },
            submarket: function() {
                return $('[name=submarket]', this.form_selector()).val();
            },
            underlying: function() {
                return $('#bet_underlying', this.form_selector()).val();
            },
            underlying_text: function() {
                return $('#bet_underlying option:selected', this.form_selector()).text();
            },
            spot: function() {
                return $('[name=S]', this.form_selector()).val();
            },
            start_time: function() {
                return $('[name=date_start]', this.form_selector()).val();
            },
            start_time_moment: function() {
                var start_time = this.start_time();
                var now = moment.utc(BetForm.bom_gmt_time());
                if (typeof start_time !== 'undefined' && start_time !== 'now') {
                    now = moment.utc(start_time*1000);
                }

                return now;
            },
            barrier_1: function() {
                return $('#bet_H', this.form_selector()).val();
            },
            barrier_2: function() {
                return $('#bet_L', this.form_selector()).val();
            },
            pip_size: function() {
                return $('[name=pip_size]', this.form_selector()).val();
            },
            barrier_type: function() {
                var barriers = $('[name=H]', this.form_selector()).length + $('[name=L]', this.form_selector()).length;
                if(barriers > 0) {
                    return $('[name=barrier_type]', this.form_selector()).val();
                }
                return;
            },
            duration_container: function() {
                return $('#duration_container', this.form_selector());
            },
            duration_amount: function() {
                return $('#duration_amount', this.form_selector()).val();
            },
            duration_units: function() {
                return $('[name=duration_units]', this.form_selector()).val();
            },
            duration_seconds: function() {
                var duration = parseInt(parseFloat(this.duration_amount()));
                var duration_units = this.duration_units();

                if(duration_units == 'm') {
                    return duration * 60;
                } else if(duration_units == 'h') {
                    return duration * 3600;
                } else if(duration_units == 'd') {
                    return duration * 86400;
                }

                return duration;
            },
            duration_string: function() {
                return this.duration_amount() + this.duration_units();
            },
            minimum_duration_for: function(unit) {
                var duration_container = this.duration_container();
                var minimums = duration_container.find('.' + unit);
                if(minimums.html()) {
                    return parseInt(parseFloat(minimums.html().split(':')[1]));
                }

                return;
            },
            currency: function() {
                return $('[name=currency]', this.form_selector()).val();
            },
            amount: function() {
                var amount_str =  $('#amount', BetForm.attributes.form_selector()).val();
                if(amount_str) {
                    amount_str = amount_str.replace(',', '.');
                    amount_str = amount_str.replace(/[^\d\.]/g, '');
                }
                var amount_f = parseFloat(amount_str);
                var amount = 0;
                if (!isNaN(amount_f) && amount_f > 0) {
                    // only keep the first 2 digits of the floating value, and only 2
                    amount_f = Math.round(amount_f * 100) / 100;
                    var amount_int = Math.floor(amount_f);
                    var float_val = amount_f - amount_int;
                    if (float_val) {
                        amount = amount_f.toFixed(2);
                    } else {
                        amount = amount_int;
                    }
                }
                return amount;
            },
            is_amount_payout: function() {
                return ($('#amount_type').val() == "payout");
            },
            is_amount_stake: function() {
                return ($('#amount_type').val() == "stake");
            },
            amount_type: function() {
                return $('#amount_type', this.form_selector()).val();
            },
            extratab: function() {
                return ($('input[name="extratab"]', this.form_selector()).val());
            },
            is_forward_starting: function() {
                return (this.start_time() && this.start_time().match(/^\d+$/));
            },
            can_select: function (selector, value) {
                if ($('#'+selector+' option[value="'+value+'"]').length > 0) {
                    return true;
                } else {
                    return false;
                }
            },
            model: function() {
                return {
                    form_name: function(form_name) {
                        var fallback = 'bets_tab_callput';
                        if(form_name) {
                            LocalStore.set('bet_page.form_name', form_name);
                        }

                        form_name = this.get_setting_or_param('bet_page.form_name', 'form_name') || fallback;
                        if(!$('#' + form_name).length) {
                            form_name = fallback;
                        }

                        return form_name;
                    },
                    market: function() {
                        var market = page.url.param_if_valid('market');
                        if (market) {
                            LocalStore.set('bet_page.market', market);
                        }
                        return page.url.param_if_valid('market') || LocalStore.get('bet_page.market') || 'forex';
                    },
                    underlying: function(underlying) {
                        var for_market = this.market();
                        if(underlying) {
                            for_market = markets.by_symbol(underlying).market.name;
                            LocalStore.set('bet_page.underlying.'+for_market, underlying);
                            page.url.invalidate();
                        }

                        return page.url.param_if_valid('underlying_symbol') || LocalStore.get('bet_page.underlying.'+for_market);
                    },
                    submarket: function(submarket) {
                        if(submarket) {
                            LocalStore.set('bet_page.submarket', submarket);
                            page.url.invalidate();
                        }

                        return LocalStore.get('bet_page.submarket');
                    },
                    start_time: function(start_time) {
                        if(start_time) {
                            LocalStore.set('bet_page.start_time', start_time);
                            page.url.invalidate();
                        }

                        return this.get_setting_or_param('bet_page.start_time', 'date_start');
                    },
                    stop_type: function(stop_type) {
                        if (stop_type) {
                            LocalStore.set('bet_page.stop_type', stop_type);
                            page.url.invalidate();
                        }

                        return page.url.param_if_valid('stop_type') || LocalStore.get('bet_page.stop_type') || 'point';
                    },
                    stop_loss: function(stop_loss) {
                        if (stop_loss) {
                            LocalStore.set('bet_page.stop_loss', stop_loss);
                            page.url.invalidate();
                        }

                        return page.url.param_if_valid('stop_loss') || LocalStore.get('bet_page.stop_loss') || 10;
                    },
                    stop_profit: function(stop_profit) {
                        if (stop_profit) {
                            LocalStore.set('bet_page.stop_profit', stop_profit);
                            page.url.invalidate();
                        }

                        return page.url.param_if_valid('stop_profit') || LocalStore.get('bet_page.stop_profit') || 10;
                    },
                    amount_per_point: function(amount_per_point) {
                        if (amount_per_point) {
                            LocalStore.set('bet_page.amount_per_point', amount_per_point);
                            page.url.invalidate();
                        }

                        return page.url.param_if_valid('amount_per_point') || LocalStore.get('bet_page.amount_per_point') || 1;
                    },
                    expiry_type: function(expiry_type) {
                        if (expiry_type) {
                            LocalStore.set('bet_page.expiry_type', expiry_type);
                            page.url.invalidate();
                        }

                        return page.url.param_if_valid('expiry_type') || LocalStore.get('bet_page.expiry_type') || 'duration';
                    },
                    time: function(time) {
                        if(time) {
                            LocalStore.set('bet_page.time', time);
                            page.url.invalidate();
                        }

                        return this.get_setting_or_param("bet_page.time", 'time');
                    },
                    barrier_1: function() {
                        return page.url.param_if_valid('H');
                    },
                    barrier_2: function() {
                        return page.url.param_if_valid('L');
                    },
                    amount: function(amount) {
                        if(amount) {
                            LocalStore.set('bet_page.amount', amount);
                            page.url.invalidate();
                        }

                        return this.get_setting_or_param("bet_page.amount", 'amount');
                    },
                    amount_type: function(amount_type) {
                        if(amount_type) {
                            LocalStore.set('bet_page.amount_type', amount_type);
                            page.url.invalidate();
                        }

                        return this.get_setting_or_param("bet_page.amount_type", 'amount_type');
                    },
                    currency: function(currency) {
                        if(currency) {
                            LocalStore.set('bet_page.currency', currency);
                            page.url.invalidate();
                        }

                        var url_currency = page.url.param_if_valid('currency');
                        if(url_currency) {
                            return url_currency;
                        }

                        var session_currency = LocalStore.get('bet_page.currency');
                        if(session_currency) {
                            return session_currency;
                        }

                        return;
                    },
                    get_setting_or_param: function(setting_name, param_name) {
                        var saved_param = LocalStore.get(setting_name);
                        var url_param = page.url.param_if_valid(param_name);

                        //Only take the url provided param if its valid.
                        if(url_param) {
                            return url_param;
                        }

                        return saved_param;
                    },
                };
            }(),
            restore: function() {
                return {
                    all: function() {
                        this.submarket();
                        this.underlying();
                        this.amount();
                        this.amount_type();
                        this.currency();
                    },
                    all_but_underlying: function() {
                        this.submarket();
                        this.amount();
                        this.amount_type();
                        this.currency();
                    },
                    underlying: function() {
                        var underlying = BetForm.attributes.model.underlying();
                        var market = BetForm.attributes.model.market();
                        if(underlying && BetForm.attributes.can_select('bet_underlying', underlying)) {
                            $('#bet_underlying', BetForm.attributes.form_selector()).val(underlying);
                        }
                    },
                    submarket: function() {
                        var market = BetForm.attributes.model.market();
                        var submarket = BetForm.attributes.model.submarket();
                        if(submarket && BetForm.attributes.can_select('submarket', submarket)) {
                            $('#submarket', BetForm.attributes.form_selector()).val(submarket);
                            BetForm.underlying_drop_down.update_for_submarket(submarket);
                        }
                    },
                    amount: function() {
                        var amount = BetForm.attributes.model.amount();
                        if(amount) {
                            $('#amount', BetForm.attributes.form_selector()).val(amount);
                        }
                    },
                    amount_type: function() {
                        var amount_type = BetForm.attributes.model.amount_type();
                        if(amount_type) {
                            $('#amount_type', BetForm.attributes.form_selector()).val(amount_type);
                        }
                    },
                    currency: function() {
                        if(!page.client.check_storage_values('attributes.restore.currency')) {
                            return;
                        }

                        var currencies = page.client.get_storage_value('currencies');
                        if(currencies && currencies.length > 0) {
                            var client_currencies = currencies.split(',');
                            $('#bet_currency option').each(function() {
                                if($.inArray($(this).val(), client_currencies) < 0) {
                                    $(this).remove();
                                }
                            });
                        }

                        var currency = BetForm.attributes.model.currency();
                        if(currency && BetForm.attributes.can_select('bet_currency', currency)) {
                            $('#bet_currency').val(currency);
                        }
                    },
                };

            }()
    };
}();
;BetForm.Barriers = function() {
    this.defaults = {};
    this.barriers = [];
};

BetForm.Barriers.prototype = {
    register: function() {
        var that = this;
        this.each(function(barrier) {
            barrier.register();
            $(barrier).on('change', function(event, value) {
                $(that).trigger('change', [ value ]);
            });
        });
    },
    unregister: function() {
        this.each(function(barrier) {
            barrier.unregister();
            $(barrier).off('change');
        });
    },
    spot_changed: function(spot) {
        this.each(function(barrier) { barrier.update_calclulated_value(barrier.value()); });
    },
    time_changed: function(end_time) {
        var current_barrier_type = BetForm.attributes.barrier_type();
        if(!moment.utc().isSame(moment.utc(end_time), 'day')) {
            if(current_barrier_type == 'relative') {
                this.switch_to('absolute');
            }
        } else if (current_barrier_type == 'absolute' && page.settings.get('enable_relative_barrier')) {
            this.switch_to('relative');
        }
    },
    init: function() {
        this.barriers = [];
        var barrier,
            barrier_type = BetForm.attributes.barrier_type();
        if($('#bet_H').length > 0) {
            barrier = new BetForm.Barriers.Barrier({
                    component_id: 'bet_H',
                    calculated_barrier_id: 'betInputBox span.calculated_barrier_from_relative_high',
                    barrier_type: barrier_type,
            });

            barrier.value(this.select_barrier_value(BetForm.attributes.barrier_1(), 'H'));
            this.barriers.push(barrier);
        }

        if($('#bet_L').length > 0) {
            barrier = new BetForm.Barriers.Barrier({
                    component_id: 'bet_L',
                    calculated_barrier_id: 'betInputBox span.calculated_barrier_from_relative_low',
                    barrier_type: barrier_type,
            });
            barrier.value(this.select_barrier_value(BetForm.attributes.barrier_2(), 'L'));
            this.barriers.push(barrier);
        }

        this.register();
    },
    select_barrier_value: function(model_value, default_type) {
        var barrier_value;
        var is_valid_barrier = function(value) {
            return true;
        };

        if(is_valid_barrier(model_value)) {
            return model_value;
        }

        var defaults = this.get_defaults_for(BetForm.attributes.barrier_type());
        if(defaults && is_valid_barrier(defaults[default_type])) {
            return defaults[default_type];
        }

        return 0;
    },
    switch_to: function(barrier_type) {
        if(barrier_type == 'absolute') {
            $('.barrier_text_absolute').show();
            $('.barrier_text_relative').hide();
            $('[name=barrier_type]', BetForm.attributes.form_selector()).val('absolute');
            this.each(function(barrier) { barrier.switch_to('absolute'); });
        } else if(barrier_type == 'relative') {
            $('.barrier_text_absolute').hide();
            $('.barrier_text_relative').show();
            $('[name=barrier_type]', BetForm.attributes.form_selector()).val('relative');
            this.each(function(barrier) { barrier.switch_to('relative'); });
        }
    },
    each: function(method) {
        var rets = [];
        var barriers_count = this.barriers.length - 1;
        while(barriers_count >= 0) {
            rets.push(method(this.barriers[barriers_count]));
            barriers_count--;
        }

        return rets;
    },
    get_defaults_for: function(barrierType) {
        var that = this;
        var underlying = BetForm.attributes.underlying();
        market = BetForm.attributes.market();
        time = BetForm.attributes.duration_string();
        form_name = BetForm.attributes.form_name();
        prediction = BetForm.attributes.prediction();

        var lookup = underlying + '_' +  time + '_' + form_name + '_' + prediction;
        if(typeof this.defaults[lookup] === 'undefined') {
            $.ajax({
                url: page.url.url_for('trade_get.cgi'),
                data: {
                    controller_action: 'barrier_defaults',
                    underlying_symbol: underlying,
                    market: market,
                    time: time,
                    form_name: form_name,
                    barrier_type: barrierType,
                },
                dataType: 'json',
                type: 'GET',
                async: false,
            }).done(function(ranges) {
                that.defaults[lookup] = ranges;
            });
        }

        return this.defaults[lookup];
    },
};

BetForm.Barriers.Barrier = function(args) {
    args = (typeof args === 'undefined') ? {} : args;
    this.component_id = args.component_id;
    this.calculated_barrier_id = args.calculated_barrier_id;
    this.barrier_type = args.barrier_type;
};

BetForm.Barriers.Barrier.prototype = {
    register: function() {
        this.on_change();
        this.on_keyup();
    },
    unregister: function() {
        $('#' + this.component_id).off('keyup');
        $('#' + this.component_id).off('change');
    },
    value: function(value) {
        if(typeof value !== 'undefined') {
            var barrier_prefix = "";
            if (BetForm.attributes.form_name() != 'digits') {
                if(this.barrier_type == 'relative') {
                    if(value > 0) {
                        barrier_prefix = "+";
                    } else if(value === 0) {
                        barrier_prefix = "+";
                        value = this.min_value();
                    }
                } else {
                    if(value < 0) {
                        value = BetForm.spot.value();
                    } else if(value === 0) {
                        value = this.to_absolute_value(this.min_value());
                    }
                }
                value = this.pipsized_value(value);
            }

            $('#' + this.component_id).val(barrier_prefix + value);

            this.update_calclulated_value(value);
            $(this).trigger('change', [ barrier_prefix + value ]);
        }

        return $('#' + this.component_id).val();
    },
    switch_to: function(barrier_type) {
        this.barrier_type = barrier_type;
        var value = $('#' + this.component_id).val();
        if(barrier_type == 'absolute') {
            this.value(this.to_absolute_value(value));
            $('#' + this.calculated_barrier_id).hide();
        } else if(barrier_type == 'relative') {
            this.value(this.to_relative_value(value));
            $('#' + this.calculated_barrier_id).show();
        }
    },
    update_calclulated_value: function(value) {
        if(this.barrier_type == 'relative') {
            value = this.pipsized_value(this.to_absolute_value(value));
            $('#' + this.calculated_barrier_id).html("(" + value + ")");
        }
    },
    on_change: function() {
        var that = this;
        $('#' + this.component_id).on('change', function(event) {
            var value = $(this).val();
            if(value.length > 0) {
                that.value(value);
            }
        }).addClass('unbind_later');
    },
    on_keyup: function() {
        var that = this;
        $('#' + this.component_id).on('keyup', function(event) {
            var value = $(this).val();
            if(value.length > 0) {
                that.update_calclulated_value(value);
            }
        }).addClass('unbind_later');
    },
    pipsized_value: function(value) {
        var pip_size = BetForm.attributes.pip_size();
        if (/indices/.test(window.location.search)) {
            return parseInt(value);
        } else {
            return parseFloat(value).toFixed(pip_size);
        }
    },
    to_relative_value: function(barrier) {
        var spot = BetForm.spot.value();
        if(spot > 0) {
            return this.pipsized_value(parseFloat(barrier) - spot);
        }

        return 0.00;
    },
    to_absolute_value: function(barrier) {
        var spot = BetForm.spot.value();
        if(spot > 0) {
            return this.pipsized_value(parseFloat(barrier) + spot);
        }

        return 0.00;
    },
    min_value: function() {
        if(typeof this.min_relative_value === 'undefined') {
            var pip_size = BetForm.attributes.pip_size();
            var value = "0.";
            var zeros = pip_size - 1;
            while(zeros > 0) {
                value += 0;
                zeros--;
            }
            value += 1;
            this.min_relative_value = value;
        }

        if(this.barrier_type == "absolute") {
            return this.to_absolute_value(this.min_relative_value);
        }

        return this.min_relative_value;
    },
};
;/*
 * Represents the overall time selection ui(duration & end time)
*/
BetForm.Time = function() {
    this.model = {};
    this.model.expiry_type = BetForm.attributes.model.expiry_type();
    this.trading_time = new BetForm.TradingTime();
    this.duration = new BetForm.Time.Duration(this.trading_time);
    this.end_time = new BetForm.Time.EndTime(this.trading_time);
};

BetForm.Time.prototype = {
    init: function() {
        // spreads doesn't have any concept of expiry
        if (BetForm.attributes.model.form_name() != "spreads") {
            this.trading_time.init();
            this.duration.init();
            this.end_time.init();
            this.register();
            if (BetForm.attributes.model.form_name() == "digits" || BetForm.attributes.model.form_name() == "asian") {
                var expiry_val = 'duration';
                $('#expiry_type').val(expiry_val);
                page.url.invalidate();
                LocalStore.set('bet_page.expiry_type', expiry_val);
                BetForm.attributes.model.expiry_type(expiry_val);
                this.model.expiry_type = expiry_val;
                $('#duration_amount').val(this.trading_time.min_unit().min);
            } else {
                $('#expiry_type').val(this.model.expiry_type);
            }
            this.update_ui();
        }
    },
    register: function() {
        this.on_expiry_type_change();
        this.duration.register();
        this.end_time.register();

        var that = this;
        $(this.duration).on('change', function(event, time) {
            $(that).trigger('change', [ time ]);
        });

        $(this.end_time).on('change', function(event, time) {
            $(that).trigger('change', [ time ]);
        });

        $(this.duration).on('enter_pressed', function() {
            $(that).trigger('enter_pressed');
        });

        $(this.end_time).on('enter_pressed', function() {
            $(that).trigger('enter_pressed');
        });
    },
    unregister: function() {
        $('#expiry_type').off('change');
        if(this.duration) {
            this.duration.unregister();
        }

        if(this.end_time) {
            this.end_time.unregister();
        }

        $(this.duration).off('change');
        $(this.end_time).off('change');

        $(this.duration).off('enter_pressed');
        $(this.end_time).off('enter_pressed');
    },
    update_for_start_time_change: function() {
        this.duration.update_units_select();
        this.duration.update_ui();
        this.end_time.update_ui();
    },
    update_ui: function() {
        if(this.model.expiry_type == 'duration') {
            this.duration.show();
            this.end_time.hide();
        } else {
            this.duration.hide();
            this.end_time.show();
        }
    },
    on_expiry_type_change: function() {
        var that = this;
        $('#expiry_type').on('change', function() {
            BetForm.attributes.model.expiry_type($(this).val());
            that.model.expiry_type = $(this).val();
            that.update_ui();
        }).addClass('unbind_later');
    },
};

/*
 * This object acts as a model for time parameter. It performs the following functions.
 *      - Read and interpret the time parameter from model(input / localstore).
 *              - The data can be interpretted in both duration format and end time format independent of underlying storage.
 *      - Provide a meachanism to parse and query the minimum durations passed through the form.
 *      - Provide functions to query trading_days and trading_times from the server.
 *      - Validate the time parameter
 *              - through the minimum durations passed to us through the form.
 *              - by querying on trading_days and trading_times from the server.
 *      - Provide mechanism to update the time model.
*/
BetForm.TradingTime = function() {
    this.time_is_duration_regex = /^\d+[smhd]$/;
    this.time_is_tick_regex = /^\d+t$/;
    this.trading_info = {};
};

BetForm.TradingTime.prototype = {
    init: function() {
        this.suggested_duration = this.virgule_duration("" + $('#duration_amount').val() + $('#duration_units').val());
        this.parse_units_from_form();
    },
    value: function(time) {
        if(time) {
            BetForm.attributes.model.time(time);
        }

        time = BetForm.attributes.model.time();
        if(time) {
            return time;
        }

        
        //If we are not able to find something in the model(param/stored) 
        //then we just use the value in duration as defaults.
        //This is becuase only duration comes populated.
        return "" + $('#duration_amount').val() + $('#duration_units').val();
    },
    underlying: function() {
        return BetForm.attributes.underlying();
    },
    is_forward_starting: function() {
        return BetForm.attributes.is_forward_starting();
    },
    as_duration: function() {
        var time = this.value();
        var duration;
        if(this.time_is_tick(time)) {
            duration = this.virgule_duration(time);
        } else if(this.time_is_duration(time)) {
            duration = this.virgule_duration(time);
        } else if(isNaN(parseInt(time))) {
            duration = this.suggested_duration;
        } else {
            duration = this.convert_to_duration(time);
        }

        //Validate the duration
        var selected_unit = this.configured_unit_for(duration.units);

        if(!selected_unit) {
            var min_unit = this.min_unit();
            duration.amount = min_unit.min;
            duration.units = min_unit.units;
        }

        return duration;
    },
    as_end_time: function() {
        var time = this.value();
        var end_time;
        if(this.time_is_duration(time)) {
            var duration = this.virgule_duration(time);
            end_time = this.convert_to_end_time(duration.amount, duration.units);
        } else if(isNaN(parseInt(time))) {
            end_time = this.convert_to_end_time(this.suggested_duration);
        } else {
            end_time = this.virgule_end_time(time);
        }

        //Validate the end_time
        var min_time = this.min_time();
        if(end_time.moment.isBefore(min_time)) {
            end_time = this.virgule_end_time(min_time.utc() / 1000);
        }

        var max_time = this.max_time();
        if(end_time.moment.isAfter(max_time)) {
            end_time = this.virgule_end_time(min_time.utc() / 1000);
        }

        return end_time;
    },
    update_from_duration: function(amount, unit) {
        var selected_unit = this.configured_unit_for(unit);

        this.value("" + amount + unit);
    },
    update_from_end_time: function(expiry_date, expiry_time) {
        var end_time = moment.utc(expiry_date + " " + expiry_time);
        var min_time = this.min_time();
        if(end_time.isBefore(min_time)) {
            end_time = min_time;
        }

        if(!moment.utc().isSame(end_time, 'day')) {
            var trading_times = this.get_trading_times(expiry_date);
            end_time = moment.utc(trading_times.closing);
        }

        this.value(Math.ceil(end_time.utc() / 1000));
    },
    min_time: function() {
        var min_unit = this.min_unit();
        return this.convert_to_end_time(min_unit.min, min_unit.units).moment;
    },
    max_time: function() {
        var max_unit = this.max_unit();
        return this.convert_to_end_time(max_unit.max, max_unit.units).moment;
    },
    min_unit: function() {
        var units = this.configured_units_by_start_time();
        var order = ['d', 'h', 'm', 's' ,'t'];
        var checking = order.length;
        while(checking > 0) {
            checking--;
            if(units[order[checking]]) {
                return units[order[checking]];
            }
        }
    },
    max_unit: function() {
        var units = this.configured_units_by_start_time();
        var order = ['t', 's', 'm', 'h', 'd'];
        var checking = order.length;
        while(checking > 0) {
            checking--;
            if(units[order[checking]]) {
                return units[order[checking]];
            }
        }
    },
    time_is_tick: function(time) {
        return this.time_is_tick_regex.test(time);
    },
    time_is_duration: function(time) {
        return this.time_is_duration_regex.test(time);
    },
    convert_to_duration: function(inputTime) {
        var units;
        var amount;
        var start_time = BetForm.attributes.start_time_moment();
        var time = moment.utc(parseInt(inputTime) * 1000);

        var diff = time.valueOf() - start_time.valueOf();
        var min_unit = this.min_unit();
        var min_expiration_time = BetForm.attributes.start_time_moment().add(min_unit.min, min_unit.units);
        if(time.isBefore(min_expiration_time)) {
            units = min_unit.units;
            amount = min_unit.min;
        } else if(diff / 1000 < 60) {
            units = 's';
            amount = Math.ceil(diff / 1000);
        } else if (diff / (60 * 1000) < 60) {
            units = 'm';
            amount = Math.ceil(diff / (60 * 1000));
        } else if (diff / (3600 * 1000) < 24) {
            units = 'h';
            amount = Math.ceil(diff / (3600 * 1000));
        } else {
            units = 'd';
            amount = time.diff(start_time, 'day');
        }

        return {
            units: units,
            amount: amount
        };
    },
    convert_to_end_time: function(duration_amount, duration_units) {
        var ms = BetForm.attributes.start_time_moment();
        ms.add(duration_amount, duration_units);
        if(duration_units == "d") {
            var trading_times = this.get_trading_times(ms.format("YYYY-MM-DD"));
            ms = trading_times.closing;
        }

        var expiry_time = ms.format('HH:mm:ss');
        if(moment.utc().isSame(ms, 'day')) {
            expiry_time = ms.format('HH:mm');
        }
        return {
            expiry_date: ms.format('YYYY-MM-DD'),
            expiry_time: expiry_time,
            moment: ms
        };
    },
    virgule_duration: function(time) {
        var units = time.substring(time.length - 1);
        var amount = time.substring(0, time.length - 1);

        return {
            units: units,
            amount: amount
        };
    },
    virgule_end_time: function(inputTime) {
        var time = parseInt(inputTime) * 1000,
            ms = moment.utc(time),
            expiry_time = ms.format('HH:mm:ss');
        
        if(moment.utc().isSame(ms, 'day')) {
            expiry_time = ms.format('HH:mm');
        }
        if(!moment.utc().isSame(ms, 'day')) {
            var trading_times = this.get_trading_times(ms.format('YYYY-MM-DD'));
            expiry_time = moment.utc(trading_times.closing).format('HH:mm:ss');
        }
        
        return {
            expiry_date: ms.format('YYYY-MM-DD'),
            expiry_time: expiry_time,
            moment: ms
        };
    },
    is_valid_duration: function(amount, unit) {
        var selected_unit = this.configured_unit_for(unit);
        if(amount < selected_unit.min) {
            return false;
        }

        return true;
    },
    configured_units_by_start_time: function() {
        var units = this.configured_units.spot;
        if(this.is_forward_starting()) {
            units = this.configured_units.forward_starting;
        }

        return units;
    },
    configured_unit_for: function(duration_unit) {
        var units = this.configured_units_by_start_time();
        return units[duration_unit];
    },
    parse_units_from_form: function() {
        var normal_durations = {};
        var forward_starting_durations = {};
        var duration_container = BetForm.attributes.duration_container();
        $('#duration_units > option').each(function(){
            var duration_unit = {};
            duration_unit.className = $(this).attr('class');
            duration_unit.selected = $(this).attr('selected');
            duration_unit.units = $(this).val();
            duration_unit.label = $(this).text();

            duration_unit.max = 59;
            if(duration_unit.units == 'd') {
                duration_unit.max = 365;
            } else if(duration_unit.units == 'h') {
                duration_unit.max = 23;
            } else if (duration_unit.units == 't') {
                duration_unit.max = 10;
            }

            if(duration_unit.className == 'forward_starting') {
                duration_unit.min_select = duration_container.find('.non_input.forward_starting.' + duration_unit.units);
                duration_unit.min = parseInt(duration_unit.min_select.html().split(":")[1]);
                forward_starting_durations[duration_unit.units] = duration_unit;
            } else {
                duration_unit.min_select = duration_container.find('.non_input.' + duration_unit.units + ':not(.forward_starting)');
                duration_unit.min = parseInt(duration_unit.min_select.html().split(":")[1]);
                normal_durations[duration_unit.units] = duration_unit;
            }
        });

        this.configured_units = {};
        this.configured_units.spot = normal_durations;
        this.configured_units.forward_starting = forward_starting_durations;
    },
    trading_dates: function() {
        var trading_dates  = [];
        var trading_days = this.get_trading_days();

        for (var day in trading_days) {
            if(trading_days[day]['trading']) {
                trading_dates.push(day);
            }
        }

        return trading_dates;
    },
    get_trading_days: function() {
        var underlying_symbol = BetForm.attributes.underlying();
        var barrier = BetForm.attributes.barrier_1();
        if (typeof this.trading_info[underlying_symbol] === 'undefined') {
            var that = this;
            $.ajax({
                url: page.url.url_for('trade_get.cgi'),
                data: { controller_action: 'trading_days',
                        underlying_symbol: underlying_symbol,
                        form_name: BetForm.attributes.form_name(),
                        date_start: BetForm.attributes.start_time(),
                        barrier: barrier,
                    },
                dataType:'json',
                async: false
            }).done(function(trading_days) {
                that.trading_info[underlying_symbol] = {};
                for (var day in trading_days) if (trading_days.hasOwnProperty(day)) {
                    var day_arr = day.split('-');
                    day_arr[1] = parseInt(day_arr[1] - 1);
                    var date = moment.utc(day_arr).format("YYYY-MM-DD");
                    that.trading_info[underlying_symbol][date] = { trading: ((trading_days[day] == 1) ? true: false) };
                }
            });
        }
        return this.trading_info[underlying_symbol];
    },
    get_trading_times: function(date) {
        var underlying_symbol = this.underlying();
        if(typeof this.trading_info[underlying_symbol] === "undefined") {
            this.get_trading_days();
        }

        var that = this;
        if(typeof this.trading_info[underlying_symbol] === 'undefined' || typeof this.trading_info[underlying_symbol][date] === "undefined") {
            this.trading_info[underlying_symbol][date] = { trading: 0 };
        }

        if(typeof this.trading_info[underlying_symbol][date]['opening'] === "undefined" ||
            typeof this.trading_info[underlying_symbol][date]['closing'] === "undefined") {
            $.ajax({
                url: page.url.url_for('trade_get.cgi', '', 'cached'),
                data: {
                    controller_action: 'trading_times',
                    underlying_symbol: underlying_symbol,
                    trading_date: date,
                },
                dataType: 'json',
                type: 'GET',
                async: false,
            }).done(function(response) {
                that.trading_info[underlying_symbol][date].opening = moment.utc(response.opening);
                that.trading_info[underlying_symbol][date].closing = moment.utc(response.closing);
            });
        }
        return this.trading_info[underlying_symbol][date];
    },
};

/*
 * Represents the duration ui
*/
BetForm.Time.Duration = function(trading_time) {
    this.trading_time = trading_time;
    this.date_picker = new DatePicker.SelectedDates('duration_amount', 'diff');
};

BetForm.Time.Duration.prototype = {
    init: function() {
        this.update_units_select();
    },
    register: function() {
        this.on_unit_change();
        this.on_amount_change();

        var that = this;
        $(this.date_picker).on('enter_pressed', function() {
            $(that).trigger('enter_pressed');
        });
    },
    unregister: function() {
        this.date_picker.hide();

        $(this.date_picker).off('change');
        $('#duration_amount').off('change');

        $(this.date_picker).off('enter_pressed');
        $('#duration_units').off('change');
    },
    show: function(ms) {
        $('#expiry_type_duration').show();
        this.update_ui();
    },
    hide: function() {
        $('#expiry_type_duration').hide();
        this.date_picker.hide();
    },
    update_units_select: function() {
        $('#duration_units option').remove();
        var configured_units = this.trading_time.configured_units_by_start_time();
        for (var unit in configured_units) if (configured_units.hasOwnProperty(unit)) {
            this.add_duration_unit(configured_units[unit]);
        }
    },
    update_ui: function() {
        var selected = this.trading_time.as_duration();
        if($('#duration_units >option[value=' + selected.units + ']').length > 0) {
            $('#duration_units').val(selected.units);
            var unit = this.trading_time.configured_unit_for(selected.units);
            BetForm.attributes.duration_container().find('.non_input').hide();
            unit.min_select.show();
        }
        $('#duration_amount').val(selected.amount);
        if(selected.units == 'd') {
            this.date_picker.show(this.trading_time.trading_dates());
        } else {
            this.date_picker.hide();
        }

        var hidden_expiry_type;
        if (selected.units == 't') {
            $('#expiry_type option[value="endtime"]').prop('disabled', true);
        } else {
            $('#expiry_type option[value="endtime"]').prop('disabled', false);
            $(this).trigger('change', [ this.trading_time.as_end_time().moment ]);
        }

    },
    on_unit_change: function() {
        var that = this;
        $('#duration_units').on('change', function(event) {
            var amount = that.trading_time.as_duration().amount;
            that.trading_time.update_from_duration(amount, this.value);
            $(that).trigger('change', [ that.trading_time.as_end_time().moment ]);
            that.update_ui();
        }).addClass('unbind_later');
    },
    on_amount_change: function() {
        var that = this;
        var handle_change = function(duration) {
            var selected_units = that.trading_time.as_duration().units;
            duration = isNaN(parseInt(duration)) ? BetForm.time.trading_time.configured_unit_for(selected_units).min : parseInt(duration);
            var min_span = that.trading_time.configured_unit_for(selected_units).min_select;

            that.trading_time.update_from_duration(duration, selected_units);
            that.update_ui();
            if(that.trading_time.is_valid_duration(duration, selected_units)) {
                $(this).removeClass('error');
                min_span.removeClass('error');
            } else {
                $(this).addClass('error');
                min_span.addClass('error');
            }
        };

        $('#duration_amount').on('change', function() {
            handle_change($(this).val());
        }).addClass('unbind_later');

        $(this.date_picker).on('change', function(event, duration) {
            handle_change(duration);
        });
    },
    add_duration_unit: function(duration_unit) {
        if(duration_unit) {
            var option = this.create_option(duration_unit);
            var drop_down = document.getElementById("duration_units");
            try {
                // for IE version less than 8
                drop_down.add(option, drop_down.options[null]);
            } catch (e) {
                drop_down.add(option, null);
            }
        }
    },
    create_option: function(duration_unit) {
        var option = document.createElement("option");

        option.className = duration_unit.className;
        option.value = duration_unit.units;
        option.selected = duration_unit.selected;
        option.text = duration_unit.label;

        return option;
    },
};

/*
 * Represents the end time ui
*/
BetForm.Time.EndTime = function(trading_time) {
    this.trading_time = trading_time;
    this.time_picker = new TimePicker('expiry_time');
    this.date_picker = new DatePicker.SelectedDates('expiry_date');
};

BetForm.Time.EndTime.prototype = {
    init: function() {
    },
    register: function() {
        this.on_time_change();
        this.on_date_change();

        var that = this;
        var when_enter_pressed = function() {
            $(that).trigger('enter_pressed');
        };

        $(this.time_picker).on('enter_pressed', when_enter_pressed);
        $(this.date_picker).on('enter_pressed', when_enter_pressed);
    },
    unregister: function() {
        this.time_picker.hide();
        this.date_picker.hide();
        $(this.date_picker).off('change');
        $(this.time_picker).off('change');

        $(this.date_picker).off('enter_pressed');
        $(this.time_picker).off('enter_pressed');
    },
    show: function(ms) {
        $('#expiry_type_endtime').show();
        this.update_ui();
    },
    hide: function() {
        $('#expiry_type_endtime').hide();
        this.time_picker.hide();
        this.date_picker.hide();
    },
    update_ui: function() {
        var selected = this.trading_time.as_end_time();
        $('#expiry_date').val(selected.expiry_date);
        $('#expiry_time').val(selected.expiry_time);
        $(this).trigger('change', [ selected.moment ]);

        var now = moment.utc();
        this.date_picker.hide();
        this.time_picker.hide();
        if(now.isSame(selected.moment, 'day')) {
            $('#expiry_time').attr('disabled', false);
            var trading_times = this.trading_time.get_trading_times(selected.expiry_date);
            this.time_picker.show(trading_times.opening, trading_times.closing);
            $('#market-closed-tip').hide();
        } else {
            $('#expiry_time').attr('disabled', true);
            $('#market-closed-tip').show();
        }

        if(this.trading_time.is_forward_starting()) {
            $('#expiry_date').attr('disabled', true);
        } else {
            $('#expiry_date').attr('disabled', false);
        }

        //Add Today, to make it selectable.
        var min_unit = this.trading_time.min_unit();
        var dates = this.trading_time.trading_dates();
        if(min_unit.units !== "d" || min_unit.min === 0) {
            dates.push(now.format("YYYY-MM-DD"));
        }
        this.date_picker.show(dates);
    },
    on_date_change: function() {
        var that = this;
        $(this.date_picker).on('change', function(event, date) {
            var selected = that.trading_time.as_end_time();
            that.trading_time.update_from_end_time(date, selected.expiry_time);
            that.update_ui();
        }).addClass('unbind_later');
    },
    on_time_change: function() {
        var that = this;
        $(this.time_picker).on('change', function(event, time) {
            var selected = that.trading_time.as_end_time();
            that.trading_time.update_from_end_time(selected.expiry_date, time);
            that.update_ui();
        }).addClass('unbind_later');
    },
};
;var BetPrice = function() {
    var price_request = null;
    var _buy_response_container = null;
    return {
        deregister: function() {
            $('#content button.buy_bet_button').off('click');
        },
        container: function() {
            return $('#bet_calculation_container');
        },
        price_url: function() {
            var url = BetForm.attributes.form_selector() ? BetForm.attributes.form_selector().action : '';
            if (url) {
                return url;
            } else {
                return '';
            }
        },
        params: function() {
            var params = getFormParams(BetForm.attributes.form_selector());
            params += '&st=' + BetForm.attributes.underlying();
            params += '&expiry=' + BetForm.attributes.duration_string();
            params += '&'+Math.floor(Math.random()*83720);
            params += '&ajax_only=1&price_only=1';
            return params;
        },
        cancel_previous_request: function() {
            if (price_request) {
                price_request.abort();
            }
        },
        get_price: function() {
            var that = this;
            this.cancel_previous_request();
            this.show_loading();
            var url = this.price_url();
            if (url) {
                price_request = $.ajax(ajax_loggedin({
                  url     : url,
                  dataType: 'html',
                  data    : this.params(),
                  success : function(data) { that.price_update(data); },
                })).fail(function ( jqXHR, textStatus ) {
                    that.error_handler();
                });
            } else {
                that.error_handler();
            }
        },
        error_handler: function() {
            this.container().find('div.rbox-lowpad:first').html(text.localize("There was a problem accessing the server."));
            this.streaming.stop();
        },
        price_update: function(data) {
            price_request = null;
            this.deregister();
            var price_container = BetPrice.container().find('div.rbox-lowpad:first');
            price_container.hide().html(data);
            this.on_buy();
            var sendBetUrl = $('#sendBetUrlLink').attr('href');
            if (sendBetUrl){
                page.url.update(sendBetUrl);
            }
            price_container.show();
            BetForm.amount.update_settings();
            this.streaming.start();
        },
        on_buy: function() {
            var that = this;
            $('#content button.buy_bet_button').on('click', function (e) {
                e = e || window.event;
                if (typeof e.preventDefault == 'function') {
                    e.preventDefault();
                }
                BetPrice.order_form.disable_buy_buttons();
                that.hide_buy_buttons();
                var form = $(e.target).parents('form');
                that.buy_bet(form);
                return false;
            }).addClass('unbind_later');
            $('a.spread_250, a.spread_260').on('click', function (e) {
                e = e || window.event;
                if (typeof e.preventDefault == 'function') {
                    e.preventDefault();
                }
                var target = $(e.target);
                var button = target.parents('a[class^="spread"]');
                that.spread.disable(button);
                var form = $(e.target).parents('form');
                that.buy_bet(form);
                return false;
            }).addClass('unbind_later');
        },
        buy_bet: function (form) {
            var that = this;
            var timeout = 60000;

            if(!$.cookie('login')) {
                page.client.is_logged_in = false;
                window.location.href = page.url.url_for('login');
                return;
            }

            // pass the DOM form object wrapped in jQuery form object to getFormParams
            var data = getFormParams(form.get(0)) + '&ajax_only=1';
            $.ajax(ajax_loggedin({
                url     : form.attr('action'),
                type    : 'POST',
                async   : true,
                data    : data,
                timeout : timeout,
                success : function (resp, resp_status, jqXHR) { that.on_buy_bet_success(form, resp, resp_status, jqXHR); },
                error   : function (jqXHR, resp_status, exp) { that.on_buy_bet_error(form, jqXHR, resp_status, exp); },
            }));
            $('.price_box').fadeTo(200, 0.6);
        },
        on_buy_bet_success: function (form, resp, resp_status, jqXHR) {
            var data = {};
            if (typeof resp == 'object') {
               data = resp;
            } else {
                try {
                    data = (JSON && JSON.parse(resp)) || $.parseJSON(resp) || {};
                } catch (e) {
                    var width = this.container().width() || 300; // since the error message could be any size, set the continer size to a good value
                    return;
                }
            }
            if (data.redirect) {
                window.location.href = data.redirect;
                return;
            } else if (data.error) {
                var width = this.container().width(); // since the error message could be any size, set the continer size to a good value
                this.display_buy_error(data.error);
            } else if (data.display) {
                this.display_buy_results(data);
            } else {
                throw new Error("Invalid server response: " + data);
            }
            $('.price_box').fadeTo(0, 1);
            BetPrice.order_form.enable_buy_buttons();
            this.display_buy_buttons();
        },
        on_buy_bet_error: function (form, jqXHR, resp_status, exp) {
            var details = '' + exp;
            if (jqXHR.responseText) {
                details += jqXHR.responseText;
            } else if (document.location.href.match(/^http:/) && (!details || details.match(/access/i))) {
                details += '<ul>Please <a href="' + document.location.href.replace('http://', 'https://') + '">continue browsing using HTTPS secure protocol</a></ul>';
            } else {
                details += text.localize('There was a problem accessing the server during purchase.');
            }
            var width = this.container().width(); // since the error message could be any size, set the continer size to a good value
            this.display_buy_error('<div style="width: ' + width + 'px;"><h3>Error</h3><p>' + details + ' </p></div>', 1);
            $('.price_box').fadeTo(0, 1);
            BetPrice.order_form.enable_buy_buttons();
            this.display_buy_buttons();
        },
        buy_response_container: function () {
            if (!_buy_response_container) {
                var price_container = this.container();
                _buy_response_container = $('<div id="buy_confirm_container" class="trade_confirm_container ajax_response"><a class="close">x</a><div></div></div>');
                _buy_response_container.hide();
                _buy_response_container.height('100%');
                price_container.append(_buy_response_container);
            }
            return _buy_response_container;
        },
        display_buy_results: function (data) {
            var that = this;

            var display_html = data.display;
            var con = this.buy_response_container();
            con.children('div').first().html(display_html);

            if ($('#tick_chart').length > 0) {
                data['show_contract_result'] = 1;
                TickDisplay.initialize(data);
            }

            if ($('#is-digit').data('is-digit')) {
                var start_moment = moment(data.contract_start*1000).utc();
                that.digit.process(start_moment);
            }

            con.show();
            // push_data_layer();
            var _clear_results = function () { that.clear_buy_results(); };
            con.find('a.close').on('click', _clear_results).css('cursor', 'pointer').addClass('unbind_later');
        },
        spread: function() {
            var that = this;
            return {
                reset: function() {
                    if (typeof this._stream !== 'undefined') {
                        this._stream.close();
                        this._stream.onmessage = function() {};
                    }
                },
                validate_change: function(target) {
                    var current = target.attr('value');
                    var new_value = target.val();
                    if (!new_value.toString().match(/^[0-9.]*$/)) {
                        new_value = current;
                    }

                    return new_value;
                },
                disable: function(target) {
                    var that = this;
                    target.unbind('click');
                },
                on_sell: function(form) {
                    var that = this;
                    $('button.close_position').on('click', function (e) {
                        e = e || window.event;
                        if (typeof e.preventDefault == 'function') {
                            e.preventDefault();
                        }
                        var target = $(e.target);
                        BetSell.model.reload_page_on_close($('trading_socket_container') ? false : true);
                        that.spread_con().find('#sell_level').parent().hide();
                        that.sell_bet(target);
                        return false;
                    }).addClass('unbind_later');
                },
                sell_bet: function(target) {
                    var that = this;
                    that.reset();
                    target.attr('disabled','disabled').hide();
                    var form = target.parents('form');
                    var timeout = 60000;

                    if(!$.cookie('login')) {
                        page.client.is_logged_in = false;
                        window.location.href = page.url.url_for('login');
                        return;
                    }

                    // pass the DOM form object wrapped in jQuery form object to getFormParams
                    var data = getFormParams(form.get(0)) + '&ajax_only=1';
                    $.ajax(ajax_loggedin({
                        url     : form.attr('action'),
                        type    : 'POST',
                        async   : true,
                        data    : data,
                        timeout : timeout,
                        success : function (resp, resp_status, jqXHR) { that.on_sell_success(form, resp, resp_status, jqXHR); },
                        error   : function (jqXHR, resp_status, exp) { that.on_sell_error(form, jqXHR, resp_status, exp); },
                    }));
                    $('.price_box').fadeTo(200, 0.6);
                },
                on_sell_error: function(form, resp, resp_status, jqXHR) {
                    var that = this;

                    if (typeof(resp.error) !== 'undefined') {
                        that.err_con().find('p').text(resp.error);
                        that.err_con().show();
                    }
                },
                on_sell_success: function(form, resp, resp_status, jqXHR) {
                    var that = this;

                    var con = that.spread_con();
                    if (typeof(resp.error) !== 'undefined') {
                        that.err_con().find('p').text(resp.error);
                        that.err_con().show();
                    } else {
                        con.find('#status').addClass('loss').text(text.localize('Closed'));
                        that.paint_it(resp.value.dollar, con.find('#pnl_value').text(resp.value.dollar));
                        con.find('#pnl_point').text(resp.value.point);
                        con.find('#exit_level').text(resp.exit_level).parents('tr').show();
                    }
                },
                paint_it: function(value, target) {
                    var color = value > 0 ? 'profit' : 'loss';
                    $(target).removeClass().addClass(color);
                },
                stream: function(channel) {
                    var that = this;
                    that.on_sell();
                    var url = window.location.protocol + '//' + page.settings.get('streaming_server')+'/push/price/'+channel;
                    that._stream = new EventSource(url, { withCredentials: true });
                    that._stream.onmessage = function(e) {
                        var data = JSON.parse(e.data);
                        var prices = data.prices;
                        var con = that.spread_con();
                        var err_con = that.err_con();
                        for (var i = 0; i < prices.length; i++) {
                            var id = prices[i].id;
                            var level = parseFloat(prices[i].level);

                            if (typeof(prices[i].value) !== 'undefined') {
                                if (prices[i].err !== null) {
                                    con.find('.close_position').hide();
                                    err_con.find('p').text(prices[i].err);
                                    err_con.show();
                                    break;
                                } else {
                                    err_con.hide();
                                    con.find('.close_position').show();
                                    con.find('#sell_level').text(level);
                                    var current_value = that.round(parseFloat(prices[i].value.dollar),2);
                                    that.paint_it(current_value, con.find('#pnl_value').text(current_value));
                                    con.find('#pnl_point').text(prices[i].value.point);
                                }
                            }

                            var higher_stop_level;
                            var lower_stop_level;
                            if (that.stop_loss_level() > that.stop_profit_level()) {
                                higher_stop_level = that.stop_loss_level();
                                lower_stop_level = that.stop_profit_level();
                            } else {
                                lower_stop_level = that.stop_loss_level();
                                higher_stop_level = that.stop_profit_level();
                            }

                            if (level >= higher_stop_level || level <= lower_stop_level) {
                                var sell_button = con.find('.close_position');
                                sell_button.click();
                                break;
                            }
                        }
                    };
                    that._stream.onerror = function() {
                        that._stream.close();
                    };
                },
                err_con: function() {
                    var that = this;
                    return that.spread_con().find('#error_box');
                },
                spread_con: function() {
                    return $('#sell_content_wrapper');
                },
                split_level: function(level) {
                    var that = this;
                    var matches = level.toString().match(/[0-9]+/g);
                    var point_val = matches[0];
                    var cents_val = matches[1] || '00';

                    return {
                        point: point_val,
                        decimal: cents_val,
                    };
                },
                stop_loss_level: function() {
                    var that = this;
                    return parseFloat(that.spread_con().find('#stop_loss_level').text());
                },
                stop_profit_level: function() {
                    var that = this;
                    return parseFloat(that.spread_con().find('#stop_profit_level').text());
                },
                round: function(number,number_after_dec) {
                    var result = Math.round(number * Math.pow(10,number_after_dec)) / Math.pow(10,number_after_dec);
                    result = result.toFixed(number_after_dec);
                    return result;
                },
            };
        }(),
        digit: function() {
            return {
                reset: function() {
                    var $self = this;

                    $self.ev.close();
                    $self.digit_tick_count = 0;
                    $self.applicable_ticks = [];
                    $self.info_for_display = [];
                },
                process: function(start_moment) {
                    var $self = this;

                    $self.digit_tick_count = 0;
                    $self.applicable_ticks = [];
                    $self.info_for_display = [];
                    var symbol = BetForm.attributes.underlying();
                    var how_many_ticks = $('#tick-count').data('count');
                    var stream_url = window.location.protocol + '//' + page.settings.get('streaming_server');
                    stream_url += "/stream/ticks/" + symbol + "/" + start_moment.unix();
                    $self.ev = new EventSource(stream_url, { withCredentials: true });

                    $self.ev.onmessage = function(msg) {
                        var data = JSON.parse(msg.data);
                                if (!(data[0] instanceof Array)) {
                                    data = [ data ];
                                }
                                for (var i = 0; i < data.length; i++) {
                                    if (data[i][0] === 'tick') {
                                        var tick = {
                                            epoch: data[i][1],
                                            quote: data[i][2]
                                        };
                                        if (tick.epoch > start_moment.unix() && $self.digit_tick_count < how_many_ticks) {
                                            // checking for duplicate entries and skip them if they exists
                                            if ($self.applicable_ticks.length > 0) {
                                                var previous_tick_epoch = $self.info_for_display[$self.info_for_display.length-1][1];
                                                if (previous_tick_epoch === tick.epoch) {
                                                    continue;
                                                }
                                            }

                                            $self.applicable_ticks.push(tick.quote);
                                            $self.digit_tick_count++;
                                            $self.info_for_display.push([$self.digit_tick_count,tick.epoch,tick.quote]);
                                            $self.update_display();

                                            if ($('#digit-contract-details').css('display') === 'none') {
                                                $('#digit-contract-details').show();
                                            }
                                        }

                                        if ($self.applicable_ticks.length === how_many_ticks) {
                                            $self.evaluate_digit_outcome();
                                            $self.reset();
                                            break; // need to break the loop else it will keep on processing the extra tick
                                        }
                                    }
                                }
                    };
                    $self.ev.onerror = function() { $self.ev.close(); };
                },
                update_display: function(data) {
                    var $self = this;

                    var ticks_to_display = $self.info_for_display.slice(-5);
                    for (var i=0;i<5;i++) {
                        if (typeof ticks_to_display[i] !== 'undefined') {
                            var tick_number = ticks_to_display[i][0];
                            var tick_time = moment.utc(ticks_to_display[i][1]*1000).format("hh:mm:ss");
                            var tick_string = ticks_to_display[i][2].toString();
                            $('#count-'+i).text('Tick '+tick_number);
                            $('#time-'+i).text(tick_time);
                            var shorten = tick_string.substr(0,tick_string.length-1);
                            var last = tick_string.substr(-1);
                            $('#tick-'+i+' span#latest-shorten').text(shorten);
                            $('#tick-'+i+' span#latest-last').text(last);
                        }
                    }
                },
                evaluate_digit_outcome: function() {
                    var $self = this;

                    var prediction = $('#contract-sentiment').data('contract-sentiment');
                    var client_prediction = $('#client-prediction').data('client-prediction');
                    var last_tick = $self.applicable_ticks[$self.applicable_ticks.length-1];
                    var last_digit = parseInt(last_tick.toString().substr(-1));
                    var potential_payout = parseFloat($('#outcome-payout').data('payout').toString().replace(',',''));
                    var cost = parseFloat($('#outcome-buyprice').data('buyprice').toString().replace(',',''));

                    // buy price
                    $('#contract-outcome-buyprice').text($('#outcome-buyprice').data('buyprice'));

                    var final_price;

                    if (prediction === 'match') {
                        final_price = (last_digit === client_prediction) ? potential_payout : 0;
                    } else if (prediction === 'differ') {
                        final_price = (last_digit !== client_prediction) ? potential_payout : 0;
                    }

                    $('#confirmation_table').hide();
                    $('#contract-outcome-payout').text($self.round(final_price,2));

                    if (final_price !== 0) {
                        $('#bet-confirm-header').text(text.localize('This contract won'));
                        $('#contract-outcome-profit').removeClass('standin').addClass('standout profit').text($self.round(potential_payout - cost,2));
                        $('#digit-contract-details').css('background', 'rgba(46,136,54,0.198039)');
                    } else {
                        $('#bet-confirm-header').text(text.localize('This contract lost'));
                        $('#contract-outcome-label').removeClass('standout profit').addClass('standin loss').text(text.localize('Loss'));
                        $('#contract-outcome-profit').removeClass('standout profit').addClass('standin loss').text($self.round(cost,2));
                        $('#digit-contract-details').css('background', 'rgba(204,0,0,0.098039)');
                    }

                    $('#contract-outcome-details').show();
                },
                round: function(number,number_after_dec) {
                    var result = Math.round(number * Math.pow(10,number_after_dec)) / Math.pow(10,number_after_dec);
                    result = result.toFixed(number_after_dec);
                    return result;
                },
            };
        }(),
        display_buy_error: function (data, extra_info) {
            var that = this;
            var con = this.buy_response_container();
            con.addClass('bet_confirm_error');
            if (extra_info) {
                data += '<p>' + text.localize('Please confirm the trade on your statement before proceeding.') + '</p>';
            }
            data = '<p>' + data + '</p>';
            con.children('div').first().html(data);
            con.show();
            var _clear_results = function () { that.clear_buy_results(); };
            con.find('a.close').on('click', _clear_results).css('cursor', 'pointer').addClass('unbind_later');
        },
        clear_buy_results: function () {
            var con = this.buy_response_container();
            if ($('#tick_chart').length > 0) {
                TickDisplay.reset();
            }

            if ($('#is-digit').data('is-digit')) {
                this.digit.reset();
            }

            if ($('a[class^=spread]').length > 0) {
                this.spread.reset();
            }

            con.hide().remove();
            _buy_response_container = null;
        },
        hide_buy_buttons: function() {
            this.deregister();
            this.order_form.hide_buy_button();
        },
        display_buy_buttons: function() {
            this.on_buy();
            this.order_form.show_buy_button();
        },
        show_loading: function() {
            var image_link = page.settings.get('image_link');
            var loading_html = '<p id="loading-price">'+text.localize('loading...')+'<br /><img src="'+image_link['hourglass']+'" /></p>';
            this.container().find('div.rbox-lowpad:first').show().html('<div class="rbox rbox-bg-alt"><div class="rbox-wrap"><div class="rbox-content">'+loading_html+'</div></div><span class="tl">&nbsp;</span><span class="tr">&nbsp;</span><span class="bl">&nbsp;</span><span class="br">&nbsp;</span></div></div>');
            this.container().show();
        },
        streaming: function() {
            var price_stream = null;
            var update_from_stream = false;
            return {
                start: function() {
                    BetForm.spot.clear_sparkline();
                    this.stop();
                    update_from_stream = true;
                    var stream_channel = this.stream_channel();
                    var url = window.location.protocol + '//' + page.settings.get('streaming_server')+'/push/price/'+stream_channel;
                    if(url && typeof (EventSource) !== "undefined") {
                        price_stream = new EventSource(url, { retry: 18000000 });
                        var that = this;
                        price_stream.onmessage = function(e) {
                            that.process_message(e.data);
                        };
                        price_stream.addEventListener("ping", function(e) { return true; });
                    } else {
                        $('#spot_spark').html("<span title=\"" + text.localize("We are not able to stream live prices at the moment. To enjoy live streaming of prices try refreshing the page, if you get this issue after repeated attempts try a different browser") + "\">" + text.localize("No Live price update") + "</span>");
                    }
                },
                stop: function() {
                    if (price_stream !== null) {
                        price_stream.close();
                        price_stream = null;
                    }
                },
                ignore_updates: function() {
                    update_from_stream = false;
                },
                stream_channel: function() {
                    return $('#stream_channel').html();
                },
                process_message: function(data) {
                    if(data == 'stop_bet') {
                        BetPrice.order_form.hide_buy_button();
                    } else {
                        BetPrice.order_form.show_buy_button();
                    }

                    if(update_from_stream) {
                        var bet = JSON.parse(data);
                        BetForm.spot.update(bet.spot);
                        BetPrice.order_form.update_from_stream(bet);
                    }
                },
            };
        }(),
        order_form: function() {
            return {
                forms: function() {
                    return $('form[name=orderform]');
                },
                form_by_id: function(id) {
                    return $('#orderform_' + id);
                },
                verify_display_id: function(id) {
                    var display_id = $('input[name="display_id"]', this.form_by_id(id));
                    return (display_id && display_id.val() == id);
                },
                hide_buy_button: function() {
                    return $('button[name^="btn_buybet"]').parent().hide();
                },
                show_buy_button: function() {
                    return $('button[name^="btn_buybet"]').parent().show();
                },
                disable_buy_buttons: function() {
                    $('button[name^="btn_buybet"]').attr('disabled','disabled');
                },
                enable_buy_buttons: function() {
                    $('a[id^="spread"]').removeAttr('disabled');
                    $('button[name^="btn_buybet"]').removeAttr('disabled');
                },
                update_from_stream: function(stream) {
                    var type = stream.type;
                    if (type === 'spread') {
                        this.update_spread_ui(stream.prices);
                    } else if (type === 'price') {
                        var prices = this.prices_from_stream(stream.prices);
                        this.update_form(prices);
                        this.update_ui(prices);
                    }
                },
                update: function(prices) {
                    prices = typeof prices !== 'undefined' ? prices : this.prices_from_form();
                    this.update_form(prices);
                    this.update_ui(prices);
                },
                prices_from_stream: function(stream) {
                    var prices = [];
                    for (var i = 0; i < stream.length; i++) {
                        var id = stream[i].id || undefined;
                        var prob = stream[i].value || undefined;
                        if (!id || prob === undefined) {
                            continue;
                        }
                        prices.push(this.calculate_price(id, prob, stream[i].err));
                    }

                    return prices;
                },
                prices_from_form: function () {
                    var prices = [],
                        order_forms = $('.orderform'),
                        order_forms_count = order_forms ? order_forms.length : 0,
                        i,
                        id,
                        prob,
                        error;
                    if (order_forms_count > 0 ) {
                        for (i = 0; i < order_forms_count; i++) {
                            id = $('input[name="display_id"]', form).val();
                            prob = $('input[name="prob"]', form).val();
                            var form = $(order_forms[i]),
                                error_box_html = form.parent().parent().parents().siblings(".bet-error-box").html();
                            // We handle payout messages locally and after recalculation
                            if (error_box_html.length > 0 &&
                                error_box_html != BetForm.amount.payout_err &&
                                error_box_html != BetForm.amount.stake_err) {
                                error = error_box_html;
                            }
                            prices.push(this.calculate_price(id, prob, error));
                        }
                    } else {
                        var error_boxes = $('#bet_calculation_container').find('.bet-error-box');
                        var count = error_boxes.length;
                        for (i = 0; i < count; i++) {
                            var error_box = $(error_boxes[i]);
                            id = error_box.find('#error_display_id').val();
                            if(!id) {
                                continue;
                            }
                            prob = error_box.find('#error_probability_' + id).val();
                            error = undefined;
                            if(error_box.html().length > 0) {
                                error = error_box.html();
                            }
                            prices.push(this.calculate_price(id, prob, error));
                        }
                    }
                    return prices;
                },
                calculate_price: function(id, prob, error) {
                    var form = this.form_by_id(id);
                    var amount = BetForm.amount.calculation_value;
                    var price;
                    var payout;
                    var profit;
                    var roi;
                    if(BetForm.attributes.is_amount_stake()) {
                        payout = this.virgule_amount(Math.round((amount / prob) * 100));
                        price = this.virgule_amount(amount * 100);
                    } else if(BetForm.attributes.is_amount_payout()) {
                        price = this.virgule_amount(Math.round((amount * prob) * 100));
                        payout = this.virgule_amount(amount * 100);
                    }

                    var prev_price = $('input[name="price"]', form).length ? parseFloat($('input[name="price"]', form).val()) : 0;
                    var prev_payout = $('input[name="payout"]', form).length ? parseFloat($('input[name="payout"]', form).val()) : 0;

                    if (payout && price) {
                        profit =  this.virgule_amount(payout.raw - price.raw);
                        roi = Math.round(profit.raw / price.raw * 100);
                    } else {
                        profit = this.virgule_amount(0);
                        roi = this.virgule_amount(0);
                    }

                    payout = payout ? payout : this.virgule_amount(0);
                    price = price ? price : this.virgule_amount(0);

                    return {
                        type: 'price',
                        id: id,
                        prob: prob,
                        err: error,
                        price: price,
                        payout: payout,
                        profit: profit,
                        roi: roi,
                        prev_price: this.virgule_amount(prev_price * 100),
                        prev_payout: this.virgule_amount(prev_payout * 100)
                    };
                },
                update_form: function(prices) {
                    for (var i = 0; i < prices.length; i++) {
                        var form = this.form_by_id(prices[i].id);
                        $('input[name="prob"]', form).val(prices[i].prob);
                        $('input[name="price"]', form).val(prices[i].price.raw/100);
                        $('input[name="payout"]', form).val(prices[i].payout.raw/100);
                        $('input[name="amount_type"]', form).val(BetForm.attributes.amount_type());
                    }
                },
                update_ui: function(prices) {
                    for (var i = 0; i < prices.length; i++) {
                        var form = this.form_by_id(prices[i].id);
                        var err = prices[i].err;
                        var bf_amount = BetForm.amount;
                        var epsilon = 0.001; // Outside the visible range of a price.
                        // We're intentionally making payout errors have highest priority
                        // it's something they can fix immediately on this web interface.

                        if (prices[i].payout.raw/100  - epsilon > bf_amount.payout_max ||
                            prices[i].payout.raw/100 + epsilon < bf_amount.payout_min) {
                            err = bf_amount.payout_err;
                        } else if (prices[i].price.raw/100 - epsilon > bf_amount.stake_max ||
                            prices[i].price.raw/100 + epsilon < bf_amount.stake_min) {
                            // You probably think there should be two conditions above, but too high stake just
                            // makes for "too high payout" or "no return" errors.
                            err = bf_amount.stake_err;
                        }
                        this.show_error(form, err);
                        this.update_price(prices[i].id, prices[i].price, prices[i].prev_price);
                        this.update_description(prices[i].id, prices[i].payout, prices[i].prev_payout);
                        this.update_profit_roi(prices[i].id, prices[i].profit, prices[i].roi);
                    }
                },
                update_spread_ui: function(spread) {
                    var that = this;

                    for (var i = 0; i < spread.length; i++) {
                        var id = spread[i].id;
                        var level = spread[i].level;
                        var chunks = BetPrice.spread.split_level(level);

                        var con = $('.spread_'+id);
                        con.find('.spread_point_' + id).text(chunks.point);
                        con.find('.spread_decimal_' + id).text('.'+chunks.decimal);
                    }
                },
                update_price: function(id, price, old_price) {
                    var units_box = $('#units_for_' + id);
                    var cents_box = $('#cents_for_' + id);
                    var amount_box = $('#amount_for_' + id);

                    price_moved(amount_box, old_price.raw, price.raw);

                    units_box.text(price.units);
                    cents_box.text(price.cents);
                },
                update_description: function(id, payout, old_payout) {
                    $('#amount_for_' + id).siblings('.bet_description').each(function () {
                            var elm = $(this);
                            if (elm) {
                                var desc = elm.text();
                                if (desc) {
                                    desc = desc.trim();
                                    if(/^([A-Z]{3}) [\d+,]*\d+\.\d+/.test(desc)) {
                                        desc = desc.replace(/[\d+,]*\d+\.\d+/, payout.value);
                                        elm.text(desc);
                                    }
                                }
                            }
                    });
                },
                update_profit_roi: function(id, profit, roi) {
                    $("#id_" + id + "_profit").text(profit.value);
                    $("#id_" + id + "_roi").text(roi);
                },
                show_error: function(form, error) {
                    var buy_button= form.parent();
                    var error_box = buy_button.parents().siblings(".bet-error-box");
                    if (!error) {
                        error_box.hide();
                        buy_button.show();
                    } else {
                        error_box.html(error);
                        error_box.show();
                        buy_button.hide();
                    }
                },
                virgule_amount: function (big_amount) {
                    var amount_string = big_amount.toFixed(0).toString();

                    while (amount_string.length < 3)  {
                        amount_string = '0' + amount_string;
                    }

                    var amount_break = amount_string.length - 2;

                    var units =  virgule(amount_string.substr(0, amount_break));
                    var cents =  '.' + amount_string.substr(amount_break);

                    return {
                        units: units,
                        cents: cents,
                        value: units + cents,
                        raw: big_amount
                    };
                },
            };
        }(),
    };
}();
;var BetSell = function() {
    var _sell_request = null;
    var _analyse_request = null;
    var _container = null;
    var _sell_button_disabled = false;
    var _timer_interval_obj = {};
    var _timeout_variables = {};
    var _diff_end_start_time = 300; // we show point markers if end time start time difference is <= than this (5 minutes default)
    var _model = {
        currency: null,
        shortcode: null,
        payout: null,
        purchase_price: null,
        reload_page_on_close: false,
    };
    return {
        _init: function () {
            _sell_request = null;
            _analyse_request = null;
            _container = null;
            _sell_button_disabled = false;
            _timer_interval_obj = {};
            _timeout_variables = {};
            _model = {
                currency: null,
                shortcode: null,
                payout: null,
                purchase_price: null,
                reload_page_on_close: false,
            };
            this.update_high_low(true);
        },
        model: {
            currency: function (val) {
                if (val) {
                    _model.currency = val;
                    return this;
                }
                return _model.currency;
            },
            shortcode: function (val) {
                if (val) {
                    _model.shortcode = val;
                    return this;
                }
                return _model.shortcode;
            },
            payout: function (val) {
                if (val) {
                    _model.payout = val;
                    return this;
                }
                return _model.payout;
            },
            purchase_price: function (val) {
                if (val) {
                    _model.purchase_price = val;
                    return this;
                }
                return _model.purchase_price;
            },
            reload_page_on_close: function (val) {
                if (val !== undefined) {
                    _model.reload_page_on_close = (val ? true : false);
                    return this;
                }
                return _model.reload_page_on_close;
            },
        },
        container: function (refresh) {
            if (refresh) {
                if (this._container) {
                    this._container.remove();
                }
                this._container = null;
            }
            if (!this._container) {
                var that = this;
                var con = $('<div class="inpage_popup_container" id="sell_popup_container"><a class="close">x</a><div class="inpage_popup_content"></div></div>');
                con.hide();
                var _on_close = function () {
                    var should_reload = that.model.reload_page_on_close();
                    that.cleanup(true);
                    if (should_reload) {
                        window.location.reload(true);
                    }
                };
                con.find('a.close').on('click', function () { _on_close(); } );
                $(document).on('keydown', function(e) {
                     if (e.which === 27) _on_close();
                });
                this._container = con;
            }
            return this._container;
        },
        clear_timers: function () {
            for (var timerKey in _timer_interval_obj) {
                if (_timer_interval_obj.hasOwnProperty(timerKey)) {
                    window.clearInterval(_timer_interval_obj[timerKey]);
                }
            }
            for (var timeoutKey in _timeout_variables) {
                if (_timeout_variables.hasOwnProperty(timeoutKey)) {
                    window.clearTimeout(_timeout_variables[timeoutKey]);
                }
            }
        },
        cleanup: function (cancel_prev_req) {
            this.close_container();
            if (cancel_prev_req) {
                this.cancel_previous_sell_request();
                this.cancel_previous_analyse_request();
            }
            this._init();
        },
        basic_cleanup: function () {
            this.clear_timers();
            this.sparkline.clear();
            this.streaming.stop();
            this.streaming.url(null);
        },
        close_container: function () {
            this.basic_cleanup();
            if (live_chart && typeof live_chart !== "undefined") {
                live_chart.close_chart();
            }
            if (this._container) {
                this._container.hide().remove();
                this._container = null;
            }
        },
        server_data: function () {
            var data = {};
            var field = $('#sell_extra_info_data');
            if (field) {
                if (sessionStorage.getItem('stream_url') && sessionStorage.getItem('stream_url') == field.attr('stream_url')) {
                    data['stream_url'] = sessionStorage.getItem('stream_url');
                } else {
                    sessionStorage.setItem('stream_url', field.attr('stream_url'));
                    data['stream_url'] = field.attr('stream_url');
                }
                if (sessionStorage.getItem('submit_url') && sessionStorage.getItem('submit_url') == field.attr('submit_url')) {
                    data['submit_url'] = sessionStorage.getItem('submit_url');
                } else {
                    sessionStorage.setItem('submit_url', field.attr('submit_url'));
                    data['submit_url'] = field.attr('submit_url');
                }
                if (sessionStorage.getItem('error_message') && sessionStorage.getItem('error_message') == field.attr('submit_url')) {
                    data['error_message'] = sessionStorage.getItem('error_message');
                } else {
                    sessionStorage.setItem('error_message', field.attr('error_message'));
                    data['error_message'] = field.attr('error_message');
                }
                data['sell_channel'] = field.attr('sell_channel');
                data['barrier'] = field.attr('barrier');
                data['barrier2'] = field.attr('barrier2');
                data['is_immediate'] = field.attr('is_immediate');
                data['is_negative'] = field.attr('is_negative');
                data['is_forward_starting'] = field.attr('is_forward_starting');
                data['trade_feed_delay'] = field.attr('trade_feed_delay');
                data['currency'] = field.attr('currency');
                data['purchase_price'] = field.attr('purchase_price');
                data['shortcode'] = field.attr('shortcode');
                data['payout'] = field.attr('payout');
                data['contract_id'] = field.attr('contract_id');
            }
            return data;
        },
        general_error_message: function () {
            var data = this.server_data();
            return data.error_message || 'Contract cannot be sold at this time.';
        },
        show_warning: function(data, replace) {
            if (replace) {
                this.clear_warnings();
            }
            var con = this.container();
            $('.sell_price_wrapper', con).hide();
            var warn_con = $(con.find('#warning_container')[0]);
            var warn = $('<p class="comment">' + data + '</p>');
            warn_con.html(warn).show();
            warn.show();
        },
        clear_warnings: function() {
            var warn_con = $(this.container().find('#warning_container')[0]);
            warn_con.hide();
            $('.message', warn_con).each(function () { $(this).hide().remove(); });
        },
        sell_button: function () {
            return $(this.container().find('#sell_at_market')[0]);
        },
        disable_button: function (button) {
            button.attr('disabled', 'disabled');
            button.fadeTo(0, 0.5);
        },
        enable_button: function (button) {
            button.removeAttr('disabled');
            button.fadeTo(0, 1);
        },
        disable_sell_button: function (button_id, hide) {
            var btn = $(button_id);
            var that = this;
            btn.attr('disabled', 'disabled');
            if (hide) {
                btn.hide();
            }
            this._sell_button_disabled = true;
        },
        enable_sell_button: function () {
            if (this._sell_button_disabled) {
                $('#sell_contract_form', this.container()).show();
                var btn = this.sell_button();
                btn.removeAttr('disabled');
                btn.show();
                this._sell_button_disabled = false;
            }
        },
        get_loading_html: function() {
            var image_link = page.settings.get('image_link');
            return '<span class="loading">'+text.localize('loading...')+'&nbsp;<img src="'+image_link['hourglass']+'" /></span>';
        },
        show_inpage_popup: function (data) {
            var con = this.container(true);
            if (data) {
                $('.inpage_popup_content', con).html(data);
            }
            var body = $(document.body);
            con.css('position', 'fixed').css('z-index', get_highest_zindex() + 100);
            body.append(con);
            con.show();
            // push_data_layer();
            if ($('#sell_bet_desc', con).length > 0) {
                con.draggable({
                    handle: '#sell_bet_desc'
                });
            } else {
                con.draggable();
            }
            this.reposition_confirmation();
            return con;
        },
        reposition_confirmation: function (x, y) {
            var con = this.container();
            var win_ = $(window);

            var x_min = 50;
            var y_min = 50;

            //To be responsive, on mobiles and phablets we show popup as full screen.
            if(win_.width() < 767) {
                x_min = 0;
                y_min = 0;
            }

            if (x === undefined) {
                x = Math.max(Math.floor((win_.width() - win_.scrollLeft() - con.width()) / 2), x_min) + win_.scrollLeft();
            }

            if (y === undefined) {
                y = Math.min(Math.floor((win_.height() - con.height()) / 2), y_min) + win_.scrollTop();
            }

            con.offset({left: x, top: y});
        },
        update_price: function (price) {
            var con = this._container;
            if (!con) {
                throw new Error("container is not available yet");
            }
            if (typeof price == 'object') {
                if (typeof price.price != 'undefined') {
                    price = price.price;
                } else if (typeof price.value != 'undefined') {
                    var payout = this.model.payout();
                    if (isNaN(payout)) {
                        throw new Error("Invalid payout " + payout);
                    }
                    price = price.value * payout;
                }
            }
            if (isNaN(price)) {
                throw new Error("Invalid price structure: " + price);
            }

            // update returns
            this.update_return(price);

            price = parseFloat(price).toFixed(2);
            var cur = this.model.currency(),
                prev_price;
            var price_parts = stylized_price(price);
            var price_con = $('#sell_price_container', con);

            if(price_con.length > 0) {
                var stylized = $('.stylized_price', price_con);
                $('.stylized_units', stylized).html(price_parts.units);
                $('.stylized_cents', stylized).html(price_parts.cents);
                $('.stylized_currency', stylized).html(cur);
                var price_field = $('input[name="price"]', price_con);
                prev_price = price_field.val();
                price_field.val(price);
                BetSell.sparkline.update(price);
                if (!prev_price) {
                    return;
                }

                if (prev_price < price) {
                    stylized.removeClass('price_moved_down');
                    stylized.addClass('price_moved_up');
                } else if (prev_price > price) {
                    stylized.removeClass('price_moved_up');
                    stylized.addClass('price_moved_down');
                } else {
                    stylized.removeClass('price_moved_up');
                    stylized.removeClass('price_moved_down');
                }
            }
            var trade_price = $('#trade_details_price', con);
            if (trade_price.length > 0) {
                prev_price = parseFloat(trade_price.html());
                trade_price.html(price_parts.units + '' + price_parts.cents);
                if (prev_price < price) {
                    trade_price.removeClass('price_moved_down');
                    trade_price.addClass('price_moved_up');
                } else if (prev_price > price) {
                    trade_price.removeClass('price_moved_up');
                    trade_price.addClass('price_moved_down');
                } else {
                    trade_price.removeClass('price_moved_up');
                    trade_price.removeClass('price_moved_down');
                }

            }
        },
        update_return: function(price) {
            var con = this._container;
            var trade_return = $('#trade_details_return', con);
            if (trade_return.length > 0) {
                price = (((price - this.model.purchase_price()) / this.model.purchase_price()) * 100 ).toFixed(2);
                trade_return.html(price + '%');
            }
        },
        update_spot: function (spot) {
            var con = this._container;
            if (!con) {
                throw new Error("container is not available yet");
            }
            var trade_spot = $('#now_spot', con);
            if (trade_spot.length > 0) {
                var prev_spot = parseFloat(trade_spot.html());
                trade_spot.html(spot);
                if (prev_spot < spot) {
                    trade_spot.removeClass('price_moved_down');
                    trade_spot.addClass('price_moved_up');
                } else if (prev_spot > spot) {
                    trade_spot.removeClass('price_moved_up');
                    trade_spot.addClass('price_moved_down');
                } else {
                    trade_spot.removeClass('price_moved_up');
                    trade_spot.removeClass('price_moved_down');
                }
            }
        },
        update_time: function(epoch_time){
            var that = this;

            var date = that.get_date_from_seconds(epoch_time);
            var mom = moment.utc(date).format('YYYY-MM-DD HH:mm:ss');
            
            var con = this._container;
            var selector = con.find('#trade_details_now_date');

            selector.attr('epoch_time', epoch_time);
            selector.html(mom);
        },
        update_timer: function (con, container_id, duration) {
            var that = this;
            var container = con.find('#'+container_id);

            if(container.length>0){
                var text_year = text.localize('year');
                var text_years = text.localize('years');
                var text_month = text.localize('month');
                var text_months = text.localize('months');
                var text_day = text.localize('day');
                var text_days = text.localize('days');
                var text_hour = text.localize('hour');
                var text_hours = text.localize('hours');
                var text_minute = text.localize('minute');
                var text_minutes = text.localize('minutes');
                var text_second = text.localize('second');
                var text_seconds = text.localize('seconds');

                var duration_m = moment.duration(duration*1000); 
                var text_arr = [];

                var months = duration_m.months();
                var days = duration_m.days();
                var hours = duration_m.hours();
                var minutes = duration_m.minutes();
                var seconds = duration_m.seconds();

                if(months > 0){
                    text_arr.push(months);
                    if(months > 1){
                        text_arr.push(text_months);
                    }
                    else{
                        text_arr.push(text_month);
                    }
                }

                if(days > 0){
                    text_arr.push(days);
                    if(days > 1){
                        text_arr.push(text_days);
                    }
                    else{
                        text_arr.push(text_day);
                    }
                }

                if(hours > 0){
                    text_arr.push(hours);
                    if(hours > 1){
                        text_arr.push(text_hours);
                    }
                    else{
                        text_arr.push(text_hour);
                    }
                }

                if(minutes > 0){
                    text_arr.push(minutes);
                    if(minutes > 1){
                        text_arr.push(text_minutes);
                    }
                    else{
                        text_arr.push(text_minute);
                    }
                }

                if(seconds > 0){
                    text_arr.push(seconds);
                    if(seconds > 1){
                        text_arr.push(text_seconds);
                    }
                    else{
                        text_arr.push(text_second);
                    }
                }

                var final = [text_arr[0],text_arr[1]];
                if(typeof text_arr[2] !== 'undefined'){
                    final.push(text_arr[2]);
                    final.push(text_arr[3]);
                }

                container.text(final.join(' '));
            }
        },
        update_barriers: function (barriers) {
            var that = this;
            var con = $('#live_barriers');
            if (barriers.barrier) {
                $('#now_barrier .dir', con).text(barriers.barrier.dir);
                $('#now_barrier .diff', con).text(barriers.barrier.diff);
            }
            if (barriers.barrier2) {
                $('#now_barrier2 .dir', con).html(barriers.barrier2.dir);
                $('#now_barrier2 .diff', con).text(barriers.barrier2.diff);
            }
        },
        update_high_low: function (force) {
            var con = this._container;
            var spot = $('#now_spot', con).html();
            var high = $('#now_high', con);
            var low = $('#now_low', con);
            var changed = false;
            if (high.length > 0) {
                spot = parseFloat(spot);
                if (spot > parseFloat(high.html())) {
                    high.html(spot);
                    changed = true;
                }
            }
            if (low.length > 0) {
                spot = parseFloat(spot);
                if (spot < parseFloat(low.html())) {
                    low.html(spot);
                    changed = true;
                }
            }
            if (changed || force) {
                ['now', 'final', 'eo'].forEach(function (place) {
                    var tooltip = $('#'+place+'_high_low_tooltip');
                    var local_high = $('#'+place+'_high');
                    var local_low = $('#'+place+'_low');
                    if (tooltip && local_high && local_low) {
                        tooltip.attr("title", text.localize('High') + ': '+local_high.html()+' '+text.localize('Low')+': '+ local_low.html());
                    }
                });
            }
            // Force all tooltips to the top all the time.
            // Hopefully, this isn't expensive.
            $('abbr').css('z-index', get_highest_zindex() + 1000);
        },
        resubmit_sell_at_market: function () {
            var that = this;
            this.basic_cleanup();
            $('.sell_bottom_content').hide();
            this.add_overlay();
            $('#reload_sell_container').show();
            $('#reload_sell_container').on('click', '#reload_sell', function () {
                var contractId = that.server_data().contract_id;
                that.close_container();
                _timeout_variables[Object.keys(_timeout_variables).length] = setTimeout(function() {
                    that.get_analyse_contract(contractId);
                }, 2000);
                // invoke submit after 2 seconds so settlement time differ from expiry date
            });
        },
        sell_at_market: function (data) {
            var that = this;
            var con = that.show_sell_at_market(data);
            var server_data = that.server_data();

            $('.tab_menu_container').tabs({
                load: function(event, ui){
                   var load_live_chart = ui.tab.find(".ui-tabs-anchor").attr('load_live_chart');
                   if (load_live_chart && load_live_chart == 1) {
                       var symbol = ui.tab.find(".ui-tabs-anchor").attr('underlying_symbol');
                       var liveChartConfig = new LiveChartConfig({ renderTo: 'analysis_live_chart', symbol: symbol, with_trades: 0, shift: 0});
                       var time_obj = that.get_time_interval();
                       if(time_obj['is_live'] && time_obj['is_live'] === 1) {
                            liveChartConfig.update( {
                                live: '10min'
                            });
                       } else {
                           var from_date, to_date;
                           if (server_data.is_forward_starting > 0) {
                               if(server_data.trade_feed_delay > 0) {
                                   from_date = that.get_date_from_seconds(time_obj['from_time'] - parseInt(server_data.trade_feed_delay));
                                   to_date = that.get_date_from_seconds(time_obj['to_time'] + parseInt(server_data.trade_feed_delay));
                               }
                           } else {
                               from_date = that.get_date_from_seconds(time_obj['from_time'] - 5);
                               to_date = that.get_date_from_seconds(time_obj['to_time']);
                           }

                           var display_marker = false;
                           if(time_obj['to_time'] - time_obj['from_time'] <= _diff_end_start_time) {
                               display_marker = true;
                           }

                           if(time_obj['force_tick']) {
                               liveChartConfig.update({
                                   force_tick: true,
                               });
                           }

                           liveChartConfig.update({
                               interval: {
                                   from: from_date,
                                   to: to_date
                               },
                               with_markers: display_marker,
                           });
                       }
                       configure_livechart();
                       updateLiveChart(liveChartConfig);
                       var barrier,
                           purchase_time = $('#trade_details_purchase_date').attr('epoch_time');
                       if (!purchase_time) { // dont add barrier if its forward starting
                           if(server_data.barrier && server_data.barrier2) {
                               if (liveChartConfig.has_indicator('high')) {
                                   live_chart.remove_indicator('high');
                               }
                               barrier = new LiveChartIndicator.Barrier({ name: "high", value: server_data.barrier, color: 'green', label: text.localize('High Barrier')});
                               live_chart.add_indicator(barrier);

                               if (liveChartConfig.has_indicator('low')) {
                                   live_chart.remove_indicator('low');
                               }
                               barrier = new LiveChartIndicator.Barrier({ name: "low", value: server_data.barrier2, color: 'red', label: text.localize('Low Barrier')});
                               live_chart.add_indicator(barrier);

                           } else {
                               if (liveChartConfig.has_indicator('barrier')) {
                                   live_chart.remove_indicator('barrier');
                               }
                               barrier = new LiveChartIndicator.Barrier({ name: "barrier", value: server_data.barrier, color: 'green', label: text.localize('Barrier')});
                               live_chart.add_indicator(barrier);
                           }
                       }
                       that.add_time_indicators(liveChartConfig);
                   }
                }
            });
            that.model.currency(server_data.currency);
            that.model.shortcode(server_data.shortcode);
            that.model.payout(server_data.payout);
            that.model.purchase_price(server_data.purchase_price);
            that.clear_warnings();
            var now_time_con = con.find('#now_time_container');
            if (now_time_con.length > 0 ) {
                var stream_url = server_data.stream_url + '/' + server_data.sell_channel;
                that.streaming.start(stream_url);
                // that.start_now_timer(con, 'now_time_container', 'trade_date_now'); // now timer
                // that.create_date_timer(con.find('#trade_details_now_date'));

                // var duration = now_time_con.attr('duration'); // need now duration to subtract from end duration
                // if(parseInt(duration) > 0) { // if now duration is positive then start the timer for end date
                //     if(con.find('#end_time_container').attr('duration') !== '') {
                //         duration = parseInt(con.find('#end_time_container').attr('duration')) - parseInt(duration);
                //         if (duration > 0) {
                //             that.start_end_timer(con, 'end_time_container', 'now_time_container', 'trade_date_end', duration); // end timer
                //         }
                //     }
                // }
            }
            if (con.find($('#sell_price_container')).length > 0) {
                that.sparkline.init(55);
                con.on('click', '#sell_at_market', function (e) { e.preventDefault(); that.on_sell_button_click('#sell_at_market'); return false; });
            }
            that.update_high_low(true);
            that.reposition_confirmation();
        },
        start_end_timer: function (con, end_attr_selector_id, now_attr_selector_id, container_id, duration) {
            var that = this;
            var time_container = con.find('#' + end_attr_selector_id);
            var now_time_container = con.find('#' + now_attr_selector_id);
            if (time_container.length > 0) {
                var time_obj = that.seconds_to_time(duration);
                var selected = 0;
                time_obj['is_inverse'] = 1;

                var text_year = text.localize('year');
                var text_years = text.localize('years');
                var text_month = text.localize('month');
                var text_months = text.localize('months');
                var text_day = text.localize('day');
                var text_days = text.localize('days');
                var text_hour = text.localize('hour');
                var text_hours = text.localize('hours');
                var text_minute = text.localize('minute');
                var text_minutes = text.localize('minutes');
                var text_second = text.localize('second');
                var text_seconds = text.localize('seconds');


                var interval = 1;
                var timer_input = {
                    year        : { value: time_obj.year, text: text_year, text_plural: text_years, interval: 31536000 },
                    month       : { value: time_obj.month, text: text_month, text_plural: text_months, interval: 2592000  },
                    day         : { value: time_obj.day, text: text_day, text_plural: text_days, interval: 86400 },
                    hour        : { value: time_obj.hour, text: text_hour, text_plural: text_hours, interval: 3600 },
                    minute      : { value: time_obj.minute, text: text_minute, text_plural: text_minutes, interval: 60 },
                    second      : { value: time_obj.second, text: text_second, text_plural: text_seconds, interval: 1 },
                    is_inverse  : time_obj['is_inverse'],
                };
                that.create_timer(con.find('#' + container_id), timer_input);

            }
        },
        start_now_timer: function (con, attr_selector_id, container_id) {
            var that = this;
            var time_container = con.find('#' + attr_selector_id);
            if (time_container.length > 0) {
                var time_obj = that.seconds_to_time(time_container.attr('duration'));

                var text_year = text.localize('year');
                var text_years = text.localize('years');
                var text_month = text.localize('month');
                var text_months = text.localize('months');
                var text_day = text.localize('day');
                var text_days = text.localize('days');
                var text_hour = text.localize('hour');
                var text_hours = text.localize('hours');
                var text_minute = text.localize('minute');
                var text_minutes = text.localize('minutes');
                var text_second = text.localize('second');
                var text_seconds = text.localize('seconds');

                var interval = 1;
                var timer_input = {
                    year        : { value: time_obj.year, text: text_year, text_plural: text_years, interval: 31536000 },
                    month       : { value: time_obj.month, text: text_month, text_plural: text_months, interval: 2592000  },
                    day         : { value: time_obj.day, text: text_day, text_plural: text_days, interval: 86400 },
                    hour        : { value: time_obj.hour, text: text_hour, text_plural: text_hours, interval: 3600 },
                    minute      : { value: time_obj.minute, text: text_minute, text_plural: text_minutes, interval: 60 },
                    second      : { value: time_obj.second, text: text_second, text_plural: text_seconds, interval: 1 },
                    is_negative : time_obj['is_negative'],
                };
                that.create_timer(con.find('#' + container_id), timer_input);
            }

        },
        get_params: function (element) {
            var params_arr = [];
            if (!element) return '';
            var attr = element.attributes;
            var j=0;
            for (var i = 0; i < attr.length; i++ ) {

                if (attr[i].name == 'class' || attr[i].name == 'onclick') {
                    continue;
                }

                params_arr[j] = attr[i].name+'='+encodeURIComponent(attr[i].value);
                j++;

            }
            return params_arr.join('&');
        },
        show_sell_at_market: function (data) {
            return this.show_inpage_popup('<div class="inpage_popup_content_box">' + data + '</div>');
        },
        on_sell_button_click: function (target) {
            this.disable_sell_button(target, true);
            this.streaming.stop();
            this.model.reload_page_on_close(true);
            this.show_loading();
            this.sell_bet();
        },
        cancel_previous_sell_request: function() {
            if (_sell_request) {
                _sell_request.abort();
            }
        },
        cancel_previous_analyse_request: function() {
            if (_analyse_request) {
                _analyse_request.abort();
            }
        },
        show_loading: function () {
            var con = this.container();
            var sell_info = $( con.find('.sell_info')[0] );
            var loading = this.get_loading_html();
            loading = $(loading);
            loading.show();
            sell_info.append(loading);
        },
        hide_loading: function () {
            var con = this.container();
            con.find('.loading').each( function () { $(this).hide().remove(); } );
        },
        get_sell_bet_data: function () {
            return 'controller_action=sell&purchase_price=' + this.server_data().purchase_price + '&currency=' + this.server_data().currency + '&shortcode=' + this.server_data().shortcode + '&contract_id=' + this.server_data().contract_id + '&payout=' + this.server_data().payout + '&price=' + $('input[name="price"]', $('#sell_price_container')).val() + '&ajax_only=1';
        },
        sell_bet: function () {
            var that = this;
            var timeout = 60000;
            this.cancel_previous_sell_request();
            _sell_request = $.ajax(ajax_loggedin({
                url     : that.server_data().submit_url,
                type    : 'POST',
                async   : true,
                data    : that.get_sell_bet_data(),
                timeout : timeout,
                success : function (resp, resp_status, jqXHR) {
                    that.on_sell_bet_success(resp, resp_status, jqXHR);
                },
                error   : function (jqXHR, resp_status, exp) {
                    that.on_sell_bet_error(jqXHR, resp_status, exp);
                },
            }));
        },
        on_sell_bet_success: function (resp, resp_status, jqXHR) {
            var data = {};
            if (typeof resp == 'object') {
               data = resp;
            } else {
                data = (JSON && JSON.parse(resp)) || $.parseJSON(resp) || {};
            }
            this.hide_loading();
            if (data.redirect) {
                window.location.href = data.redirect;
                return;
            } else if (data.error) {
                this.show_warning(data.error, true);
            } else if (data.display) {
                this.clear_warnings();
                this.show_inpage_popup(data.display);
            } else {
                throw new Error("Invalid server response: " + data);
            }
        },
        on_sell_bet_error: function (jqXHR, resp_status, exp) {
            this.hide_loading();
            var details = '' + exp;
            if (jqXHR.responseText) {
                details += jqXHR.responseText;
            } else if (document.location.href.match(/^http:/) && (!details || details.match(/access/i))) {
                details += '<p>Please <a href="' + document.location.href.replace('http://', 'https://') + '">continue browsing using HTTPS secure protocol</a></p>';
            }
            this.show_warning(details, true);
        },
        get_analyse_contract: function (contract_id, bologinid, clicked_button) {
            if (clicked_button) {
                this.disable_button($(clicked_button));
            }
            this.cancel_previous_analyse_request();
            var $loading = $('#trading_init_progress');
            if($loading.length){
                $loading.show();
            }
            var data = "contract_id=" + encodeURIComponent(contract_id);
            if (bologinid) {
                data += '&bo_client=' + encodeURIComponent(bologinid);
            }
            _analyse_request = $.ajax(ajax_loggedin({
                context : this,
                url     : page.url.url_for('trade/analyse_contract'),
                type    : 'POST',
                data    : data,
                success : function (data, textStatus, jqXHR) {
                    if (jqXHR.responseJSON) {
                        this.only_show_chart(data);
                    } else {
                        var html = $.parseHTML(data);
                        if ($(html).find('#is_spread_contract').length) {
                            this.show_buy_sell(data);
                        } else {
                            this.sell_at_market(data);
                        }
                    }
                },
                error   : function (jqXHR, resp_status, exp) {
                    this.show_sell_at_market(text.localize("Please try again."));
                },
            })).always(function () {
                if($loading.length){
                    $loading.hide();
                }
                if (clicked_button) {
                    this.enable_button($(clicked_button));
                }
            });
        },
        register: function () {
            var that = this;
            $('#profit-table, #portfolio-table, #bet_calculation_container, #statement-table, #statement-ws-container, #contract_confirmation_container, #profit-table-ws-container').on('click', '.open_contract_details', function (e) {
                e.preventDefault();
                that.get_analyse_contract($(this).attr('contract_id'), $(this).attr('bo_client'), this);
            });
        },
        show_buy_sell: function(data) {
            var con = this.show_spread_popup(data);
            if (con && !con.find('#status').hasClass('loss')) {
                BetPrice.spread.stream($('#sell_extra_info_data').attr('sell_channel'));
            }
        },
        show_spread_popup: function(data) {
            var that = this;

            var con = that.container(true);
            con.addClass('spread_popup');
            data = '<div class="inpage_popup_content_box">' + data + '</div>';
            if (data) {
                $('.inpage_popup_content', con).html(data);
            }
            var body = $(document.body);
            con.css('position', 'fixed').css('z-index', get_highest_zindex() + 100);
            body.append(con);
            con.show();
            // push_data_layer();
            if ($('#sell_bet_desc', con).length > 0) {
                con.draggable({
                    handle: '#sell_bet_desc'
                });
            } else {
                con.draggable();
            }
            this.reposition_confirmation();
            return con;
        },
        only_show_chart: function(data) {
            this.show_inpage_popup('<div class="inpage_popup_content_box"><div class="popup_bet_desc drag-handle">'+data.longcode+'</div><div id="tick_chart"></div></div>');
            TickDisplay.initialize(data);
        },
        streaming: function() {
            var _stream = null;
            var _update_from_stream = false;
            var _url = null;
            var timer;
            return {
                start: function(url) {
                    BetSell.sparkline.clear();
                    this.stop();
                    if (url) {
                        this._url = url;
                    }
                    _update_from_stream = true;
                    url = this._url;
                    if (url && typeof (EventSource) !== "undefined") {
                        this._stream = new EventSource(url, { retry: 18000000 });
                        var that = this;
                        this._stream.onmessage = function(e) {
                            that.process_message(e.data);
                        };
                        this._stream.addEventListener("ping", function(e) { return true; });
                        return true;
                    } else {
                        var err_msg = "We are not able to stream live prices at the moment. To enjoy live streaming of prices try refreshing the page, if you get this issue after repeated attempts try a different browser";
                        BetSell.show_warning(err_msg);
                        $('#spot_spark').html('<span title="' + err_msg + '">No Live price update</span>"');
                        return false;
                    }
                },
                stop: function() {
                    if (this._stream) {
                        this._stream.close();
                        this._stream = null;
                    }
                },
                ignore_updates: function() {
                    _update_from_stream = false;
                },
                process_message: function(data) {
                    if (_update_from_stream) {
                        var bet = JSON.parse(data);
                        var no_error = true;
                        this.update_price(bet);
                    }
                }, // process_message

                update_price: function(bet) {
                    var prices = bet.prices;
                    var spot = bet.spot;
                    var epoch = bet.epoch;

                    var con = BetSell.container();
                    var start_epoch_el =  con.find('#trade_details_start_date');
                    var end_epoch_el = con.find('#trade_details_end_date');

                    if(start_epoch_el.length && end_epoch_el.length && start_epoch_el.attr('epoch_time') && end_epoch_el.attr('epoch_time')){
                        var start_epoch = start_epoch_el.attr('epoch_time');
                        var end_epoch = end_epoch_el.attr('epoch_time');

                        if(epoch > end_epoch){
                            epoch = end_epoch; 
                            this.stop();
                        }
                        else{
                            BetSell.update_spot(spot);
                            for (var i = 0; i < prices.length; i++) {
                                if (!prices[i] || prices[i].id != 'sell') {
                                    continue;
                                }
                                if (prices[i].err) {
                                    BetSell.show_warning(prices[i].err, true);
                                    BetSell.disable_sell_button('#sell_at_market', true);
                                    no_error = false;
                                } else {
                                    BetSell.clear_warnings();
                                    BetSell.enable_sell_button();
                                }
                                BetSell.update_price(prices[i]);
                                BetSell.update_barriers(bet.barriers);
                            } // for    
                        }
                        BetSell.update_time(epoch);
                        BetSell.update_timer(con,'trade_date_now', epoch-start_epoch);
                        BetSell.update_timer(con,'trade_date_end', end_epoch-epoch);                 
                    }
                },
                url: function(val) {
                    if (val !== undefined) {
                        this._url = val;
                        return this;
                    }
                    return this._url;
                },
            };
        }(), // streaming
        sparkline: function() {
            var _values = [];
            var _length = 30;
            return {
                init:   function(length) {
                    _values = [];
                    if (length) {
                        _length = length;
                    }
                    var container = $(BetSell.container().find('#sell_price_container')[0]);
                    $('#sell_price_sparkline').remove();
                    var spark = $('<div id="sell_price_sparkline"></div>');
                    container.append(spark);
                    spark.show();
                    $('#sell_price_container').on('mouseover', '#sell_price_sparkline canvas', function () { $('#jqstooltip').css('z-index', get_highest_zindex() + 100); });
                },
                update: function(val) {
                    var that = this;
                    _values.push(val);
                    if (_values.length >= _length) {
                        _values.shift();
                    }
                    $('#sell_price_sparkline').sparkline(_values, that._config);
                },
                clear: function() {
                    var that = this;
                    _values = [];
                    $('#sell_price_sparkline').sparkline(_values, that._config);
                },
                _config: {
                    type: 'line',
                    lineColor: '#606060',
                    fillColor: false,
                    spotColor: '#00f000',
                    minSpotColor: '#f00000',
                    maxSpotColor: '#0000f0',
                    highlightSpotColor: '#ffff00',
                    highlightLineColor: '#000000',
                    spotRadius: 1.25
                },
            };
        }(), // sparkline
        create_timer: function (selector, input) { // input in form of obj have year : { value: 0, text: 'text', interval: 1}
            var duration_obj = {};
            var interval = 1;
            var that = this;
            if(input.year && input.year.value > 0) {
                duration_obj['year'] = input.year.value;
                interval = input.year.interval;
            }
            if(input.month && input.month.value > 0) {
                duration_obj['month'] = input.month.value;
                interval = input.month.interval;
            }
            if(input.day && input.day.value > 0) {
                duration_obj['day'] = input.day.value;
                interval = input.day.interval;
            }
            if(input.hour && input.hour.value > 0) {
                duration_obj['hour'] = input.hour.value;
                interval = input.hour.interval;
            }
            if(input.minute && input.minute.value > 0) {
                duration_obj['minute'] = input.minute.value;
                interval = input.minute.interval;
            }
            if(input.second && input.second.value > 0) {
                duration_obj['second'] = input.second.value;
                interval = input.second.interval;
            }

            var duration = moment.duration(duration_obj);
            _timer_interval_obj[Object.keys(_timer_interval_obj).length] = setInterval(function anonymous() {
                    var timestring;
                    var count = 0;

                    if (input['is_negative']) {
                        timestring = '- ';
                        duration = moment.duration(duration.asSeconds() - interval, 'seconds');
                    } else if (input['is_inverse']) {
                        timestring = '';
                        duration = moment.duration(duration.asSeconds() - interval, 'seconds');
                    } else {
                        timestring = '';
                        duration = moment.duration(duration.asSeconds() + interval, 'seconds');
                    }
                    var full_count_days =  Math.floor(duration.asDays());
                    if (full_count_days == 1 && count < 2) {
                        timestring += full_count_days + ' ' + input.day.text + ' ';
                        count++;
                    } else if (full_count_days > 1 && count < 2) {
                        timestring += full_count_days + ' ' + input.day.text_plural + ' ';
                        count++;
                    }
                    if (duration.hours() == 1 && count < 2) {
                        timestring += duration.hours() + ' ' + input.hour.text + ' ';
                        count++;
                    } else if (duration.hours() > 1 && count < 2) {
                        timestring += duration.hours() + ' ' + input.hour.text_plural + ' ';
                        count++;
                    }
                    if (duration.minutes() == 1 && count < 2) {
                        timestring += duration.minutes() + ' ' + input.minute.text + ' ';
                        count++;
                    } else if (duration.minutes() > 1 && count < 2) {
                        timestring += duration.minutes() + ' ' + input.minute.text_plural + ' ';
                        count++;
                    }

                    if (duration.seconds() == 1 && count < 2) {
                        timestring += duration.seconds() + ' ' + input.second.text;
                        count++;
                    } else if (duration.seconds() > 1 && count < 2) {
                        timestring += duration.seconds() + ' ' + input.second.text_plural;
                        count++;
                    } else if (duration.seconds() === 0 && count < 1) {
                        timestring += duration.seconds() + ' ' + input.second.text;
                        count++;
                    }

                    if (count === 0) {
                        that.resubmit_sell_at_market();
                    } else if (full_count_days === 0 && duration.hours() === 0 && duration.minutes() === 0 && duration.seconds() === 0) {
                        selector.html(timestring);
                        that.resubmit_sell_at_market();
                    } else {
                        selector.html(timestring);
                    }
                    return anonymous;
            }(), Math.abs(interval) * 1000);
        },
        create_date_timer: function(selector) {
            var interval = 1;
            var that = this;
            var epoch_time = parseInt(selector.attr('epoch_time')) + 1;
            _timer_interval_obj[Object.keys(_timer_interval_obj).length] = setInterval(function anonymous() {
                epoch_time += interval;
                var date = that.get_date_from_seconds(epoch_time);
                var mom = moment.utc(date).format('YYYY-MM-DD HH:mm:ss');
                selector.attr('epoch_time', epoch_time);
                selector.html(mom);
                return anonymous;
            },  Math.abs(interval) * 1000);
        },
        seconds_to_time: function(seconds) {
            var duration = moment.duration(Math.abs(parseInt(seconds)), 'seconds');
            var days, months;
            // as we dont use month in our date format
            if (duration.asDays() > 365) {
                days = duration.days();
                months = duration.months();
            } else {
                days = Math.floor(duration.asDays());
                months = 0;
            }
            var obj = {
                year: duration.years(),
                month: months,
                day: days,
                hour: duration.hours(),
                minute: duration.minutes(),
                second: duration.seconds(),
            };
            obj['is_negative'] = parseInt(seconds) < 0 ? 1 : 0;
            return obj;
        },
        get_date_from_seconds: function(seconds) {
            var date = new Date(seconds*1000);
            return date;
        },
        get_time_interval: function() {
            var time_obj = {};
            var start_time = $('#trade_details_start_date').attr('epoch_time');
            var purchase_time = $('#trade_details_purchase_date').attr('epoch_time');
            var now_time = $('#trade_details_now_date').attr('epoch_time');
            var end_time = $('#trade_details_end_date').attr('epoch_time');
            if(purchase_time) { // forward starting
                time_obj['from_time'] = parseInt(purchase_time);
                time_obj['to_time'] = parseInt(start_time);
            } else if(start_time && now_time) {
                if (now_time > start_time) {
                    if (((parseInt(end_time) - parseInt(start_time)) > 3600) && ((parseInt(now_time) - parseInt(start_time)) < 3600)) {
                        // check if end date is more than 1 hours and now time - start time is less than 1 hours
                        // in this case we switch back to tick chart rather than ohlc
                        time_obj['from_time'] = parseInt(start_time);
                        time_obj['to_time'] = parseInt(start_time) + 3595;
                    } else if ((parseInt(end_time) - parseInt(start_time)) === 3600) {
                        time_obj['from_time'] = parseInt(start_time);
                        time_obj['to_time'] = parseInt(end_time);
                        time_obj['force_tick'] = 1;
                    } else {
                        time_obj['from_time'] = parseInt(start_time);
                        time_obj['to_time'] = parseInt(end_time);
                    }
                }
            } else if (!now_time && start_time && end_time) { // bet has expired
                time_obj['from_time'] = parseInt(start_time);
                time_obj['to_time'] = parseInt(end_time);
            } else {
                time_obj['is_live'] = 1;
            }
            return time_obj;
        },
        add_time_indicators: function(liveChartConfig) {
            var that = this,
                indicator;
            var start_time = $('#trade_details_start_date').attr('epoch_time');
            var purchase_time = $('#trade_details_purchase_date').attr('epoch_time');
            var sold_time = $('#trade_details_sold_date').attr('epoch_time');
            var end_time = $('#trade_details_end_date').attr('epoch_time');
            var entry_spot_time = $('#trade_details_entry_spot_time').attr('epoch_time');
            if(purchase_time) {
                if (liveChartConfig.has_indicator('purchase_time')) {
                    live_chart.remove_indicator('purchase_time');
                }
                indicator = new LiveChartIndicator.Barrier({ name: "purchase_time", label: 'Purchase Time', value: that.get_date_from_seconds(parseInt(purchase_time)), color: '#e98024', axis: 'x'});
                live_chart.add_indicator(indicator);
            }

            if(start_time) {
                if (liveChartConfig.has_indicator('start_time')) {
                    live_chart.remove_indicator('start_time');
                }
                indicator = new LiveChartIndicator.Barrier({ name: "start_time", label: 'Start Time', value: that.get_date_from_seconds(parseInt(start_time)), color: '#e98024', axis: 'x'});
                live_chart.add_indicator(indicator);
            }

            if(entry_spot_time && entry_spot_time != start_time) {
                if (liveChartConfig.has_indicator('entry_spot_time')) {
                    live_chart.remove_indicator('entry_spot_time');
                }

                if (start_time && entry_spot_time < start_time) {
                    indicator = new LiveChartIndicator.Barrier({ name: "entry_spot_time", label: 'Entry Spot', value: that.get_date_from_seconds(parseInt(entry_spot_time)), color: '#e98024', axis: 'x'});
                } else {
                    indicator = new LiveChartIndicator.Barrier({ name: "entry_spot_time", label: 'Entry Spot', value: that.get_date_from_seconds(parseInt(entry_spot_time)), color: '#e98024', axis: 'x', nomargin: true});
                }
                live_chart.add_indicator(indicator);
            }

            if(end_time) {
                if (liveChartConfig.has_indicator('end_time')) {
                    live_chart.remove_indicator('end_time');
                }

                indicator = new LiveChartIndicator.Barrier({ name: "end_time", label: 'End Time', value: that.get_date_from_seconds(parseInt(end_time)), color: '#e98024', axis: 'x'});
                live_chart.add_indicator(indicator);
            }
            if(sold_time) {
                if (liveChartConfig.has_indicator('sold_time')) {
                    live_chart.remove_indicator('sold_time');
                }

                indicator = new LiveChartIndicator.Barrier({ name: "sold_time", label: 'Sell Time', value: that.get_date_from_seconds(parseInt(sold_time)), color: '#e98024', axis: 'x'});
                live_chart.add_indicator(indicator);
            }

        },
        add_overlay: function() {
            var overlay = $('#overlay-wrapper');
            overlay.show();
            overlay.css({
                height: $('#sell_content_container').outerHeight(true) + 'px',
                top: $('#sell_bet_desc').outerHeight() + 'px', // appending pixel because this height is already generated
            });
        },
        show_popup: function(trans_id) {
            var contract_id = (/trading/i).test(window.location.pathname) ? 
                $('div.button button.open_contract_detailsws').attr('contract_id') :
                $('td').filter(function() {return $(this).text() == trans_id;}).parents('tr').find('button.open_contract_detailsws').attr('contract_id');
            this.get_analyse_contract(contract_id);
        },
    }; // BetSell
}();
;var PricingDetails = function() {
    return {
        register: function() {
            if(this.popup().length > 0) {
                this.on_open_debug_link();
                this.on_close();
            }
        },
        on_open_debug_link: function() {
            var that = this;
            $('a.pricing-details').on('click', function (event) {
                var popup = that.popup();
                $('.draggable').draggable(); // This is overkill, but nobody cares.
                popup.toggleClass('invisible');

                $('#' + popup.children(':first').attr('id')).tabs();

                event.preventDefault();
            }).addClass('unbind_later');
        },
        on_close: function() {
            var that = this;
            $('a.pricing-details-close').on('click', function (event) {
                that.popup().addClass('invisible');
                event.preventDefault();
            }).addClass('unbind_later');
        },
        popup: function() {
            return $('#pricing_details_popup');
        }
    };
}();
;var TickDisplay = function() {
    return {
        reset: function() {
            var $self = this;
            $self.contract_barrier = null;
            $self.applicable_ticks = [];
            $self.number_of_ticks = null;
            $self.ev.close();
            $self.chart.destroy();
        },
        initialize: function(data) {
            var $self = this;

            // setting up globals
            $self.number_of_ticks = parseInt(data.number_of_ticks);
            $self.symbol = data.symbol;
            $self.display_symbol = data.display_symbol;
            $self.contract_start_ms = parseInt(data.contract_start * 1000);
            $self.contract_category = data.contract_category;
            $self.set_barrier = ($self.contract_category.match('digits')) ? false : true;
            $self.display_decimals = data.display_decimals || 2;
            $self.show_contract_result = data.show_contract_result;
            var tick_frequency = 5;

            if (data.show_contract_result) {
                $self.contract_sentiment = data.contract_sentiment;
                $self.price = parseFloat(data.price);
                $self.payout = parseFloat(data.payout);
            }

            var minimize = data.show_contract_result;

            $self.set_x_indicators();
            $self.initialize_chart({
                plot_from: data.previous_tick_epoch * 1000,
                plot_to: new Date((parseInt(data.contract_start) + parseInt(($self.number_of_ticks+2)*tick_frequency)) * 1000).getTime(),
                minimize: minimize,
                width: data.width ? data.width : undefined
            });
        },
        set_x_indicators: function() {
            var $self = this;

            var exit_tick_index = $self.number_of_ticks - 1;
            if ($self.contract_category.match('asian')) {
                $self.ticks_needed = $self.number_of_ticks;
                $self.x_indicators = {
                    '_0': { label: 'Entry Spot', id: 'start_tick'},
                };
                $self.x_indicators['_' + exit_tick_index] = {
                    label: 'Exit Spot',
                    id: 'exit_tick',
                };
            } else if ($self.contract_category.match('callput')) {
                $self.ticks_needed = $self.number_of_ticks + 1;
                $self.x_indicators = {
                    '_0': { label: 'Entry Spot', id: 'entry_tick'},
                };
                $self.x_indicators['_' + $self.number_of_ticks] = {
                    label: 'Exit Spot',
                    id: 'exit_tick',
                };
            } else if ($self.contract_category.match('digits')) {
                $self.ticks_needed = $self.number_of_ticks;
                $self.x_indicators = {
                    '_0': { label: 'Tick 1', id: 'start_tick'},
                };
                $self.x_indicators['_' + exit_tick_index] = {
                    label:  'Tick ' + $self.number_of_ticks,
                    id: 'last_tick',
                };
            } else {
                $self.x_indicators = {};
            }
        },
        initialize_chart: function(config) {
            var $self = this;

            $self.chart = new Highcharts.Chart({
                chart: {
                    type: 'line',
                    renderTo: 'tick_chart',
                    width: config.width ? config.width : (config.minimize ? 394 : null),
                    height: config.minimize ? 143 : null,
                    backgroundColor: null,
                    events: { load: $self.plot(config.plot_from, config.plot_to) },
                    marginLeft: 100
                },
                credits: {enabled: false},
                tooltip: {
                    formatter: function () {
                        var that = this;
                        var new_y = that.y.toFixed($self.display_decimals);
                        var mom = moment.utc($self.applicable_ticks[that.x].epoch*1000).format("dddd, MMM D, HH:mm:ss");
                        return mom + "<br/>" + $self.display_symbol + " " + new_y;
                    },
                },
                xAxis: {
                    type: 'linear',
                    min: 0,
                    max: $self.number_of_ticks + 1,
                    labels: { enabled: false, }
                },
                yAxis: {
                    opposite: false,
                    labels: {
                        align: 'left',
                        x: 0,
                    },
                    title: ''
                },
                series: [{
                    data: [],
                }],
                title: '',
                exporting: {enabled: false, enableImages: false},
                legend: {enabled: false},
            });
        },
        plot: function(plot_from, plot_to) {
            var $self = this;

            var plot_from_moment = moment(plot_from).utc();
            var plot_to_moment = moment(plot_to).utc();
            var contract_start_moment = moment($self.contract_start_ms).utc();
            $self.counter = 0;
            $self.applicable_ticks = [];

            var symbol = $self.symbol;
            var stream_url = window.location.protocol + '//' + page.settings.get('streaming_server');
            stream_url += "/stream/ticks/" + symbol + "/" + plot_from_moment.unix() + "/" + plot_to_moment.unix();
            $self.ev = new EventSource(stream_url, { withCredentials: true });

            $self.ev.onmessage = function(msg) {
                if ($self.applicable_ticks.length >= $self.ticks_needed) {
                    $self.ev.close();
                    $self.evaluate_contract_outcome();
                    return;
                }

                var data = JSON.parse(msg.data);
                if (data && !(data[0] instanceof Array)) {
                    data = [ data ];
                }
                if (data) {
                    for (var i = 0; i < data.length; i++) {
                        if (data[i][0] === 'tick') {
                            var tick = {
                                epoch: parseInt(data[i][1]),
                                quote: parseFloat(data[i][2])
                            };

                            if (tick.epoch > contract_start_moment.unix()) {
                                if ($self.applicable_ticks.length >= $self.ticks_needed) {
                                    $self.ev.close();
                                    $self.evaluate_contract_outcome();
                                    return;
                                } else {
                                    if (!$self.chart) return;
                                    if (!$self.chart.series) return;
                                    $self.chart.series[0].addPoint([$self.counter, tick.quote], true, false);
                                    $self.applicable_ticks.push(tick);
                                    var indicator_key = '_' + $self.counter;
                                    if (typeof $self.x_indicators[indicator_key] !== 'undefined') {
                                        $self.x_indicators[indicator_key]['index'] = $self.counter;
                                        $self.add($self.x_indicators[indicator_key]);
                                    }

                                    $self.add_barrier();
                                    $self.apply_chart_background_color(tick);
                                    $self.counter++;
                                }
                            }

                        }
                    }
                }
            };
            $self.ev.onerror = function(e) {$self.ev.close(); };
        },
        apply_chart_background_color: function(tick) {
            var $self = this;
            if(!$self.show_contract_result) {
                return;
            }
            var chart_container = $('#tick_chart');
            if ($self.contract_sentiment === 'up') {
                if (tick.quote > $self.contract_barrier) {
                    chart_container.css('background-color', 'rgba(46,136,54,0.198039)');
                } else {
                    chart_container.css('background-color', 'rgba(204,0,0,0.098039)');
                }
            } else if ($self.contract_sentiment === 'down') {
                if (tick.quote < $self.contract_barrier) {
                    chart_container.css('background-color', 'rgba(46,136,54,0.198039)');
                } else {
                    chart_container.css('background-color', 'rgba(204,0,0,0.098039)');
                }
            }
        },
        add_barrier: function() {
            var $self = this;

            if (!$self.set_barrier) {
                return;
            }

            var barrier_type = $self.contract_category.match('asian') ? 'asian' : 'static';

            if (barrier_type === 'static') {
                var barrier_tick = $self.applicable_ticks[0];
                $self.chart.yAxis[0].addPlotLine({
                    id: 'tick-barrier',
                    value: barrier_tick.quote,
                    label: {text: 'Barrier ('+barrier_tick.quote+')', align: 'center'},
                    color: 'green',
                    width: 2,
                    zIndex: 2,
                });
                $self.contract_barrier = barrier_tick.quote;
                $self.set_barrier = false;
            }

            if (barrier_type === 'asian') {
                var total = 0;
                for (var i=0; i < $self.applicable_ticks.length; i++) {
                    total += parseFloat($self.applicable_ticks[i].quote);
                }
                var calc_barrier =  total/$self.applicable_ticks.length;
                calc_barrier = calc_barrier.toFixed(parseInt($self.display_decimals) + 1); // round calculated barrier

                $self.chart.yAxis[0].removePlotLine('tick-barrier');
                $self.chart.yAxis[0].addPlotLine({
                    id: 'tick-barrier',
                    value: calc_barrier,
                    color: 'green',
                    label: {
                        text: 'Average ('+calc_barrier+')',
                        align: 'center'
                    },
                    width: 2,
                    zIndex: 2,
                });
                $self.contract_barrier = calc_barrier;
            }
        },
        add: function(indicator) {
            var $self = this;

            $self.chart.xAxis[0].addPlotLine({
               value: indicator.index,
               id: indicator.id,
               label: {text: indicator.label, x: /start_tick|entry_tick/.test(indicator.id) ? -15 : 5},
               color: '#e98024',
               width: 2,
               zIndex: 2,
            });
        },
        evaluate_contract_outcome: function() {
            var $self = this;

            if (!$self.contract_barrier) {
                return; // can't do anything without barrier
            }

            var exit_tick_index = $self.applicable_ticks.length - 1;
            var exit_spot = $self.applicable_ticks[exit_tick_index].quote;

            if ($self.contract_sentiment === 'up') {
                if (exit_spot > $self.contract_barrier) {
                    $self.win();
                } else {
                    $self.lose();
                }
            } else if ($self.contract_sentiment === 'down') {
                if (exit_spot < $self.contract_barrier) {
                    $self.win();
                } else {
                    $self.lose();
                }
            }
        },
        win: function() {
            var $self = this;

            var profit = $self.payout - $self.price;
            $self.update_ui($self.payout, profit, text.localize('This contract won'));
        },
        lose: function() {
            var $self = this;
            $self.update_ui(0, -$self.price, text.localize('This contract lost'));
        },
        update_ui: function(final_price, pnl, contract_status) {
            var $self = this;

            $('#bet-confirm-header').text(text.localize(contract_status));
            $('#contract-outcome-buyprice').text($self.to_monetary_format($self.price));
            $('#contract-outcome-payout').text($self.to_monetary_format(final_price));

            if (pnl > 0) {
                $('#contract-outcome-label').removeClass('standin loss').addClass('standout profit').text(text.localize('Profit'));
                $('#contract-outcome-profit').removeClass('standin loss').addClass('standout profit').text($self.to_monetary_format(pnl));
            } else {
                $('#contract-outcome-label').removeClass('standout profit').addClass('standin loss').text(text.localize('Loss'));
                $('#contract-outcome-profit').removeClass('standout profit').addClass('standin loss').text($self.to_monetary_format(pnl));
            }
            $('#confirmation_table').hide();
            $('#contract-outcome-details').show();
        },
        to_monetary_format: function(number) {
            return number.toFixed(2);
        }
    };
}();
;var rearrange_compare_underlying_list = function () {
    var instrument_content = $('#instrument-content');
    instrument_content.find('input').removeAttr('disabled');

    var first_li, line1, symbol, url;
    var all_li = $('#chart_compare_underlying').find('li');

    if (all_li.length == 1) {
        $('#instrument-content').find('input:checked').attr('disabled', true);
    }

    all_li.each(function (index) {
        var li = $(this);
        var instrument = instrument_content.find('#s_'+li.find('input[type=checkbox]').val().replace(/-$/,''));

        li.removeClass().addClass('line_'+(index+1));

        if (index === 0) {
            instrument.attr('checked', 'checked');
        }
    });

};

// Check input error
var check_input_error = function (container)
{
    var valid = true;

    container
        .find('.errorfield').remove()
        .end()
        .find('input[type=text]').each(function (){
            var error_message;

            if (!this.value.toString().match(/^\d+\.?\d*$/))
            {
                error_message = lightchart_text.error_digitonly;
            }
            else if(this.value <= 0)
            {
                error_message = lightchart_text.error_nonzero;
            }

            // If not digit
            if (error_message)
            {
                error_message = error_message.replace(/\{\d+:INPUT\}/, this.previousSibling.innerHTML);
                $(this).after('<div class="errorfield">'+error_message+'</div>');

                valid = false;
                return valid;
            }
        }).end()
        .siblings().find('input[type=text]').each(function () {
            if (!this.value.toString().match(/^\d+\.?\d*$/)) {
                $(this).remove();
            }
        });

    return valid;
};

function listen_to_chart_element () {
    var current_hover_li = null;
    var form_chart_director = $('#form_chart_director');
    var chart_director_imageholder = document.getElementById('chart_director_imageholder');
    var chart_properties = $('#chart_properties');
    var chart_overlay_or_new = $('#chart_overlay_or_new');
    var lightchart_text = {};
    var lightchart_texts = $('#lightchart_texts').find('li');
    var selected_field_history = {};
    var chart_compare_underlying = $('#chart_compare_underlying');
    var chart_period = $('#chart_period');

    lightchart_texts.each(function()
    {
        lightchart_text[this.id] = this.innerHTML;
    });

    var instrument_content = $('#instrument-content');
    instrument_content.find('input[value='+chart_compare_underlying.find('li:first input[name=overlay]').val()+']').attr('checked', 'checked');
    $('#form_chart_director input[name=symbol]').val(chart_compare_underlying.find('li:first input[name=overlay]').val().replace(/-$/,''));
    draw_chart();
    rearrange_compare_underlying_list();

    var remove_hover = function () {
        current_hover_li.removeClass('hover').find('.menu-wrap-a .tm-a').unwrap().unwrap();
    };

    var popup_content = {};
    var item_on_focus = {};

    $('.drop-down')
        .on('mouseover', '.tm-li', function (event) {
            var target = $(event.target);

            if (!target.hasClass('.tm-li')) {
                target = target.parents('.tm-li');
            }

            current_hover_li = target;

            target
                .parents('.tm-ul').find('.menu-wrap-a .tm-a').unwrap().unwrap()
                .end().end()
                .siblings().removeClass('hover').end()
                .find('.tm-a')
                .wrap('<span class="menu-wrap-a"><span class="menu-wrap-b"></span></span>');
        })
        .on('mouseout', '.tm-li', function (event) {
            if (!current_hover_li.hasClass('hover')) {
                $(event.target).parents('.tm-ul').find('.menu-wrap-a .tm-a').unwrap().unwrap();
            }
        });

    var previous_selected_radio = {};
    $('#form_chart_director')
        .find('input[type=radio]').each(function(){
            if (this.checked) {
                previous_selected_radio[this.name] = this.id;
            }
        }).end()
        .on('click', 'input[name=period],input[name=interval]', function (event){
            var target = $(event.target);
            if (target.attr('name') == 'interval')
            {
                target = $(document.getElementById('pr_1')).attr('checked', 'checked');
                $('#settings-content').find('input[value=CLOSE]').attr('checked', 'checked');
            }

            draw_chart(function () {
                target
                    .parents('#chart_period').find('.button').removeClass('disabled')
                    .end().end()
                    .siblings('label').addClass('disabled').children().addClass('disabled');
                return true;
            });
        })
        .on('click', '#settings-content input,input[value=None]', function (){
            draw_chart();
        })
        .on('click', '#band-content input,#indicator-content input,#moving-average-content input,#instrument-content input', function (event) {
            var selected_value = event.target.value;
            var key = selected_value.replace(/-$/,'');
            var prefix = event.target.name;
            var selected_id = event.target.id;

            if (event.target.type.toLowerCase() == 'checkbox' && !event.target.checked) {
                $('#chart_compare_underlying').find('ul').find('li input[value^=' + $(this).val() + ']').parents('li').remove();
                $('#form_chart_director input[name=symbol]').val($('#chart_compare_underlying').find('li:first input[name=overlay]').val().replace(/-$/,''));
                draw_chart();
                return true;
            }

            if (event.target.checked){
                item_on_focus = event.target;
            }

            if (prefix == '__selsym') {
                var overlays = chart_compare_underlying.find('li');

                if (overlays.size() > 5) {
                    overlays.filter(':nth-child(2)').remove();
                }

                overlays
                    .filter(':last').after('<li>'+($(event.target).next().html())+'<input type="checkbox" checked="checked" value="'+selected_value+'-" name="overlay" /></li>');

                $('#form_chart_director input[name=symbol]').val(selected_value);
                rearrange_compare_underlying_list();
                remove_hover();
                draw_chart();
                return true;
            }

            if (typeof popup_content[key] == 'object') {
                popup_content[key].removeClass('invisible').data('related_input_name', prefix).data('related_input_id', selected_id);
                remove_hover();
                return true;
            }
            else {
                // Request for the properties box if not exist
                $.get(
                    form_chart_director.attr('action') + '&' + form_chart_director.serialize()+ '&getdesc='+key+ '&prefix='+prefix,
                    function (texts) {
                        if (!texts) {
                            draw_chart();
                            return false;
                        }

                        // Append the container into its chart properties container,
                        // which groups all the chart properties
                        popup_content[key] = $('<div class="popupbox">'+decodeURIComponent(texts)+'</div>').appendTo(chart_properties);
                        popup_content[key].removeClass('invisible').data('related_input_name', prefix).data('related_input_id', selected_id);
                    }
                );
            }
        })
        .on('click', 'div.popupbox .close-button', function(event){
            var popupbox = $(event.target).parents('div.popupbox').addClass('invisible');
            $('#'+previous_selected_radio[popupbox.data('related_input_name')]).attr('checked', 'checked');
            $(item_on_focus).removeAttr('checked');
        })
        .on('click', 'div.popupbox button[type=submit]', function (event){
            event.preventDefault();

            var popupbox = $(event.target).parents('div.popupbox');

            var valid = check_input_error(popupbox);

            if (valid)
            {
                previous_selected_radio[popupbox.data('related_input_name')] = popupbox.data('related_input_id');

                draw_chart(function (){
                    popupbox.addClass('invisible');
                });
            }

            item_on_focus = null;
        })
        .on('mouseover', '#chart_compare_underlying li', function (event) {
            $(event.target).addClass('hover').parents('li').addClass('hover');
        })
        .on('mouseout', '#chart_compare_underlying li', function (event) {
            $(event.target).removeClass('hover').parents('li').removeClass('hover');
        })
        .on('click', '#chart_overlay_or_new .draw-overlay', function (event){
            if (chart_overlay_or_new.find('input:checked').val() == 'overlay') {
                var overlays = chart_compare_underlying.find('li');

                if (overlays.size() > 5) {
                    overlays.filter(':nth-child(2)').remove();
                }

                overlays
                    .filter(':last').after(
                        '<li><a href="#">' +
                        chart_overlay_or_new.find('h4').html() +
                        '</a><input type="checkbox" checked="checked" value="'+previous_selected_radio[chart_overlay_or_new.data('related_input_name')]+'" name="overlay"></li>'
                    );

                chart_compare_underlying.find('li').each(function (index){
                    this.className = 'line_'+(index+1);
                });
            }
        });

    $('li.interval').hover(function () {
        $('#intraday_interval').show();
    }, function () {
        $('#intraday_interval').hide();
    });
}

var draw_chart = function (callback_after_complete) {

    var chart_director_imageholder = document.getElementById('chart_director_imageholder');

    if (chart_director_imageholder === null) return;

    var all_li = $('#chart_compare_underlying').find('li');
    if (all_li.length == 1) {
        $('#instrument-content').find('input:checked').attr('disabled', true);
    }

    var prn = parseInt(Math.random()*8989898, 10);
    var form_chart_director = $('#form_chart_director');
    var img_url = form_chart_director.attr('action') + '&' + form_chart_director.serialize()+'&cache='+parseInt(Math.random()*8989898, 10)+'&current_width='+get_container_width();
    // I know this is nasty and gross, but so is the problem.
    // If I thought we were never going to fix charting, I would try to do
    // this better. Feel free to punch me in the face.  -mwm (2011-09-08)
    var tick_url = img_url.replace('print_chart', 'getticker');
    $('#ticker').load(tick_url);
    var image = new Image();

    showLoadingImage($('#chart_director_imageholder'));

    image.src = img_url;

    // show the image directly, it was cached by the browser
    if (image.complete)
    {
        // Append image to the container
        chart_director_imageholder.innerHTML = '';
        chart_director_imageholder.appendChild(image);

        if (typeof callback_after_complete == 'function') {
            callback_after_complete();
        }
    }
    else
    {
        // Image error checking
        image.onerror = function (event)
        {
            chart_director_imageholder.innerHTML='<p>Chart couldn\'t be loaded. </p>';
        };

        // Image loaded successfully
        image.onload = function ()
        {
            chart_director_imageholder.innerHTML = '';
            chart_director_imageholder.appendChild(image);
            // The onload event always occurs in firefox 1.0 infinitely,
            // so clear the onload listener once the image is loaded
            this.onload = null;

            if (typeof callback_after_complete == 'function') {
                callback_after_complete();
            }
        };
    }
};

onLoad.queue_for_url(function() {
    listen_to_chart_element();
}, 'smartchart');
;var load_chart_app = function () {
    var isMac = /Mac/i.test(navigator.platform),
        isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent),
        isAndroid = /Android/i.test(navigator.userAgent),
        isWindowsPhone = /Windows Phone/i.test(navigator.userAgent),
        isJavaInstalled = navigator.javaEnabled(),
        isMobile = isIOS || isAndroid || isWindowsPhone,
        shouldBeInstalled = !isJavaInstalled && !isMobile;

    $('#install-java').toggle(shouldBeInstalled);
    $('#download-app').toggle(isJavaInstalled);

    $('#download-app').on('click', function () {
        if (isMac) {
            alert('You need to change your security preferences!');
            return;
        }

        if (isMobile) {
            alert('The charting app is not available on mobile devices!');
        }
    });
};
;var client_form;
onLoad.queue(function() {
    client_form = new ClientForm({valid_loginids: page.settings.get('valid_loginids')});
});
;var APITokenWS = (function() {
    "use strict";

    var columns,
        errorClass,
        hideClass,
        isValid,
        tableContainer,
        maxTokens;


    var init = function() {
        columns = ['Name', 'Token', 'Scopes', 'Last Used', 'Action'];
        errorClass  = 'errorfield';
        hideClass   = 'dynamic';
        tableContainer = '#tokens_list';
        maxTokens = 30;

        showLoadingImage($(tableContainer));

        BinarySocket.send({"api_token": "1"});

        $('#btnCreate').click(function(e) {
            e.preventDefault();
            e.stopPropagation();
            createToken();
        });
    };

    var responseHandler = function(response) {
        if('error' in response) {
            showMessage(response.error.message, false);
            return false;
        }

        clearMessages();

        var rebuildTable = true;
        var api_token = response.api_token;
        var newToken  = '';

        if('new_token' in api_token) {
            if(api_token.new_token === 1) {
                showFormMessage(text.localize('New token created.'), true);
                $('#txtName').val('');
                newToken = response.echo_req.new_token;
            }
        }
        else if('delete_token' in api_token) {
            rebuildTable = false;
            var deletedToken = response.echo_req.delete_token;
            if(api_token.delete_token !== 1) {
                showError(deletedToken, text.localize('An error occured.'));
            }
            else {
                $('#' + deletedToken).parents('tr').removeClass('new').addClass('deleting').fadeOut(700, function(){
                    $(this).remove();
                    // Hide the table if there is no Token remained
                    if(api_token.tokens.length === 0) {
                        $(tableContainer).addClass(hideClass);
                    }
                });
            }
        }

        if(rebuildTable) {
            populateTokensList(api_token, newToken);
        }

        // Hide form if tokens count reached the maximum limit
        if(api_token.tokens.length >= maxTokens) {
            $('#token_form').addClass(hideClass);
            showMessage(text.localize('The maximum number of tokens ([_1]) has been reached.').replace('[_1]', maxTokens), false);
        }
        else {
            $('#token_form').removeClass(hideClass);
        }
    };

    // -----------------------
    // ----- Tokens List -----
    // -----------------------
    var populateTokensList = function(api_token, newTokenName) {
        var $tableContainer = $(tableContainer);
        if(api_token.tokens.length === 0) {
            $tableContainer.addClass(hideClass);
            return;
        }

        $tableContainer.removeClass(hideClass);
        showLoadingImage($(tableContainer));

        var tokens = api_token.tokens;
        var $tokensTable = createEmptyTable('tokens_table');

        for(var i = 0; i < tokens.length; i++) {
            var $tableRow = createTableRow(tokens[i]);
            if(newTokenName && tokens[i].display_name === newTokenName) {
                $tableRow.addClass('new');
            }
            $tokensTable.find('tbody').append($tableRow);
        }

        $tableContainer.empty().append($tokensTable);

        $('.btnDelete').click(function(e) {
            e.preventDefault();
            e.stopPropagation();
            if(window.confirm(
                text.localize('Are you sure that you want to permanently delete token') +
                ': "' + $(this).parents('tr').find('td.name').text() + '"?')) {
                    deleteToken($(this).attr('id'));
            }
        });
    };

    String.prototype.capitalizeFirstLetter = function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };

    var createTableRow = function(token) {
        var lastUsed = token.last_used ? token.last_used : text.localize('Never Used');
        var scopes = token.scopes.map(function (v) {
            return v.capitalizeFirstLetter();
        });
        // sort with Read, Trade, Payments, Admin
        var scopes_i = {'Read': 0, 'Trade': 1, 'Payments': 2, 'Admin': 3};
        scopes.sort(function(a, b) {
            return scopes_i[a] > scopes_i[b];
        });
        var $tableRow = Table.createFlexTableRow(
            [
                token.display_name,
                token.token,
                scopes.join(', '),
                lastUsed,
                ''  // btnDelete
            ],
            columns,
            "data"
        );

        $tableRow.children('.action').html(
            $('<span/>', {class: 'button'})
                .append($('<button/>', {class: 'button btnDelete', text: text.localize('Delete'), id: token.token})
            )
        );

        return $tableRow;
    };

    var createEmptyTable = function(tableID) {
        var header = [];
        columns.map(function(col) {
            header.push(text.localize(col));
        });

        var metadata = {
            id: tableID,
            cols: columns
        };

        return Table.createFlexTable([], metadata, header);
    };

    // ---------------------------
    // ----- Form Validation -----
    // ---------------------------
    var formValidate = function() {
        clearMessages();
        isValid = true;

        var nameID  = '#txtName';
        var newName = $(nameID).val().trim();

        var letters = Content.localize().textLetters,
            numbers = Content.localize().textNumbers,
            space   = Content.localize().textSpace;

        // Token Name
        if(!isRequiredError(nameID) && !isCountError(nameID, 2, 32)){
            if(!(/^\w+$/).test(newName)) {
                showError(nameID, Content.errorMessage('reg', [letters, numbers, '_']));
            }
        }

        var scopes = $('input:checkbox[name="scopes[]"]:checked').map(function () {
            return this.value;
        }).get();
        if (scopes.length === 0) {
            showError('#scopes', text.localize('Please select at least one scope.'));
        }

        return isValid ? newName : false;
    };

    var isRequiredError = function(fieldID) {
        if(!$(fieldID).val() || !(/.+/).test($(fieldID).val().trim())){
            showError(fieldID, Content.errorMessage('req'));
            return true;
        } else {
            return false;
        }
    };

    var isCountError = function(fieldID, min, max) {
        var fieldValue = $(fieldID).val().trim();
        if((fieldValue.length > 0 && fieldValue.length < min) || fieldValue.length > max) {
            showError(fieldID, Content.errorMessage('range', '(' + min + '-' + max + ')'));
            return true;
        } else {
            return false;
        }
    };

    // ---------------------------
    // ----- Actions Process -----
    // ---------------------------
    var createToken = function() {
        var is_valid = formValidate();
        if(is_valid !== false) {
            var newName = $('#txtName').val().trim();
            var scopes = $('input:checkbox[name="scopes[]"]:checked').map(function () {
                return this.value;
            }).get();

            BinarySocket.send({
                "api_token" : 1,
                "new_token" : newName,
                "new_token_scopes": scopes
            });
        }
    };

    var deleteToken = function(token) {
        if(token) {
            BinarySocket.send({
                "api_token"    : 1,
                "delete_token" : token
            });
        }
    };

    // -----------------------------
    // ----- Message Functions -----
    // -----------------------------
    var showMessage = function(msg, isSuccess) {
        $('#token_message > p')
            .attr('class', isSuccess ? 'success-msg' : 'errorfield')
            .html(isSuccess ? '<ul class="checked"><li>' + text.localize(msg) + '</li></ul>' : text.localize(msg));
        $('#token_message').removeClass(hideClass);
    };

    var showFormMessage = function(msg, isSuccess) {
        var $elmID = $('#formMessage');
        $elmID
            .attr('class', isSuccess ? 'success-msg' : 'errorfield')
            .html(isSuccess ? '<ul class="checked"><li>' + text.localize(msg) + '</li></ul>' : text.localize(msg))
            .css('display', 'block')
            .delay(3000)
            .fadeOut(1000);
    };

    var showError = function(fieldID, errMsg) {
        $(fieldID).parent().append($('<p/>', {class: errorClass, text: errMsg}));
        isValid = false;
    };

    var clearMessages = function(fieldID) {
        $(fieldID ? fieldID : '#frmNewToken .' + errorClass).remove();
        $('#token_message').addClass(hideClass);
        $('#formMessage').html('');
    };


    return {
        init: init,
        responseHandler: responseHandler
    };
}());



pjax_config_page("api_tokenws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "api_token") {
                            APITokenWS.responseHandler(response);
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });

            Content.populate();
            APITokenWS.init();
        }
    };
});
;var PasswordWS = (function(){

  var $form, $result;

  var init = function() {
    $form   = $("#change-password > form");
    $result = $("#change-password > div[data-id='success-result']");
    $form.find("button").on("click", function(e){
      e.preventDefault();
      e.stopPropagation();
      PasswordWS.sendRequest();
    });
  };

  var validateForm = function() {

    var isValid 	= true,
      old_pass 	= $form.find("input[name='oldpassword']").val(),
      new_pass 	= $form.find("input[name='new-password']").val(),
      repeat_pass = $form.find("input[name='repeat-password']").val();

    /**
     * Validation for new-password
    **/

    // Old passwrod cannot be blank. We leave the actual matching to backend
    if(0 === old_pass.length) {
      $form.find("p[data-error='old-blank']").removeClass("hidden");
      isValid = false;
    } else {
      $form.find("p[data-error='old-blank']").addClass("hidden");
    }

    // New password cannot be the same as the old password
    if(new_pass.length > 0 && new_pass === old_pass) {
      $form.find("p[data-error='same-as-old']").removeClass("hidden");
      isValid = false;
    } else {
      $form.find("p[data-error='same-as-old']").addClass("hidden");
    }

    if (!Validate.errorMessagePassword(document.getElementById('password').value, document.getElementById('repeat-password').value, document.getElementById('error-password'), document.getElementById('error-repeat-password'))){
      isValid = false;
    }

    // New and Repeat should be the same
    if(new_pass !== repeat_pass) {
      $form.find("p[data-error='not-the-same']").removeClass("hidden");
      isValid = false;
    } else {
      $form.find("p[data-error='not-the-same']").addClass("hidden");
    }

    if(isValid) return {
      old_pass: old_pass,
      new_pass: new_pass
    };

    return false;

  };

  var sendRequest = function() {

    $form.find("p[data-error='server-sent-error']").addClass("hidden");

    var passwords = validateForm();
    if(false === passwords) return false;

    BinarySocket.send({
        "change_password": "1",
        "old_password": passwords.old_pass,
        "new_password": passwords.new_pass
    });

  };

  var apiResponse = function(resp) {

    console.log("apiResponse:", resp);

    /**
     * Failed
    **/
    if("error" in resp) {
      var errorMsg = text.localize("Old password is wrong.");
      if("message" in resp.error) {
        errorMsg = resp.error.message;
      }
      $form.find("p[data-error='server-sent-error']").text(errorMsg).removeClass("hidden");
      return false;
    }

    /**
     * Succeeded
    **/
    $form.addClass("hidden");
    $result.removeClass("hidden");
    return true;

  };

  return {
    init: init,
    sendRequest: sendRequest,
    apiResponse: apiResponse
  };

})();

pjax_config_page("user/change_password", function() {
    return {
        onLoad: function() {
          if (page.client.redirect_if_logout()) {
              return;
          }

          Content.populate();
          if (isIE() === false) {
            $('#password').on('input', function() {
              $('#password-meter').attr('value', testPassword($('#password').val())[0]);
            });
          } else {
            $('#password-meter').remove();
          }

          BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);
                    if (response) {
                        var type = response.msg_type;
                        if (type === "change_password" || (type === "error" && "change_password" in response.echo_req)){
                            PasswordWS.apiResponse(response);
                        }
                    }
                }
            });
            PasswordWS.init();
        }
    };
});
;var ClientForm = function(init_params) {
    this.valid_loginids =  new RegExp("^(" + init_params['valid_loginids'] + ")[0-9]+$", "i");
};

ClientForm.prototype = {
    is_loginid_valid: function(login_id) {
        if (login_id.length > 0) {
            login_id = login_id.toUpperCase();
            return this.valid_loginids.test(login_id);
        }

        return true;
    }
};
;var SelfExlusionWS = (function() {
    "use strict";

    var $form,
        $loading,
        dateID,
        errorClass,
        hiddenClass;

    var fields,
        submittedValues,
        isValid;

    var init = function() {
        $form       = $('#frmSelfExclusion');
        $loading    = $('#loading');
        dateID      = 'exclude_until';
        errorClass  = 'errorfield';
        hiddenClass = 'hidden';

        if(page.client.is_virtual()) {
            $('#selfExclusionDesc').addClass(hiddenClass);
            showPageError(Content.localize().textFeatureUnavailable, true);
            return;
        }

        showLoadingImage($loading);

        submittedValues = {};

        fields = {};
        $form.find('input').each(function() {
            fields[$(this).attr('id')] = '';
        });

        initDatePicker();
        $form.find('button').on('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if(formValidate()) {
                setRequest();
            }
        });

        getRequest();
    };

    // ----------------------
    // ----- Get Values -----
    // ----------------------
    var getRequest = function() {
        BinarySocket.send({"get_self_exclusion": "1"});
    };

    var getResponse = function(response) {
        $loading.addClass(hiddenClass);
        $form.removeClass(hiddenClass);

        if('error' in response) {
            if (response.error.code === 'ClientSelfExclusion') {
              BinarySocket.send({logout: 1});
            }
            if('message' in response.error) {
                showPageError(response.error.message, true);
            }
            return false;
        } else {
            $.each(response.get_self_exclusion, function(key, value) {
                fields[key] = value + '';
                $form.find('#' + key).val(value);
            });
        }
    };

    var initDatePicker = function () {
        // 6 months from now
        var start_date = new Date();
        start_date.setMonth(start_date.getMonth() + 6);
        start_date.setDate(start_date.getDate() + 1);

        // 5 years from now
        var end_date = new Date();
        end_date.setFullYear(end_date.getFullYear() + 5);

        var $dateID = $('#' + dateID);
        $dateID.datepicker({
            dateFormat: 'yy-mm-dd',
            minDate   : start_date,
            maxDate   : end_date,
            onSelect  : function(dateText, inst) {
                $dateID.attr('value', dateText);
            }
        });
    };

    // ----------------------
    // ----- Set Values -----
    // ----------------------
    var setRequest = function() {
        submittedValues['set_self_exclusion'] = '1';
        BinarySocket.send(submittedValues);
    };

    var setResponse = function(response) {
        if('error' in response) {
            var  errMsg = response.error.message;
            if('field' in response.error) {
                showError(response.error.field, text.localize(errMsg));
            }
            else {
                showFormMessage(text.localize(errMsg), false);
            }
        }
        else {
            showFormMessage(text.localize('Your changes have been updated.'), true);
            getRequest();
        }
    };

    // ----------------------------
    // ----- Form Validations -----
    // ----------------------------
    var formValidate = function() {
        clearError();
        isValid = true;
        var isChanged = false;
        submittedValues = {};

        $.each(fields, function(key, currentValue) {
            var newValue = $form.find('#' + key).val().trim();

            if(newValue.length > 0) {
                submittedValues[key] = newValue;
            }

            if(key === dateID) {
                validateExclusionDate(newValue);
            }
            else {
                if(newValue.length > 0 && !isNormalInteger(newValue)) {
                    showError(key, text.localize('Please enter an integer value'));
                }
                else if(currentValue > 0 && (newValue.length === 0 || isLargerInt(newValue, currentValue))) {
                    showError(key, text.localize('Please enter a number between 0 and [_1]').replace('[_1]', currentValue));
                }
                else if(key === 'session_duration_limit' && newValue > (6 * 7 * 24 * 60)) {
                    showError(key, text.localize('Session duration limit cannot be more than 6 weeks.'));
                }
            }

            if(newValue !== currentValue) {
                isChanged = true;
            }
        });

        if(isValid && !isChanged) {
            showFormMessage('You did not change anything.', false);
            isValid = false;
        }

        return isValid;
    };

    var isLargerInt = function(a, b) {
        return a.length === b.length ? a > b : a.length > b.length;
    };

    var isNormalInteger = function(value) {
        return /^\d+$/.test(value);
    };

    var validateExclusionDate = function(exclusion_date) {
        var date_regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/;
        var errMsg = '';

        if (exclusion_date) {
            if(date_regex.test(exclusion_date) === false){
                errMsg = 'Please select a valid date';
            }
            else {
                exclusion_date = new Date(exclusion_date);
                // self exclusion date must > 6 months from now
                var six_month_date = new Date();
                six_month_date.setMonth(six_month_date.getMonth() + 6);
                // self exclusion date must < 5 years from now
                var five_year_date = new Date();
                five_year_date.setFullYear(five_year_date.getFullYear() + 5);

                if (exclusion_date < new Date()) {
                    errMsg = 'Exclude time must be after today.';
                }
                else if (exclusion_date < six_month_date) {
                    errMsg = 'Exclude time cannot be less than 6 months.';
                }
                else if (exclusion_date > five_year_date) {
                    errMsg = 'Exclude time cannot be for more than 5 years.';
                }
                else {
                    var isConfirmed = confirm(text.localize('When you click "Ok" you will be excluded from trading on the site until the selected date.'));
                    if(!isConfirmed) {
                        isValid = false;
                    }
                }
            }
        }

        if(errMsg.length > 0) {
            showError(dateID, text.localize(errMsg));
        }
    };

    // -----------------------------
    // ----- Message Functions -----
    // -----------------------------
    var showPageError = function(errMsg, hideForm) {
        $('#errorMsg').html(errMsg).removeClass(hiddenClass);
        if(hideForm) {
            $form.addClass(hiddenClass);
        }
    };

    var showError = function(fieldID, errMsg) {
        $('#' + fieldID).parent().append($('<p/>', {class: errorClass, text: errMsg}));
        isValid = false;
    };

    var clearError = function(fieldID) {
        $(fieldID ? fieldID : '#frmSelfExclusion p.' + errorClass).remove();
        $('#errorMsg').html('').addClass(hiddenClass);
        $('#formMessage').html('');
    };

    var showFormMessage = function(msg, isSuccess) {
        var $elmID = $('#formMessage');
        $elmID
            .attr('class', isSuccess ? 'success-msg' : errorClass)
            .html(isSuccess ? '<ul class="checked"><li>' + text.localize(msg) + '</li></ul>' : text.localize(msg))
            .css('display', 'block')
            .delay(5000)
            .fadeOut(1000);
    };


    return {
        init        : init,
        getResponse : getResponse,
        setResponse : setResponse
    };
}());


pjax_config_page("user/self_exclusionws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

          BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "authorize") {
                            SelfExlusionWS.init();
                        }
                        else if (response.msg_type === "get_self_exclusion") {
                            SelfExlusionWS.getResponse(response);
                        }
                        else if (response.msg_type === "set_self_exclusion") {
                            SelfExlusionWS.setResponse(response);
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });

            Content.populate();
            if(TUser.get().hasOwnProperty('is_virtual')) {
                SelfExlusionWS.init();
            }
        }
    };
});
;var SettingsDetailsWS = (function() {
    "use strict";

    var formID,
        frmBtn,
        RealAccElements,
        errorClass;
    var fieldIDs;
    var isValid;


    var init = function() {
        formID = '#frmPersonalDetails';
        frmBtn = formID + ' button';
        RealAccElements = '.RealAcc';
        errorClass = 'errorfield';
        fieldIDs = {
            address1 : '#Address1',
            address2 : '#Address2',
            city     : '#City',
            state    : '#State',
            postcode : '#Postcode',
            phone    : '#Phone'
        };

        BinarySocket.send({"get_settings": "1"});
    };

    var getDetails = function(response) {
        var data = response.get_settings;

        $('#lblCountry').text(data.country);
        $('#lblEmail').text(data.email);

        if(page.client.is_virtual()){ // Virtual Account
            $(RealAccElements).remove();
        }
        else { // Real Account
            var birthDate = data.date_of_birth ? moment.utc(new Date(data.date_of_birth * 1000)).format("YYYY-MM-DD") : '';
            $('#lblBirthDate').text(birthDate);
            // Generate states list
            var residence = $.cookie('residence');
            BinarySocket.send({"states_list": residence, "passthrough": {"value": data.address_state}});
            if (page.client.residence === 'jp') {
                $('#lblName').text((data.last_name || '') + ' ' + (data.first_name || ''));
                $('#lblGender').text(text.localize(data.gender) || '');
                $('#lblOccupation').text(text.localize(data.occupation) || '');
                $('#lblAddress1').text(data.address_line_1 || '');
                $('#lblAddress2').text(data.address_line_2 || '');
                $('#lblCity').text(data.address_city || '');
                $('#lblPostcode').text(data.address_postcode || '');
                $('#lblPhone').text(data.phone || '');
                $('#lblAnnualIncome').text(text.localize(data.annual_income) || '');
                $('#lblFinancialAsset').text(text.localize(data.financial_asset) || '');
                $('#lblDailyLossLimit').text(data.daily_loss_limit || '');
                $('#lblEquities').text(text.localize(data.trading_experience_equities) || '');
                $('#lblCommodities').text(text.localize(data.trading_experience_commodities) || '');
                $('#lblForeignCurrencyDeposit').text(text.localize(data.trading_experience_foreign_currency_deposit) || '');
                $('#lblMarginFX').text(text.localize(data.trading_experience_margin_fx) || '');
                $('#lblInvestmentTrust').text(text.localize(data.trading_experience_investment_trust) || '');
                $('#lblPublicCorporationBond').text(text.localize(data.trading_experience_public_bond) || '');
                $('#lblDerivativeTrading').text(text.localize(data.trading_experience_option_trading) || '');
                $('#lblPurposeOfTrading').text(text.localize(data.trading_purpose) || '');
                if (data.hedge_asset !== null && data.hedge_asset_amount !== null) {
                  $('#lblHedgeAsset').text(text.localize(data.hedge_asset) || '');
                  $('#lblHedgeAssetAmount').text(data.hedge_asset_amount || '');
                  $('.hedge').css('display', 'block');
                }
                $('.JpAcc').css('display', 'block');
                $('.rowBirthDate').removeClass('hidden');
                $('.rowName').removeClass('hidden');
                $('.rowCustomerSupport').removeClass('hidden');
            } else {
                $('#lblName').text((data.salutation || '') + ' ' + (data.first_name || '') + ' ' + (data.last_name || ''));
                $(fieldIDs.address1).val(data.address_line_1);
                $(fieldIDs.address2).val(data.address_line_2);
                $(fieldIDs.city).val(data.address_city);

                $(fieldIDs.postcode).val(data.address_postcode);
                $(fieldIDs.phone).val(data.phone);

                $(RealAccElements).removeClass('hidden');

                $(frmBtn).click(function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    return setDetails();
                });
            }
        }

        $(formID).removeClass('hidden');
    };

    var populateStates = function(response) {
        $(fieldIDs.state).empty();
        var defaultValue = response.echo_req.passthrough.value;
        var states = response.states_list;
        if(states.length > 0) {
            for(var i = 0; i < states.length; i++){
                $(fieldIDs.state).append($('<option/>', {value: states[i].value, text: states[i].text}));
            }
            // set Current value
            $(fieldIDs.state).val(defaultValue);
        }
        else {
            $(fieldIDs.state).replaceWith($('<input/>', {id: 'State', type: 'text', maxlength: '35', value: defaultValue}));
        }
        $('#lblState').text($('#State option:selected').text());
    };

    var formValidate = function() {
        clearError();
        isValid = true;

        var address1 = $(fieldIDs.address1).val().trim(),
            address2 = $(fieldIDs.address2).val().trim(),
            city     = $(fieldIDs.city).val().trim(),
            state    = $(fieldIDs.state).val(),
            postcode = $(fieldIDs.postcode).val().trim(),
            phone    = $(fieldIDs.phone).val().trim();

        var letters = Content.localize().textLetters,
            numbers = Content.localize().textNumbers,
            space   = Content.localize().textSpace,
            period  = Content.localize().textPeriod,
            comma   = Content.localize().textComma;

        // address 1
        if(!isRequiredError(fieldIDs.address1) && !(/^[a-zA-Z0-9\s\,\.\-\/\(\)#']+$/).test(address1)) {
            showError(fieldIDs.address1, Content.errorMessage('reg', [letters, numbers, space, period, comma, '- / ( ) # \'']));
        }

        // address line 2
        if(!(/^[a-zA-Z0-9\s\,\.\-\/\(\)#']*$/).test(address2)) {
            showError(fieldIDs.address2, Content.errorMessage('reg', [letters, numbers, space, period, comma, '- / ( ) # \'']));
        }

        // town/city
        isRequiredError(fieldIDs.city);

        // state
        if(!isRequiredError(fieldIDs.state) && ($(fieldIDs.state).is('input') && !(/^[a-zA-Z\s\-']+$/).test(state))) {
            showError(fieldIDs.state, Content.errorMessage('reg', [letters, space, '- \'']));
        }

        // postcode
        if(!isRequiredError(fieldIDs.postcode) && !isCountError(fieldIDs.postcode, 4, 20) && !(/(^[a-zA-Z0-9\s\-\/]+$)/).test(postcode)) {
            showError(fieldIDs.postcode, Content.errorMessage('reg', [letters, numbers, space, '- /']));
        }

        // telephone
        if(!isCountError(fieldIDs.phone, 6, 35) && !(/^(|\+?[0-9\s\-]+)$/).test(phone)) {
            showError(fieldIDs.phone, Content.errorMessage('reg', [numbers, space, '-']));
        }

        if(isValid) {
            return {
                address1 : address1,
                address2 : address2,
                city     : city,
                state    : state,
                postcode : postcode,
                phone    : phone
            };
        }
        else {
            return false;
        }
    };

    var isRequiredError = function(fieldID) {
        if(!$(fieldID).val() || !(/.+/).test($(fieldID).val().trim())){
            showError(fieldID, Content.errorMessage('req'));
            return true;
        } else {
            return false;
        }
    };

    var isCountError = function(fieldID, min, max) {
        var fieldValue = $(fieldID).val().trim();
        if((fieldValue.length > 0 && fieldValue.length < min) || fieldValue.length > max) {
            showError(fieldID, Content.errorMessage('range', '(' + min + '-' + max + ')'));
            return true;
        } else {
            return false;
        }
    };

    var showError = function(fieldID, errMsg) {
        $(fieldID).after($('<p/>', {class: errorClass, text: errMsg}));
        isValid = false;
    };

    var clearError = function(fieldID) {
        $(fieldID ? fieldID : formID + ' .' + errorClass).remove();
    };

    var setDetails = function() {
        var formData = formValidate();
        if(!formData)
            return false;

        BinarySocket.send({
            "set_settings"    : 1,
            "address_line_1"  : formData.address1,
            "address_line_2"  : formData.address2,
            "address_city"    : formData.city,
            "address_state"   : formData.state,
            "address_postcode": formData.postcode,
            "phone"           : formData.phone
        });
    };

    var setDetailsResponse = function(response) {
        var isError = response.set_settings !== 1;
        $('#formMessage').css('display', '')
            .attr('class', isError ? 'errorfield' : 'success-msg')
            .html(isError ? text.localize('Sorry, an error occurred while processing your account.') : '<ul class="checked"><li>' + text.localize('Your settings have been updated successfully.') + '</li></ul>')
            .delay(3000)
            .fadeOut(1000);
    };


    return {
        init: init,
        getDetails: getDetails,
        setDetails: setDetails,
        setDetailsResponse: setDetailsResponse,
        populateStates: populateStates
    };
}());



pjax_config_page("settings/detailsws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        var type = response.msg_type;
                        switch(type){
                            case "get_settings":
                                SettingsDetailsWS.getDetails(response);
                                break;
                            case "set_settings":
                                SettingsDetailsWS.setDetailsResponse(response);
                                break;
                            case "states_list":
                                SettingsDetailsWS.populateStates(response);
                                break;
                            case "error":
                                $('#formMessage').attr('class', 'errorfield').text(response.error.message);
                                break;
                            default:
                                break;
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });

            Content.populate();
            SettingsDetailsWS.init();
        }
    };
});
;var SettingsWS = (function() {
    "use strict";

    var init = function() {
        var classHidden = 'invisible',
            classReal   = '.real';

        if(!page.client.is_virtual()) {
            $(classReal).removeClass(classHidden);
        }
        else {
            $(classReal).addClass(classHidden);
        }

        $('#settingsContainer').removeClass(classHidden);
    };

    return {
        init: init
    };
}());


pjax_config_page("settingsws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

            if(page.client.get_storage_value('is_virtual').length === 0) {
                BinarySocket.init({
                    onmessage: function(msg) {
                        var response = JSON.parse(msg.data);
                        if (response && response.msg_type === 'authorize') {
                            SettingsWS.init();
                        }
                    }
                });
            }
            else {
                SettingsWS.init();
            }
        }
    };
});
;var TNCApproval = (function() {
    "use strict";

    var terms_conditions_version,
        client_tnc_status,
        hiddenClass,
        isReal;


    var init = function() {
        hiddenClass = 'invisible';
        showLoadingImage($('#tnc-loading'));

        BinarySocket.send({"get_settings"   : "1"});
        BinarySocket.send({"website_status" : "1"});

        $('#btn-accept').click(function(e) {
            e.preventDefault();
            e.stopPropagation();
            BinarySocket.send({"tnc_approval" : "1"});
        });
    };

    var showTNC = function() {
        if(!terms_conditions_version || !client_tnc_status) {
            return;
        }

        if(terms_conditions_version === client_tnc_status) {
            redirectToMyAccount();
            return;
        }

        $('#tnc-loading').addClass(hiddenClass);
        $('#tnc_image').attr('src', page.url.url_for_static('images/pages/cashier/protection-icon.svg'));
        $('#tnc_approval').removeClass(hiddenClass);
        $('#tnc-message').html(
            text.localize('[_1] has updated its [_2]. By clicking OK, you confirm that you have read and accepted the updated [_2].')
                .replace('[_1]', page.client.get_storage_value('landing_company_name'))
                .replace(/\[_2\]/g, $('<a/>', {class: 'pjaxload', href: page.url.url_for('terms-and-conditions'), text: text.localize('Terms & Conditions')}).prop('outerHTML'))
        );
        $('#btn-accept').text(text.localize('OK'));
    };

    var responseTNCApproval = function(response) {
        if(!response.hasOwnProperty('error')) {
            redirectToMyAccount();
        }
        else {
            $('#err_message').html(response.error.message).removeClass(hiddenClass);
        }
    };

    var redirectToMyAccount = function() {
        window.location.href = page.url.url_for('user/my_accountws');
    };

    var apiResponse = function(response) {
        isReal = !TUser.get().is_virtual;
        if(!isReal) {
            redirectToMyAccount();
        }

        switch(response.msg_type) {
            case 'website_status':
                terms_conditions_version = response.website_status.terms_conditions_version;
                showTNC();
                break;
            case 'get_settings':
                client_tnc_status = response.get_settings.client_tnc_status || '-';
                showTNC();
                break;
            case 'tnc_approval':
                responseTNCApproval(response);
                break;
            default:
                break;
        }
    };

    return {
        init : init,
        apiResponse : apiResponse
    };
}());



pjax_config_page("tnc_approvalws", function() {
    return {
        onLoad: function() {
            if (!$.cookie('login')) {
                window.location.href = page.url.url_for('login');
                return;
            }

            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        TNCApproval.apiResponse(response);
                    }
                }
            });

            Content.populate();
            TNCApproval.init();
        }
    };
});
;var ForwardWS = (function() {
  function init() {
    Content.populate();
    var verification_error = document.getElementById('verification-error');
    $('#submit-currency').click(function() {
      $('#submit-currency').attr('disabled', 'disabled');
      BinarySocket.send({"set_account_currency": $('#select-currency').val()});
    });
    $('#submit-verification').click(function() {
      var verification_token = document.getElementById('verification-token').value;
      if (!Validate.errorMessageToken(verification_token, verification_error)) {
        $('#submit-verification').attr('disabled', 'disabled');
        getCashierURL(verification_token);
      }
    });
    $('#submit-ukgc-funds-protection').click(function() {
      $('#submit-ukgc-funds-protection').attr('disabled', 'disabled');
      BinarySocket.send({"tnc_approval": 1, "ukgc_funds_protection": 1});
    });
  }
  function getCashierType() {
    var cashier_type;
    if (/withdraw/.test(window.location.hash)) {
      cashier_type = 'withdraw';
      document.getElementById('deposit-withdraw-heading').innerHTML = 'Withdraw';
    } else if (/deposit/.test(window.location.hash)) {
      cashier_type = 'deposit';
      document.getElementById('deposit-withdraw-heading').innerHTML = 'Deposit';
    }
    return cashier_type;
  }
  function getCashierURL(verification_token) {
    var req = {'cashier':getCashierType()};
    if (verification_token) req.verification_code = verification_token;
    BinarySocket.send(req);
  }
  function showError(error) {
    $('#withdraw-form').hide();
    $('#currency-form').hide();
    $('#ukgc-funds-protection').hide();
    document.getElementById('deposit-withdraw-message').innerHTML = error.message || text.localize('Sorry, an error occurred while processing your request.');
  }
  return {
    init: init,
    getCashierType: getCashierType,
    getCashierURL: getCashierURL,
    showError: showError
  };
})();

pjax_config_page("cashier/forwardws", function() {
    return {
        onLoad: function() {
          if (page.client.redirect_if_logout()) {
              return;
          }
          if (page.client.is_virtual()) {
            document.getElementById('deposit-withdraw-message').innerHTML = text.localize('This feature is not relevant to virtual-money accounts.');
            return;
          }
          ForwardWS.init();
          BinarySocket.init({
            onmessage: function(msg){
              var response = JSON.parse(msg.data);
              if (response) {
                var type = response.msg_type;
                var error = response.error;
                if (type === 'cashier_password' && !error){
                  if (response.cashier_password === 1) {
                    document.getElementById('deposit-withdraw-message').innerHTML = text.localize('Your cashier is locked as per your request - to unlock it, please click [_1]here')
                                                                                        .replace('[_1]', '<a href="' + page.url.url_for('user/settings/securityws') + '">') + '.</a>';
                  } else {
                    var cashier_type = ForwardWS.getCashierType();
                    if (cashier_type === 'withdraw') {
                      BinarySocket.send({'verify_email': page.user.email, 'type': 'payment_withdraw'});
                      document.getElementById('deposit-withdraw-message').innerHTML = text.localize('For added security, please check your email to retrieve the verification token.');
                      $('#withdraw-form').show();
                    } else if (cashier_type === 'deposit') {
                      if (TUser.get().currency !== "") {
                        ForwardWS.getCashierURL();
                      } else {
                        document.getElementById('deposit-withdraw-message').innerHTML = text.localize('Please choose which currency you would like to transact in.');
                        $('#currency-form').show();
                      }
                    }
                  }
                } else if (type === 'cashier_password' && error) {
                  ForwardWS.showError(error);
                } else if (type === 'cashier' && !error) {
                  $('#currency-form').hide();
                  $('#withdraw-form').hide();
                  $('#ukgc-funds-protection').hide();
                  document.getElementById('deposit-withdraw-message').innerHTML = '';
                  $('#deposit-withdraw-iframe-container iframe').attr('src', response.cashier);
                  $('#deposit-withdraw-iframe-container').show();
                } else if (type === 'cashier' && error) {
                  $('#withdraw-form').hide();
                  $('#currency-form').hide();
                  $('#ukgc-funds-protection').hide();
                  document.getElementById('deposit-withdraw-message').innerHTML = '';
                  if (error.code && error.code === 'ASK_TNC_APPROVAL') {
                    window.location.href = page.url.url_for('user/tnc_approvalws');
                  } else if (error.code && error.code === 'ASK_FIX_ADDRESS') {
                    document.getElementById('deposit-withdraw-message').innerHTML = text.localize('There was a problem validating your personal details. Please fix the fields [_1]here')
                                                                                        .replace('[_1]', '<a href="' + page.url.url_for('user/settings/detailsws') + '">') + '.</a> ' +
                                                                                        text.localize('If you need assistance feel free to contact our [_1]Customer Support')
                                                                                        .replace('[_1]', '<a href="' + page.url.url_for('contact') + '">') + '.</a>';
                  } else if (error.code && error.code === 'ASK_UK_FUNDS_PROTECTION') {
                    $('#ukgc-funds-protection').show();
                  } else if (error.code && error.code === 'ASK_AUTHENTICATE') {
                    document.getElementById('deposit-withdraw-message').innerHTML = text.localize('Your account is not fully authenticated. Please visit the <a href="[_1]">authentication</a> page for more information.')
                                                                                        .replace('[_1]', page.url.url_for('cashier/authenticatews'));
                  } else {
                      ForwardWS.showError(error);
                  }
                } else if (type === 'set_account_currency' && !error) {
                  ForwardWS.getCashierURL();
                } else if (type === 'set_account_currency' && error) {
                  ForwardWS.showError(error);
                } else if (type === 'tnc_approval' && !error) {
                  ForwardWS.getCashierURL();
                } else if (type === 'tnc_approval' && error) {
                  ForwardWS.showError(error);
                }
              }
            }
          });
          BinarySocket.send({"cashier_password": "1"});
        }
    };
});
;var sidebar_scroll = function(elm_selector) {
    elm_selector.on('click', '#sidebar-nav li', function() {
        var clicked_li = $(this);
        $.scrollTo($('.section:eq(' + clicked_li.index() + ')'), 500);
        return false;
    }).addClass('unbind_later');

    if (elm_selector.size()) {
        // grab the initial top offset of the navigation
        var selector = elm_selector.find('.sidebar');
        var width = selector.width();
        var sticky_navigation_offset_top = selector.offset().top;
        // With thanks:
        // http://www.backslash.gr/content/blog/webdevelopment/6-navigation-menu-that-stays-on-top-with-jquery

        // our function that decides weather the navigation bar should have "fixed" css position or not.
        var sticky_navigation = function() {
            var scroll_top = $(window).scrollTop(); // our current vertical position from the top

            // if we've scrolled more than the navigation, change its position to fixed to stick to top,
            // otherwise change it back to relative
            if (scroll_top > sticky_navigation_offset_top) {
                selector.css({'position': 'fixed', 'top': 0, 'width': width});
            } else {
                selector.css({'position': 'relative'});
            }
        };

        //run our function on load
        sticky_navigation();

        var sidebar_nav = selector.find('#sidebar-nav');
        var length = elm_selector.find('.section').length;
        $(window).on('scroll', function() {
            // and run it again every time you scroll
            sticky_navigation();

            for (var i = 0; i < length; i++) {
                if ($(window).scrollTop() === 0 || $(this).scrollTop() >= $('.section:eq(' + i + ')').offset().top - 5) {
                    sidebar_nav.find('li').removeClass('selected');

                    if ($(window).scrollTop() === 0) {
                        // We're at the top of the screen, so highlight first nav item
                        sidebar_nav.find('li:first-child').addClass('selected');
                    } else if ($(window).scrollTop() + $(window).height() >= $(document).height()) {
                        // We're at bottom of screen so highlight last nav item.
                        sidebar_nav.find('li:last-child').addClass('selected');
                    } else {
                        sidebar_nav.find('li:eq(' + i + ')').addClass('selected');
                    }
                }
            }
        });
    }
};

var get_started_behaviour = function() {
    // Get Started behaviour:
    var update_active_subsection = function(to_show) {
        var fragment;
        var subsection = $('.subsection');
        subsection.addClass('hidden');
        to_show.removeClass('hidden');
        var nav_back = $('.subsection-navigation .back');
        var nav_next = $('.subsection-navigation .next');

        if (to_show.hasClass('first')) {
            nav_back.addClass('disabled');
            nav_next.removeClass('disabled');
        } else if (to_show.hasClass('last')) {
            nav_back.removeClass('disabled');
            nav_next.addClass('disabled');
        } else {
            nav_back.removeClass('disabled');
            nav_next.removeClass('disabled');
        }

        fragment = to_show.find('a[name]').attr('name').slice(0, -8);
        document.location.hash = fragment;

        return false;
    };
    var to_show;
    var nav = $('.get-started').find('.subsection-navigation');
    var fragment;
    var len = nav.length;

    if (len) {
        nav.on('click', 'a', function() {
            var button = $(this);
            if (button.hasClass('disabled')) {
                return false;
            }
            var now_showing = $('.subsection:not(.hidden)');
            var show = button.hasClass('next') ? now_showing.next('.subsection') : now_showing.prev('.subsection');
            return update_active_subsection(show);
        });

        fragment = (location.href.split('#'))[1];
        to_show = fragment ? $('a[name=' + fragment + '-section]').parent('.subsection') : $('.subsection.first');
        update_active_subsection(to_show);
    }
};

var Charts = function(charts) {
    window.open(charts, 'DetWin', 'width=580,height=710,scrollbars=yes,location=no,status=no,menubar=no');
};

var email_rot13 = function(str) {
    return str.replace(/[a-zA-Z]/g, function(c){return String.fromCharCode((c<="Z"?90:122)>=(c=c.charCodeAt(0)+13)?c:c-26);});
};

var display_cs_contacts = function () {
    $('.contact-content').on("change", '#cs_telephone_number', function () {
        var val = $(this).val();
        $('#display_cs_telephone').text(val);
    });
    $('#cs_contact_eaddress').html(email_rot13("<n uers=\"znvygb:fhccbeg@ovanel.pbz\" ery=\"absbyybj\">fhccbeg@ovanel.pbz</n>"));
};

var change_chat_icon = function () {
  // desk.com change icon - crude way
  var len = $('#live-chat-icon').length;
  if( len > 0 ) {
      var timer = null;
      var updateIcon =  function () {
          var image_link = page.settings.get('image_link');
          var desk_widget = $('.a-desk-widget');
          var image_str = desk_widget.css('background-image');
          if(image_str) {
              desk_widget.css({
                  'background-image': 'url("' + image_link['livechaticon'] + '")',
                  'background-size': 'contain',
                  'min-width': 50,
                  'min-height': 50,
                  'width': 'auto'
              });
              desk_widget.hover(function() {
                  $(this).css({
                      'background': 'url("' + image_link['livechaticon'] + '") no-repeat scroll 0 0',
                      'background-size': 'contain',
                  });
              });

              if(image_str.match(/live-chat-icon/g)){
                  clearInterval(timer);
              }
          }
      };
      timer = setInterval(updateIcon, 500);
  }
};

var render_desk_widget = function() {
       new DESK.Widget({
                version: 1,
                site: 'binary.desk.com',
                port: '80',
                type: 'chat',
                id: 'live-chat-icon',
                displayMode: 0,  //0 for popup, 1 for lightbox
                features: {
                        offerAlways: true,
                        offerAgentsOnline: false,
                        offerRoutingAgentsAvailable: false,
                        offerEmailIfChatUnavailable: false
                },
                fields: {
                        ticket: {
                                // desc: &#x27;&#x27;,
                // labels_new: &#x27;&#x27;,
                // priority: &#x27;&#x27;,
                // subject: &#x27;&#x27;,
                // custom_loginid: &#x27;&#x27;
                        },
                        interaction: {
                                // email: &#x27;&#x27;,
                // name: &#x27;&#x27;
                        },
                        chat: {
                                //subject: ''
                        },
                        customer: {
                                // company: &#x27;&#x27;,
                // desc: &#x27;&#x27;,
                // first_name: &#x27;&#x27;,
                // last_name: &#x27;&#x27;,
                // locale_code: &#x27;&#x27;,
                // title: &#x27;&#x27;,
                // custom_loginid: &#x27;&#x27;
                        }
                }
        }).render();
};

var show_live_chat_icon = function() {
    if(typeof DESK === 'undefined') {
        loadCSS("https://d3jyn100am7dxp.cloudfront.net/assets/widget_embed_191.cssgz?1367387331");
        loadJS("https://d3jyn100am7dxp.cloudfront.net/assets/widget_embed_libraries_191.jsgz?1367387332");
    }


    var desk_load = setInterval(function() {
        if(typeof DESK !== "undefined") {
            render_desk_widget();
            change_chat_icon();
            clearInterval(desk_load);
        }
    }, 80);
};

var display_career_email = function() {
    $("#hr_contact_eaddress").html(email_rot13("<n uers=\"znvygb:ue@ovanel.pbz\" ery=\"absbyybj\">ue@ovanel.pbz</n>"));
};

function check_login_hide_signup() {
    if (page.client.is_logged_in) {
        $('#verify-email-form').remove();
        $('.break').attr('style', 'margin-bottom:1em');
    }
}

function hide_if_logged_in() {
    if (page.client.is_logged_in) {
        $('.client_logged_out').remove();
    }
}

// use function to generate elements and append them
// e.g. element is select and element to append is option
function appendTextValueChild(element, text, value, disabled){
    var option = document.createElement("option");
    option.text = text;
    option.value = value;
    if (disabled === 'disabled') {
      option.setAttribute('disabled', disabled);
    }
    element.appendChild(option);
    return;
}

// append numbers to a drop down menu, eg 1-30
function dropDownNumbers(select, startNum, endNum) {
    select.appendChild(document.createElement("option"));

    for (i = startNum; i <= endNum; i++){
        var option = document.createElement("option");
        option.text = i;
        option.value = i;
        select.appendChild(option);
    }
    return;

}

function dropDownMonths(select, startNum, endNum) {
    var months = [
        text.localize("Jan"),
        text.localize("Feb"),
        text.localize("Mar"),
        text.localize("Apr"),
        text.localize("May"),
        text.localize("Jun"),
        text.localize("Jul"),
        text.localize("Aug"),
        text.localize("Sep"),
        text.localize("Oct"),
        text.localize("Nov"),
        text.localize("Dec")
    ];
    select.appendChild(document.createElement("option"));
    for (i = startNum; i <= endNum; i++){
        var option = document.createElement("option");
        if (i <= '9') {
            option.value = '0' + i;
        } else {
            option.value = i;
        }
        for (j = i; j <= i; j++) {
            option.text = months[j-1];
        }
        select.appendChild(option);
    }
    return;
}

function generateBirthDate(){
    var days    = document.getElementById('dobdd'),
        months  = document.getElementById('dobmm'),
        year    = document.getElementById('dobyy');
    //days
    dropDownNumbers(days, 1, 31);
    //months
    dropDownMonths(months, 1, 12);
    var currentYear = new Date().getFullYear();
    var startYear = currentYear - 100;
    var endYear = currentYear - 17;
    //years
    dropDownNumbers(year, startYear, endYear);
    return;
}

function isValidDate(day, month, year){
    // Assume not leap year by default (note zero index for Jan)
    var daysInMonth = [31,28,31,30,31,30,31,31,30,31,30,31];

    // If evenly divisible by 4 and not evenly divisible by 100,
    // or is evenly divisible by 400, then a leap year
    if ( ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0) ) {
        daysInMonth[1] = 29;
    }
    return day <= daysInMonth[--month];
}

function handle_residence_state_ws(){
  BinarySocket.init({
    onmessage: function(msg){
      var select;
      var response = JSON.parse(msg.data);
      if (response) {
        var type = response.msg_type;
        var residenceDisabled = $('#residence-disabled');
        if (type === 'get_settings') {
          var country = response.get_settings.country_code;
          if (country && country !== null) {
            page.client.residence = country;
            generateBirthDate();
            generateState();
            if (/maltainvestws/.test(window.location.pathname)) {
              var settings = response.get_settings;
              var title = document.getElementById('title'),
                  fname = document.getElementById('fname'),
                  lname = document.getElementById('lname'),
                  dobdd = document.getElementById('dobdd'),
                  dobmm = document.getElementById('dobmm'),
                  dobyy = document.getElementById('dobyy');
              var inputs = document.getElementsByClassName('input-disabled');
              if (settings.salutation) {
                title.value = settings.salutation;
                fname.value = settings.first_name;
                lname.value = settings.last_name;
                var day = moment.utc(settings.date_of_birth * 1000).format('DD');
                dobdd.value = /^0/.test(day) ? day.replace('0','') : day;
                dobmm.value = moment.utc(settings.date_of_birth * 1000).format('MM');
                dobyy.value = moment.utc(settings.date_of_birth * 1000).format('YYYY');
                for (i = 0; i < inputs.length; i++) {
                    inputs[i].disabled = true;
                }
                document.getElementById('address1').value = settings.address_line_1;
                document.getElementById('address2').value = settings.address_line_2;
                document.getElementById('address-town').value = settings.address_city;
                window.state = settings.address_state;
                document.getElementById('address-postcode').value = settings.address_postcode;
                document.getElementById('tel').value = settings.phone;
              } else {
                for (i = 0; i < inputs.length; i++) {
                    inputs[i].disabled = false;
                }
              }
            }
            return;
          } else if (document.getElementById('move-residence-here')) {
            var residenceForm = $('#residence-form');
            $('#real-form').hide();
            residenceDisabled.insertAfter('#move-residence-here');
            $('#error-residence').insertAfter('#residence-disabled');
            residenceDisabled.removeAttr('disabled');
            residenceForm.show();
            residenceForm.submit(function(evt) {
              evt.preventDefault();
              if (Validate.fieldNotEmpty(residenceDisabled.val(), document.getElementById('error-residence'))) {
                page.client.residence = residenceDisabled.val();
                BinarySocket.send({set_settings:1, residence:page.client.residence});
              }
              return;
            });
            return;
          }
        } else if (type === 'set_settings') {
          var errorElement = document.getElementById('error-residence');
          if (response.hasOwnProperty('error')) {
            if (response.error.message) {
              errorElement.innerHTML = response.error.message;
              errorElement.setAttribute('style', 'display:block');
            }
            return;
          } else {
            errorElement.setAttribute('style', 'display:none');
            BinarySocket.send({landing_company: page.client.residence});
            return;
          }
        } else if (type === 'landing_company') {
          $.cookie('residence', page.client.residence, {domain: '.' + document.domain.split('.').slice(-2).join('.'), path: '/'});
          if (response.landing_company.hasOwnProperty('financial_company') && !response.landing_company.hasOwnProperty('gaming_company') && response.landing_company.financial_company.shortcode === 'maltainvest') {
            window.location.href = page.url.url_for('new_account/maltainvestws');
            return;
          } else if (response.landing_company.hasOwnProperty('financial_company') && !response.landing_company.hasOwnProperty('gaming_company') && response.landing_company.financial_company.shortcode === 'japan') {
            window.location.href = page.url.url_for('new_account/japanws');
            return;
          } else if (!$('#real-form').is(':visible')) {
            $('#residence-form').hide();
            residenceDisabled.insertAfter('#move-residence-back');
            $('#error-residence').insertAfter('#residence-disabled');
            residenceDisabled.attr('disabled', 'disabled');
            $('#real-form').show();
            generateBirthDate();
            generateState();
            return;
          }
        } else if (type === 'states_list'){
          select = document.getElementById('address-state');
          var states_list = response.states_list;
          if (states_list.length > 0){
            for (i = 0; i < states_list.length; i++) {
                appendTextValueChild(select, states_list[i].text, states_list[i].value);
            }
            select.parentNode.parentNode.setAttribute('style', 'display:block');
            if (window.state) {
              select.value = window.state;
            }
          }
          return;
        } else if (type === 'residence_list'){
          select = document.getElementById('residence-disabled') || document.getElementById('residence');
          var phoneElement   = document.getElementById('tel'),
              residenceValue = page.client.residence,
              residence_list = response.residence_list;
          if (residence_list.length > 0){
            for (i = 0; i < residence_list.length; i++) {
              if (residence_list[i].disabled  && select) {
                appendTextValueChild(select, residence_list[i].text, residence_list[i].value, 'disabled');
              } else if (select) {
                appendTextValueChild(select, residence_list[i].text, residence_list[i].value);
              }
              if (phoneElement && phoneElement.value === '' && residence_list[i].phone_idd && residenceValue === residence_list[i].value){
                phoneElement.value = '+' + residence_list[i].phone_idd;
              }
            }
            if (residenceValue && select){
                select.value = residenceValue;
            }
            if (document.getElementById('virtual-form')) {
                BinarySocket.send({website_status:1});
            }
          }
          return;
        } else if (type === 'website_status') {
          var status  = response.website_status;
          if (status && status.clients_country) {
            var clientCountry = $('#residence option[value="' + status.clients_country + '"]');
            if (!clientCountry.attr('disabled')) {
                clientCountry.attr('selected', 'selected');
            }
          }
          return;
        }
      }
    }
  });
}

function generateState() {
    var state = document.getElementById('address-state');
    appendTextValueChild(state, Content.localize().textSelect, '');
    if (page.client.residence !== "") {
      BinarySocket.send({ states_list: page.client.residence });
    }
    return;
}

function getUrlVars() {
    var vars = {};
    var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
        vars[key] = value;
    });
    return vars;
}

// returns true if internet explorer browser
function isIE() {
  return /(msie|trident|edge)/i.test(window.navigator.userAgent) && !window.opera;
}

// trim leading and trailing white space
function Trim(str){
  while(str.charAt(0) == (" ") ){str = str.substring(1);}
  while(str.charAt(str.length-1) ==" " ){str = str.substring(0,str.length-1);}
  return str;
}

function changeLanguage(lang) {
  str = window.location.search;
  str = page.url.replaceQueryParam('l', lang, str);
  window.location = window.location.pathname + str;
}

function limitLanguage(lang) {
  if (page.language() !== lang) {
    changeLanguage(lang);
  }
  if (document.getElementById('language_select')) {
    $('#language_select').remove();
    $('#gmt-clock').removeClass();
    $('#gmt-clock').addClass('grd-grid-6 grd-grid-mobile-12');
    $('#contact-us').removeClass();
    $('#contact-us').addClass('grd-grid-6 grd-hide-mobile');
  }
}

function checkClientsCountry() {
  var clients_country = localStorage.getItem('clients_country');
  if (clients_country) {
    var str;
    if (clients_country === 'jp') {
      limitLanguage('JA');
    } else if (clients_country === 'id') {
      limitLanguage('ID');
    } else {
      $('#language_select').show();
    }
  } else {
    BinarySocket.init();
    BinarySocket.send({"website_status" : "1"});
  }
}


if (page.language() === 'ID') {
  change_blog_link('id');
}

function change_blog_link(lang) {
  var regex = new RegExp(lang);
  if (!regex.test($('.blog a').attr('href'))) {
    $('.blog a').attr('href', $('.blog a').attr('href') + '/' + lang + '/');
  }
}

function isNotBackoffice() {
  return !/backoffice/.test(window.location.pathname);
}

pjax_config_page('/\?.+|/home', function() {
    return {
        onLoad: function() {
            check_login_hide_signup();
            submit_email();
        }
    };
});

pjax_config_page('/why-us', function() {
    return {
        onLoad: function() {
            var whyus = $('.why-us');
            sidebar_scroll(whyus);
            hide_if_logged_in();
        },
        onUnload: function() {
            $(window).off('scroll');
        }
    };
});

pjax_config_page('/smart-indices', function() {
    return {
        onLoad: function() {
            sidebar_scroll($('.smart-indices'));
            if (page.url.location.hash !== "") {
              $('a[href="' + page.url.location.hash + '"]').click();
            }
        },
        onUnload: function() {
            $(window).off('scroll');
        }
    };
});

pjax_config_page('/volidx-markets', function() {
    return {
        onLoad: function() {
            sidebar_scroll($('.volidx-markets'));
            if (page.url.location.hash !== "") {
              $('a[href="' + page.url.location.hash + '"]').click();
            }
        },
        onUnload: function() {
            $(window).off('scroll');
        }
    };
});

pjax_config_page('/open-source-projects', function() {
    return {
        onLoad: function() {
            sidebar_scroll($('.open-source-projects'));
        },
        onUnload: function() {
            $(window).off('scroll');
        }
    };
});

pjax_config_page('/payment-agent', function() {
    return {
        onLoad: function() {
            sidebar_scroll($('.payment-agent'));
        },
        onUnload: function() {
            $(window).off('scroll');
        }
    };
});

pjax_config_page('/get-started', function() {
    return {
        onLoad: function() {
            if (!/jp/.test(window.location.pathname) && page.language().toLowerCase() === 'ja') {
              window.location.href = page.url.url_for('get-started-jp');
            }
            get_started_behaviour();
        },
        onUnload: function() {
            $(window).off('scroll');
        },
    };
});

pjax_config_page('/contact', function() {
    return {
        onLoad: function() {
            display_cs_contacts();
            show_live_chat_icon();
        },
    };
});

pjax_config_page('/careers', function() {
    return {
        onLoad: function() {
            display_career_email();
        },
    };
});

pjax_config_page('/bulk-trader-facility', function() {
    return {
        onLoad: function() {
            var whyus = $('.bulk-trader-facility');
            sidebar_scroll(whyus);
        },
        onUnload: function() {
            $(window).off('scroll');
        }
    };
});

pjax_config_page('/terms-and-conditions', function() {
    return {
        onLoad: function() {
            if (page.language() === 'JA' && /^jp/.test(window.location.pathname)) {
              window.location.href = page.url.url_for('terms-and-conditions-jp');
            } else if (page.language() === 'EN' && /jp/.test(window.location.pathname)) {
              window.location.href = page.url.url_for('terms-and-conditions');
            }
            var year = document.getElementsByClassName('currentYear');
            for (i = 0; i < year.length; i++){
              year[i].innerHTML = new Date().getFullYear();
            }
        },
    };
});

pjax_config_page('/login', function() {
    return {
        onLoad: function() {
            if (page.user.is_logged_in) {
              window.location.href = page.url.url_for('user/my_accountws');
            }
        }
    };
});
;pjax_config_page('/get-started-jp', function() {
    return {
        onLoad: function() {
          if (page.language().toLowerCase() !== 'ja') {
            window.location.href = page.url.url_for('get-started');
          }
          var tab = window.location.hash;
          if (tab && tab !== '') {
            $('#index').hide();
            $('.sidebar-left ul li.' + tab.slice(1, tab.length)).addClass('selected');
            showSelectedTab();
          }
          function showSelectedTab() {
            var updatedTab = window.location.hash;
            $('.contents div').hide();
            if (updatedTab && updatedTab !== '') {
              if ($('#index').is(":visible")) $('#index').hide();
              $('.contents div[id=content-' + updatedTab.slice(1, updatedTab.length) + ']').show();
              $('.contents div[id=content-' + updatedTab.slice(1, updatedTab.length) + '] div').show();
              $('.sidebar-left ul li').removeClass('selected');
              $('.sidebar-left ul li.' + updatedTab.slice(1, updatedTab.length)).addClass('selected');
              $('.contents').show();
            }
            else {
              $('.contents').hide();
              $('.sidebar-left ul li').removeClass('selected');
              $('#index').show();
            }
          }
          $(window).on('hashchange', function(){
            showSelectedTab();
          });
          $('.sidebar-left ul li').click(function(e) {
            $('.sidebar-left ul li').removeClass('selected');
            $(this).addClass('selected');
          });
        }
    };
});
;/*
 *  This is developed to simplify the usage of enjoyhint (https://github.com/xbsoftware/enjoyhint) 
 *
 *  How to Implement in a page:
 *  1. Add the button element to the template: <div id="guideBtn"></div>
 *  2. Add the js initialization call, having the customized parameters: Guide.init({script : 'trading'});
 *  3. Add the script data to getScript() method
 */

var Guide = (function() {
	var opt,
		cookieName,
		btnNext,
		btnFinish;

	var init = function(options) {
		opt = {
			script	       : '',      // the script name in scripts
			autoStart      : false,   // false: start by button click
			guideBtnID     : '#guideBtn',
			btnText        : text.localize('Walkthrough Guide'),  // guide start button's text
			blink_class    : 'highlight',
			blink_inDelay  : 1000,
			blink_outDelay : 1000,
			blink_interval : 3000,    // 0: continous blinking (blink_inDelay + blink_outDelay)
			blink_count    : 0        // 0: infinite
		};
        $.extend(true, opt, options);

        cookieName = 'hide_guide';
		btnNext    = {className: "button", html: '<span>' + text.localize('Next') + '</span>'};
		btnFinish  = {className: "button btnFinish", html: '<span>' + text.localize('Finish') + '</span>'};

		if($(opt.guideBtnID).length === 0) {
			console.warn('Could not find the button placeholder: <div id="' + opt.guideBtnID + '"></div>');
			return;
		}

		if(opt.script.length === 0) {
			console.warn('"script" name should be specified');
			return;
		}

		if(isDisabled()) {
			$(opt.guideBtnID).remove();
			return;
		}

		makeButton();
	};

	/*
	 *  do not show the guide button if its close (X) has been clicked before
	 */
	var isDisabled = function() {
		var disabled = $.cookie(cookieName);
		return !!disabled && $.inArray(opt.script, disabled.split(',')) >= 0;
	};

	/*
	 *  handle the guide button appearance using a cookie for all scripts
	 */
	var setDisabled = function() {
		if(!isDisabled()) {
			var disabled = $.cookie(cookieName);
			$.cookie(cookieName, (!disabled ? opt.script : disabled + ',' + opt.script));
		}
	};

	/*
	 *  generate the button's html
	 */
	var makeButton = function() {
		if($(opt.guideBtnID).children().length > 0) {
			return;
		}

		$(opt.guideBtnID)
			.addClass('grd-hide-mobile pulser')
			.append($('<span/>', {class: 'close', text: 'X'}))
			.append($('<strong/>'));
		$(opt.guideBtnID + ' strong').html('<span></span>' + opt.btnText);

		setEvents();
	};

	/*
	 *  both buttons' click event
	 */
	var setEvents = function() {
		$(opt.guideBtnID + ' strong').click(function(e){
			var enjoyhint_instance = null;
			enjoyhint_instance = new EnjoyHint({});
			enjoyhint_instance.setScript(getScript(opt.script));
			enjoyhint_instance.runScript();
		});
		
		if(opt.autoStart) {
			$(opt.guideBtnID).click();
		}

		// Hide button
		$(opt.guideBtnID + ' span.close').click(function(){
			setDisabled();
			$(opt.guideBtnID).remove();
		});
	};

	/*
	 *  each page's script
	 */
	var getScript = function(scriptName) {
		if(scriptName === 'trading') {
			return [
				{
					selector    : '#contract_markets',
					description : '<h1>' + text.localize('Step') + ' 1</h1>' + 
									text.localize('Select your market'),
					event_type  : 'next',
					nextButton  : btnNext
				},
				{
					selector    : '#underlying',
					description : '<h1>' + text.localize('Step') + ' 2</h1>' + 
									text.localize('Select your underlying asset'),
					event_type  : 'next',
					nextButton  : btnNext
				},
				{
					selector    : '#contract_form_name_nav',
					description : '<h1>' + text.localize('Step') + ' 3</h1>' +
									text.localize('Select your trade type'),
					event_type  : 'next',
					nextButton  : btnNext
				},
				{
					selector    : '#websocket_form',
					description : '<h1>' + text.localize('Step') + ' 4</h1>' + 
									text.localize('Adjust trade parameters'),
					event_type  : 'next',
					nextButton  : btnNext
				},
				{
					selector    : '#contracts_list',
					description : '<h1>' + text.localize('Step') + ' 5</h1>' + 
									text.localize('Predict the direction<br />and purchase'),
					event_type  : 'next',
					nextButton  : btnFinish
				}
			];
		}
	};


	return {
		init: init
	};
})();
;pjax_config_page('/open-positions', function() {
  return {
      onLoad: function() {
        if (document.getElementById('Information_Technology')) {
          if (page.url.location.hash) {
              $.scrollTo($(page.url.location.hash));
          }
        }
      }
  };
});
pjax_config_page('/open-positions/job-details', function() {
    return {
        onLoad: function() {
          var dept = page.url.params_hash().dept,
              sidebarListItem = $('#sidebar-nav li');
          function showSelectedDiv() {
            $('.sections div').hide();
            $('.sections div[id=' + dept + '-' + page.url.location.hash.substring(1) + ']').show();
            $('.title-sections').html($('.sidebar li[class="selected"]').text());
          }
          $(window).on('hashchange', function(){
            showSelectedDiv();
          });
          $('.job-details').find('#title').html(text.localize(dept.replace(/_/g, ' ')));
          var deptImage = $('.dept-image'),
              sourceImage = deptImage.attr('src').replace('Information_Technology', dept);
          deptImage.attr('src', sourceImage)
                   .show();
          var deptContent = $('#content-' + dept + ' div');
          var section,
              sections = ['section-one', 'section-two', 'section-three', 'section-four', 'section-five', 'section-six', 'section-seven', 'section-eight'];
          sidebarListItem.slice(deptContent.length).hide();
          for (i = 0; i < deptContent.length; i++) {
              section = $('#' + dept + '-' + sections[i]);
              section.insertAfter('.sections div:last-child');
              if (section.attr('class')) {
                $('#sidebar-nav a[href="#' + sections[i] + '"]').html(text.localize(section.attr('class').replace(/_/g, ' ')));
              }
          }
          $('.sidebar').show();
          if ($('.sidebar li:visible').length === 1) {
            $('.sidebar').hide();
          }
          $('#' + page.url.location.hash.substring(9)).addClass('selected');
          showSelectedDiv();
          $('#back-button').attr('href', page.url.url_for('open-positions') + '#' + dept);
          sidebarListItem.click(function(e) {
            sidebarListItem.removeClass('selected');
            $(this).addClass('selected');
          });
        }
    };
});
;var minDT = new Date();
minDT.setUTCFullYear(minDT.getUTCFullYear - 3);
var liveChartsFromDT, liveChartsToDT, liveChartConfig;

var updateDatesFromConfig = function(config) {
    var duration = $('#live_chart_duration li[data-live=' + config.live + ']').attr('id');
    var now = new Date();
    liveChartsFromDT.setDateTime(new Date(now.getTime() - (duration * 1000)));
    liveChartsToDT.setDateTime(now);
};

var show_chart_for_instrument = function() {
    var symb, disp_symb;
    $("#instrument_select .deleteme").remove();
    $("#instrument_select option:selected").each(function(){
        symb = $(this).val();
        disp_symb = $(this).text();
    });

    if (symb) {
        liveChartConfig.update({
            symbol: symb,
            update_url: 1
        });
        updateLiveChart(liveChartConfig);
    }
};

var remove_highlight_chart_duration = function () {
    $('#live_chart_duration').find('.live_charts_stream_button').each( function () {
        $(this).find('span').removeClass('current');
    });
};

var build_markets_select = function() {
    var market_select = $("#market_select");
    markets.each(function() {
        if (this.name == 'forex') {
            market_select.append("<option id='opt_" + this.name + "' value='" + this.name + "'>" + this.translated_display_name() + "</option>");
        } else {
            market_select.append("<option class='ja-hide' id='opt_" + this.name + "' value='" + this.name + "'>" + this.translated_display_name() + "</option>");
        }
    });

    $("#market_select").val(liveChartConfig.market.name);
    build_instrument_select();

    $("#market_select").change(build_instrument_select);
};

var build_instrument_select = function() {
    var instrument_select = $("#instrument_select");
    var market = markets.get($('#market_select').val());
    $("#instrument_span").hide();
    if(market) {
        $("#instrument_select option").remove();
        instrument_select.append("<option class='deleteme'></option>");
        market.each(function() {
            this.each(function() {
                instrument_select.append("<option value='" + this.symbol + "'>" + this.translated_display_name() + "</option>");
            });
        });
        $("#instrument_span").show();
        $("#instrument_select").change(show_chart_for_instrument);
        $("#instrument_select").val(liveChartConfig.symbol.symbol);
    }
};

var init_live_chart = function () {
    liveChartsFromDT = new DateTimePicker({
        id: "live_charts_from",
        onChange: function(date) { liveChartsToDT.setMinDateTime(date); }
    });

    liveChartsToDT = new DateTimePicker({
        id: "live_charts_to",
        onChange: function(date) { liveChartsFromDT.setMaxDateTime(date); }
    });


    liveChartConfig = new LiveChartConfig({
        renderTo: 'live_chart_div',
    });

    configure_livechart();
    build_markets_select();


    $(".notice").hide();
    $("#live_chart_extended_options").hide();
    $("#live_charts_show_extended_options").on('click', function(e){
        e.preventDefault();
        $("#live_chart_extended_options").toggle();
    });
    $("#live_charts_high_barrier").change(function(){
        var val = $(this).val();
        if(liveChartConfig.has_indicator('high') || !val) {
            live_chart.remove_indicator('high');
        }

        if (val) {
            var barrier = new LiveChartIndicator.Barrier({ name: "high", value: val, color: 'green'});
            live_chart.add_indicator(barrier);
        }
    });
    $("#live_charts_low_barrier").change(function(){
        var val = $(this).val();
        if(liveChartConfig.has_indicator('low') || !val) {
            live_chart.remove_indicator('low');
        }

        if (val) {
            var barrier = new LiveChartIndicator.Barrier({ name: "low", value: val, color: 'red'});
            live_chart.add_indicator(barrier);
        }
    });


    $('#live_charts_hide_spot').hide();
    $("#live_charts_show_spot").on('click', function(e){
        e.preventDefault();
        var barrier = new LiveChartIndicator.Barrier({ name: "spot", value: "+0"});
        live_chart.add_indicator(barrier);
        $(this).hide();
        $('#live_charts_hide_spot').show();
    });

    $("#live_charts_hide_spot").on('click', function(e){
        e.preventDefault();
        live_chart.remove_indicator('spot');
        $(this).hide();
        $('#live_charts_show_spot').show();
    });

    $("#live_charts_show_interval").on('click', function() {
        liveChartConfig.update({
            interval: {
                from: liveChartsFromDT.getDateTime(),
                to: liveChartsToDT.getDateTime()
            },
            update_url: 1
        });
        updateLiveChart(liveChartConfig);
    });

    $("#live_chart_duration").on('duration_change', function(e) {
        updateDatesFromConfig(e.config);
    });

    show_chart_for_instrument();
    updateDatesFromConfig(liveChartConfig);
};


pjax_config_page('livechart', function() {
    return {
        onLoad: function() {
            init_live_chart();
        },
        onUnload: function() {
            live_chart.close_chart();
            live_chart = null;
        }
    };
});

//The first time some one loads live chart in the session, the script might not have finished loading by the time onLoad.fire() was called.
//So we check if livechart was not configured when we loaded this script then we initialize it manually.
$(function() {
    if(!live_chart && /livechart/.test(window.location.pathname)) {
        init_live_chart();
    }

});
;var PortfolioWS =  (function() {
    'use strict';

    var rowTemplate;

    var init = function() {
        showLoadingImage($("#portfolio-loading"));
        // get the row template and then discard the node as it has served its purpose
        var $tempRow = $("#portfolio-dynamic tr[data-contract_id='!contract_id!']");
        if($tempRow) {
            rowTemplate = $tempRow[0].outerHTML;
            $tempRow.remove();
        }
        BinarySocket.send({"balance":1});
        BinarySocket.send({"portfolio":1});
        // Subscribe transactions to auto update new purchases
        BinarySocket.send({'transaction': 1, 'subscribe': 1});
    };


    /**
     * Show balance
    **/
    var updateBalance = function(data) {
        $("span[data-id='balance']").text(data.balance.currency + ' ' + addComma(parseFloat(data.balance.balance)));
        if(parseFloat(data.balance.balance, 10) > 0) {
            $("#if-balance-zero").remove();
        }
    };

    /**
     * Updates portfolio table
    **/
    var updatePortfolio = function(data) {
        /**
         * Check for error
        **/
        if("error" in data) {
            throw new Error("Trying to get portfolio data, we got this error", data.error);
        }

        /**
         * no open contracts
        **/
        if(0 === data.portfolio.contracts.length) {
            $("#portfolio-no-contract").show();
            $("#portfolio-table").addClass("dynamic");
            $("#portfolio-content").removeClass("dynamic");
            $("#portfolio-loading").hide();
            return true;
        }

        /**
         * User has at least one contract
        **/
        if(!rowTemplate) init();
        $("#portfolio-no-contract").hide();
        var contracts = '';
        var sumPurchase = 0.0;
        var currency;
        $.each(data.portfolio.contracts, function(ci, c) {
            sumPurchase += parseFloat(c.buy_price, 10);
            currency = c.currency;
            contracts += rowTemplate
            .split("!transaction_id!").join(c.transaction_id)
            .split("!contract_id!").join(c.contract_id)
            .split("!longcode!").join(c.longcode)
            .split("!currency!").join(c.currency)
            .split("!buy_price!").join(addComma(parseFloat(c.buy_price)));
        });

        // contracts is ready to be added to the dom
        $("#portfolio-dynamic").append(trans(contracts));
        if(contracts.length > 0) {
            $("#portfolio-table").removeClass("dynamic");
        }

        // update footer area data
        sumPurchase = sumPurchase.toFixed(2);
        $("#cost-of-open-positions").text(currency + ' ' + addComma(parseFloat(sumPurchase)));

        // request "proposal_open_contract"
        BinarySocket.send({"proposal_open_contract":1, "subscribe":1});

        // ready to show portfolio table
        $("#portfolio-loading").remove();
        $("#portfolio-content").removeClass("dynamic");
    };

    var transactionResponseHandler = function(response) {
        if(response.hasOwnProperty('error')) {
            return;
        }

        if(response.transaction.action === 'buy') {
            $('#portfolio-dynamic').empty();
            BinarySocket.send({'portfolio': 1});
        }
        else if(response.transaction.action === 'sell') {
            $("tr[data-contract_id='" + response.transaction.contract_id + "']").remove();
            if($('#portfolio-dynamic tr').length === 0) {
                BinarySocket.send({"portfolio":1});
            }
        }
    };

    var updateIndicative = function(data) {
        var proposal = data.proposal_open_contract;
        var $td = $("tr[data-contract_id='" + proposal.contract_id + "'] td.indicative");
        var old_indicative = $td.find('strong').text();
        old_indicative = parseFloat(old_indicative, 2);
        if(isNaN(old_indicative)) old_indicative = 0.0;

        var new_indicative = parseFloat(proposal.bid_price, 2);
        if(isNaN(new_indicative)) new_indicative = 0.0;

        var bid_price = parseFloat(proposal.bid_price || 0).toFixed(2);

        var status_class = '';
        var no_resale_html = '';
        if(proposal.is_sold == 1) {
            $td.parent('tr').remove();
            if($('#portfolio-dynamic tr').length === 0) {
                BinarySocket.send({"portfolio":1});
            }
        }
        else {
            if(proposal.is_valid_to_sell != 1) {
                no_resale_html = '<span>' + text.localize('Resale not offered') + '</span>';
                $td.addClass("no_resale");
            }
            else {
                status_class = new_indicative < old_indicative ? ' price_moved_down' : (new_indicative > old_indicative ? ' price_moved_up' : '');
                $td.removeClass("no_resale");
            }
            $td.html(proposal.currency + ' <strong class="indicative_price' + status_class + '"">' + bid_price + '</strong>' + no_resale_html);
        }

        var indicative_sum = 0, indicative_price = 0, up_down;
        $("strong.indicative_price").each(function() {
            indicative_price = $(this).text();
            indicative_price = parseFloat(indicative_price, 2);
            if(!isNaN(indicative_price)) {
                indicative_sum += indicative_price;
            }
        });

        indicative_sum = indicative_sum.toFixed(2);

        $("#value-of-open-positions").text('USD ' + parseFloat(indicative_sum).toFixed(2));
    };


    /*** utility functions ***/

    // Dynamic text
    var dTexts = ["view", "indicative"];

    /**
     * In the dynamic parts we have strings to include
     * For instance, in portfolio table, we have a 'View' button
     * for each contract.
    **/
    var trans = function(str) {
        var placeholder;
        for(var i = 0, l = dTexts.length; i < l; i++) {
            placeholder = ":"+dTexts[i]+":";
            if(-1 === str.indexOf(placeholder)) continue;
            str = str.split(placeholder).join(text.localize(dTexts[i]));
        }
        return str;
    };

    var onLoad = function() {
        if (page.client.redirect_if_logout()) {
            return;
        }
        BinarySocket.init({
            onmessage: function(msg){
                var response;
                try {
                    response  = JSON.parse(msg.data);
                    if("object" !== typeof response || !("msg_type" in response)) {
                        throw new Error("Response from WS API is not well formatted.");
                    }
                } catch(e) {
                    throw new Error("Response from WS API is not well formatted."+ e);
                }

                var msg_type = response.msg_type;
                switch(msg_type) {
                    case "balance":
                        updateBalance(response);
                        break;
                    case "portfolio":
                        updatePortfolio(response);
                        break;
                    case "transaction":
                        transactionResponseHandler(response);
                        break;
                    case "proposal_open_contract":
                        updateIndicative(response);
                        break;
                    default:
                        // msg_type is not what PortfolioWS handles, so ignore it.
                }
            }
        });
        init();
    };

    var onUnload = function(){
        BinarySocket.send({"forget_all": "proposal_open_contract"});
        BinarySocket.send({"forget_all": "transaction"});
    };

    return {
        init: init,
        updateBalance: updateBalance,
        updatePortfolio: updatePortfolio,
        updateIndicative: updateIndicative,
        transactionResponseHandler: transactionResponseHandler,
        onLoad: onLoad,
        onUnload: onUnload,
    };

})();

pjax_config_page("user/openpositionsws", function() {
    return {
        onLoad: PortfolioWS.onLoad,
        onUnload: PortfolioWS.onUnload,
    };
});
;$(function() {
    $( "#accordion" ).accordion({
      heightStyle: "content",
      collapsible: true,
      active: false
    });
});
;function currencyConvertorCalculator()
{
    var currencyto = document.getElementById('currencyto');
    if (currencyto.options.length > 0)
    {
        currencyto.options.length = 0;
    }

    var i=0;
    $('#currencyfrom').find('option').each(function(){
        if (this.selected !== true)
        {
            currencyto.options[i] = new Option(this.value, this.text);
            i++;
        }
    });

    return true;
}

function checkCurrencyAmountFormat(input_value)
{
    var amount = $(input_value).val();
    var amountEXP = '^\\d+(\\.)?(\\d)?(\\d)?$';
    var amountRex = new RegExp(amountEXP);
    var displayerror = $('#currencyconverterror');
    var currencysubmit = $('#currencysubmit');

    if (amount === '')
    {
        displayerror.addClass('invisible button-disabled');
        currencysubmit.attr('disabled', 'disabled').addClass('button-disabled').parents('.button').addClass('button-disabled');
        return 1;
    }

    if (!amountRex.test(amount) && displayerror)
    {
        displayerror.removeClass('invisible');
        currencysubmit.attr('disabled', 'disabled').addClass('button-disabled').parents('.button').addClass('button-disabled');
    }
    else
    {
        displayerror.addClass('invisible');
        currencysubmit.removeAttr('disabled').removeClass('button-disabled').parents('.button').removeClass('button-disabled');
    }

    return false;
}

var Portfolio = function () {
    var _price_request = null;
    var elements = $('button.open_contract_details');
    return {
        update_indicative_prices: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

            this.cancel_price_request();
            var that = this;
            if ($.isEmptyObject(elements)) return; // There are no open positions we will be able to update.
            _price_request = $.ajax(ajax_loggedin({
                url     : '/d/trade.cgi',
                type    : 'POST',
                async   : true,
                data    : 'controller_action=open_position_values',
                timeout : 60000,
                success : that.on_price_request_success,
                error   : that.on_price_request_error,
            }));
        },
        cancel_price_request: function() {
            if (_price_request) {
                _price_request.abort();
            }
        },
        on_price_request_success: function(resp, resp_status, jqXHR) {
            var data = {};
            var prices = {};
            if (typeof resp == 'object') {
               data = resp;
            } else {
                data = (JSON && JSON.parse(resp)) || $.parseJSON(resp) || {};
            }
            if (data.redirect) {
                window.location.href = data.redirect;
                return;
            } else if (data.error) {
                return;         // Something went wrong, just leave the cached version in place, it says indicative.
            } else if (data.prices) {
                prices = data.prices;
            } else {
                console.log(data);
                var exception = new Error("Invalid server response: " + data);
                Portfolio.on_price_request_error(jqXHR, resp_status, exception);
            }
            Portfolio.set_contract_prices(prices);
        },
        on_price_request_error: function(jqXHR, resp_status, exp) {
            return;         // Something went wrong, just leave the cached version in place, it says indicative.
        },
        set_contract_prices: function(prices) {
            var that = this;
            var default_price = ((prices && prices['*']) ? prices['*'] : null);
            var _update_element_price = function() {
                var el = $(this);
                var price;
                data = element_data_attrs(el);
                var shortcode = data.shortcode;
                var currency = data.currency;
                if (!prices[currency]) {
                    if (default_price !== null) {
                        prices[currency] = {};
                    } else {
                        return;
                    }
                }
                if (default_price !== null && prices[currency][shortcode] === undefined) {
                    prices[currency][shortcode] = default_price;
                }
                price = prices[currency][shortcode];
                if (price !== undefined) {
                    if (isNaN(price)) {
                        /* price is not a number, could be an error report. do not use currency nor update
                         * the price attr of the button. just update portfolio table value shown to user
                         */
                        $('p', el.parents('div').children('div')[2]).text(price);
                    } else {
                        el.attr('price', price);
                        price = stylized_price(price);
                        price = price.units + price.cents;
                        $('p', el.parents('div').children('div')[2]).text(currency + ' ' + price);
                    }
                }
            };
            elements.each(_update_element_price);
        }
    };
}();

pjax_config_page('portfolio', function() {
    return {
        onLoad: function() {
            $('#portfolio-table .hourglass').hide();
            $('#currencyfrom').change(function(event) { currencyConvertorCalculator(event.target); });
            $('#currencyfrom').keyup(function(event) { currencyConvertorCalculator(event.target); });
            $('#currencyfromvalue').change(function(event) { checkCurrencyAmountFormat(event.target); });
            $('#currencyfromvalue').keyup(function(event) { checkCurrencyAmountFormat(event.target); });
            Portfolio.update_indicative_prices();
        }
    };
});
;var AssetIndexWS = (function() {
    "use strict";

    var $container,
        $tabs,
        $contents;
    
    var activeSymbols,
        assetIndex,
        marketColumns,
        idx;

    var init = function() {
        $container = $('#asset-index');
        showLoadingImage($container);
        marketColumns = {};
        activeSymbols = null;
        assetIndex = null;
        // index of items in asset_index response
        idx = {
            symbol: 0,
            displayName: 1,
            cells : 2,
                cellName: 0,
                cellDisplayName: 1,
                cellFrom: 2,
                cellTo  : 3,
            symInfo: 3,
            values : 4
        };

        var $args = {
            active_symbols: "brief"
        };
        if (isJapanTrading()) {
            $args['landing_company'] = "japan";
        }

        BinarySocket.send($args);
        BinarySocket.send({"asset_index": 1});
    };

    var getActiveSymbols = function(response) {
        activeSymbols = response.active_symbols;
        if(assetIndex) {
            populateTable();
        }
    };

    var getAssetIndex = function(response) {
        assetIndex = response.asset_index;
        if(activeSymbols) {
            populateTable();
        }
    };

    // Search and Remove (to decrease the next search count)
    var getSymbolInfo = function(qSymbol) {
        return activeSymbols.filter(function(sy, id) {
            if(sy.symbol === qSymbol) {
                activeSymbols.splice(id, 1);
                return true;
            }
        });
    };

    /*
     * This method generates headers for all tables of each market
     * should include headers existed in all assets of each market and its submarkets
     */
    var organizeData = function() {
        for(var i = 0; i < assetIndex.length; i++) {
            var assetItem = assetIndex[i];
            var symbolInfo = getSymbolInfo(assetItem[idx.symbol])[0];
            if(!symbolInfo) {
                continue;
            }
            var market = symbolInfo.market;

            assetItem.push(symbolInfo);

            // Generate market columns to use in all this market's submarket tables
            if(!(market in marketColumns)) {
                marketColumns[market] = {
                    header : [''],
                    columns: ['']
                };
            }

            var assetCells = assetItem[idx.cells],
                values = {};
            for(var j = 0; j < assetCells.length; j++) {
                var col  = assetCells[j][idx.cellName];
                
                values[col] = assetCells[j][idx.cellFrom] + ' - ' + assetCells[j][idx.cellTo];
                
                var marketCols = marketColumns[market];
                if($.inArray(col, marketCols.columns) === -1) {
                    marketCols.header.push(text.localize(assetCells[j][idx.cellDisplayName]));
                    marketCols.columns.push(col);
                }
            }
            assetItem.push(values);
        }
    };

    var populateTable = function() {
        $('#errorMsg').addClass('hidden');
        organizeData();

        var isJapan = page.language().toLowerCase() === 'ja';
        
        $tabs = $('<ul/>', {class: isJapan ? 'hidden' : ''});
        $contents = $('<div/>');

        for(var i = 0; i < assetIndex.length; i++) {
            var assetItem  = assetIndex[i];
            var symbolInfo = assetItem[idx.symInfo];
            if(!symbolInfo) {
                continue;
            }

            // just show "Major Pairs" when the language is JA
            if(isJapan && symbolInfo.submarket !== 'major_pairs') {
                continue;
            }            

            var $submarketTable = getSubmarketTable(assetItem, symbolInfo);
            $submarketTable.find('tbody').append(createSubmarketTableRow(assetItem, symbolInfo));
        }

        $container
            .empty()
            .append($tabs)
            .append($('<div/>', {class: 'grd-row-padding'}))
            .append($contents.children());

        $container.tabs('destroy').tabs();
    };

    var getSubmarketTable = function(assetItem, symbolInfo) {
        var marketID    = 'market-'    + symbolInfo.market;
        var submarketID = 'submarket-' + symbolInfo.submarket;
        
        var $table = $contents.find('#' + submarketID);
        if($table.length === 0) {
            // Create the table for this submarket
            var $market = $contents.find('#' + marketID);
            if($market.length === 0) {
                // Create the market and tab elements
                $market = $('<div/>', {id: marketID});
                $tabs.append($('<li/>').append($('<a/>', {href: '#' + marketID, text: symbolInfo.market_display_name, id: 'outline'})));
            }
            $table = createEmptyTable(assetItem, symbolInfo, submarketID);
            $market.append($table);
            $contents.append($market);
        }

        return $table;
    };

    var createSubmarketTableRow = function(assetItem, symbolInfo) {
        var cells   = [symbolInfo.display_name],
            columns = ["asset"];

        var marketCols = marketColumns[symbolInfo.market],
            assetCells = assetItem[idx.values];
        for(var i = 1; i < marketCols.columns.length; i++) {
            var prop = marketCols.columns[i];
            if(prop.length > 0) {
                cells.push(prop in assetCells ? assetCells[prop] : '--');
                columns.push(prop);
            }
        }

        return Table.createFlexTableRow(cells, columns, "data");
    };

    var createEmptyTable = function(assetItem, symbolInfo, submarketID) {
        var market = symbolInfo.market;

        var metadata = {
            id: submarketID,
            cols: marketColumns[market].columns
        };

        var $submarketTable = Table.createFlexTable([], metadata, marketColumns[market].header);
        
        var $submarketHeader = $('<tr/>', {class: 'flex-tr'})
            .append($('<th/>', {class: 'flex-tr-child submarket-name', colspan: marketColumns[market].columns.length, text: symbolInfo.submarket_display_name}));
        $submarketTable.find('thead').prepend($submarketHeader);

        return $submarketTable;
    };


    return {
        init: init,
        getAssetIndex: getAssetIndex,
        getActiveSymbols: getActiveSymbols
    };
}());



pjax_config_page("asset_indexws", function() {
    return {
        onLoad: function() {
            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "asset_index") {
                            AssetIndexWS.getAssetIndex(response);
                        }
                        else if (response.msg_type === "active_symbols") {
                            AssetIndexWS.getActiveSymbols(response);
                        }
                    }
                }
            });

            Content.populate();
            AssetIndexWS.init();
        }
    };
});
;var MarketTimesWS = (function() {
    "use strict";

    var $date,
        $container;

    var columns,
        activeSymbols, 
        tradingTimes;


    var init = function() {
        $date      = $('#trading-date');
        $container = $('#trading-times');
        columns    = ['Asset', 'Opens', 'Closes', 'Settles', 'UpcomingEvents'];
        activeSymbols = null;
        tradingTimes = null;
        showLoadingImage($container);
        BinarySocket.send({"active_symbols": "brief"});
        sendRequest('today');

        $date.val(moment.utc(new Date()).format('YYYY-MM-DD'));
        $date.datepicker({minDate: 0, maxDate: '+1y', dateFormat: 'yy-mm-dd', autoSize: true});
        $date.change(function() {
            $container.empty();
            showLoadingImage($container);
            sendRequest();
        });
    };

    var sendRequest = function(date) {
        tradingTimes = null;
        BinarySocket.send({"trading_times": (date ? date : $date.val())});
    };

    var getActiveSymbols = function(response) {
        activeSymbols = response.active_symbols;
        if(tradingTimes) {
            populateTable();
        }
    };

    var getTradingTimes = function(response) {
        tradingTimes = response.trading_times;
        if(activeSymbols) {
            populateTable();
        }
    };

    var populateTable = function() {
        $('#errorMsg').addClass('hidden');

        var isJapanTrading = page.language().toLowerCase() === 'ja';

        var markets = tradingTimes.markets;

        var $ul = $('<ul/>', {class: isJapanTrading ? 'hidden' : ''});
        var $contents = $('<div/>');

        for(var m = 0; m < markets.length; m++) {
            var tabID = 'market_' + (m + 1);

            // tabs
            if(!isJapanTrading) {
                $ul.append($('<li/>').append($('<a/>', {href: '#' + tabID, text: markets[m].name, id: 'outline'})));
            }

            // contents
            var $market = $('<div/>', {id: tabID});
            $market.append(createMarketTables(markets[m], isJapanTrading));
            $contents.append($market);
        }

        $container
            .empty()
            .append($ul)
            .append($('<div/>', {class: 'grd-row-padding'}))
            .append($contents.children());

        $container.tabs('destroy').tabs();
    };

    var createMarketTables = function(market, isJapanTrading) {
        var $marketTables = $('<div/>');

        // submarkets of this market
        var submarkets = market.submarkets;
        for(var s = 0; s < submarkets.length; s++) {
            // just show "Major Pairs" when the language is JA
            if(isJapanTrading) {
                var symbolInfo = symbolSearch(submarkets[s].name);
                if(symbolInfo.length > 0 && symbolInfo[0].submarket !== 'major_pairs') {
                    continue;
                }
            }

            // submarket table
            var $submarketTable = createEmptyTable(market.name + '-' + s);

            // submarket name
            $submarketTable.find('thead').prepend(createSubmarketHeader(submarkets[s].name));

            // symbols of this submarket
            var symbols = submarkets[s].symbols;
            for(var sy = 0; sy < symbols.length; sy++) {
                $submarketTable.find('tbody').append(createSubmarketTableRow(market.name, submarkets[s].name, symbols[sy]));
            }

            $marketTables.append($submarketTable);
        }

        return $marketTables;
    };

    var createSubmarketHeader = function(submarketName) {
        return $('<tr/>', {class: 'flex-tr'})
            .append($('<th/>', {class: 'flex-tr-child submarket-name', colspan: columns.length, text: submarketName}));
    };

    var createSubmarketTableRow = function(marketName, submarketName, symbol) {
        var $tableRow = Table.createFlexTableRow(
            [
                symbol.name,
                '', // Opens
                '', // Closes
                symbol.times.settlement,
                ''  // UpcomingEvents
            ], 
            columns, 
            "data"
        );

        $tableRow.children('.opens').html(symbol.times.open.join('<br />'));
        $tableRow.children('.closes').html(symbol.times.close.join('<br />'));
        $tableRow.children('.upcomingevents').html(createEventsText(symbol.events));

        return $tableRow;
    };

    var symbolSearch = function(submarketname) {
        return activeSymbols.filter(function(sy) {
            return sy.submarket_display_name === submarketname;
        });
    };

    var createEventsText = function(events) {
        var result = '';
        for(var i = 0; i < events.length; i++) {
            result += (i > 0 ? '<br />' : '') + events[i].descrip + ': ' + events[i].dates;
        }
        return result.length > 0 ? result : '--';
    };

    var createEmptyTable = function(tableID) {
        var header = [
            Content.localize().textAsset,
            Content.localize().textOpens,
            Content.localize().textCloses,
            Content.localize().textSettles,
            Content.localize().textUpcomingEvents
        ];

        var metadata = {
            id: tableID,
            cols: columns
        };

        return Table.createFlexTable([], metadata, header);
    };


    return {
        init: init,
        getTradingTimes : getTradingTimes,
        getActiveSymbols: getActiveSymbols
    };
}());



pjax_config_page("market_timesws", function() {
    return {
        onLoad: function() {
            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "trading_times") {
                            MarketTimesWS.getTradingTimes(response);
                        }
                        else if (response.msg_type === "active_symbols") {
                            MarketTimesWS.getActiveSymbols(response);
                        }
                    }
                }
            });

            Content.populate();
            MarketTimesWS.init();
        }
    };
});
;/*
 * This file contains the code related to loading of trading page bottom analysis
 * content. It will contain jquery so as to compatible with old code and less rewrite
 *
 * Please note that this will be removed in near future
 */

/*
 * This function is called whenever we change market, form
 * or underlying to load bet analysis for that particular event
 */

var TradingAnalysis = (function() {
    var trading_digit_info, tab_japan_info;

    var requestTradeAnalysis = function() {
        var contentId = document.getElementById('trading_bottom_content');
        var formName = $('#contract_form_name_nav').find('.a-active').attr('id');
        if (formName === 'matchdiff') {
          formName = 'digits';
        }
        contentId.innerHTML =
          '<div class="content-tab-container page-section">' +
            '<div class="tab-menu">' +
              '<div class="tab-menu-wrap grd-container">' +
                '<ul id="betsBottomPage" class="tm-ul">' +
                  '<li id="tab_portfolio" class="tm-li invisible first">' +
                    '<a href="#tab_portfolio" class="tm-a first">' + text.localize('Portfolio') + '</a>' +
                  '</li>' +
                  '<li id="tab_graph" class="tm-li first">' +
                    '<a href="#tab_graph" class="tm-a first">' + text.localize('Chart') + '</a>' +
                  '</li>' +
                  '<li id="tab_explanation" class="tm-li active">' +
                    '<a href="' + page.url.url_for('trade/bet_explanation') + '&underlying_symbol=' + $('#underlying').val() +
                    '&form_name=' + formName +
                    '" class="tm-a">' + text.localize('Explanation') + '</a>' +
                  '</li>' +
                  '<li id="tab_last_digit" class="invisible tm-li">' +
                    '<a href="#" class="tm-a">' +
                    text.localize('Last Digit Stats') + '</a>' +
                  '</li>' +
                  '<li id="tab_japan_info" class="invisible tm-li last">' +
                    '<a href="#" class="tm-a">' + text.localize('Prices') + '</a>' +
                  '</li>' +
                '</ul>' +
              '</div>' +
            '</div>' +
            '<div class="tab-content grd-container">' +
              '<div class="tab-content-wrapper" id="bet_bottom_content">' +
                '<div id="tab_portfolio-content" class="toggle-content invisible "></div>' +
                '<div id="tab_graph-content" class="toggle-content invisible">' +
                  '<div id="trade_live_chart"></div>' +
                '</div>' +
                '<div id="tab_explanation-content" class="toggle-content selectedTab"></div>' +
                '<div id="tab_last_digit-content" class="toggle-content invisible "></div>' +
                '<div id="tab_japan_info-content" class="toggle-content invisible "></div>' +
              '</div>' +
            '</div>' +
          '</div>';
        if (formName === 'digits' || formName === 'overunder' || formName === 'evenodd') {
            $('#tab_last_digit').removeClass("invisible");
        }
        sessionStorage.setItem('currentAnalysisTab', getActiveTab());
        bindAnalysisTabEvent();
        loadAnalysisTab();
    };

    /*
     * This function bind event to link elements of bottom content
     * navigation
     */
    var bindAnalysisTabEvent = function() {
        'use strict';
        var analysisNavElement = document.querySelector('#trading_bottom_content #betsBottomPage');
        if (analysisNavElement) {
            analysisNavElement.addEventListener('click', function(e) {
                if (e.target && e.target.nodeName === 'A') {
                    e.preventDefault();

                    var clickedLink = e.target,
                        clickedElement = clickedLink.parentElement,
                        isTabActive = clickedElement.classList.contains('active');

                    sessionStorage.setItem('currentAnalysisTab', clickedElement.id);

                    if (!isTabActive) {
                        loadAnalysisTab();
                    }
                }
            });
        }
    };

    /*
     * This function handles all the functionality on how to load
     * tab according to current paramerted
     */
    var loadAnalysisTab = function() {
        'use strict';
        var currentTab = getActiveTab(),
            currentLink = document.querySelector('#' + currentTab + ' a'),
            contentId = document.getElementById(currentTab + '-content');

        var analysisNavElement = document.querySelector('#trading_bottom_content #betsBottomPage');
        toggleActiveNavMenuElement(analysisNavElement, currentLink.parentElement);
        toggleActiveAnalysisTabs();

        tab_japan_info = new BetAnalysis.JapanInfo();
        BetAnalysis.Portfolio.init();

        if(currentTab === 'tab_portfolio'){
            BetAnalysis.Portfolio.show();
        } else if (currentTab === 'tab_japan_info') {
            tab_japan_info.show();
        } else {
            BetAnalysis.Portfolio.hide();
            tab_japan_info.hide();
            if (currentTab === 'tab_graph') {
                if (document.getElementById('underlying')){
                    showHighchart();
                } else {
                    BetAnalysis.tab_live_chart.reset();
                    BetAnalysis.tab_live_chart.render(true);
                }
            } else {
                if (currentTab == 'tab_last_digit') {
                    var underlying = $('[name=underlying] option:selected').val() || $('#underlying option:selected').val();
                    var tick = $('[name=tick_count]').val() || 100;
                    trading_digit_info = TradingAnalysis.tab_last_digitws;
                    var request = JSON.parse('{"ticks_history":"'+ underlying +'",'+
                                              '"end": "latest",'+
                                              '"count": '+ tick +','+
                                              '"req_id": 1}');
                    BinarySocket.send(request);
                } else{
                    var url = currentLink.getAttribute('href') ;
                    $.ajax({
                        method: 'GET',
                        url: url,
                    })
                    .done(function(data) {
                        contentId.innerHTML = data;
                        if (currentTab == 'tab_last_digit') {
                            trading_digit_info = new BetAnalysis.DigitInfo();
                            trading_digit_info.on_latest();
                            trading_digit_info.show_chart(sessionStorage.getItem('underlying'));
                        }

                    });
                }
            }
        }

    };

    /*
     * function to toggle the active element for analysis menu
     */
    var toggleActiveAnalysisTabs = function() {
        'use strict';
        var currentTab = getActiveTab(),
            analysisContainer = document.getElementById('bet_bottom_content');

        if (analysisContainer) {
            trading_digit_info = undefined;
            var childElements = analysisContainer.children,
                currentTabElement = document.getElementById(currentTab + '-content'),
                classes = currentTabElement.classList;

            for (var i = 0, len = childElements.length; i < len; i++) {
                childElements[i].classList.remove('selectedTab');
                childElements[i].classList.add('invisible');
            }

            classes.add('selectedTab');
            classes.remove('invisible');
        }
    };

    /*
     * get the current active tab if its visible i.e allowed for current parameters
     */
    var getActiveTab = function() {
        var selectedTab = sessionStorage.getItem('currentAnalysisTab') || (isJapanTrading() ? 'tab_portfolio' : 'tab_explanation'),
            selectedElement = document.getElementById(selectedTab);

        if (selectedElement && selectedElement.classList.contains('invisible')) {
            selectedTab = 'tab_explanation';
            sessionStorage.setItem('currentAnalysisTab', 'tab_explanation');
        }

        return selectedTab;
    };

    return {
        request: requestTradeAnalysis,
        digit_info: function() {
            return trading_digit_info;
        },
        // Should be removed with legacy trading.
        set_digit_info: function(obj) {
            trading_digit_info = obj;
        },
        japan_info: function() {
            return tab_japan_info;
        },
        tab_portfolio: function() {
            return tab_portfolio;
        },
        getActiveTab: getActiveTab
    };

})();
;/*
 * Handles barrier processing and display
 *
 * It process `Contract.barriers` and display them if its applicable
 * for current `Contract.form()
 */

var Barriers = (function () {
    'use strict';

    var isBarrierUpdated = false;

    var display = function (barrierCategory) {
        var barriers = Contract.barriers()[Defaults.get('underlying')],
            formName = Contract.form();

        if (barriers && formName && Defaults.get('formname')!=='risefall') {
            var barrier = barriers[formName];
            if(barrier) {
                var unit = document.getElementById('duration_units'),
                    end_time = document.getElementById('expiry_date'),
                    currentTick = Tick.quote(),
                    indicativeBarrierTooltip = document.getElementById('indicative_barrier_tooltip'),
                    indicativeHighBarrierTooltip = document.getElementById('indicative_high_barrier_tooltip'),
                    indicativeLowBarrierTooltip = document.getElementById('indicative_low_barrier_tooltip'),
                    decimalPlaces = countDecimalPlaces(currentTick);

                if (barrier.count === 1) {
                    document.getElementById('high_barrier_row').style.display = 'none';
                    document.getElementById('low_barrier_row').style.display = 'none';
                    document.getElementById('barrier_row').setAttribute('style', '');

                    var defaults_barrier = Defaults.get('barrier');
                    var barrier_def = defaults_barrier && !isNaN(defaults_barrier) ? defaults_barrier : barrier['barrier'];
                    var elm = document.getElementById('barrier'),
                        tooltip = document.getElementById('barrier_tooltip'),
                        span = document.getElementById('barrier_span');
                    if ((unit && unit.value === 'd') || (end_time && moment(end_time.value).isAfter(moment(),'day'))) {
                        if (currentTick && !isNaN(currentTick) && barrier_def.match(/^[+-]/)) {
                            elm.value = (parseFloat(currentTick) + parseFloat(barrier_def)).toFixed(decimalPlaces);
                            elm.textContent = (parseFloat(currentTick) + parseFloat(barrier_def)).toFixed(decimalPlaces);
                        } else {
                            elm.value = parseFloat(barrier_def);
                            elm.textContent = parseFloat(barrier_def);
                        }
                        tooltip.style.display = 'none';
                        span.style.display = 'inherit';
                        // no need to display indicative barrier in case of absolute barrier
                        indicativeBarrierTooltip.textContent = '';
                    } else {
                        elm.value = barrier_def;
                        elm.textContent = barrier_def;
                        span.style.display = 'none';
                        tooltip.style.display = 'inherit';
                        if (currentTick && !isNaN(currentTick)) {
                            indicativeBarrierTooltip.textContent = (parseFloat(currentTick) + parseFloat(barrier_def)).toFixed(decimalPlaces);
                        } else {
                            indicativeBarrierTooltip.textContent = '';
                        }
                    }
                    Defaults.set('barrier', elm.value);
                    Defaults.remove('barrier_high', 'barrier_low');
                    return;
                } else if (barrier.count === 2) {
                    document.getElementById('barrier_row').style.display = 'none';
                    document.getElementById('high_barrier_row').setAttribute('style', '');
                    document.getElementById('low_barrier_row').setAttribute('style', '');

                    var high_elm = document.getElementById('barrier_high'),
                        low_elm = document.getElementById('barrier_low'),
                        high_tooltip = document.getElementById('barrier_high_tooltip'),
                        high_span = document.getElementById('barrier_high_span'),
                        low_tooltip = document.getElementById('barrier_low_tooltip'),
                        low_span = document.getElementById('barrier_low_span');

                    var defaults_barrier_high = Defaults.get('barrier_high'), defaults_barrier_low = Defaults.get('barrier_low');
                    var barrier_high = defaults_barrier_high && !isNaN(defaults_barrier_high) ? defaults_barrier_high : barrier['barrier'],
                        barrier_low  = defaults_barrier_low  && !isNaN(defaults_barrier_low)  ? defaults_barrier_low  : barrier['barrier1'];
                    if (unit && unit.value === 'd') {
                        if (currentTick && !isNaN(currentTick) && barrier_high.match(/^[+-]/)) {
                            high_elm.value = (parseFloat(currentTick) + parseFloat(barrier_high)).toFixed(decimalPlaces);
                            high_elm.textContent = (parseFloat(currentTick) + parseFloat(barrier_high)).toFixed(decimalPlaces);

                            low_elm.value = (parseFloat(currentTick) + parseFloat(barrier_low)).toFixed(decimalPlaces);
                            low_elm.textContent = (parseFloat(currentTick) + parseFloat(barrier_low)).toFixed(decimalPlaces);
                        } else {
                            high_elm.value = parseFloat(barrier_high);
                            high_elm.textContent = parseFloat(barrier_high);

                            low_elm.value = parseFloat(barrier_low);
                            low_elm.textContent = parseFloat(barrier_low);
                        }

                        high_tooltip.style.display = 'none';
                        high_span.style.display = 'inherit';
                        low_tooltip.style.display = 'none';
                        low_span.style.display = 'inherit';

                        indicativeHighBarrierTooltip.textContent = '';
                        indicativeLowBarrierTooltip.textContent = '';
                    } else {
                        high_elm.value = barrier_high;
                        high_elm.textContent = barrier_high;

                        low_elm.value = barrier_low;
                        low_elm.textContent = barrier_low;

                        high_span.style.display = 'none';
                        high_tooltip.style.display = 'inherit';
                        low_span.style.display = 'none';
                        low_tooltip.style.display = 'inherit';

                        if (currentTick && !isNaN(currentTick)) {
                            indicativeHighBarrierTooltip.textContent = (parseFloat(currentTick) + parseFloat(barrier_high)).toFixed(decimalPlaces);
                            indicativeLowBarrierTooltip.textContent = (parseFloat(currentTick) + parseFloat(barrier_low)).toFixed(decimalPlaces);
                        } else {
                            indicativeHighBarrierTooltip.textContent = '';
                            indicativeLowBarrierTooltip.textContent = '';
                        }
                    }
                    Defaults.set('barrier_high', high_elm.value);
                    Defaults.set('barrier_low', low_elm.value);
                    Defaults.remove('barrier');
                    return;
                }
            }
        }

        var elements = document.getElementsByClassName('barrier_class');
        for (var i = 0; i < elements.length; i++){
            elements[i].style.display = 'none';
        }
        Defaults.remove('barrier', 'barrier_high', 'barrier_low');
    };

    return {
        display: display,
        isBarrierUpdated: function () { return isBarrierUpdated; },
        setBarrierUpdate: function (flag) {
            isBarrierUpdated = flag;
        }
    };
})();
;TradingAnalysis.DigitInfoWS = function() {
    this.chart_config = {
        chart: {
                renderTo:'last_digit_histo',
                defaultSeriesType:'column',
                backgroundColor:'#eee',
                borderWidth:1,
                borderColor:'#ccc',
                plotBackgroundColor:'#fff',
                plotBorderWidth:1,
                plotBorderColor:'#ccc',
                height:225 // This is "unresponsive", but so is leaving it empty where it goes to 400px.
        },
        title:{text:''},
        credits:{enabled:false},
        exporting:{enabled:false},
        legend:{
            enabled:false
        },
        tooltip:{
            borderWidth:1,
            formatter:function() {
                var that = this;
                var total = $("select[name='tick_count']").val();
                var percentage = that.y/total*100;
                return '<b>Digit:</b> '+ that.x +'<br/>'+
                '<b>Percentage:</b> '+ percentage.toFixed(1) + " %";
            }
        },
        plotOptions:{
            column:{
                shadow:false,
                borderWidth:0.5,
                borderColor:'#666',
                pointPadding:0,
                groupPadding:0.0,
                color: '#e1f0fb',
            },
            series: {
                dataLabels: {
                    enabled: true,
                    style: {
                        textShadow: false, 
                    },
                    formatter: function() {
                        var total = $("select[name='tick_count']").val();
                        var percentage = this.point.y/total*100;
                        return percentage.toFixed(2) + ' %';
                    },
                },
            },
        },
        xAxis:{
            categories: ['0','1','2','3','4','5','6','7','8','9'],
            lineWidth:0,
            lineColor:'#999',
            tickLength:10,
            tickColor:'#ccc',
        },
        yAxis:{
            title:{text:''},
            maxPadding:0,
            gridLineColor:'#e9e9e9',
            tickWidth:1,
            tickLength:3,
            tickColor:'#ccc',
            lineColor:'#ccc',
            endOnTick:true,
            opposite: false,
            labels: {
                align: 'left',
                x: 0,
                enabled: false,
                formatter: function() {
                    var total = $("select[name='tick_count']").val();
                    var percentage = parseInt(this.value/total*100);
                    return percentage + " %";
                },
            },
        },
    };

    this.spots = [];
    this.stream_id = null;
    // To avoid too many greens and reds
    this.prev_min_index = -1;
    this.prev_max_index = -1;
};

TradingAnalysis.DigitInfoWS.prototype = {
    add_content: function(underlying){
        var domain = document.domain.split('.').slice(-2).join('.'),
            underlyings =[];
        var symbols = Symbols.getAllSymbols();
        i=0;
        for(var key in symbols){
            if(/^(R_|RD)/.test(key)){
                underlyings[i++] = key;
            }
        }
        underlyings = underlyings.sort();
        var elem = '<select class="smallfont" name="underlying">';
        for(i=0;i<underlyings.length;i++){
            elem = elem + '<option value="'+underlyings[i]+'">'+text.localize(symbols[underlyings[i]])+'</option>';
        }
        elem = elem + '</select>';
        var contentId = document.getElementById('tab_last_digit-content'),
            content = '<div class="grd-parent">'+
                        '<div id="last_digit_histo_form" class="grd-grid-8 grd-grid-mobile-12 grd-centered">'+
                        '<form class=smallfont action="#" method="post">'+
                        '<div class="grd-grid-mobile-12">'+ text.localize('Select market')+' : ' + elem +' </div>'+
                        '<div class="grd-grid-mobile-12">'+ text.localize('Number of ticks')+' : <select class="smallfont" name="tick_count"><option value="25">25</option><option value="50">50</option><option selected="selected" value="100">100</option><option value="500">500</option><option value="1000">1000</option></select></div>'+
                        '</form>'+
                        '</div>'+
                        '<div id="last_digit_histo" class="grd-grid-8 grd-grid-mobile-12 grd-centered"></div>'+
                        '<div id="last_digit_title" class="grd-hide">'+ (domain.charAt(0).toUpperCase() + domain.slice(1)) + ' - ' + text.localize('Last digit stats for the latest [_1] ticks on [_2]') +'</div>'+
                        '</div>';
        contentId.innerHTML = content;
        $('[name=underlying]').val(underlying);
        
    },
    on_latest: function() {
        var that = this;
        var tab = $('#tab_last_digit-content');
        var form = tab.find('form:first');
        form.on('submit', function(event) {
            event.preventDefault();
            return false;
        }).addClass('unbind_later');

        var get_latest = function() {
            var symbol = $('[name=underlying] option:selected').val();
            var request = JSON.parse('{"ticks_history":"'+ symbol +'",'+
                                        '"end": "latest",'+
                                        '"count": '+ $('[name=tick_count]', form).val() +','+
                                        '"req_id": 2}');
            if(that.chart.series[0].name !== symbol){
                if($('#underlying option:selected').val() != $('[name=underlying]', form).val()){
                    request['subscribe'] = 1;
                    request['style'] = "ticks";
                }
                if(that.stream_id !== null ){
                    BinarySocket.send(JSON.parse('{"forget": "'+ that.stream_id +'"}'));
                    that.stream_id = null;
                }
            }
            BinarySocket.send(request);
        };
        $('[name=underlying]', form).on('change',  get_latest ).addClass('unbind_later');
        $('[name=tick_count]', form).on('change',  get_latest ).addClass('unbind_later');
    },
    show_chart: function(underlying, spots) {
        if(typeof spots === 'undefined' || spots.length <= 0){
            console.log("Unexpected error occured in the charts.");
            return;
        }
        var dec = spots[0].split('.')[1].length;
        for(i=0;i<spots.length;i++){
            var val = parseFloat(spots[i]).toFixed(dec);
            spots[i]=val.substr(val.length-1);
        }
        this.spots = spots;
        if(this.chart &&  $('#last_digit_histo').html()){
            this.chart.xAxis[0].update({
                title:{
                    text: $('#last_digit_title').html().replace('[_2]', $('[name=underlying] option:selected').text()).replace('[_1]',spots.length),
                }
            }, true);
            this.chart.series[0].name = underlying;
        }
        else{
            this.add_content(underlying);
            this.chart_config.xAxis.title = {
                text: $('#last_digit_title').html().replace('[_2]', $('[name=underlying] option:selected').text()).replace('[_1]',spots.length),
            };
            this.chart = new Highcharts.Chart(this.chart_config);
            this.chart.addSeries({name : underlying, data: []});
            this.on_latest();
            this.stream_id = null;
        }
        this.update();
    },
    update: function(symbol, latest_spot) {
        if(typeof this.chart === "undefined") {
            return;
        }
        
        var series = this.chart.series[0]; // Where we put the final data.
        if (series.name != symbol) {
            latest_spot = undefined; // This simplifies the logic a bit later.
        }

        if (typeof latest_spot !== "undefined") { // This is a bit later. :D
            this.spots.unshift(latest_spot.slice(-1)); // Only last digit matters
            this.spots.pop();
        }

        // Always recompute and draw, even if theres no new data.
        // This is especially useful on first reuqest, but maybe in other ways.
        var filtered_spots = [];
        var digit = 10,
            filterFunc = function (el) { return el == digit; };
        var min_max_counter = [];
        while(digit--) {
            var val = this.spots.filter(filterFunc).length;
            filtered_spots[digit] = val;
            if (typeof min_max_counter[val] === 'undefined') {
                min_max_counter[val] = 0;
            }
            min_max_counter[val]++;
        }
        var min = Math.min.apply(null, filtered_spots);
        var max = Math.max.apply(null, filtered_spots);
        var min_index = filtered_spots.indexOf(min);
        var max_index = filtered_spots.indexOf(max);
        // changing color
        if (min_max_counter[min] >= 1) {
            filtered_spots[min_index] = {y: min, color: '#CC0000'};
            if(this.prev_min_index === -1){
                this.prev_min_index = min_index;
            } else if(this.prev_min_index != min_index){
                if(typeof(filtered_spots[this.prev_min_index]) === 'object'){
                    filtered_spots[this.prev_min_index] = {y: filtered_spots[this.prev_min_index].y, color: '#e1f0fb'};
                } else
                    filtered_spots[this.prev_min_index] = {y: filtered_spots[this.prev_min_index], color: '#e1f0fb'};
                this.prev_min_index = min_index;
            }
        }

        if (min_max_counter[max] >= 1) {
            filtered_spots[max_index] = {y: max, color: '#2E8836'};
            if(this.prev_max_index === -1){
                this.prev_max_index = max_index;
            } else if(this.prev_max_index != max_index){
                if(typeof(filtered_spots[this.prev_max_index]) === 'object'){
                    filtered_spots[this.prev_max_index] = {y: filtered_spots[this.prev_max_index].y, color: '#e1f0fb'};
                } else
                    filtered_spots[this.prev_max_index] = {y: filtered_spots[this.prev_max_index], color: '#e1f0fb'};
                this.prev_max_index = max_index;
            }
        }
        return series.setData(filtered_spots);
    },
    show_tab: function() {
        var tab_last_digit = $('#tab_last_digit');
        MenuContent.show_tab(tab_last_digit);
        var saved_anaysis_tab = SessionStore.get('bet_page.selected_analysis_tab');
        if(saved_anaysis_tab == 'tab_last_digit') {
            MenuContent.trigger({
                'tab_id': saved_anaysis_tab
            });
        }
    },
    hide_tab: function() {
        var tab_last_digit = $('#tab_last_digit');
        MenuContent.hide_tab(tab_last_digit);
        if(typeof this.chart !== "undefined") {
            this.chart.destroy();
        }
        this.chart = undefined;
        this.spots = [];
    },
    update_chart: function(tick){
        if(tick.req_id === 2){
            if(this.chart.series[0].name === tick.tick.symbol){
                this.stream_id = tick.tick.id || null;
                this.update(tick.tick.symbol, tick.tick.quote);
            } else{
                BinarySocket.send(JSON.parse('{"forget":"'+tick.tick.id+'"}'));
            }
        } else{
            if(!this.stream_id){
                this.update(tick.tick.symbol, tick.tick.quote);
            }
        }
    }
};

TradingAnalysis.tab_last_digitws = new TradingAnalysis.DigitInfoWS();
;/*
 * This contains common functions we need for processing the response
 */

 Element.prototype.hide = function(){
     this.style.display = 'none';
 };

 Element.prototype.show = function(){
     this.style.display = '';
 };

/*
 * function to display contract form as element of ul
 */
 function displayContractForms(id, elements, selected) {
     'use strict';
     var target = document.getElementById(id),
         fragment = document.createDocumentFragment(),
         len = elements.length;

     target.innerHTML = '';

     if (elements) {
         var tree = getContractCategoryTree(elements);
         for(var i=0;i<tree.length;i++){
             var el1 = tree[i];
             var li = document.createElement('li');

             li.classList.add('tm-li');
             if(i===0){
                 li.classList.add('first');
             }
             else if(i===tree.length-1){
                 li.classList.add('last');
             }

             if(typeof el1 === 'object'){
                 var fragment2 = document.createDocumentFragment();
                 var flag = 0;
                 var first = '';
                 for(var j=0; j<el1[1].length; j++){
                     var el2 = el1[1][j];
                     var li2 = document.createElement('li'),
                         a2 = document.createElement('a'),
                         content2 = document.createTextNode(elements[el2]);
                     li2.classList.add('tm-li-2');

                     if(j===0){
                        first = el2.toLowerCase();
                        li2.classList.add('first');
                     }
                     else if(j===el1[1].length-1){
                         li2.classList.add('last');
                     }

                     var span_class = '';
                     if (selected && selected === el2.toLowerCase()) {
                         li2.classList.add('active');
                         a2.classList.add('a-active');
                         flag = 1;
                     }

                     a2.classList.add('tm-a-2');
                     a2.appendChild(content2);
                     a2.setAttribute('menuitem',el2.toLowerCase());
                     a2.setAttribute('id', el2.toLowerCase());

                     li2.appendChild(a2);

                     fragment2.appendChild(li2);
                 }
                 if(fragment2.hasChildNodes()){
                     var ul = document.createElement('ul'),
                         a = document.createElement('a'),
                         content = document.createTextNode(elements[el1[0]]);

                     a.appendChild(content);
                     a.setAttribute('class', 'tm-a');
                     a.setAttribute('menuitem',first);
                     ul.appendChild(fragment2);
                     ul.setAttribute('class', 'tm-ul-2');
                     ul.setAttribute('id', el1[0]+'-submenu');

                     if(flag){
                        li.classList.add('active');
                     }

                     li.appendChild(a);
                     li.appendChild(ul);
                 }
             }
             else{
                 var content3 = document.createTextNode(elements[el1]),
                     a3 = document.createElement('a');

                 if (selected && selected === el1.toLowerCase()) {
                     a3.classList.add('a-active');
                     li.classList.add('active');
                 }
                 a3.appendChild(content3);
                 a3.classList.add('tm-a');
                 a3.setAttribute('menuitem',el1);
                 a3.setAttribute('id', el1.toLowerCase());
                 li.appendChild(a3);
             }
             fragment.appendChild(li);
         }
         if (target) {
             target.appendChild(fragment);
             var list = target.getElementsByClassName('tm-li');
             for(var k=0; k < list.length; k++){
                 var li4 = list[k];
                 li4.addEventListener("mouseover", function(){
                     this.classList.add('hover');
                 });
                 li4.addEventListener("mouseout", function(){
                     this.classList.remove('hover');
                 });
             }
         }
     }
 }


 function displayMarkets(id, elements, selected) {
     'use strict';
     var target= document.getElementById(id),
         fragment =  document.createDocumentFragment();

     while (target && target.firstChild) {
         target.removeChild(target.firstChild);
     }

     var keys1 = Object.keys(elements).sort(marketSort);
     for (var i=0; i<keys1.length; i++) {
         var key = keys1[i];
         var option = document.createElement('option'), content = document.createTextNode(elements[key].name);
         option.setAttribute('value', key);
         if(!elements[key].is_active){
            option.setAttribute('disabled', '');
         }
         else if (selected && selected === key) {
             option.setAttribute('selected', 'selected');
         }
         option.appendChild(content);
         fragment.appendChild(option);

         if(elements[key].submarkets && Object.keys(elements[key].submarkets).length){
            var keys2 = Object.keys(elements[key].submarkets).sort(marketSort);
            for (var j=0; j<keys2.length; j++) {
                var key2 = keys2[j];
                option = document.createElement('option');
                option.setAttribute('value', key2);
                if(!elements[key].submarkets[key2].is_active){
                   option.setAttribute('disabled', '');
                }
                else if (selected && selected === key2) {
                    option.setAttribute('selected', 'selected');
                }
                option.textContent = '\xA0\xA0\xA0\xA0'+elements[key].submarkets[key2].name;
                fragment.appendChild(option);
            }
         }
     }
     if (target) {
         target.appendChild(fragment);

         if(target.selectedIndex < 0) {
            target.selectedIndex = 0;
         }
         var current = target.options[target.selectedIndex];
         if(selected !== current.value) {
            Defaults.set('market', current.value);
         }

         if(current.disabled) { // there is no open market
            document.getElementById('markets_closed_msg').classList.remove('hidden');
            document.getElementById('trading_init_progress').style.display = 'none';
         }
     }
 }
/*
 * function to create `option` and append to select box with id `id`
 */
function displayOptions(id, elements, selected) {
    'use strict';
    var target= document.getElementById(id),
        fragment =  document.createDocumentFragment();

    while (target && target.firstChild) {
        target.removeChild(target.firstChild);
    }

    for (var key in elements) {
        if (elements.hasOwnProperty(key)){
            var option = document.createElement('option'), content = document.createTextNode(elements[key]);
            option.setAttribute('value', key);
            if (selected && selected === key) {
                option.setAttribute('selected', 'selected');
            }
            option.appendChild(content);
            fragment.appendChild(option);
        }
    }
    if (target) {
        target.appendChild(fragment);
    }
}

/*
 * function to display underlyings
 *
 * we need separate function for this as sorting is different and later
 * we may add submarket to it
 */
function displayUnderlyings(id, elements, selected) {
    'use strict';
    var target= document.getElementById(id),
        fragment =  document.createDocumentFragment();

    while (target && target.firstChild) {
        target.removeChild(target.firstChild);
    }

    if (elements) {
        var keys = Object.keys(elements).sort(function(a, b) {
            return elements[a]['display'].localeCompare(elements[b]['display']);
        });
        var submarkets = {};
        for(var i=0; i<keys.length; i++){
            if(!submarkets.hasOwnProperty(elements[keys[i]].submarket)){
                submarkets[elements[keys[i]].submarket] = [];
            }
            submarkets[elements[keys[i]].submarket].push(keys[i]);
        }
        var keys2 = Object.keys(submarkets).sort(marketSort);
        for(var j=0; j<keys2.length; j++){
            for(var k=0; k<submarkets[keys2[j]].length; k++){
                var key = submarkets[keys2[j]][k];
                var option = document.createElement('option'), content = document.createTextNode(text.localize(elements[key]['display']));
                option.setAttribute('value', key);
                if (elements[key]['is_active'] !== 1) {
                    option.setAttribute('disabled', true);
                }
                if (selected && selected === key) {
                    option.setAttribute('selected', 'selected');
                }
                option.appendChild(content);
                fragment.appendChild(option);
            }
        }
    }
    if (target) {
        target.appendChild(fragment);
    }
}

/*
 * This maps the form name and barrierCategory we display on
 * trading form to the actual we send it to backend
 * for e.g risefall is mapped to callput with barrierCategory euro_atm
 */
function getFormNameBarrierCategory(displayFormName) {
    'use strict';
    var obj = {};
    if (displayFormName) {
        if(displayFormName === 'risefall') {
            obj['formName'] = 'callput';
            obj['barrierCategory'] = 'euro_atm';
        } else if (displayFormName === 'higherlower') {
            obj['formName'] = 'callput';
            obj['barrierCategory'] = 'euro_non_atm';
        } else if (displayFormName === 'callput'){
            obj['formName'] = displayFormName;
            obj['barrierCategory'] = 'euro_atm';
        } else if (displayFormName === 'overunder' || displayFormName === 'evenodd' || displayFormName === 'matchdiff'){
            obj['formName'] = 'digits';
            obj['barrierCategory'] = '';
        } else {
            obj['formName'] = displayFormName;
            obj['barrierCategory'] = '';
        }
    } else {
        obj['formName'] = 'callput';
        obj['barrierCategory'] = 'euro_atm';
    }
    return obj;
}

/*
 * This maps the contract type to where we display on trading form
 * and as there is no mapping on server side so need to create it
 * on front end
 *
 * for example we display CALL on top and PUT to bottom
 */
function contractTypeDisplayMapping(type) {
    'use strict';
    var obj = {
        CALL: "top",
        PUT: "bottom",
        CALLE: "top",
        PUTE: "bottom",
        ASIANU: "top",
        ASIAND: "bottom",
        DIGITMATCH: "top",
        DIGITDIFF: "bottom",
        DIGITEVEN: "top",
        DIGITODD: "bottom",
        DIGITOVER: "top",
        DIGITUNDER: "bottom",
        EXPIRYRANGEE: "top",
        EXPIRYMISSE: "bottom",
        EXPIRYRANGE: "top",
        EXPIRYMISS: "bottom",
        RANGE: "top",
        UPORDOWN: "bottom",
        ONETOUCH: "top",
        NOTOUCH: "bottom",
        SPREADU: "top",
        SPREADD: "bottom"
    };

    return type ? obj[type] : 'top';
}


/*
 * function to check if element is visible or not
 *
 * alternative to jquery $('#id').is(':visible')
 */
function isVisible(elem) {
    'use strict';
    if (elem.offsetWidth === 0 && elem.offsetHeight === 0) {
        return false;
    } else {
        return true;
    }
}

/*
 * function to hide and display the loading icon for price container
 */
function hideLoadingOverlay() {
    'use strict';
    var elm = document.getElementById('loading_container');
    if (elm) {
        elm.style.display = 'none';
    }
}

function showLoadingOverlay() {
    'use strict';
    var elm = document.getElementById('loading_container');
    if (elm) {
        elm.style.display = 'block';
    }
}

function showPriceOverlay() {
    'use strict';
    var elm = document.getElementById('loading_container2');
    if (elm) {
        elm.style.display = 'block';
    }
}

function hidePriceOverlay() {
    'use strict';
    var elm = document.getElementById('loading_container2');
    if (elm) {
        elm.style.display = 'none';
    }

}

function hideFormOverlay(){
    'use strict';
    var elm = document.getElementById('loading_container3');
    if (elm) {
        elm.style.display = 'none';
    }
}

function showFormOverlay(){
    'use strict';
    var elm = document.getElementById('loading_container3');
    if (elm) {
        elm.style.display = 'block';
    }
}

/*
 * function to hide contract confirmation overlay container
 */
function hideOverlayContainer() {
    'use strict';
    var elm = document.getElementById('contract_confirmation_container');
    if (elm) {
        elm.style.display = 'none';
    }
    var elm2 = document.getElementById('contracts_list');
    if (elm2) {
        elm2.style.display = 'flex';
    }
}

/*
 * function to assign sorting to market list
 */
function compareMarkets(a, b) {
    'use strict';
    var sortedMarkets = {
        'forex': 0,
        'indices': 1,
        'stocks': 2,
        'commodities': 3,
        'volidx': 4
    };

    if (sortedMarkets[a.toLowerCase()] < sortedMarkets[b.toLowerCase()]) {
        return -1;
    }
    if (sortedMarkets[a.toLowerCase()] > sortedMarkets[b.toLowerCase()]) {
        return 1;
    }
    return 0;
}

function getContractCategoryTree(elements){
    'use strict';

    var tree = [
        ['updown',
            ['risefall',
            'higherlower']
        ],
        'touchnotouch',
        ['inout',
            ['endsinout',
            'staysinout']
        ],
        'asian',
        ['digits',
            ['matchdiff',
            'evenodd',
            'overunder']
        ],
        'spreads'
    ];

    if(elements){
        tree = tree.map(function(e){
            if(typeof e === 'object'){
                e[1] = e[1].filter(function(e1){
                    return elements[e1];
                });
                if(!e[1].length){
                    e = '';
                }
            }
            else if(!elements[e]){
                e = '';
            }
            return e;
        });
        tree = tree.filter(function(v){ return v.length; });
    }
    return tree;
}

/*
 * function to get cookie javascript way (use if you don't want to use jquery)
 */
function getCookieItem(sKey) {
    'use strict';
    if (!sKey) { return null; }
    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
}

/*
 * Display price/spot movement variation to depict price moved up or down
 */
function displayPriceMovement(element, oldValue, currentValue) {
    'use strict';
    element.classList.remove('price_moved_down');
    element.classList.remove('price_moved_up');
    if (parseFloat(currentValue) > parseFloat(oldValue)) {
        element.classList.remove('price_moved_down');
        element.classList.add('price_moved_up');
    } else if (parseFloat(currentValue) < parseFloat(oldValue)) {
        element.classList.remove('price_moved_up');
        element.classList.add('price_moved_down');
    }
}

/*
 * resets price movement color changing, to prevent coloring on some changes
 * coloring will continue on the next proposal responses
 */
function resetPriceMovement() {
    var btns = document.getElementsByClassName('purchase_button');
    for(var i = 0; i < btns.length; i++) {
        btns[i].setAttribute('data-display_value', '');
    }
}

/*
 * function to toggle active class of menu
 */
function toggleActiveNavMenuElement(nav, eventElement) {
    'use strict';
    var liElements = nav.getElementsByTagName("li");
    var classes = eventElement.classList;

    if (!classes.contains('active')) {
        for (var i = 0, len = liElements.length; i < len; i++){
            liElements[i].classList.remove('active');
        }
        classes.add('active');
    }
}

function toggleActiveCatMenuElement(nav, eventElementId) {
    'use strict';
    var eventElement = document.getElementById(eventElementId);
    var liElements = nav.querySelectorAll('.active, .a-active');
    var classes = eventElement.classList;

    if (!classes.contains('active')) {
        for (var i = 0, len = liElements.length; i < len; i++){
            liElements[i].classList.remove('active');
            liElements[i].classList.remove('a-active');
        }
        classes.add('a-active');

        i = 0;
        var parent;
        while((parent = eventElement.parentElement) && parent.id !== nav.id && i < 10){
            if(parent.tagName === 'LI'){
                parent.classList.add('active');
            }
            eventElement = parent;
            i++;
        }
    }
}

/*
 * function to set placeholder text based on current form, used for mobile menu
 */
function setFormPlaceholderContent(name) {
    'use strict';
    var formPlaceholder = document.getElementById('contract_form_nav_placeholder');
    if (formPlaceholder) {
        name = name || Defaults.get('formname');
        formPlaceholder.textContent = Contract.contractForms()[name];
    }
}

/*
 * function to display the profit and return of bet under each trade container except spreads
 */
function displayCommentPrice(node, currency, type, payout) {
    'use strict';

    if (node && type && payout) {
        var profit = payout - type,
            return_percent = (profit/type)*100,
            comment = Content.localize().textNetProfit + ': ' + currency + ' ' + profit.toFixed(2) + ' | ' + Content.localize().textReturn + ' ' + return_percent.toFixed(0) + '%';

        if (isNaN(profit) || isNaN(return_percent)) {
            node.hide();
        } else {
            node.show();
            node.textContent = comment;
        }
    }
}

/*
 * function to display comment for spreads
 */
function displayCommentSpreads(node, currency, point) {
    'use strict';

    if (node && point) {
        var amountPerPoint = document.getElementById('amount_per_point').value,
            stopType = document.querySelector('input[name="stop_type"]:checked').value,
            stopLoss = document.getElementById('stop_loss').value,
            displayAmount = 0;

        if (isNaN(stopLoss) || isNaN(amountPerPoint)) {
            node.hide();
        } else {
            if (stopType === 'point') {
                displayAmount = parseFloat(parseFloat(amountPerPoint) * parseFloat(stopLoss));
            } else {
                displayAmount = parseFloat(stopLoss);
            }
            node.textContent = Content.localize().textSpreadDepositComment + " " + currency + " " + displayAmount.toFixed(2) + " " + Content.localize().textSpreadRequiredComment + ": " + point + " " + Content.localize().textSpreadPointsComment;
        }
    }
}

/*
 * This function is used in case where we have input and we don't want to fire
 * event on every change while user is typing for example in case of amount if
 * we want to change 10 to 1000 i.e. two zeros so two input events will be fired
 * normally, this function delay the event based on delay specified in milliseconds
 *
 * Reference
 * http://davidwalsh.name/javascript-debounce-function
 */
function debounce(func, wait, immediate) {
    'use strict';
    var timeout;
    var delay = wait || 500;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, delay);
        if (callNow) func.apply(context, args);
    };
}

/*
 * function to check if selected market is allowed for current user
 */
function getDefaultMarket() {
    'use strict';
    var mkt = Defaults.get('market');
    var markets = Symbols.markets(1);
    if (!mkt || !markets[mkt] || !markets[mkt].is_active) {
        var sorted_markets = Object.keys(Symbols.markets()).filter(function(v){return markets[v].is_active;}).sort(function(a, b) {
            return getMarketsOrder(a) - getMarketsOrder(b);
        });
        mkt = sorted_markets[0];
    }
    return mkt;
}

// Order
function getMarketsOrder(market) {
    var order = {
        'forex': 1,
        'volidx': 2,
        'indices': 3,
        'stocks': 4,
        'commodities': 5
    };
    return order[market] ? order[market] : 100;
}

/*
 * this is invoked when submit button is clicked and prevents reloading of page
 */
function addEventListenerForm(){
    'use strict';
    document.getElementById('websocket_form').addEventListener("submit", function(evt){
        evt.currentTarget.classList.add('submitted');
        evt.preventDefault();
        return false;
    }, false);
}

/*
 * this creates a button, clicks it, and destroys it to invoke the listener
 */
function submitForm(form) {
    'use strict';
    var button = form.ownerDocument.createElement('input');
    button.style.display = 'none';
    button.type = 'submit';
    form.appendChild(button).click();
    form.removeChild(button);
}

/*
 * function to display indicative barrier
 */
function displayIndicativeBarrier() {
    'use strict';
    var unit = document.getElementById('duration_units'),
        currentTick = Tick.quote(),
        indicativeBarrierTooltip = document.getElementById('indicative_barrier_tooltip'),
        indicativeHighBarrierTooltip = document.getElementById('indicative_high_barrier_tooltip'),
        indicativeLowBarrierTooltip = document.getElementById('indicative_low_barrier_tooltip'),
        barrierElement = document.getElementById('barrier'),
        highBarrierElement = document.getElementById('barrier_high'),
        lowBarrierElement = document.getElementById('barrier_low');

    if (unit && unit.value !== 'd' && currentTick && !isNaN(currentTick)) {
        var decimalPlaces = countDecimalPlaces(currentTick);
        if (indicativeBarrierTooltip && isVisible(indicativeBarrierTooltip)) {
            var barrierValue = isNaN(parseFloat(barrierElement.value))?0:parseFloat(barrierElement.value);
            indicativeBarrierTooltip.textContent = (parseFloat(currentTick) + barrierValue).toFixed(decimalPlaces);
        }

        if (indicativeHighBarrierTooltip && isVisible(indicativeHighBarrierTooltip)) {
            indicativeHighBarrierTooltip.textContent = (parseFloat(currentTick) + parseFloat(highBarrierElement.value)).toFixed(decimalPlaces);
        }

        if (indicativeLowBarrierTooltip && isVisible(indicativeLowBarrierTooltip)) {
            indicativeLowBarrierTooltip.textContent = (parseFloat(currentTick) + parseFloat(lowBarrierElement.value)).toFixed(decimalPlaces);
        }
    } else {
        indicativeBarrierTooltip.textContent = '';
        indicativeHighBarrierTooltip.textContent = '';
        indicativeLowBarrierTooltip.textContent = '';
    }
}

/*
 * function to sort the duration in ascending order
 */
function durationOrder(duration){
    'use strict';
    var order = {
        t:1,
        s:2,
        m:3,
        h:4,
        d:5
    };
    return order[duration];
}

function marketOrder(market){
    'use strict';
    var order = {
        forex: 0,
        major_pairs: 1,
        minor_pairs: 2,
        smart_fx: 3,
        indices: 4,
        asia_oceania: 5,
        europe_africa: 6,
        americas: 7,
        stocks: 8,
        france: 9,
        belgium: 10,
        amsterdam: 11,
        commodities: 12,
        metals: 13,
        energy: 14,
        volidx: 15,
        random_index: 16,
        random_daily: 17,
        random_nightly: 18
    };
    return order[market];
}

function marketSort(a,b){
    if(marketOrder(a) > marketOrder(b)){
        return 1;
    }
    else if(marketOrder(a) < marketOrder(b)){
        return -1;
    }
    else{
        return 0;
    }
}

function displayTooltip(market, symbol){
    'use strict';
    var tip = document.getElementById('symbol_tip'),
        guide = document.getElementById('guideBtn'),
        app = document.getElementById('androidApp');
    if (market.match(/^volidx/) || symbol.match(/^R/) || market.match(/^random_index/) || market.match(/^random_daily/)){
        tip.show();
        tip.setAttribute('target','/get-started/volidx-markets');
        app.show();
    } else {
      app.hide();
      tip.hide();
    }

    if (market.match(/^random_index/) || symbol.match(/^R_/)){
        tip.setAttribute('target','/get-started/volidx-markets#volidx-indices');
    }
    if (market.match(/^random_daily/) || symbol.match(/^RDB/) || symbol.match(/^RDMO/) || symbol.match(/^RDS/)){
        tip.setAttribute('target','/get-started/volidx-markets#volidx-quotidians');
    }
    if (market.match(/^smart_fx/) || symbol.match(/^WLD/)){
        tip.show();
        tip.setAttribute('target','/smart-indices#world-fx-indices');
    }
}

/*
 * count number of decimal places in spot so that we can make barrier to same decimal places
 */
function countDecimalPlaces(num) {
    'use strict';
    if (!isNaN(num)) {
        var str = num.toString();
        if (str.indexOf('.') !== -1) {
            return str.split('.')[1].length;
        } else {
            return 0;
        }
    }
}

function selectOption(option, select){
    var options = select.getElementsByTagName('option');
    var contains = 0;
    for(var i = 0; i < options.length; i++){
        if(options[i].value==option && !options[i].hasAttribute('disabled')){
            contains = 1;
            break;
        }
    }
    if(contains){
        select.value = option;
        return true;
    }
    else{
        return false;
    }
}

function updatePurchaseStatus(final_price, pnl, contract_status){
    $('#contract_purchase_heading').text(text.localize(contract_status));
    $payout = $('#contract_purchase_payout');
    $cost = $('#contract_purchase_cost');
    $profit = $('#contract_purchase_profit');

    $payout.html(Content.localize().textBuyPrice + '<p>'+addComma(Math.abs(pnl))+'</p>');
    $cost.html(Content.localize().textFinalPrice + '<p>'+addComma(final_price)+'</p>');
    if(!final_price){
        $profit.html(Content.localize().textLoss + '<p>'+addComma(pnl)+'</p>');
    }
    else{
        $profit.html(Content.localize().textProfit + '<p>'+addComma(Math.round((final_price-pnl)*100)/100)+'</p>');
    }
}

function updateWarmChart(){
    var $chart = $('#trading_worm_chart');
    var spots =  Object.keys(Tick.spots()).sort(function(a,b){return a-b;}).map(function(v){return Tick.spots()[v];});
    var chart_config = {
        type: 'line',
        lineColor: '#606060',
        fillColor: false,
        spotColor: '#00f000',
        minSpotColor: '#f00000',
        maxSpotColor: '#0000f0',
        highlightSpotColor: '#ffff00',
        highlightLineColor: '#000000',
        spotRadius: 1.25
    };
    if($chart){
        $chart.sparkline(spots, chart_config);
        if(spots.length){
            $chart.show();
        }
        else{
            $chart.hide();
        }
    }
}

function reloadPage(){
    Defaults.remove('market', 'underlying', 'formname',
        'date_start','expiry_type', 'expiry_date', 'expirt_time', 'duration_units', 'diration_value',
        'amount', 'amount_type', 'currency', 'stop_loss', 'stop_type', 'stop_profit', 'amount_per_point', 'prediction');
    location.reload();
}

function addComma(num){
    num = (num || 0) * 1;
    return num.toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function showHighchart(){
  Content.populate();

  // avoid rendering again if it already exists
  if(document.getElementById('trade_live_chart').hasChildNodes()) {
    return;
  }
  var div = document.createElement('div');
  div.className = 'grd-grid-12 chart_div';
  if (window.chartAllowed) {
    div.innerHTML = '<table width="600px" align="center"><tr id="highchart_duration"><td width="25%">' +
                    Content.localize().textDuration + ':</td><td width="25%"><select id="time_period"><option value="1t" selected="selected">1 ' +
                    Content.localize().textTickResultLabel.toLowerCase() + '</option><option value="1m">1 ' + text.localize("minute").toLowerCase() +
                    '</option><option value="2m">2 ' + Content.localize().textDurationMinutes.toLowerCase() + '</option><option value="3m">3 ' +
                    Content.localize().textDurationMinutes.toLowerCase() +'</option><option value="5m">5 ' + Content.localize().textDurationMinutes.toLowerCase() +
                    '</option><option value="10m">10 ' + Content.localize().textDurationMinutes.toLowerCase() + '</option><option value="15m">15 ' +
                    Content.localize().textDurationMinutes.toLowerCase() +'</option><option value="30m">30 ' + Content.localize().textDurationMinutes.toLowerCase() +
                    '</option><option value="1h">1 ' + text.localize('hour').toLowerCase() + '</option><option value="2h">2 ' +
                    Content.localize().textDurationHours.toLowerCase() +'</option><option value="4h">4 ' + Content.localize().textDurationHours.toLowerCase() +
                    '</option><option value="8h">8 ' + Content.localize().textDurationHours.toLowerCase() + '</option><option value="1d">1 ' +
                    text.localize('day').toLowerCase() +'</option></select></td></td></tr><tr align="center"><td colspan="4">' +
                    '<iframe src="" width="100%" height="630" id="chart_frame" style="overflow-y : hidden;" scrolling="no"></iframe></td></tr></table>';
    document.getElementById('trade_live_chart').appendChild(div);
    setUnderlyingTime();
  } else {
    div.innerHTML = '<p class="error-msg">' + text.localize('Chart is not available for this underlying.') + '</p>';
    document.getElementById('trade_live_chart').appendChild(div);
    return;
  }
}

function setUnderlyingTime() {
   var instrumentCode = document.getElementById('underlying'),
       contractMarkets = document.getElementById('bet_underlying'),
       highchart_time =  document.getElementById('time_period');
   highchart_time.addEventListener("change", function(){
     setUnderlyingTime();
   });
   if (instrumentCode) {
     instrumentCode.addEventListener("change", function(){
       setUnderlyingTime();
     });
     chartFrameSource(instrumentCode.value, highchart_time);
   } else if (contractMarkets) {
     contractMarkets.addEventListener("change", function(){
       setUnderlyingTime();
     });
     document.getElementById('submarket').addEventListener("change", function(){
       setUnderlyingTime();
     });
     chartFrameSource(contractMarkets.value, highchart_time);
   }
}

function chartFrameSource(underlying, highchart_time){
  document.getElementById('chart_frame').src = 'https://webtrader.binary.com?affiliates=true&instrument=' + underlying + '&timePeriod=' + highchart_time.value + '&gtm=true';
}

function isJapanTrading(){
    return $('#trading_socket_container.japan').length;
}
;var Content = (function() {
    'use strict';

    var localize = {};

    var populate = function() {
        localize = {
            textStartTime: text.localize('Start time'),
            textSpot: text.localize('Spot'),
            textBarrier: text.localize('Barrier'),
            textBarrierOffset: text.localize('Barrier offset'),
            textHighBarrier: text.localize('High barrier'),
            textHighBarrierOffset: text.localize('High barrier offset'),
            textLowBarrier: text.localize('Low barrier'),
            textLowBarrierOffset: text.localize('Low barrier offset'),
            textPayout: text.localize('Payout'),
            textStake: text.localize('Stake'),
            textPurchase: text.localize('Purchase'),
            textDuration: text.localize('Duration'),
            textEndTime: text.localize('End Time'),
            textMinDuration: text.localize('min'),
            textMinDurationTooltip: text.localize('minimum available duration'),
            textBarrierOffsetTooltip: text.localize("Enter the barrier in terms of the difference from the spot price. If you enter +0.005, then you will be purchasing a contract with a barrier 0.005 higher than the entry spot. The entry spot will be the next tick after your order has been received"),
            textDurationSeconds: text.localize('seconds'),
            textDurationMinutes: text.localize('minutes'),
            textDurationHours: text.localize('hours'),
            textDurationDays: text.localize('days'),
            textDurationTicks: text.localize('ticks'),
            textNetProfit: text.localize('Net profit'),
            textReturn: text.localize('Return'),
            textNow: text.localize('Now'),
            textContractConfirmationHeading: text.localize('Contract Confirmation'),
            textContractConfirmationReference: text.localize('Your transaction reference is'),
            textContractConfirmationBalance: text.localize('Account balance:'),
            textFormRiseFall: text.localize('Rise/Fall'),
            textFormHigherLower: text.localize('Higher/Lower'),
            textFormUpDown: text.localize('Up/Down'),
            textFormInOut: text.localize('In/Out'),
            textContractPeriod: text.localize('Period'),
            predictionLabel: text.localize('Last Digit Prediction'),
            textContractConfirmationPayout: text.localize('Potential Payout'),
            textContractConfirmationCost: text.localize('Total Cost'),
            textContractConfirmationProfit: text.localize('Potential Profit'),
            textAmountPerPoint: text.localize('Amount per point'),
            textStopLoss: text.localize('Stop-loss'),
            textStopProfit: text.localize('Stop-profit'),
            textStopType: text.localize('Stop-type'),
            textStopTypePoints: text.localize('Points'),
            textContractConfirmationButton: text.localize('View'),
            textIndicativeBarrierTooltip: text.localize('This is an indicative barrier. Actual barrier will be the entry spot plus the barrier offset.'),
            textSpreadTypeLong: text.localize('Long'),
            textSpreadTypeShort: text.localize('Short'),
            textSpreadDepositComment: text.localize('Deposit of'),
            textSpreadRequiredComment: text.localize('is required. Current spread'),
            textSpreadPointsComment: text.localize('points'),
            textContractStatusWon: text.localize('This contract won'),
            textContractStatusLost: text.localize('This contract lost'),
            textTickResultLabel: text.localize('Tick'),
            textStatement: text.localize('Statement'),
            textDate: text.localize('Date'),
            textRef: text.localize('Ref.'),
            textAction: text.localize('Action'),
            textDescription: text.localize('Description'),
            textCreditDebit: text.localize('Credit/Debit'),
            textBalance: text.localize('Balance'),
            textDetails: text.localize('Details'),
            textProfitTable: text.localize('Profit Table'),
            textPurchaseDate: text.localize('Date (GMT)'),
            textContract: text.localize('Contract'),
            textPurchasePrice: text.localize('Purchase Price'),
            textSaleDate: text.localize('Sale Date'),
            textSalePrice: text.localize('Sale Price'),
            textProfitLoss: text.localize('Profit/Loss'),
            textTotalProfitLoss: text.localize('Total Profit/Loss'),
            textLimits: text.localize('Trading and Withdrawal Limits'),
            textItem: text.localize('Item'),
            textLimit: text.localize('Limit'),
            textMaxOpenPosition: text.localize('Maximum number of open positions'),
            textMaxOpenPositionTooltip: text.localize('Represents the maximum number of outstanding contracts in your portfolio. Each line in your portfolio counts for one open position. Once the maximum is reached, you will not be able to open new positions without closing an existing position first.'),
            textMaxAccBalance: text.localize('Maximum account cash balance'),
            textMaxAccBalanceTooltip: text.localize('Represents the maximum amount of cash that you may hold in your account.  If the maximum is reached, you will be asked to withdraw funds.'),
            textMaxDailyTurnover: text.localize('Maximum daily turnover'),
            textMaxDailyTurnoverTooltip: text.localize('Represents the maximum volume of contracts that you may purchase in any given trading day.'),
            textMaxAggregate: text.localize('Maximum aggregate payouts on open positions'),
            textMaxAggregateTooltip: text.localize('Presents the maximum aggregate payouts on outstanding contracts in your portfolio. If the maximum is attained, you may not purchase additional contracts without first closing out existing positions.'),
            textTradingLimits: text.localize('Trading Limits'),
            textWithdrawalTitle: text.localize('Withdrawal Limits'),
            textAuthenticatedWithdrawal: text.localize('Your account is fully authenticated and your withdrawal limits have been lifted.'),
            textWithdrawalLimits: text.localize('Your withdrawal limit is [_1] [_2].'),
            textWithdrawalLimitsEquivalant: text.localize('Your withdrawal limit is [_1] [_2] (or equivalent in other currency).'),
            textWithrawalAmount: text.localize('You have already withdrawn [_1] [_2].'),
            textWithrawalAmountEquivalant: text.localize('You have already withdrawn the equivalent of [_1] [_2].'),
            textCurrentMaxWithdrawal: text.localize('Therefore your current immediate maximum withdrawal (subject to your account having sufficient funds) is [_1] [_2].'),
            textCurrentMaxWithdrawalEquivalant: text.localize('Therefore your current immediate maximum withdrawal (subject to your account having sufficient funds) is [_1] [_2] (or equivalent in other currency).'),
            textWithdrawalLimitsEquivalantDay: text.localize('Your [_1] day withdrawal limit is currently [_2] [_3] (or equivalent in other currency).'),
            textWithrawalAmountEquivalantDay: text.localize('You have already withdrawn the equivalent of [_1] [_2] in aggregate over the last [_3] days.'),
            textBuyPrice: text.localize('Buy price'),
            textFinalPrice: text.localize('Final price'),
            textLoss: text.localize('Loss'),
            textProfit: text.localize('Profit'),
            textFormMatchesDiffers: text.localize('Matches/Differs'),
            textFormEvenOdd: text.localize('Even/Odd'),
            textFormOverUnder: text.localize('Over/Under'),
            textMessageRequired: text.localize('This field is required.'),
            textMessageCountLimit: text.localize('You should enter between [_1] characters.'), // [_1] should be replaced by a range. sample: (6-20)
            textMessageJustAllowed: text.localize('Only [_1] are allowed.'), // [_1] should be replaced by values including: letters, numbers, space, period, ...
            textMessageValid: text.localize('Please submit a valid [_1].'), // [_1] should be replaced by values such as email address
            textLetters: text.localize('letters'),
            textNumbers: text.localize('numbers'),
            textSpace: text.localize('space'),
            textPeriod: text.localize('period'),
            textComma: text.localize('comma'),
            textHyphen: text.localize('hyphen'),
            textApost: text.localize('apostrophe'),
            textPassword: text.localize('password'),
            textPasswordsNotMatching: text.localize('The two passwords that you entered do not match.'),
            textClickHereToRestart: text.localize('Your token has expired. Please click <a class="pjaxload" href="[_1]">here</a> to restart the verification process.'),
            textAsset: text.localize('Asset'),
            textOpens: text.localize('Opens'),
            textCloses: text.localize('Closes'),
            textSettles: text.localize('Settles'),
            textUpcomingEvents: text.localize('Upcoming Events'),
            textMr: text.localize('Mr'),
            textMrs: text.localize('Mrs'),
            textMs: text.localize('Ms'),
            textMiss: text.localize('Miss'),
            textErrorBirthdate: text.localize('Please input a valid date'),
            textSelect: text.localize('Please select'),
            textUnavailableReal: text.localize('Sorry, account opening is unavailable.'),
            textMessageMinRequired: text.localize('Minimum of [_1] characters required.'),
            textFeatureUnavailable: text.localize('Sorry, this feature is not available.'),
            textExercisePrice: text.localize('Exercise price'),
            textPrices: text.localize('Prices'),
            textLots: text.localize('Lots'),
            textBuy: text.localize('Buy'),
            textSell: text.localize('Sell'),
            textCALLE: text.localize('[_1] [_2] payout if [_3] is strictly higher or equal than Exercise price at close  on [_4].'),
            textPUT: text.localize('[_1] [_2] payout if [_3] is strictly lower than Exercise price at close on [_4].'),
            textNOTOUCH: text.localize('[_1] [_2] payout if [_3] does not touch Exercise price through close on [_4].'),
            textONETOUCH: text.localize('[_1] [_2] payout if [_3] touches Exercise price through close on [_4].'),
            textEXPIRYRANGEE: text.localize('[_1] [_2] payout if [_3] ends on or between low and high values of Exercise price at close on [_4].'),
            textEXPIRYMISS: text.localize('[_1] [_2] payout if [_3] ends otside low and high values of Exercise price at close on [_4].'),
            textRANGE: text.localize('[_1] [_2] payout if [_3] stays between low and high values of Exercise price through close on [_4].'),
            textUPORDOWN: text.localize('[_1] [_2] payout if [_3] goes ouside of low and high values of Exercise price through close on [_4].'),
            textBuyPriceUnit: text.localize('BUY price per unit'),
            textSellPriceUnit: text.localize('SELL price  per unit'),
            textUnits: text.localize('Units'),
            textMessagePasswordScore: text.localize( 'Password score is: [_1]. Passing score is: 20.'),
            textShouldNotLessThan: text.localize('Please enter a number greater or equal to [_1].'),
            textNumberLimit: text.localize('Please enter a number between [_1].')       // [_1] should be a range
        };

        var starTime = document.getElementById('start_time_label');
        if (starTime) {
            starTime.textContent = localize.textStartTime;
        }

        var minDurationTooltip = document.getElementById('duration_tooltip');
        if (minDurationTooltip) {
            minDurationTooltip.textContent = localize.textMinDuration;
            minDurationTooltip.setAttribute('title', localize.textMinDurationTooltip);
        }

        var spotLabel = document.getElementById('spot_label');
        if (spotLabel) {
            spotLabel.textContent = localize.textSpot;
        }

        var barrierTooltip = document.getElementById('barrier_tooltip');
        if (barrierTooltip) {
            barrierTooltip.textContent = localize.textBarrierOffset;
            barrierTooltip.setAttribute('title', localize.textBarrierOffsetTooltip);
        }

        var barrierSpan = document.getElementById('barrier_span');
        if (barrierSpan) {
            barrierSpan.textContent = localize.textBarrier;
        }

        var barrierHighTooltip = document.getElementById('barrier_high_tooltip');
        if (barrierHighTooltip) {
            barrierHighTooltip.textContent = localize.textHighBarrierOffset;
            barrierHighTooltip.setAttribute('title', localize.textBarrierOffsetTooltip);
        }
        var barrierHighSpan = document.getElementById('barrier_high_span');
        if (barrierHighSpan) {
            barrierHighSpan.textContent = localize.textHighBarrier;
        }

        var barrierLowTooltip = document.getElementById('barrier_low_tooltip');
        if (barrierLowTooltip) {
            barrierLowTooltip.textContent = localize.textLowBarrierOffset;
            barrierLowTooltip.setAttribute('title', localize.textBarrierOffsetTooltip);
        }
        var barrierLowSpan = document.getElementById('barrier_low_span');
        if (barrierLowSpan) {
            barrierLowSpan.textContent = localize.textLowBarrier;
        }

        var predictionLabel = document.getElementById('prediction_label');
        if (predictionLabel) {
            predictionLabel.textContent = localize.predictionLabel;
        }

        var payoutOption = document.getElementById('payout_option');
        if (payoutOption) {
            payoutOption.textContent = localize.textPayout;
        }

        var japanUnit = document.getElementById('japan_unit_label');
        if (japanUnit) {
            japanUnit.textContent = localize.textUnits;
        }

        var japanPayout = document.getElementById('japan_payout_label');
        if (japanPayout) {
            japanPayout.textContent = localize.textPayout;
        }

        var stakeOption = document.getElementById('stake_option');
        if (stakeOption) {
            stakeOption.textContent = localize.textStake;
        }

        var purchaseButtonTop = document.getElementById('purchase_button_top');
        if (purchaseButtonTop) {
            purchaseButtonTop.textContent = localize.textPurchase;
        }

        var purchaseButtonBottom = document.getElementById('purchase_button_bottom');
        if (purchaseButtonBottom) {
            purchaseButtonBottom.textContent = localize.textPurchase;
        }

        var period_label = document.getElementById('period_label');
        if (period_label) {
            period_label.textContent = localize.textContractPeriod;
        }

        var amount_per_point_label = document.getElementById('amount_per_point_label');
        if (amount_per_point_label) {
            amount_per_point_label.textContent = localize.textAmountPerPoint;
        }

        var stop_loss_label = document.getElementById('stop_loss_label');
        if (stop_loss_label) {
            stop_loss_label.textContent = localize.textStopLoss;
        }

        var stop_profit_label = document.getElementById('stop_profit_label');
        if (stop_profit_label) {
            stop_profit_label.textContent = localize.textStopProfit;
        }

        var stop_type_label = document.getElementById('stop_type_label');
        if (stop_type_label) {
            stop_type_label.textContent = localize.textStopType;
        }

        var stop_type_points = document.getElementById('stop_type_points_label');
        if (stop_type_points) {
            stop_type_points.textContent = localize.textStopTypePoints;
        }

        var indicative_barrier_tooltip = document.getElementById('indicative_barrier_tooltip');
        if (indicative_barrier_tooltip) {
            indicative_barrier_tooltip.setAttribute('title', localize.textIndicativeBarrierTooltip);
        }

        var indicative_high_barrier_tooltip = document.getElementById('indicative_high_barrier_tooltip');
        if (indicative_high_barrier_tooltip) {
            indicative_high_barrier_tooltip.setAttribute('title', localize.textIndicativeBarrierTooltip);
        }

        var indicative_low_barrier_tooltip = document.getElementById('indicative_low_barrier_tooltip');
        if (indicative_low_barrier_tooltip) {
            indicative_low_barrier_tooltip.setAttribute('title', localize.textIndicativeBarrierTooltip);
        }

        var jpbarrier_label = document.getElementById('jbarrier_label');
        if (jpbarrier_label) {
            jpbarrier_label.textContent = localize.textExercisePrice;
        }

        var jpbarrier_high_label = document.getElementById('jbarrier_high_label');
        if (jpbarrier_high_label) {
            jpbarrier_high_label.textContent = localize.textHighBarrier;
        }

        var jpbarrier_low_label = document.getElementById('jbarrier_low_label');
        if (jpbarrier_low_label) {
            jpbarrier_low_label.textContent = localize.textLowBarrier;
        }
    };

    var statementTranslation = function() {
        var titleElement = document.getElementById("statement-title").firstElementChild;
        titleElement.textContent = localize.textStatement;
    };

    var profitTableTranslation = function() {
        var titleElement = document.getElementById("profit-table-title").firstElementChild;
        titleElement.textContent = localize.textProfitTable;
    };

    var limitsTranslation = function() {
        var titleElement = document.getElementById("limits-ws-container").firstElementChild;
        titleElement.textContent = localize.textLimits;

        if (page.client.is_logged_in && !page.client.is_virtual()) {
            var loginId = page.client.loginid;

            var tradingLimits = document.getElementById("trading-limits");
            tradingLimits.textContent = loginId + " - " + localize.textTradingLimits;

            var withdrawalTitle = document.getElementById("withdrawal-title");
            withdrawalTitle.textContent = loginId + " - " + localize.textWithdrawalTitle;
        }
    };

    var errorMessage = function(messageType, param) {
        var msg = "",
            separator = ', ';
        switch (messageType) {
            case 'req':
                msg = localize.textMessageRequired;
                break;
            case 'reg':
                if (param)
                    msg = localize.textMessageJustAllowed.replace('[_1]', param.join(separator));
                break;
            case 'range':
                if (param)
                    msg = localize.textMessageCountLimit.replace('[_1]', param);
                break;
            case 'valid':
                if (param)
                    msg = localize.textMessageValid.replace('[_1]', param);
                break;
            case 'min':
                if (param)
                    msg = localize.textMessageMinRequired.replace('[_1]', param);
                break;
            case 'pass':
                if (param)
                    msg = localize.textMessagePasswordScore.replace('[_1]', param);
                break;
            case 'number_not_less_than':
                msg = localize.textShouldNotLessThan.replace('[_1]', param);
                break;
            case 'number_should_between':
                msg = localize.textNumberLimit.replace('[_1]', param);
                break;
            default:
                break;
        }
        return msg;
    };

    return {
        localize: function() {
            return localize;
        },
        populate: populate,
        statementTranslation: statementTranslation,
        profitTableTranslation: profitTableTranslation,
        limitsTranslation: limitsTranslation,
        errorMessage: errorMessage
    };

})();
;/*
 * Contract object mocks the trading form we have on our website
 * It parses the contracts json we get from socket.send({contracts_for: 'R_50'})
 * and gives back barriers, startDate, durations etc
 *
 *
 * Usage:
 *
 * use `Contract.details` to populate this object
 *
 * then use
 *
 * `Contract.durations()` to get durations like seconds, hours etc
 * `Contract.open()` `Contract.close()`
 * `Contract.barriers` if applicable for current underlying
 */
var Contract = (function() {
    'use strict';

    var contractDetails = {},
        durations = {},
        startDates = {},
        barriers = {},
        contractType = {},
        open, close, form, barrier;

    var populate_durations = function(currentContract) {
        var currentCategory = currentContract['contract_category'];
        if (!durations[currentContract['expiry_type']]) {
            durations[currentContract['expiry_type']] = {};
        }

        if (!durations[currentContract['expiry_type']][currentCategory]) {
            durations[currentContract['expiry_type']][currentCategory] = {};
        }

        if (!durations[currentContract['expiry_type']][currentCategory][currentContract['barrier_category']]) {
            durations[currentContract['expiry_type']][currentCategory][currentContract['barrier_category']] = {};
        }

        if (!durations[currentContract['expiry_type']][currentCategory][currentContract['barrier_category']][currentContract['start_type']]) {
            durations[currentContract['expiry_type']][currentCategory][currentContract['barrier_category']][currentContract['start_type']] = {};
        }

        durations[currentContract['expiry_type']][currentCategory][currentContract['barrier_category']][currentContract['start_type']]['max_contract_duration'] = currentContract['max_contract_duration'];

        durations[currentContract['expiry_type']][currentCategory][currentContract['barrier_category']][currentContract['start_type']]['min_contract_duration'] = currentContract['min_contract_duration'];
    };

    var details = function(formName) {
        var contracts = Contract.contracts()['contracts_for'],
            contractCategories = {},
            barrierCategory;

        startDates = { has_spot: 0, list: [] };
        durations = {};
        open = contracts['open'];
        close = contracts['close'];

        var formBarrier = getFormNameBarrierCategory(formName);
        form = formName = formBarrier['formName'];
        barrier = barrierCategory = formBarrier['barrierCategory'];

        contracts.available.forEach(function(currentObj) {
            var contractCategory = currentObj['contract_category'];

            if (formName && formName === contractCategory) {
                if (barrierCategory) {
                    if (barrierCategory === currentObj['barrier_category']) {
                        populate_durations(currentObj);
                    }
                } else {
                    populate_durations(currentObj);
                }

                if (currentObj.forward_starting_options && currentObj['start_type'] === 'forward' && sessionStorage.formname !== 'higherlower') {
                    startDates.list = currentObj.forward_starting_options;
                } else if (currentObj.start_type === 'spot') {
                    startDates.has_spot = 1;
                }

                var symbol = currentObj['underlying_symbol'];
                if (currentObj.barrier_category && currentObj.barrier_category !== "non_financial") {
                    if (!barriers.hasOwnProperty(symbol)) {
                        barriers[symbol] = {};
                    }
                    if (currentObj.barriers === 1) {
                        barriers[symbol][contractCategory] = {
                            count: 1,
                            barrier: currentObj['barrier'],
                            barrier_category: currentObj['barrier_category']
                        };
                    } else if (currentObj.barriers === 2) {
                        barriers[symbol][contractCategory] = {
                            count: 2,
                            barrier: currentObj['high_barrier'],
                            barrier1: currentObj['low_barrier'],
                            barrier_category: currentObj['barrier_category']
                        };
                    }
                }

                if (!contractType[contractCategory]) {
                    contractType[contractCategory] = {};
                }

                if (!contractType[contractCategory].hasOwnProperty(currentObj['contract_type'])) {
                    contractType[contractCategory][currentObj['contract_type']] = text.localize(currentObj['contract_display']);
                }
            }
        });

        if (formName && barrierCategory) {
            if (barriers && barriers[formName] && barriers[formName]['barrier_category'] !== barrierCategory) {
                barriers = {};
            }
        }
    };

    var getContracts = function(underlying) {
        BinarySocket.send({ contracts_for: underlying });
    };

    var getContractForms = function() {
        var contracts = Contract.contracts()['contracts_for'],
            tradeContractForms = {};

        contracts.available.forEach(function(currentObj) {
            var contractCategory = currentObj['contract_category'];
            if (contractCategory && !tradeContractForms.hasOwnProperty(contractCategory)) {
                if (contractCategory === 'callput') {
                    if (currentObj['barrier_category'] === 'euro_atm') {
                        tradeContractForms['risefall'] = Content.localize().textFormRiseFall;
                    } else {
                        tradeContractForms['higherlower'] = Content.localize().textFormHigherLower;
                    }
                } else {
                    tradeContractForms[contractCategory] = text.localize(currentObj['contract_category_display']);
                    if (contractCategory === 'digits') {
                        tradeContractForms['matchdiff'] = Content.localize().textFormMatchesDiffers;
                        if (page.language() !== 'ID') {
                          tradeContractForms['evenodd'] = Content.localize().textFormEvenOdd;
                          tradeContractForms['overunder'] = Content.localize().textFormOverUnder;
                        }
                    }
                }
            }
        });

        if (tradeContractForms.risefall || tradeContractForms.higherlower) {
            tradeContractForms['updown'] = Content.localize().textFormUpDown;
        }

        if (tradeContractForms.endsinout || tradeContractForms.staysinout) {
            tradeContractForms['inout'] = Content.localize().textFormInOut;
        }

        return tradeContractForms;
    };

    return {
        details: details,
        getContracts: getContracts,
        contractForms: getContractForms,
        open: function() {
            return open; },
        close: function() {
            return close; },
        contracts: function() {
            return contractDetails; },
        durations: function() {
            return durations; },
        startDates: function() {
            return startDates; },
        barriers: function() {
            return barriers; },
        contractType: function() {
            return contractType; },
        form: function() {
            return form; },
        barrier: function() {
            return barrier; },
        setContracts: function(data) {
            contractDetails = data;
        }
    };

})();
;/*
 * Handles currency display
 *
 * It process 'socket.send({payout_currencies:1})` response
 * and display them
 */
function displayCurrencies(selected) {
    'use strict';

    var target = document.getElementById('currency'),
        fragment =  document.createDocumentFragment(),
        currencies = page.client.get_storage_value('currencies').split(',');

    if (!target) {
        return;
    }

    while (target && target.firstChild) {
        target.removeChild(target.firstChild);
    }

    currencies.forEach(function (currency) {
        var option = document.createElement('option'),
            content = document.createTextNode(currency);

        option.setAttribute('value', currency);
        if (selected && selected == key) {
            option.setAttribute('selected', 'selected');
        }

        option.appendChild(content);
        fragment.appendChild(option);
    });

    target.appendChild(fragment);
    Defaults.set('currency', target.value);
}
;/*
 * Handles trading page default values
 * 
 * Priorities:
 * 1. Client's input: on each change to form, it will reflect to both query string & session storage
 * 2. Query string parameters: will change session storage values
 * 3. Session storage values: if none of the above, it will be the source
 *
 */

var Defaults = (function(){
    'use strict';

    var params = {};
    var getDefault = function(key) {
        var pValue = params[key] || page.url.param(key),
            sValue = sessionStorage.getItem(key);
        if(pValue && (!sValue || pValue != sValue)) {
            sessionStorage.setItem(key, pValue);
        }
        if(!pValue && sValue) {
            setDefault(key, sValue);
        }
        return pValue || sValue;
    };

    var setDefault = function(key, value) {
        if(key) {
            value = value || '';
            if(Object.keys(params).length === 0) params = page.url.params_hash();
            if(params[key] != value) {
                params[key] = value;
                // to increase speed, do not set values when form is still loading
                if(!isVisible(document.getElementById('trading_init_progress'))) {
                    sessionStorage.setItem(key, value);
                    updateURL();
                }
            }
        }
    };

    var removeDefault = function() {
        if(Object.keys(params).length === 0) params = page.url.params_hash();
        var isUpdated = false;
        for (var i = 0; i < arguments.length; i++) {
            if(params.hasOwnProperty(arguments[i])) {
                sessionStorage.removeItem(arguments[i]);
                delete(params[arguments[i]]);
                isUpdated = true;
            }
        }
        if(isUpdated) {
            updateURL();
        }
    };

    var updateAll = function() {
        for(var key in params)
            if (params.hasOwnProperty(key)) {
                sessionStorage.setItem(key, params[key]);
            }
        updateURL();
    };

    var updateURL = function() {
        window.history.replaceState(null, null, window.location.pathname + '?' + page.url.params_hash_to_string(params));
    };

    return {
        get   : getDefault,
        set   : setDefault,
        update: updateAll,
        remove: removeDefault,
        clear : function(){params = {};}
    };
})();
;/*
 * Handles duration processing display
 *
 * It process `Contract.durations()` and display them according to
 * the current `Contract.form()` and `Contract.barriers()`
 *
 * It also populate expiry type select box i.e Durations and Endtime select
 *
 */

var Durations = (function(){
    'use strict';

    var trading_times = {};
    var selected_duration = {};
    var expiry_time = '';
    var has_end_date = 0;

    var displayDurations = function() {
        var startType;
        if(Defaults.get('date_start') !== 'now' && StartDates.displayed() && moment(Defaults.get('date_start')*1000).isAfter(moment())) {
            startType = 'forward';
        }
        else {
            startType = 'spot';
        }

        var durations = Contract.durations();
        if (durations === false) {
            document.getElementById('expiry_row').style.display = 'none';
            Defaults.remove('expiry_type', 'duration_amount', 'duration_units', 'expiry_date', 'expiry_time');
            return false;
        }

        var target = document.getElementById('duration_units'),
            formName = Contract.form(),
            barrierCategory = Contract.barrier(),
            fragment = document.createDocumentFragment(), durationContainer = {};

        while (target && target.firstChild) {
            target.removeChild(target.firstChild);
        }

        for (var key in durations) {
            if (durations.hasOwnProperty(key)) {
                for (var form in durations[key][formName]) {
                    if (durations[key][formName].hasOwnProperty(form)) {
                        var obj = {};
                        if (barrierCategory) {
                            obj = durations[key][formName][barrierCategory];
                        } else {
                            obj = durations[key][formName][form];
                        }
                        for (var type in obj) {
                            if (obj.hasOwnProperty(type)) {
                                if (startType) {
                                    if (startType === type) {
                                        if(!durationContainer.hasOwnProperty(startType)) {
                                            durationContainer[key] = obj[startType];
                                        }
                                    }
                                } else {
                                    if(!durationContainer.hasOwnProperty(type)) {
                                        durationContainer[key] = obj[type];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        var duration_list = {};
        for (var duration in durationContainer) {
            if(durationContainer.hasOwnProperty(duration)) {
                var min = durationContainer[duration]['min_contract_duration'],
                    textMapping = durationTextValueMappings(min);

                var option, content;
                if (duration === 'intraday') {
                    switch (textMapping['value']) {
                        case 's':
                            option = document.createElement('option');
                            content = document.createTextNode(textMapping['text']);
                            option.setAttribute('value', textMapping['value']);
                            option.setAttribute('data-minimum', textMapping['min']);
                            option.appendChild(content);
                            duration_list[textMapping['value']]=option;
                            option = document.createElement('option');
                            content = document.createTextNode(Content.localize().textDurationMinutes);
                            option.setAttribute('value', 'm');
                            option.setAttribute('data-minimum', 1);
                            option.setAttribute('selected', 'selected');
                            option.appendChild(content);
                            duration_list['m']=option;
                            option = document.createElement('option');
                            content = document.createTextNode(Content.localize().textDurationHours);
                            option.setAttribute('value', 'h');
                            option.setAttribute('data-minimum', 1);
                            option.appendChild(content);
                            duration_list['h']=option;
                            break;
                        case 'm':
                            option = document.createElement('option');
                            content = document.createTextNode(textMapping['text']);
                            option.setAttribute('value', textMapping['value']);
                            option.setAttribute('data-minimum', textMapping['min']);
                            option.setAttribute('selected', 'selected');
                            option.appendChild(content);
                            duration_list[textMapping['value']]=option;
                            option = document.createElement('option');
                            content = document.createTextNode(Content.localize().textDurationHours);
                            option.setAttribute('value', 'h');
                            option.setAttribute('data-minimum', 1);
                            option.appendChild(content);
                            duration_list['h']=option;
                            break;
                        case 'h':
                            option = document.createElement('option');
                            content = document.createTextNode(textMapping['text']);
                            option.setAttribute('value', textMapping['value']);
                            option.setAttribute('data-minimum', textMapping['min']);
                            option.appendChild(content);
                            duration_list[textMapping['value']]=option;
                            break;
                        default :
                            option = document.createElement('option');
                            content = document.createTextNode(textMapping['text']);
                            option.setAttribute('value', textMapping['value']);
                            option.setAttribute('data-minimum', textMapping['min']);
                            option.appendChild(content);
                            duration_list[textMapping['value']]=option;
                            break;
                    }
                } else if (duration === 'daily') {
                    option = document.createElement('option');
                    content = document.createTextNode(textMapping['text']);
                    option.setAttribute('value', textMapping['value']);
                    option.setAttribute('data-minimum', textMapping['min']);
                    option.appendChild(content);
                    duration_list[textMapping['value']]=option;
                } else if (duration === 'tick') {
                    option = document.createElement('option');
                    content = document.createTextNode(textMapping['text']);
                    option.setAttribute('value', textMapping['value']);
                    option.setAttribute('data-minimum', textMapping['min']);
                    option.appendChild(content);
                    duration_list[textMapping['value']]=option;
                }
            }
        }
        var list = Object.keys(duration_list).sort(function(a,b){
            if(durationOrder(a)>durationOrder(b)){
                return 1;
            }
            else{
                return -1;
            }
        });
        has_end_date = 0;
        for(var k=0; k<list.length; k++){
            var d = list[k];
            if(d!=='t'){
                has_end_date = 1;
            }
            if(duration_list.hasOwnProperty(d)){
                target.appendChild(duration_list[d]);
            }
        }

        if(selected_duration.unit){
            if(!selectOption(selected_duration.unit,target)){
                selected_duration = {};
            }
        }

        durationPopulate();
    };

    var displayEndTime = function(){
        var current_moment = moment().add(5, 'minutes').utc();
        var expiry_date = Defaults.get('expiry_date') || current_moment.format('YYYY-MM-DD'),
            expiry_time = Defaults.get('expiry_time') || current_moment.format('HH:mm');
        document.getElementById('expiry_date').value = expiry_date;
        document.getElementById('expiry_time').value = expiry_time;
        Defaults.set('expiry_date', expiry_date);
        Defaults.set('expiry_time', expiry_time);
        Durations.setTime(expiry_time);

        durationPopulate();
    };

    var durationTextValueMappings = function(str) {
        var mapping = {
            s : Content.localize().textDurationSeconds,
            m : Content.localize().textDurationMinutes,
            h : Content.localize().textDurationHours,
            d : Content.localize().textDurationDays,
            t : Content.localize().textDurationTicks
        };

        var arry = str ? str.toString().match(/[a-zA-Z]+|[0-9]+/g) : [],
            obj = {};

        if (arry.length > 1) {
            obj['value'] = arry[1];
            obj['text'] = mapping[arry[1]];
            obj['min'] = arry[0];
        } else {
            obj['value'] = 't';
            obj['text'] = mapping['t'];
            obj['min'] = arry[0];
        }

        return obj;
    };

    var durationPopulate = function() {
        var unit = document.getElementById('duration_units');
        var unitMinValue = unit.options[unit.selectedIndex].getAttribute('data-minimum'),
            unitValue = Defaults.get('duration_amount') || unitMinValue;
        unit.value = Defaults.get('duration_units') &&
            document.querySelectorAll('select[id="duration_units"] [value="' + Defaults.get('duration_units') + '"]').length ?
                Defaults.get('duration_units') : unit.value;
        document.getElementById('duration_minimum').textContent = unitMinValue;
        if(selected_duration.amount && selected_duration.unit > unitValue){
            unitValue = selected_duration.amount;
        }
        document.getElementById('duration_amount').value = unitValue;
        Defaults.set('duration_amount', unitValue);
        displayExpiryType(unit.value);
        Defaults.set('duration_units', unit.value);

        // jquery for datepicker
        var amountElement = $('#duration_amount');
        if (unit.value === 'd') {
            var tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);

            amountElement.datepicker({
                minDate: tomorrow,
                onSelect: function(value) {
                    var dayDiff;
                    if($('#duration_amount').val()){
                        dayDiff = $('#duration_amount').val();
                    }
                    else{
                        var date = new Date(value);
                        var today = new Date();
                        dayDiff = Math.ceil((date - today) / (1000 * 60 * 60 * 24));
                    }                    
                    amountElement.val(dayDiff);
                    amountElement.trigger('change');
                }
            });
        } else {
            amountElement.datepicker("destroy");
        }

        // we need to call it here as for days we need to show absolute barriers
        Barriers.display();
    };

    var displayExpiryType = function(unit) {
        var target = document.getElementById('expiry_type'),
            fragment = document.createDocumentFragment();

        // in case of having endtime as expiry_type and change the form to contract types
        // which only have duration and do not support endtime, it should change the Default value
        // to get corrected based on contract situations
        if($('#expiry_type').find('option[value=' + Defaults.get('expiry_type') + ']').length === 0 && target.value) {
                Defaults.set('expiry_type', target.value);
        }
        var current_selected = Defaults.get('expiry_type') || target.value || 'duration',
            id = current_selected,
            hideId = (current_selected === 'duration') ? 'endtime' : 'duration';

        id = document.getElementById('expiry_type_' + id);
        if (id) {
            id.style.display = 'flex';
        }
        // need to hide the non selected one
        hideId = document.getElementById('expiry_type_' + hideId);
        if (hideId) {
            hideId.style.display = 'none';
        }

        while (target && target.firstChild) {
            target.removeChild(target.firstChild);
        }

        var option = document.createElement('option'),
            content = document.createTextNode(Content.localize().textDuration);

        option.setAttribute('value', 'duration');
        if (current_selected === 'duration') {
            option.setAttribute('selected', 'selected');
        }
        option.appendChild(content);
        fragment.appendChild(option);

        if (has_end_date) {
            option = document.createElement('option');
            content = document.createTextNode(Content.localize().textEndTime);
            option.setAttribute('value', 'endtime');
            if (current_selected === 'endtime') {
                option.setAttribute('selected', 'selected');
            }
            option.appendChild(content);
            fragment.appendChild(option);
        }
        target.appendChild(fragment);
    };

    var processTradingTimesAnswer = function(response){
        if(!trading_times.hasOwnProperty(response.echo_req.trading_times) && response.hasOwnProperty('trading_times') && response.trading_times.hasOwnProperty('markets')){
            for(var i=0; i<response.trading_times.markets.length; i++){
                var submarkets = response.trading_times.markets[i].submarkets;
                if(submarkets){
                    for(var j=0; j<submarkets.length; j++){
                        var symbols = submarkets[j].symbols;
                        if(symbols){
                            for(var k=0; k<symbols.length; k++){
                                var symbol = symbols[k];
                                if(!trading_times[response.echo_req.trading_times]){
                                    trading_times[response.echo_req.trading_times] = {};
                                }
                                trading_times[response.echo_req.trading_times][symbol.symbol] = symbol.times.close;
                            }
                        }
                    }
                }
            }
        }
    };

    var selectEndDate = function(end_date){
        var expiry_time = document.getElementById('expiry_time');
        $('#expiry_date').val(end_date);
        Defaults.set('expiry_date', end_date);
        if(moment(end_date).isAfter(moment(),'day')){
            Durations.setTime('');
            Defaults.remove('expiry_time');
            StartDates.setNow();
            expiry_time.hide();
            var date_start = StartDates.node();
            processTradingTimesRequest(end_date);
        }
        else{
            Durations.setTime(expiry_time.value);
            Defaults.set('expiry_time', Defaults.get('expiry_time') || expiry_time.value);
            expiry_time.show();
            processPriceRequest();
        }

        Barriers.display();
    };

    return {
        display: displayDurations,
        displayEndTime: displayEndTime,
        populate: durationPopulate,
        setTime: function(time){ $('#expiry_time').val(time); Defaults.set('expiry_time', time); expiry_time = time; },
        getTime: function(){ return expiry_time; },
        processTradingTimesAnswer: processTradingTimesAnswer,
        trading_times: function(){ return trading_times; },
        select_amount: function(a){ selected_duration.amount = a; },
        select_unit: function(u){ selected_duration.unit = u; } ,
        selectEndDate: selectEndDate       
    };
})();

;/*
 * TradingEvents object contains all the event handler function required for
 * websocket trading page
 *
 * We need it as object so that we can call TradingEvent.init() only on trading
 * page for pjax to work else it will fire on all pages
 *
 */
var TradingEvents = (function () {
    'use strict';

    var onStartDateChange = function(value){
        var $dateStartSelect = $('#date_start');
        if(!value || !$dateStartSelect.find('option[value='+value+']').length){
            return 0;
        }

        var yellowBorder = 'light-yellow-background';
        if (value !== 'now') {
            $dateStartSelect.addClass(yellowBorder);
        } else {
            $dateStartSelect.removeClass(yellowBorder);
        }

        $dateStartSelect.val(value);

        var make_price_request = 1;
        if (value !== 'now' && $('expiry_type').val() === 'endtime') {
            make_price_request = -1;
            var end_time = moment(value*1000).utc().add(15,'minutes');
            Durations.setTime(Defaults.get('expiry_time') || end_time.format("hh:mm"));
            Durations.selectEndDate(Defaults.get('expiry_date') || end_time.format("YYYY-MM-DD"));
        }
        Durations.display();
        return make_price_request;
    };

    var onExpiryTypeChange = function(value){
        if(!value || !$('#expiry_type').find('option[value='+value+']').length){
            value = 'duration';
        }
        $('#expiry_type').val(value);

        var make_price_request = 0;
        if(value === 'endtime'){
            Durations.displayEndTime();
            if(Defaults.get('expiry_date')){
                Durations.selectEndDate(Defaults.get('expiry_date'));
                make_price_request = -1;
            }
            Defaults.remove('duration_units', 'duration_amount');
        }
        else{
            Durations.display();
            if(Defaults.get('duration_units')){
                TradingEvents.onDurationUnitChange(Defaults.get('duration_units'));
            }
            var duration_amount = Defaults.get('duration_amount');
            if(duration_amount && duration_amount > $('#duration_minimum').text()){
                $('#duration_amount').val(duration_amount);
            }
            make_price_request = 1;
            Defaults.remove('expiry_date', 'expiry_time', 'end_date');
        }

        return make_price_request;
    };

    var onDurationUnitChange = function(value){
        if(!value || !$('#duration_units').find('option[value='+value+']').length){
            return 0;
        }

        $('#duration_units').val(value);
        Defaults.set('duration_units', value);

        Durations.select_unit(value);
        Durations.populate();

        return 1;
    };

    var initiate = function () {
        /*
         * attach event to market list, so when client change market we need to update undelryings
         * and request for new Contract details to populate the form and request price accordingly
         */
        var marketNavElement = document.getElementById('contract_markets');
        var onMarketChange = function(market){
            showPriceOverlay();
            Defaults.set('market', market);

            // as different markets have different forms so remove from sessionStorage
            // it will default to proper one
            Defaults.remove('formname');
            Defaults.remove('underlying');
            processMarket(1);
        };

        if (marketNavElement) {
            marketNavElement.addEventListener('change', function(e) {
                var clickedMarket = e.target;
                onMarketChange(clickedMarket.value);
            });
        }

        /*
         * attach event to form list, so when client click on different form we need to update form
         * and request for new Contract details to populate the form and request price accordingly
         */
        var contractFormEventChange = function () {
            processContractForm();
            TradingAnalysis.request();
        };

        var formNavElement = document.getElementById('contract_form_name_nav');
        if (formNavElement) {
            formNavElement.addEventListener('click', function(e) {
                if (e.target && e.target.getAttribute('menuitem')) {
                    var clickedForm = e.target;
                    var isFormActive = clickedForm.classList.contains('active');
                    Defaults.set('formname', clickedForm.getAttribute('menuitem'));

                    setFormPlaceholderContent();
                    // if form is already active then no need to send same request again
                    toggleActiveCatMenuElement(formNavElement, e.target.getAttribute('menuitem'));

                    if (!isFormActive) {
                        contractFormEventChange();
                    }
                    var contractFormCheckbox = document.getElementById('contract_form_show_menu');
                    if (contractFormCheckbox) {
                        contractFormCheckbox.checked = false;
                    }
                }
            });
        }

        /*
         * attach event to underlying change, event need to request new contract details and price
         */
        var underlyingElement = document.getElementById('underlying');
        if (underlyingElement) {
            underlyingElement.addEventListener('change', function(e) {
                if (e.target) {
                    showFormOverlay();
                    showPriceOverlay();
                    if(e.target.selectedIndex < 0) {
                        e.target.selectedIndex = 0;
                    }
                    var underlying = e.target.value;
                    Defaults.remove('barrier', 'barrier_high', 'barrier_low');
                    Defaults.set('underlying', underlying);
                    TradingAnalysis.request();

                    Tick.clean();

                    updateWarmChart();

                    Contract.getContracts(underlying);

                    // forget the old tick id i.e. close the old tick stream
                    processForgetTicks();
                    // get ticks for current underlying
                    Tick.request(underlying);
                    displayTooltip('', underlying);
                }
            });
            underlyingElement.addEventListener('mousedown', function(e) {
                Symbols.getSymbols(0);
            });
        }

        /*
         * bind event to change in duration amount, request new price
         */
        function triggerOnDurationChange(e){
            if (e.target.value % 1 !== 0 ) {
                e.target.value = Math.floor(e.target.value);
            }
            Defaults.set('duration_amount', e.target.value);
            Durations.select_amount(e.target.value);
            processPriceRequest();
            submitForm(document.getElementById('websocket_form'));
        }
        var durationAmountElement = document.getElementById('duration_amount'),
            inputEventTriggered = false;          // For triggering one of the two events.
        if (durationAmountElement) {
            durationAmountElement.addEventListener('keypress', onlyNumericOnKeypress);
            // jquery needed for datepicker
            $('#duration_amount').on('input', debounce(function (e) {
                triggerOnDurationChange(e);
                inputEventTriggered = true;
            }));
            $('#duration_amount').on('change', debounce(function (e) {
                // using Defaults, to update the value by datepicker if it was emptied by keyboard (delete)
                if(inputEventTriggered === false || !Defaults.get('duration_amount'))
                    triggerOnDurationChange(e);
                else
                    inputEventTriggered = false;
            }));
        }

        /*
         * attach event to expiry time change, event need to populate duration
         * and request new price
         */
        var expiryTypeElement = document.getElementById('expiry_type');
        if (expiryTypeElement) {
            expiryTypeElement.addEventListener('change', function(e) {
                Defaults.set('expiry_type', e.target.value);
                onExpiryTypeChange(e.target.value);
                processPriceRequest();
            });
        }

        /*
         * bind event to change in duration units, populate duration and request price
         */
        var durationUnitElement = document.getElementById('duration_units');
        if (durationUnitElement) {
            durationUnitElement.addEventListener('change', function (e) {
                Defaults.remove('barrier', 'barrier_high', 'barrier_low');
                onDurationUnitChange(e.target.value);
                processPriceRequest();
            });
        }

        /*
         * bind event to change in endtime date and time
         */
        var endDateElement = document.getElementById('expiry_date');
        if (endDateElement) {
            // need to use jquery as datepicker is used, if we switch to some other
            // datepicker we can move back to javascript
            $('#expiry_date').on('change input', function () {
                Durations.selectEndDate(this.value);
            });
        }

        var endTimeElement = document.getElementById('expiry_time');
        if (endTimeElement) {
            $('#expiry_time').on('change input', function () {
                Durations.setTime(endTimeElement.value);
                processPriceRequest();
            });
        }

        /*
         * attach event to change in amount, request new price only
         */
        var amountElement = document.getElementById('amount');
        if (amountElement) {
            amountElement.addEventListener('keypress', onlyNumericOnKeypress);

            amountElement.addEventListener('input', debounce( function(e) {
                e.target.value = e.target.value.replace(/[^0-9.]/g, '');
                if (isStandardFloat(e.target.value)) {
                    e.target.value = parseFloat(e.target.value).toFixed(2);
                }
                Defaults.set('amount', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach event to start time, display duration based on
         * whether start time is forward starting or not and request
         * new price
         */
        var dateStartElement = StartDates.node();
        if (dateStartElement) {
            dateStartElement.addEventListener('change', function (e) {
                Defaults.set('date_start', e.target.value);
                var r = onStartDateChange(e.target.value);
                if(r>=0){
                    processPriceRequest();
                }
            });
        }

        /*
         * attach event to change in amount type that is whether its
         * payout or stake and request new price
         */
        var amountTypeElement = document.getElementById('amount_type');
        if (amountTypeElement) {
            amountTypeElement.addEventListener('change', function (e) {
                Defaults.set('amount_type', e.target.value);
                processPriceRequest();
            });
        }

        /*
         * attach event to change in submarkets. We need to disable
         * underlyings that are not in selected seubmarkets
         */
        var submarketElement = document.getElementById('submarket');
        if (submarketElement) {
            submarketElement.addEventListener('change', function (e) {
                if (e.target) {
                    var elem = document.getElementById('underlying');
                    var underlyings = elem.children;

                    for (var i = 0, len = underlyings.length; i < len; i++ ) {
                        if (e.target.value !== 'all' && e.target.value !== underlyings[i].className) {
                            underlyings[i].disabled = true;
                        } else {
                            underlyings[i].disabled = false;
                        }
                    }

                    // as submarket change has modified the underlying list so we need to manually
                    // fire change event for underlying
                    document.querySelectorAll('#underlying option:enabled')[0].selected = 'selected';
                    var event = new Event('change');
                    elem.dispatchEvent(event);
                }
            });
        }

        /*
         * attach an event to change in currency
         */
        var currencyElement = document.getElementById('currency');
        if (currencyElement) {
            currencyElement.addEventListener('change', function (e) {
                Defaults.set('currency', e.target.value);
                var stopTypeDollarLabel = document.getElementById('stop_type_dollar_label');
                if (stopTypeDollarLabel && isVisible(stopTypeDollarLabel)) {
                    stopTypeDollarLabel.textContent = e.target.value;
                }
                processPriceRequest();
            });
        }

        /*
         * attach event to purchase buttons to buy the current contract
         */
        // using function expression form here as it used inside for loop
        var purchaseContractEvent = function () {
            var id = this.getAttribute('data-purchase-id'),
                askPrice = this.getAttribute('data-ask-price');

            var params = {buy: id, price: askPrice, passthrough:{}};
            for(var attr in this.attributes){
                if(attr && this.attributes[attr] && this.attributes[attr].name){
                    var m = this.attributes[attr].name.match(/data\-(.+)/);

                    if(m && m[1] && m[1]!=="purchase-id" && m[1]!=="passthrough"){
                        params.passthrough[m[1]] = this.attributes[attr].value;
                    }
                }
            }
            if (id && askPrice) {
                BinarySocket.send(params);
                Price.incrFormId();
                processForgetProposals();
            }
        };

        var purchaseButtonElements = document.getElementsByClassName('purchase_button');
        if (purchaseButtonElements) {
            for (var j = 0, l = purchaseButtonElements.length; j < l; j++) {
                purchaseButtonElements[j].addEventListener('click', purchaseContractEvent);
            }
        }

        /*
         * attach event to close icon for purchase container
         */
        var closeContainerElement = document.getElementById('close_confirmation_container');
        if (closeContainerElement) {
            closeContainerElement.addEventListener('click', function (e) {
                if (e.target) {
                    e.preventDefault();
                    document.getElementById('contract_confirmation_container').style.display = 'none';
                    document.getElementById('contracts_list').style.display = 'flex';
                    processPriceRequest();
                }
            });
        }

        /*
         * attach an event to change in barrier
         */
        var barrierElement = document.getElementById('barrier');
        if (barrierElement) {
            barrierElement.addEventListener('input', debounce( function (e) {
                Defaults.set('barrier', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach an event to change in low barrier
         */
        var lowBarrierElement = document.getElementById('barrier_low');
        if (lowBarrierElement) {
            lowBarrierElement.addEventListener('input', debounce( function (e) {
                Defaults.set('barrier_low', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach an event to change in high barrier
         */
        var highBarrierElement = document.getElementById('barrier_high');
        if (highBarrierElement) {
            highBarrierElement.addEventListener('input', debounce( function (e) {
                Defaults.set('barrier_high', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach an event to change in digit prediction input
         */
        var predictionElement = document.getElementById('prediction');
        if (predictionElement) {

            predictionElement.addEventListener('change', debounce( function (e) {
                Defaults.set('prediction', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach an event to change in amount per point for spreads
         */
        var amountPerPointElement = document.getElementById('amount_per_point');
        if (amountPerPointElement) {
            amountPerPointElement.addEventListener('input', debounce( function (e) {
                if (isStandardFloat(e.target.value)) {
                    e.target.value = parseFloat(e.target.value).toFixed(2);
                }
                Defaults.set('amount_per_point', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach an event to change in stop type for spreads
         */
        var stopTypeEvent = function (e) {
            Defaults.set('stop_type', e.target.value);
            processPriceRequest();
        };

        var stopTypeElement = document.querySelectorAll('input[name="stop_type"]');
        if (stopTypeElement) {
            for (var i = 0, len = stopTypeElement.length; i < len; i++) {
                stopTypeElement[i].addEventListener('click', stopTypeEvent);
            }
        }

        /*
         * attach an event to change in stop loss input value
         */
        var stopLossElement = document.getElementById('stop_loss');
        if (stopLossElement) {
            stopLossElement.addEventListener('input', debounce( function (e) {
                if (isStandardFloat(e.target.value)) {
                    e.target.value = parseFloat(e.target.value).toFixed(2);
                }
                Defaults.set('stop_loss', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        /*
         * attach an event to change in stop profit input value
         */
        var stopProfitElement = document.getElementById('stop_profit');
        if (stopProfitElement) {
            stopProfitElement.addEventListener('input', debounce( function (e) {
                if (isStandardFloat(e.target.value)) {
                    e.target.value = parseFloat(e.target.value).toFixed(2);
                }
                Defaults.set('stop_profit', e.target.value);
                processPriceRequest();
                submitForm(document.getElementById('websocket_form'));
            }));
        }

        // For verifying there are 2 digits after decimal
        var isStandardFloat = (function(value){
            return (value % 1 !== 0 && ((+parseFloat(value)).toFixed(10)).replace(/^-?\d*\.?|0+$/g, '').length>2);
        });

        var jhighBarrierElement = document.getElementById('jbarrier_high');
        if (jhighBarrierElement) {
            jhighBarrierElement.addEventListener('change', function (e) {
                processPriceRequest();
            });
        }


        var jlowBarrierElement = document.getElementById('jbarrier_low');
        if (jlowBarrierElement) {
            jlowBarrierElement.addEventListener('change', function (e) {
                var options = jhighBarrierElement.getElementsByTagName('option');
                var f = 0;
                if(jhighBarrierElement.value > jlowBarrierElement.value){
                    f = 1;
                }
                for(var i=0; i<options.length; i++){
                    option = options[i];

                    if(option.value <= jlowBarrierElement.value){
                        option.setAttribute('disabled', true);
                    }
                else{
                    if(!f){
                        jhighBarrierElement.value = option.value;
                        f=1;
                    }
                    option.removeAttribute('disabled');
                }
                }
                processPriceRequest();
            });
        }

        var jbarrierElement = document.getElementById('jbarrier');
        if (jbarrierElement) {
            jbarrierElement.addEventListener('change', function (e) {
                processPriceRequest();
            });
        }

        var period = document.getElementById('period');
        if(period){
            period.addEventListener('change', function (e) {
                Periods.displayBarriers();
                processPricingTableRequest();
                // processPriceRequest();
                var japan_info = TradingAnalysis.japan_info();
                if(japan_info && TradingAnalysis.getActiveTab() === 'tab_japan_info'){
                    japan_info.show();
                }
            });
        }

        if(isJapanTrading()){
            var amount_type = document.getElementById('amount_type');
            var options = amount_type.getElementsByTagName('option');
            for(var d=0; d<options.length; d++){
                if(options[d].value!='payout'){
                    options[d].setAttribute('disabled', true);
                }
            }
        }

        var init_logo = document.getElementById('trading_init_progress');
        if(init_logo){
            init_logo.addEventListener('click', debounce( function (e) {
                reloadPage();
            }));
        }

        var tip = document.getElementById('symbol_tip');
        if(init_logo){
            tip.addEventListener('click', debounce( function (e) {
                var url = e.target.getAttribute('target');
                load_with_pjax(url);
            }));
        }

        var $japanUnit = $('#japan_unit');
        var japanState = PricingTable.getState();
        $japanUnit.keyup(function(e){
            var value = Math.abs(parseInt(e.target.value, 10)) || 1;
            japanState.units = value;
            $('#japan_payout').text('¥'+ parseInt(value)*1000);
        });

        /*
         * attach datepicker and timepicker to end time durations
         * have to use jquery
         */
        $(".pickadate").datepicker({
            minDate: new Date(),
            dateFormat: "yy-mm-dd"
        });
        var date = new Date();
        $(".pickatime" ).timepicker({minTime:{hour: date.getUTCHours(), minute: date.getUTCMinutes()}});
    };

    return {
        init: initiate,
        onStartDateChange: onStartDateChange,
        onExpiryTypeChange: onExpiryTypeChange,
        onDurationUnitChange: onDurationUnitChange
    };
})();
;/*
 * This Message object process the response from server and fire
 * events based on type of response
 */
var Message = (function () {
    'use strict';

    var process = function (msg) {
        var response = JSON.parse(msg.data);
        if(!TradePage.is_trading_page()){
            forgetTradingStreams();
            return;
        }
        if (response) {
            var type = response.msg_type;
            if (type === 'active_symbols') {
                processActiveSymbols(response);
            } else if (type === 'contracts_for') {
                processContract(response);
                window.contracts_for = response;
            } else if (type === 'payout_currencies') {
                page.client.set_storage_value('currencies', response.payout_currencies);
                displayCurrencies();
                Symbols.getSymbols(1);
            } else if (type === 'proposal') {
                processProposal(response);
            } else if (type === 'buy') {
                if(isJapanTrading()){
                    PricingTable.processBuy(response);
                }
                Purchase.display(response);
            } else if (type === 'tick') {
                processTick(response);
            } else if (type === 'history') {
                var digit_info = TradingAnalysis.digit_info();
                if(response.req_id === 1 || response.req_id === 2){
                    digit_info.show_chart(response.echo_req.ticks_history, response.history.prices);
                } else
                    Tick.processHistory(response);
            } else if (type === 'trading_times'){
                processTradingTimes(response);
            } else if (type === 'statement'){
                StatementWS.statementHandler(response);
            } else if (type === 'profit_table'){
                ProfitTableWS.profitTableHandler(response);
            } else if (type === 'pricing_table'){
                PricingTable.handleResponse(response);
            } else if (type === 'error') {
                $(".error-msg").text(response.error.message);
            } else if(type === 'balance'){
                PortfolioWS.updateBalance(response);
            } else if(type === 'portfolio'){
                PortfolioWS.updatePortfolio(response);
            } else if(type === 'proposal_open_contract'){
                PortfolioWS.updateIndicative(response);
            } else if(type === 'transaction'){
                PortfolioWS.transactionResponseHandler(response);
            }
        } else {

            console.log('some error occured');
        }
    };

    return {
        process: process
    };

})();
;/*
 * Price object handles all the functions we need to display prices
 *
 * We create Price proposal that we need to send to server to get price,
 * longcode and all other information that we need to get the price for
 * current contract
 *
 *
 * Usage:
 *
 * `socket.send(Price.createProposal())` to send price proposal to sever
 * `Price.display()` to display the price details returned from server
 */
var Price = (function() {
    'use strict';

    var typeDisplayIdMapping = {},
        form_id = 0;

    var createProposal = function(typeOfContract) {
        var proposal = {
                proposal: 1,
                subscribe: 1
            },
            underlying = document.getElementById('underlying'),
            submarket = document.getElementById('submarket'),
            contractType = typeOfContract,
            amountType = document.getElementById('amount_type'),
            currency = document.getElementById('currency'),
            payout = document.getElementById('amount'),
            startTime = StartDates.node(),
            expiryType = document.getElementById('expiry_type'),
            duration = document.getElementById('duration_amount'),
            durationUnit = document.getElementById('duration_units'),
            endDate = document.getElementById('expiry_date'),
            endTime = document.getElementById('expiry_time'),
            barrier = document.getElementById('barrier'),
            highBarrier = document.getElementById('barrier_high'),
            lowBarrier = document.getElementById('barrier_low'),
            prediction = document.getElementById('prediction'),
            amountPerPoint = document.getElementById('amount_per_point'),
            stopType = document.querySelector('input[name="stop_type"]:checked'),
            stopLoss = document.getElementById('stop_loss'),
            stopProfit = document.getElementById('stop_profit');

        if (payout && isVisible(payout) && payout.value) {
            proposal['amount'] = parseFloat(payout.value);
        }

        if (amountType && isVisible(amountType) && amountType.value) {
            proposal['basis'] = amountType.value;
        }

        if (contractType) {
            proposal['contract_type'] = typeOfContract;
        }

        if (currency && currency.value) {
            proposal['currency'] = currency.value;
        }

        if (underlying && underlying.value) {
            proposal['symbol'] = underlying.value;
        }

        if (startTime && isVisible(startTime) && startTime.value !== 'now') {
            proposal['date_start'] = startTime.value;
        }

        if (expiryType && isVisible(expiryType) && expiryType.value === 'duration') {
            proposal['duration'] = parseInt(duration.value);
            proposal['duration_unit'] = durationUnit.value;
        } else if (expiryType && isVisible(expiryType) && expiryType.value === 'endtime') {
            var endDate2 = endDate.value;
            var endTime2 = Durations.getTime();
            if (!endTime2) {
                var trading_times = Durations.trading_times();
                if (trading_times.hasOwnProperty(endDate2) && typeof trading_times[endDate2][underlying.value] === 'object' && trading_times[endDate2][underlying.value].length && trading_times[endDate2][underlying.value][0] !== '--') {
                    if( trading_times[endDate2][underlying.value].length>1)
                        endTime2 = trading_times[endDate2][underlying.value][1];
                    else
                         endTime2=trading_times[endDate2][underlying.value];
                }
            }

            proposal['date_expiry'] = moment.utc(endDate2 + " " + endTime2).unix();
            // For stopping tick trade behaviour
            proposal['duration_unit'] = "m";
        }

        if (barrier && isVisible(barrier) && barrier.value) {
            proposal['barrier'] = barrier.value;
        }

        if (highBarrier && isVisible(highBarrier) && highBarrier.value) {
            proposal['barrier'] = highBarrier.value;
        }

        if (lowBarrier && isVisible(lowBarrier) && lowBarrier.value) {
            proposal['barrier2'] = lowBarrier.value;
        }

        if (prediction && isVisible(prediction)) {
            proposal['barrier'] = parseInt(prediction.value);
        }

        if (amountPerPoint && isVisible(amountPerPoint)) {
            proposal['amount_per_point'] = parseFloat(amountPerPoint.value);
        }

        if (stopType && isVisible(stopType)) {
            proposal['stop_type'] = stopType.value;
        }

        if (stopLoss && isVisible(stopLoss)) {
            proposal['stop_loss'] = parseFloat(stopLoss.value);
        }

        if (stopProfit && isVisible(stopProfit)) {
            proposal['stop_profit'] = parseFloat(stopProfit.value);
        }

        if (contractType) {
            proposal['contract_type'] = typeOfContract;
        }

        proposal['passthrough'] = {
            form_id: form_id
        };

        resetPriceMovement();

        return proposal;
    };

    var display = function(details, contractType) {
        var proposal = details['proposal'];
        var id = proposal ? proposal['id'] : '';
        var params = details['echo_req'];

        var type = params['contract_type'];
        if (id && !type) {
            type = typeDisplayIdMapping[id];
        }

        var is_spread = false;
        if (params.contract_type && (params.contract_type === 'SPREADU' || params.contract_type === 'SPREADD')) {
            is_spread = true;
        }

        if (params && id && Object.getOwnPropertyNames(params).length > 0) {
            typeDisplayIdMapping[id] = type;
        }

        var position = contractTypeDisplayMapping(type);

        if (!position) {
            return;
        }

        var container = document.getElementById('price_container_' + position);
        if (!$(container).is(":visible")) {
            $(container).fadeIn(200);
        }

        var h4 = container.getElementsByClassName('contract_heading')[0],
            amount = container.getElementsByClassName('contract_amount')[0],
            purchase = container.getElementsByClassName('purchase_button')[0],
            description = container.getElementsByClassName('contract_description')[0],
            comment = container.getElementsByClassName('price_comment')[0],
            error = container.getElementsByClassName('contract_error')[0],
            amount_wrapper = container.getElementsByClassName('amount_wrapper')[0],
            price_wrapper = container.getElementsByClassName('price_wrapper')[0],
            currency = document.getElementById('currency');

        var display = type ? (contractType ? contractType[type] : '') : '';
        if (display) {
            h4.setAttribute('class', 'contract_heading ' + type);
            if (is_spread) {
                if (position === "top") {
                    h4.textContent = Content.localize().textSpreadTypeLong;
                } else {
                    h4.textContent = Content.localize().textSpreadTypeShort;
                }
            } else {
                h4.textContent = display;
            }
        }

        if (details['error']) {
            purchase.hide();
            comment.hide();
            var extraInfo = details['error']['details'];
            if (extraInfo && extraInfo['display_value']) {
                if (is_spread) {
                    amount.textContent = extraInfo['display_value'];
                } else {
                    amount.textContent = currency.value + ' ' + extraInfo['display_value'];
                }

                extraInfo['longcode'] = extraInfo['longcode'].replace(/[\d\,]+\.\d\d/, function(x) {
                    return '<b>' + x + '</b>';
                });

                description.innerHTML = '<div>' + extraInfo['longcode'] + '</div>';
                price_wrapper.classList.remove('small');
            } else {
                description.innerHTML = "";
                amount_wrapper.hide();
                price_wrapper.classList.add('small');
            }

            error.show();
            error.textContent = details['error']['message'];
        } else {
            if (proposal && proposal['display_value']) {
                if (is_spread) {
                    amount.textContent = proposal['display_value'];
                } else {
                    amount.textContent = currency.value + ' ' + proposal['display_value'];
                }
            }

            if (proposal && proposal['longcode']) {
                proposal['longcode'] = proposal['longcode'].replace(/[\d\,]+\.\d\d/, function(x) {
                    return '<b>' + x + '</b>';
                });
                description.innerHTML = '<div>' + proposal['longcode'] + '</div>';
            }

            purchase.show();
            comment.show();
            amount_wrapper.show();
            price_wrapper.classList.remove('small');
            error.hide();
            if (is_spread) {
                displayCommentSpreads(comment, currency.value, proposal['spread']);
            } else {
                displayCommentPrice(comment, currency.value, proposal['ask_price'], proposal['payout']);
            }
            var oldprice = purchase.getAttribute('data-display_value');
            displayPriceMovement(amount, oldprice, proposal['display_value']);
            purchase.setAttribute('data-purchase-id', id);
            purchase.setAttribute('data-ask-price', proposal['ask_price']);
            purchase.setAttribute('data-display_value', proposal['display_value']);
            purchase.setAttribute('data-symbol', id);
            for (var key in params) {
                if (key && key !== 'proposal') {
                    purchase.setAttribute('data-' + key, params[key]);
                }
            }
        }
    };

    var clearMapping = function() {
        typeDisplayIdMapping = {};
    };

    var clearFormId = function() {
        form_id = 0;
    };

    return {
        proposal: createProposal,
        display: display,
        clearMapping: clearMapping,
        idDisplayMapping: function() {
            return typeDisplayIdMapping;
        },
        getFormId: function() {
            return form_id;
        },
        incrFormId: function() {
            form_id++;
        },
        clearFormId: clearFormId
    };

})();
;/*
 * This function process the active symbols to get markets
 * and underlying list
 */
function processActiveSymbols(data) {
    'use strict';

    // populate the Symbols object
    Symbols.details(data);

    var market = getDefaultMarket();

    // store the market
    Defaults.set('market', market);

    displayMarkets('contract_markets', Symbols.markets(), market);
    processMarket();
    // setTimeout(function(){
    // if(document.getElementById('underlying')){
    //     Symbols.getSymbols(0);
    // }
    // }, 60*1000);
}


/*
 * Function to call when market has changed
 */
function processMarket(flag) {
    'use strict';

    // we can get market from sessionStorage as allowed market
    // is already set when this function is called
    var market = Defaults.get('market');
    var symbol = Defaults.get('underlying');
    var update_page = Symbols.need_page_update() || flag;

    // change to default market if query string contains an invalid market
    if(!market || !Symbols.underlyings()[market]) {
        market = getDefaultMarket();
        Defaults.set('market', market);
    }
    if (update_page && (!symbol || !Symbols.underlyings()[market][symbol] || !Symbols.underlyings()[market][symbol].is_active)) {
        symbol = undefined;
    }
    displayUnderlyings('underlying', Symbols.underlyings()[market], symbol);

    if (update_page) {
        processMarketUnderlying();
    }
}

/*
 * Function to call when underlying has changed
 */
function processMarketUnderlying() {
    'use strict';

    var underlyingElement = document.getElementById('underlying');
    if (!underlyingElement) {
        return;
    }

    if(underlyingElement.selectedIndex < 0) {
        underlyingElement.selectedIndex = 0;
    }
    var underlying = underlyingElement.value;
    Defaults.set('underlying', underlying);

    showFormOverlay();

    // forget the old tick id i.e. close the old tick stream
    processForgetTicks();
    // get ticks for current underlying
    Tick.request(underlying);

    Tick.clean();

    updateWarmChart();

    BinarySocket.clearTimeouts();

    Contract.getContracts(underlying);

    displayTooltip(Defaults.get('market'), underlying);
}

/*
 * Function to display contract form for current underlying
 */
function processContract(contracts) {
    'use strict';
    if(contracts.hasOwnProperty('error') && contracts.error.code === 'InvalidSymbol') {
        processForgetProposals();
        var container = document.getElementById('contract_confirmation_container'),
            message_container = document.getElementById('confirmation_message'),
            confirmation_error = document.getElementById('confirmation_error'),
            contracts_list = document.getElementById('contracts_list');
        container.style.display = 'block';
        contracts_list.style.display = 'none';
        message_container.hide();
        confirmation_error.show();
        confirmation_error.innerHTML = contracts.error.message + ' <a href="javascript:;" onclick="TradePage.reload();">' + text.localize('Please reload the page') + '</a>';
        return;
    }

    window.chartAllowed = true;
    if (contracts.contracts_for && contracts.contracts_for.feed_license && contracts.contracts_for.feed_license === 'chartonly') {
      window.chartAllowed = false;
    }

    document.getElementById('trading_socket_container').classList.add('show');
    var init_logo = document.getElementById('trading_init_progress');
    if(init_logo.style.display !== 'none') {
        init_logo.style.display = 'none';
        Defaults.update();
    }

    Contract.setContracts(contracts);

    var contract_categories = Contract.contractForms();
    var formname;
    if (Defaults.get('formname') && contract_categories[Defaults.get('formname')]) {
        formname = Defaults.get('formname');
    } else {
        var tree = getContractCategoryTree(contract_categories);
        if (tree[0]) {
            if (typeof tree[0] === 'object') {
                formname = tree[0][1][0];
            } else {
                formname = tree[0];
            }
        }
    }

    // set form to session storage
    Defaults.set('formname', formname);

    // change the form placeholder content as per current form (used for mobile menu)
    setFormPlaceholderContent(formname);

    displayContractForms('contract_form_name_nav', contract_categories, formname);

    processContractForm();

    TradingAnalysis.request();

    hideFormOverlay();
}

function processContractForm() {
    Contract.details(sessionStorage.getItem('formname'));

    StartDates.display();

    displayPrediction();

    displaySpreads();

    var r1;
    if (StartDates.displayed() && Defaults.get('date_start') && Defaults.get('date_start') !== 'now') {
        r1 = TradingEvents.onStartDateChange(Defaults.get('date_start'));
        if (!r1 || Defaults.get('expiry_type') === 'endtime') Durations.display();
    } else {
        Durations.display();
    }

    if (Defaults.get('amount')) $('#amount').val(Defaults.get('amount'));
        else Defaults.set('amount', document.getElementById('amount').value);
    if (Defaults.get('amount_type')) selectOption(Defaults.get('amount_type'), document.getElementById('amount_type'));
        else Defaults.set('amount_type', document.getElementById('amount_type').value);
    if (Defaults.get('currency')) selectOption(Defaults.get('currency'), document.getElementById('currency'));

    var expiry_type = Defaults.get('expiry_type') || 'duration';
    var make_price_request = TradingEvents.onExpiryTypeChange(expiry_type);

    if (make_price_request >= 0) {
        processPriceRequest();
    }

    if(Defaults.get('formname') === 'spreads') {
        Defaults.remove('expiry_type', 'duration_amount', 'duration_units', 'expiry_date', 'expiry_time', 'amount', 'amount_type');
    } else {
        Defaults.remove('amount_per_point', 'stop_type', 'stop_loss', 'stop_profit');
    }
}

function displayPrediction() {
    var predictionElement = document.getElementById('prediction_row');
    if (Contract.form() === 'digits' && sessionStorage.getItem('formname') !== 'evenodd') {
        predictionElement.show();
        if (Defaults.get('prediction')) {
            selectOption(Defaults.get('prediction'), document.getElementById('prediction'));
        }
        else {
            Defaults.set('prediction', document.getElementById('prediction').value);
        }
    } else {
        predictionElement.hide();
        Defaults.remove('prediction');
    }
}

function displaySpreads() {
    var amountType = document.getElementById('amount_type'),
        amountPerPointLabel = document.getElementById('amount_per_point_label'),
        amount = document.getElementById('amount'),
        amountPerPoint = document.getElementById('amount_per_point'),
        spreadContainer = document.getElementById('spread_element_container'),
        stopTypeDollarLabel = document.getElementById('stop_type_dollar_label'),
        expiryTypeRow = document.getElementById('expiry_row');

    if (sessionStorage.getItem('formname') === 'spreads') {
        amountType.hide();
        amount.hide();
        expiryTypeRow.hide();
        amountPerPointLabel.show();
        amountPerPoint.show();
        spreadContainer.show();
        stopTypeDollarLabel.textContent = document.getElementById('currency').value;
        if (Defaults.get('stop_type')) {
            var el = document.querySelectorAll('input[name="stop_type"][value="' + Defaults.get('stop_type') + '"]');
            if (el) {
                el[0].setAttribute('checked', 'checked');
            }
        } else {
            Defaults.set('stop_type', document.getElementById('stop_type_points').checked ? 'point' : 'dollar');
        }
        if (Defaults.get('amount_per_point')) amountPerPoint.value = Defaults.get('amount_per_point');
            else Defaults.set('amount_per_point', amountPerPoint.value);
        if (Defaults.get('stop_loss')) document.getElementById('stop_loss').value = Defaults.get('stop_loss');
            else Defaults.set('stop_loss', document.getElementById('stop_loss').value);
        if (Defaults.get('stop_profit')) document.getElementById('stop_profit').value = Defaults.get('stop_profit');
            else Defaults.set('stop_profit', document.getElementById('stop_profit').value);
    } else {
        amountPerPointLabel.hide();
        amountPerPoint.hide();
        spreadContainer.hide();
        expiryTypeRow.show();
        amountType.show();
        amount.show();
    }
}

function forgetTradingStreams() {
    processForgetProposals();
    processForgetTicks();
}
/*
 * Function to request for cancelling the current price proposal
 */
function processForgetProposals() {
    'use strict';
    showPriceOverlay();
    BinarySocket.send({
        forget_all: "proposal"
    });
    Price.clearMapping();
}

/*
 * Function to process and calculate price based on current form
 * parameters or change in form parameters
 */
function processPriceRequest() {
    'use strict';

    Price.incrFormId();
    processForgetProposals();
    showPriceOverlay();
    var types = Contract.contractType()[Contract.form()];
    if (Contract.form() === 'digits') {
        switch (sessionStorage.getItem('formname')) {
            case 'matchdiff':
                types = {
                    'DIGITMATCH': 1,
                    'DIGITDIFF': 1
                };
                break;
            case 'evenodd':
                types = {
                    'DIGITEVEN': 1,
                    'DIGITODD': 1
                };
                break;
            case 'overunder':
                types = {
                    'DIGITOVER': 1,
                    'DIGITUNDER': 1
                };
        }
    }
    for (var typeOfContract in types) {
        if (types.hasOwnProperty(typeOfContract)) {
            BinarySocket.send(Price.proposal(typeOfContract));
        }
    }
}

/*
 * Function to cancel the current tick stream
 * this need to be invoked before makin
 */
function processForgetTicks() {
    'use strict';
    BinarySocket.send({
        forget_all: 'ticks'
    });
}

/*
 * Function to process ticks stream
 */
function processTick(tick) {
    'use strict';
    var symbol = sessionStorage.getItem('underlying');
    var digit_info = TradingAnalysis.digit_info();
    if(tick.echo_req.ticks === symbol || (tick.tick && tick.tick.symbol === symbol)){
        Tick.details(tick);
        Tick.display();
        if (digit_info && tick.tick) {
            digit_info.update_chart(tick);
        }
        WSTickDisplay.updateChart(tick);
        Purchase.update_spot_list(tick);
        if (!Barriers.isBarrierUpdated()) {
            Barriers.display();
            Barriers.setBarrierUpdate(true);
        }
        updateWarmChart();
    } else {
        if(digit_info)
            digit_info.update_chart(tick);
    }
}

function processProposal(response) {
    'use strict';
    var form_id = Price.getFormId();
    if(response.echo_req.passthrough.form_id===form_id){
        hideOverlayContainer();
        Price.display(response, Contract.contractType()[Contract.form()]);
        hidePriceOverlay();
    }
}

function processTradingTimesRequest(date) {
    var trading_times = Durations.trading_times();
    if (trading_times.hasOwnProperty(date)) {
        processPriceRequest();
    } else {
        showPriceOverlay();
        BinarySocket.send({
            trading_times: date
        });
    }
}

function processTradingTimes(response) {
    Durations.processTradingTimesAnswer(response);

    processPriceRequest();
}
;/*
 * Purchase object that handles all the functions related to
 * contract purchase response
 */

var Purchase = (function () {
    'use strict';

    var purchase_data = {};

    var display = function (details) {
        purchase_data = details;

        var receipt = details['buy'],
            passthrough = details['echo_req']['passthrough'],
            container = document.getElementById('contract_confirmation_container'),
            message_container = document.getElementById('confirmation_message'),
            heading = document.getElementById('contract_purchase_heading'),
            descr = document.getElementById('contract_purchase_descr'),
            reference = document.getElementById('contract_purchase_reference'),
            chart = document.getElementById('tick_chart'),
            balance = document.getElementById('contract_purchase_balance'),
            payout = document.getElementById('contract_purchase_payout'),
            cost = document.getElementById('contract_purchase_cost'),
            profit = document.getElementById('contract_purchase_profit'),
            spots = document.getElementById('contract_purchase_spots'),
            confirmation_error = document.getElementById('confirmation_error'),
            contracts_list = document.getElementById('contracts_list'),
            button = document.getElementById('contract_purchase_button');

        var error = details['error'];
        var show_chart = !error && passthrough['duration']<=10 && passthrough['duration_unit']==='t' && (sessionStorage.formname === 'risefall' || sessionStorage.formname === 'higherlower' || sessionStorage.formname === 'asian');

        contracts_list.style.display = 'none';

        if (error) {
            container.style.display = 'block';
            message_container.hide();
            confirmation_error.show();
            confirmation_error.innerHTML = (/ClientUnwelcome/.test(error.code) ? error['message'] + '<a href="' + page.url.url_for('cashier/authenticatews') + '"> ' + text.localize('Authorise your account.' + '</a>') : error['message']);
        } else {
            var guideBtn = document.getElementById('guideBtn');
            if(guideBtn) {
                guideBtn.style.display = 'none';
            }
            container.style.display = 'table-row';
            message_container.show();
            confirmation_error.hide();

            heading.textContent = Content.localize().textContractConfirmationHeading;
            descr.textContent = receipt['longcode'];
            reference.textContent = Content.localize().textContractConfirmationReference + ' ' + receipt['transaction_id'];

            var payout_value, cost_value, profit_value;

            if(passthrough['basis'] === "payout"){
                payout_value = passthrough['amount'];
                cost_value = passthrough['ask-price'];
            }
            else{
                cost_value = passthrough['amount'];
                payout_value = receipt['payout'];
            }
            profit_value = Math.round((payout_value - cost_value)*100)/100;

            if(sessionStorage.getItem('formname')==='spreads'){
                payout.innerHTML = Content.localize().textStopLoss + ' <p>' + receipt.stop_loss_level + '</p>';
                cost.innerHTML = Content.localize().textAmountPerPoint + ' <p>' + receipt.amount_per_point + '</p>';
                profit.innerHTML = Content.localize().textStopProfit + ' <p>' + receipt.stop_profit_level + '</p>';
            }
            else {
                payout.innerHTML = Content.localize().textContractConfirmationPayout + ' <p>' + payout_value + '</p>';
                cost.innerHTML = Content.localize().textContractConfirmationCost + ' <p>' + cost_value + '</p>';
                profit.innerHTML = Content.localize().textContractConfirmationProfit + ' <p>' + profit_value + '</p>';
            }

            balance.textContent = Content.localize().textContractConfirmationBalance + ' ' + TUser.get().currency + ' ' + Math.round(receipt['balance_after']*100)/100;

            if(show_chart){
                chart.show();
            }
            else{
                chart.hide();
            }

            if(Contract.form() === 'digits'){
                spots.textContent = '';
                spots.className = '';
                spots.show();
            }
            else{
                spots.hide();
            }

            if(Contract.form() !== 'digits' && !show_chart){
                button.textContent = Content.localize().textContractConfirmationButton;
                button.setAttribute('contract_id', receipt['contract_id']);
                button.show();
                $('.open_contract_detailsws').attr('contract_id', receipt['contract_id']).removeClass('invisible');
            }
            else{
                button.hide();
                $('.open_contract_detailsws').addClass('invisible');
            }
        }

        if(show_chart){
            var contract_sentiment;
            if(passthrough['contract_type']==='CALL' || passthrough['contract_type']==='ASIANU'){
                contract_sentiment = 'up';
            }
            else{
                contract_sentiment = 'down';
            }

            //calculate number of decimals needed to display tick-chart according to the spot
            //value of the underlying
            var decimal_points = 2;
            var tick_spots = Tick.spots();
            var tick_spot_epochs = Object.keys(tick_spots);
            if ( tick_spot_epochs.length > 0 ) {
                var last_quote = tick_spots[tick_spot_epochs[0]].toString();

                if ( last_quote.indexOf(".") != -1 ) {
                    decimal_points = last_quote.split('.')[1].length;
                }
            }

            WSTickDisplay.initialize({
                symbol:passthrough.symbol,
                number_of_ticks:passthrough.duration,
                previous_tick_epoch:receipt['start_time'],
                contract_category:sessionStorage.getItem('formname')==='asian' ? 'asian' : 'callput',
                display_symbol:Symbols.getName(passthrough.symbol),
                contract_start:receipt['start_time'],
                display_decimals: decimal_points,
                contract_sentiment:contract_sentiment,
                price:passthrough['ask-price'],
                payout:receipt['payout'],
                show_contract_result:1,
                width: $('#confirmation_message').width(),
            });
            WSTickDisplay.spots_list = {};
        }
    };

    var update_spot_list = function(data){

        if($('#contract_purchase_spots:hidden').length){
            return;
        }

        var duration = purchase_data.echo_req.passthrough['duration'];

        if(!duration){
            return;
        }

        var spots = document.getElementById('contract_purchase_spots');
        var spots2 = Tick.spots();
        var epoches = Object.keys(spots2).sort(function(a,b){return a-b;});
        spots.textContent = '';

        var replace = function(d){d1 = d; return '<b>'+d+'</b>';};
        for(var s=0; s<epoches.length; s++){
            var tick_d = {
                epoch: epoches[s],
                quote: spots2[epoches[s]]
            };

            if(isVisible(spots) && tick_d.epoch && tick_d.epoch > purchase_data.buy.start_time){
                var fragment = document.createElement('div');
                fragment.classList.add('row');

                var el1 = document.createElement('div');
                el1.classList.add('col');
                el1.textContent = Content.localize().textTickResultLabel + " " + (spots.getElementsByClassName('row').length+1);
                fragment.appendChild(el1);

                var el2 = document.createElement('div');
                el2.classList.add('col');
                var date = new Date(tick_d.epoch*1000);
                var hours = date.getUTCHours() < 10 ? '0'+date.getUTCHours() : date.getUTCHours();
                var minutes = date.getUTCMinutes() < 10 ? '0'+date.getUTCMinutes() : date.getUTCMinutes();
                var seconds = date.getUTCSeconds() < 10 ? '0'+date.getUTCSeconds() : date.getUTCSeconds();
                el2.textContent = hours+':'+minutes+':'+seconds;
                fragment.appendChild(el2);

                var d1;
                var tick = tick_d.quote.replace(/\d$/,replace);
                var el3 = document.createElement('div');
                el3.classList.add('col');
                el3.innerHTML = tick;
                fragment.appendChild(el3);

                spots.appendChild(fragment);
                spots.scrollTop = spots.scrollHeight;

                if(d1 && duration===1){
                    var contract_status,
                        final_price,
                        pnl;

                    if  (  purchase_data.echo_req.passthrough.contract_type==="DIGITMATCH" && d1==purchase_data.echo_req.passthrough.barrier || purchase_data.echo_req.passthrough.contract_type==="DIGITDIFF" && d1!=purchase_data.echo_req.passthrough.barrier || purchase_data.echo_req.passthrough.contract_type==="DIGITEVEN" && d1%2===0 || purchase_data.echo_req.passthrough.contract_type==="DIGITODD" && d1%2 || purchase_data.echo_req.passthrough.contract_type==="DIGITOVER" && d1>purchase_data.echo_req.passthrough.barrier || purchase_data.echo_req.passthrough.contract_type==="DIGITUNDER" && d1<purchase_data.echo_req.passthrough.barrier){
                        spots.className = 'won';
                        final_price = $('#contract_purchase_payout p').text();
                        pnl = $('#contract_purchase_cost p').text();
                        contract_status = Content.localize().textContractStatusWon;
                    }
                    else{
                        spots.className = 'lost';
                        final_price = 0;
                        pnl = -$('#contract_purchase_cost p').text();
                        contract_status = Content.localize().textContractStatusLost;
                    }

                    updatePurchaseStatus(final_price, pnl, contract_status);
                }

                duration--;
                if(!duration){
                    purchase_data.echo_req.passthrough['duration'] = 0;
                }
            }

        }

    };

    return {
        display: display,
        update_spot_list: update_spot_list
    };

})();
;/*
 * Handles start time display
 *
 * It process `Contract.startDates` in case of forward
 * starting contracts and populate the start time select
 * box
 */

var StartDates = (function(){
    'use strict';

    var hasNow = 0;
    var displayed = 0;

    var compareStartDate = function(a,b) {
        if (a.date < b.date)
            return -1;
        if (a.date > b.date)
            return 1;
        return 0;
    };

    var getElement = function(){
        return document.getElementById('date_start');
    };

    var displayStartDates = function() {

        var startDates = Contract.startDates();

        if (startDates && startDates.list.length) {

            var target= getElement(),
                fragment =  document.createDocumentFragment(),
                row = document.getElementById('date_start_row');

            row.style.display = 'flex';

            while (target && target.firstChild) {
                target.removeChild(target.firstChild);
            }

            if(startDates.has_spot){
                var option = document.createElement('option');
                var content = document.createTextNode(Content.localize().textNow);
                option.setAttribute('value', 'now');
                $('#date_start').removeClass('light-yellow-background');
                option.appendChild(content);
                fragment.appendChild(option);
                hasNow = 1;
            }
            else{
                hasNow = 0;
            }

            startDates.list.sort(compareStartDate);

            var first;
            startDates.list.forEach(function (start_date) {
                var a = moment.unix(start_date.open).utc();
                var b = moment.unix(start_date.close).utc();

                var ROUNDING = 5 * 60 * 1000;
                var start = moment.utc();

                if(moment(start).isAfter(moment(a))){
                    a = start;
                }

                a = moment(Math.ceil((+a) / ROUNDING) * ROUNDING).utc();

                while(a.isBefore(b)) {
                    if(a.unix()-start.unix()>5*60){
                        option = document.createElement('option');
                        option.setAttribute('value', a.utc().unix());
                        if(typeof first === 'undefined' && !hasNow){
                            first = a.utc().unix();
                        }
                        content = document.createTextNode(a.format('HH:mm ddd'));
                        if(option.value === Defaults.get('date_start')) {
                            option.setAttribute('selected', 'selected');
                        }
                        option.appendChild(content);
                        fragment.appendChild(option);
                    } 
                    a.add(5, 'minutes');
                }
            });
            target.appendChild(fragment);
            Defaults.set('date_start', target.value);
            displayed = 1;
            if(first){
                TradingEvents.onStartDateChange(first);            
            }
        } else {
            displayed = 0;
            document.getElementById('date_start_row').style.display = 'none';
            Defaults.remove('date_start');
        }
    };

    var setNow = function(){
        if(hasNow){
            var element = getElement();
            element.value = 'now';
            $('#date_start').removeClass('light-yellow-background');
            Defaults.set('date_start', 'now');
        }
    } ;

    return {
        display: displayStartDates,
        node: getElement,
        setNow: setNow,
        displayed: function(){ return displayed; }
    };

})();
;/*
 * Symbols object parses the active_symbols json that we get from socket.send({active_symbols: 'brief'}
 * and outputs in usable form, it gives markets, underlyings
 *
 *
 * Usage:
 *
 * use `Symbols.details` to populate this object first
 *
 * then use
 *
 * `Symbols.markets` to get markets like Forex, Random etc
 * `Symbols.underlyings` to get underlyings
 *
 */

var Symbols = (function () {
    'use strict';

    var tradeMarkets = {}, tradeMarketsList = {}, tradeUnderlyings = {}, current = '', need_page_update = 1, names = {};

    var details = function (data) {
        var allSymbols = data['active_symbols'];

        allSymbols.forEach(function (element) {
            var currentMarket = element['market'],
                currentSubMarket = element['submarket'],
                currentUnderlying = element['symbol'];

            var is_active = !element['is_trading_suspended'] && element['exchange_is_open'];

            if(!tradeMarkets[currentMarket]){
                tradeMarkets[currentMarket] = {name:element['market_display_name'],is_active:0,submarkets:{}};
            }
            if(!tradeMarkets[currentMarket]['submarkets'][currentSubMarket]){
                tradeMarkets[currentMarket]['submarkets'][currentSubMarket] = {name: element['submarket_display_name'],is_active:0};
            }

            if(is_active){
                tradeMarkets[currentMarket]['is_active'] = 1;
                tradeMarkets[currentMarket]['submarkets'][currentSubMarket]['is_active'] = 1;
            }

            tradeMarketsList[currentMarket] = tradeMarkets[currentMarket];
            tradeMarketsList[currentSubMarket] = tradeMarkets[currentMarket]['submarkets'][currentSubMarket];

            if (!tradeUnderlyings.hasOwnProperty(currentMarket)) {
                tradeUnderlyings[currentMarket] = {};
            }

            if (!tradeUnderlyings.hasOwnProperty(currentSubMarket)) {
                tradeUnderlyings[currentSubMarket] = {};
            }

            if (!tradeUnderlyings[currentMarket].hasOwnProperty(currentUnderlying)) {
                tradeUnderlyings[currentMarket][currentUnderlying] = {
                    is_active: is_active,
                    display: element['display_name'],
                    market: currentMarket,
                    submarket: currentSubMarket
                };
            }

            if (!tradeUnderlyings[currentSubMarket].hasOwnProperty(currentUnderlying)) {
                tradeUnderlyings[currentSubMarket][currentUnderlying] = {
                    is_active: is_active,
                    display: element['display_name'],
                    market: currentMarket,
                    submarket: currentSubMarket
                };
            }

            names[currentUnderlying]=element['display_name'];
        });
    };

    var getSymbols = function (update) {
        var $args = {
            active_symbols: "brief"
        };
        if (isJapanTrading()) {
            $args['landing_company'] = "japan";
        }
        BinarySocket.send($args);
        need_page_update = update;
    };

    return {
        details: details,
        getSymbols: getSymbols,
        markets: function (list) { return list ? tradeMarketsList : tradeMarkets; },
        underlyings: function () { return tradeUnderlyings; },
        getName: function(symbol){ return names[symbol]; },
        need_page_update: function () { return need_page_update; },
        getAllSymbols: function(){return names;}
    };

})();
;/*
 * Tick object handles all the process/display related to tick streaming
 *
 * We request tick stream for particular underlying to update current spot
 *
 *
 * Usage:
 * use `Tick.detail` to populate this object
 *
 * then use
 *
 * `Tick.quote()` to get current spot quote
 * `Tick.id()` to get the unique for current stream
 * `Tick.epoch()` to get the tick epoch time
 * 'Tick.display()` to display current spot
 */
var Tick = (function() {
    'use strict';

    var quote = '',
        id = '',
        epoch = '',
        errorMessage = '',
        spots = {},
        keep_number = 20;

    var details = function(data) {
        errorMessage = '';

        if (data) {
            if (data['error']) {
                errorMessage = data['error']['message'];
            } else {
                var tick = data['tick'];
                quote = tick['quote'];
                id = tick['id'];
                epoch = tick['epoch'];

                spots[epoch] = quote;
                var epoches = Object.keys(spots).sort(function(a, b) {
                    return a - b;
                });
                if (epoches.length > keep_number) {
                    delete spots[epoches[0]];
                }
            }
        }
    };

    var display = function() {
        $('#spot').fadeIn(200);
        var spotElement = document.getElementById('spot');
        var message = '';
        if (errorMessage) {
            message = errorMessage;
        } else {
            message = quote;
        }

        if (parseFloat(message) != message) {
            spotElement.className = 'error';
        } else {
            spotElement.classList.remove('error');
            displayPriceMovement(spotElement, spotElement.textContent, message);
            displayIndicativeBarrier();
        }

        spotElement.textContent = message;
    };

    var request = function(symbol) {
        BinarySocket.send({
            "ticks_history": symbol,
            "style": "ticks",
            "end": "latest",
            "count": keep_number,
            "subscribe": 1
        });
    };

    var processHistory = function(res) {
        if (res.history && res.history.times && res.history.prices) {
            for (var i = 0; i < res.history.times.length; i++) {
                details({
                    tick: {
                        epoch: res.history.times[i],
                        quote: res.history.prices[i]
                    }
                });
            }
        }
    };

    return {
        details: details,
        display: display,
        quote: function() {
            return quote;
        },
        id: function() {
            return id;
        },
        epoch: function() {
            return epoch;
        },
        errorMessage: function() {
            return errorMessage;
        },
        clean: function() {
            spots = {};
            quote = '';
            $('#spot').fadeOut(200, function(){
                // resets spot movement coloring, will continue on the next tick responses
                $(this).removeClass('price_moved_down price_moved_up').text('');
            });
        },
        spots: function() {
            return spots;
        },
        setQuote: function(q) {
            quote = q;
        },
        request: request,
        processHistory: processHistory
    };
})();
;var WSTickDisplay = Object.create(TickDisplay);
WSTickDisplay.plot = function(plot_from, plot_to) {
    var $self = this;
    $self.contract_start_moment = moment($self.contract_start_ms).utc();
    $self.counter = 0;
    $self.applicable_ticks = [];
};
WSTickDisplay.update_ui = function(final_price, pnl, contract_status) {
    var $self = this;
    updatePurchaseStatus(final_price, final_price - pnl, contract_status);
};
WSTickDisplay.socketSend = function(req) {
    if(!req.hasOwnProperty('passthrough')) {
        req.passthrough = {};
    }
    req.passthrough['dispatch_to'] = 'ViewTickDisplayWS';
    BinarySocket.send(req);
};
WSTickDisplay.dispatch = function(data) {
  var $self = this;
  var chart = document.getElementById('tick_chart');

  if (window.subscribe && data.tick && document.getElementById('sell_content_wrapper')) {
      window.responseID = data.tick.id;
      ViewPopupWS.storeSubscriptionID(window.responseID);
  }

  if (!chart || !isVisible(chart) || !data || (!data.tick && !data.history)) {
      return;
  }

  var epoches, spots2, display_decimals;
  if (document.getElementById('sell_content_wrapper')) {
    if (data.tick && document.getElementById('sell_content_wrapper')) {
      Tick.details(data);
      if (!display_decimals) {
        display_decimals = data.tick.quote.split('.')[1].length || 2;
      }
    } else if (data.history && document.getElementById('sell_content_wrapper')) {
      if (!display_decimals) {
        display_decimals = data.history.prices[0].split('.')[1].length || 2;
      }
    }
    if (!window.tick_init || window.tick_init === '') {
      WSTickDisplay.initialize({
          "symbol"              : window.tick_underlying,
          "number_of_ticks"     : window.tick_count,
          "contract_category"   : ((/asian/i).test(window.tick_shortcode) ? 'asian' : (/digit/i).test(window.tick_shortcode) ? 'digits' : 'callput'),
          "longcode"            : window.tick_longcode,
          "display_symbol"      : window.tick_display_name,
          "contract_start"      : window.tick_date_start,
          "display_decimals"    : display_decimals,
          "show_contract_result": 0
      });
      WSTickDisplay.spots_list = {};
      window.tick_init = 'initialized';
    }
  }
  if (data.tick) {
    spots2 = Tick.spots();
    epoches = Object.keys(spots2).sort(function(a, b) {
        return a - b;
    });
  } else if (data.history) {
    epoches = data.history.times;
  }

  if ($self.applicable_ticks.length >= $self.ticks_needed) {
      $self.evaluate_contract_outcome();
      if (window.responseID) {
        BinarySocket.send({'forget':window.responseID});
      }
      return;
  } else {
      for (var d = 0; d < epoches.length; d++) {
          var tick;
          if (data.tick) {
            tick = {
                epoch: parseInt(epoches[d]),
                quote: parseFloat(spots2[epoches[d]])
            };
          } else if (data.history) {
            tick = {
                epoch: parseInt(data.history.times[d]),
                quote: parseFloat(data.history.prices[d])
            };
          }

          if (tick.epoch > $self.contract_start_moment.unix() && !$self.spots_list[tick.epoch]) {
              if (!$self.chart) return;
              if (!$self.chart.series) return;
              $self.chart.series[0].addPoint([$self.counter, tick.quote], true, false);
              $self.applicable_ticks.push(tick);
              $self.spots_list[tick.epoch] = tick.quote;
              var indicator_key = '_' + $self.counter;
              if (typeof $self.x_indicators[indicator_key] !== 'undefined') {
                  $self.x_indicators[indicator_key]['index'] = $self.counter;
                  $self.add($self.x_indicators[indicator_key]);
              }

              $self.add_barrier();
              $self.apply_chart_background_color(tick);
              $self.counter++;
          }
      }
  }
};
WSTickDisplay.updateChart = function(data, contract) {
    window.subscribe = 'false';
    if (contract) {
      window.tick_underlying = contract.underlying;
      window.tick_count = contract.tick_count;
      window.tick_longcode = contract.longcode;
      window.tick_display_name = contract.display_name;
      window.tick_date_start = contract.date_start;
      window.tick_shortcode = contract.shortcode;
      window.tick_init = '';
      var request = {
        ticks_history: contract.underlying,
        start: contract.date_start,
        end: 'latest'
      };
      if (contract.current_spot_time < contract.date_expiry) {
        request.subscribe = 1;
        window.subscribe = 'true';
      } else {
        request.end = contract.date_expiry;
      }
      WSTickDisplay.socketSend(request);
      return;
    } else {
      WSTickDisplay.dispatch(data);
    }
};
;var TradePage = (function(){
	
	var trading_page = 0;

	var onLoad = function(){
		trading_page = 1;
		if(sessionStorage.getItem('currencies')){
			displayCurrencies();
		}		
		BinarySocket.init({
			onmessage: function(msg){
				Message.process(msg);
				showRandomRenamedMsg(msg);				// temporary,
			},
			onclose: function(){
				processMarketUnderlying();
			}
		});
		Price.clearFormId();
		TradingEvents.init();
		Content.populate();
		
		if(sessionStorage.getItem('currencies')){
			displayCurrencies();
			Symbols.getSymbols(1);
		}
		else {
			BinarySocket.send({ payout_currencies: 1 });
		}
		
		if (document.getElementById('websocket_form')) {
		    addEventListenerForm();
		}

		// Walktrough Guide
		Guide.init({
			script : 'trading'
		});
	};

	var reload = function() {
		sessionStorage.removeItem('underlying');
		window.location.reload();
	};

	var onUnload = function(){
		trading_page = 0;
		forgetTradingStreams();
		BinarySocket.clear();
		Defaults.clear();
	};

	return {
		onLoad: onLoad,
		reload: reload,
		onUnload : onUnload,
		is_trading_page: function(){return trading_page;}
	};
})();;var TUser = (function () {
    var data = {};
    return {
        set: function(a){ data = a; },
        get: function(){ return data; }
    };
})();;/*
 * It provides a abstraction layer over native javascript Websocket.
 *
 * Provide additional functionality like if connection is close, open
 * it again and process the buffered requests
 *
 *
 * Usage:
 *
 * `BinarySocket.init()` to initiate the connection
 * `BinarySocket.send({contracts_for : 1})` to send message to server
 */
function BinarySocketClass() {
    'use strict';

    var binarySocket,
        bufferedSends = [],
        manualClosed = false,
        events = {},
        authorized = false,
        timeouts = {},
        req_number = 0,
        socketUrl;
        if(window.location.host == 'www.binary.com'){
          socketUrl = "wss://ws.binaryws.com/websockets/v3";
        } else{
          socketUrl = "wss://"+window.location.host+"/websockets/v3";
        }

    if (page.language()) {
        socketUrl += '?l=' + page.language();
    }

    var clearTimeouts = function(){
        for(var k in timeouts){
            if(timeouts.hasOwnProperty(k)){
                clearTimeout(timeouts[k]);
                delete timeouts[k];
            }
        }
    };

    var status = function () {
        return binarySocket && binarySocket.readyState;
    };

    var isReady = function () {
        return binarySocket && binarySocket.readyState === 1;
    };

    var isClose = function () {
        return !binarySocket || binarySocket.readyState === 2 || binarySocket.readyState === 3;
    };

    var sendBufferedSends = function () {
        while (bufferedSends.length > 0) {
            binarySocket.send(JSON.stringify(bufferedSends.shift()));
        }
    };

    var send = function(data) {
        if (isClose()) {
            bufferedSends.push(data);
            init(1);
        } else if (isReady()) {
            if(!data.hasOwnProperty('passthrough') && !data.hasOwnProperty('verify_email')){
                data.passthrough = {};
            }
            // temporary check
            if((data.contracts_for || data.proposal) && !data.passthrough.hasOwnProperty('dispatch_to')){
                data.passthrough.req_number = ++req_number;
                timeouts[req_number] = setTimeout(function(){
                    if(typeof reloadPage === 'function' && data.contracts_for){
                        alert("The server didn't respond to the request:\n\n"+JSON.stringify(data)+"\n\n");
                        reloadPage();
                    }
                    else{
                        $('.price_container').hide();
                    }
                }, 60*1000);
            }

            binarySocket.send(JSON.stringify(data));
        } else {
            bufferedSends.push(data);
        }
    };

    var init = function (es) {
        if(!es){
            events = {};
        }
        if(typeof es === 'object'){
            bufferedSends = [];
            manualClosed = false;
            events = es;
            clearTimeouts();
        }

        if(isClose()){
            binarySocket = new WebSocket(socketUrl);
        }

        binarySocket.onopen = function (){
            var loginToken = getCookieItem('login');
            if(loginToken && !authorized) {
                binarySocket.send(JSON.stringify({authorize: loginToken}));
            }
            else {
                sendBufferedSends();
            }

            if(typeof events.onopen === 'function'){
                events.onopen();
            }

            if(isReady()=== true){
                page.header.validate_cookies();
                if (clock_started === false) {
                    page.header.start_clock_ws();
                }
            }
        };

        binarySocket.onmessage = function (msg){
            var response = JSON.parse(msg.data);
            if (response) {
                if(response.hasOwnProperty('echo_req') && response.echo_req.hasOwnProperty('passthrough')) {
                    var passthrough = response.echo_req.passthrough;
                    if(passthrough.hasOwnProperty('req_number')) {
                        clearInterval(timeouts[response.echo_req.passthrough.req_number]);
                        delete timeouts[response.echo_req.passthrough.req_number];
                    }
                    else if (passthrough.hasOwnProperty('dispatch_to')) {
                      if (passthrough.dispatch_to === 'ViewPopupWS') {
                        ViewPopupWS.dispatch(response);
                      } else if (passthrough.dispatch_to === 'ViewChartWS') {
                        Highchart.dispatch(response);
                      } else if (passthrough.dispatch_to === 'ViewTickDisplayWS') {
                        WSTickDisplay.dispatch(response);
                      }
                    }
                }
                var type = response.msg_type;
                if (type === 'authorize') {
                    if(response.hasOwnProperty('error')) {
                        LocalStore.set('reality_check.ack', 0);
                       send({'logout': '1', passthrough: {'redirect': 'login'}});
                    }
                    else {
                        authorized = true;
                        page.client.response_authorize(response);
                        if(typeof events.onauth === 'function'){
                            events.onauth();
                        }
                        send({balance:1, subscribe: 1});
                        send({landing_company_details: TUser.get().landing_company_name});
                        send({get_settings: 1});
                        sendBufferedSends();
                    }
                } else if (type === 'balance') {
                    ViewBalanceUI.updateBalances(response);
                } else if (type === 'time') {
                    page.header.time_counter(response);
                } else if (type === 'logout') {
                    localStorage.removeItem('jp_test_allowed');
                    RealityCheckData.clear();
                    page.header.do_logout(response);
                } else if (type === 'landing_company_details') {
                    page.client.response_landing_company_details(response);
                    RealityCheck.init();
                } else if (type === 'payout_currencies' && response.echo_req.hasOwnProperty('passthrough') && response.echo_req.passthrough.handler === 'page.client') {
                    page.client.response_payout_currencies(response);
                } else if (type === 'get_settings') {
                    var jpStatus = response.get_settings.jp_account_status;

                    if (jpStatus) {
                        switch (jpStatus.status) {
                            case 'jp_knowledge_test_pending': localStorage.setItem('jp_test_allowed', 1);
                                break;
                            case 'jp_knowledge_test_fail':
                                if (Date.now() >= (jpStatus.next_test_epoch * 1000)) {
                                    localStorage.setItem('jp_test_allowed', 1);
                                } else {
                                    localStorage.setItem('jp_test_allowed', 0);
                                }
                                break;
                            default: localStorage.setItem('jp_test_allowed', 0);
                        }

                        KnowledgeTest.showKnowledgeTestTopBarIfValid(jpStatus);
                    } else {
                        localStorage.removeItem('jp_test_allowed');
                    }
                } else if (type === 'website_status') {
                  if (response.website_status.clients_country) {
                    localStorage.setItem('clients_country', response.website_status.clients_country);
                    if (isNotBackoffice()) {
                      checkClientsCountry();
                    }
                  }
                } else if (type === 'reality_check') {
                    RealityCheck.realityCheckWSHandler(response);
                }
                if (response.hasOwnProperty('error')) {
                    if(response.error && response.error.code) {
                      if (response.error.code === 'RateLimit') {
                        $('#ratelimit-error-message')
                            .css('display', 'block')
                            .on('click', '#ratelimit-refresh-link', function () {
                                window.location.reload();
                            });
                      } else if (response.error.code === 'InvalidToken' &&
                          type !== 'reset_password' &&
                          type !== 'new_account_virtual' &&
                          type !== 'paymentagent_withdraw') {
                        BinarySocket.send({'logout': '1'});
                      }
                    }
                }
                if(typeof events.onmessage === 'function'){
                    events.onmessage(msg);
                }
            }
        };

        binarySocket.onclose = function (e) {
            authorized = false;
            clearTimeouts();

            if(!manualClosed){
                init(1);
            }
            if(typeof events.onclose === 'function'){
                events.onclose();
            }
        };

        binarySocket.onerror = function (error) {
            console.log('socket error', error);
        };
    };

    var close = function () {
        manualClosed = true;
        bufferedSends = [];
        events = {};
        if (binarySocket) {
            binarySocket.close();
        }
    };

    var clear = function(){
        bufferedSends = [];
        manualClosed = false;
        events = {};
    };

    return {
        init: init,
        send: send,
        close: close,
        socket: function () { return binarySocket; },
        clear: clear,
        clearTimeouts: clearTimeouts
    };

}

var BinarySocket = new BinarySocketClass();
;pjax_config_page("user/applicationsws", function(){
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }
            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);

                    if (response) {
                        var type = response.msg_type;
                        if (type === 'oauth_apps'){
                            Applications.responseHandler(response);
                        }
                    }
                }
            });
            Content.populate();
            Applications.init();
        },
        onUnload: function(){
            Applications.clean();
        }
    };
});
;var ApplicationsData = (function(){
    "use strict";

    function getApplications(){
        var request = {oauth_apps: 1};
        BinarySocket.send(request);
    }
    
    function revokeApplication(id){
        if(!id){
            return;
        }
        var request = {
            oauth_apps: 1,
            revoke_app: id
        };
        
        BinarySocket.send(request);
    }
    
    return{
      getApplications: getApplications,
      revokeApplication: revokeApplication
    };
}());
;var Applications = (function(){
    "use strict";
    
    var tableExist = function(){
        return document.getElementById("applications-table");
    };
    
    function responseHandler(response){
        if (response.hasOwnProperty('error') && response.error.message) {
          $("#applications-ws-container .error-msg").text(response.error.message);
          return;
        } else {

            var applications = response.oauth_apps;
            
            if (!tableExist()) {
                $("#loading").remove();
                ApplicationsUI.createEmptyTable().appendTo("#applications-ws-container");
                var titleElement = document.getElementById("applications-title").firstElementChild,
                    desc = document.getElementById("description");
                titleElement.textContent = text.localize(titleElement.textContent);
                desc.textContent = text.localize(desc.textContent);
            }
            
            // Show a message when the table is empty.
            if (applications.length === 0) {
                ApplicationsUI.clearTableContent();
                $('#applications-table tbody')
                    .append($('<tr/>', {class: "flex-tr"})
                        .append($('<td/>', {colspan: 7})
                            .append($('<p/>', {class: "notice-msg center", text: text.localize("You have not granted access to any applications.")})
                            )
                        )
                    );
            }
            else{
                ApplicationsUI.createTable(applications);
            }
        }
    }
    
    function initPage(){
        showLoadingImage($('<div/>', {id: 'loading'}).insertAfter('#applications-title'));
        ApplicationsData.getApplications();
    }
    
    function initTable(){
        $("#applications-ws-container .error-msg").text("");
        ApplicationsUI.clearTableContent();
    }

    return {
        init: initPage,
        responseHandler: responseHandler,
        clean: initTable
    };
}());
;var ApplicationsUI = (function(){
    "use strict";
    var tableID = "applications-table",
        columns = ["name","permissions","last_used","action"];
    
    function createEmptyTable(){
        var header = [
                text.localize("Name"),
                text.localize("Permissions"),
                text.localize("Last Used"),
                text.localize("Action")
            ];
        var metadata = {
            id: tableID,
            cols: columns
        };
        var data = [];
        var $table = Table.createFlexTable(data,metadata,header);
        return $table;
    }
    
    function createTable(app){
        Table.clearTableBody(tableID);
        Table.appendTableBody(tableID, app, createRow);
    }
    
    function createRow(data){
        var name = data.name,
            permissions = data.scopes.join(", "),
            last_used = data.last_used ? moment.utc(data.last_used).format("YYYY-MM-DD HH:mm:ss") : text.localize("Never"),
            action = '';
        var $row = Table.createFlexTableRow([name,permissions,last_used,action], columns,"data");
        var $viewButtonSpan = Button.createBinaryStyledButton();
        var $viewButton = $viewButtonSpan.children(".button").first();
        $viewButton.text(text.localize("Revoke access"));
        $viewButton.on("click",function(){
            ApplicationsData.revokeApplication(data.app_id);
            $row.css({ opacity: 0.5 });
        });
        $row.children(".action").first().append($viewButtonSpan);
        return $row[0];
    }
    
    function clearTableContent(){
        Table.clearTableBody(tableID);
        $("#" + tableID +">tfoot").hide();
    }
    
    return{
        createEmptyTable: createEmptyTable,
        createTable: createTable,
        clearTableContent: clearTableContent
    };
    
}());
;pjax_config_page("cashier/authenticatews", function(){
  return {
    onLoad: function() {
      Content.populate();
      if (page.client.redirect_if_logout()) {
          return;
      }
      function show_error(error) {
        message.innerHTML = '<div class="errorbox rbox" id="client_message" style="display:block">' +
                              '<div class="rbox-wrap">' +
                                '<div class="grd-grid-12 rbox-content" id="client_message_content">' +
                                  '<p class="center notice-msg">' +
                                    error +
                                  '</p>' +
                                '</div>' +
                              '</div>' +
                            '</div>';
      }
      var message = document.getElementById('authentication-message');
      if (page.client.is_virtual()) {
        show_error(text.localize('This feature is not relevant to virtual-money accounts.'));
        return;
      } else {
        BinarySocket.init({
          onmessage: function(msg){
            var response = JSON.parse(msg.data);
            if (response) {
              var error = response.error;
              if (response.msg_type === 'get_account_status' && !error){
                if ($.inArray('authenticated', response.get_account_status) > -1) {
                  message.innerHTML = '<p>' +
                                        text.localize('Your account is fully authenticated. You can view your [_1]trading limits here').replace('[_1]', '<a class="pjaxload" href="' + page.url.url_for('cashier/limitsws') + '">') + '</a>.' +
                                      '</p>';
                } else {
                  message.innerHTML = '<p>' +
                                        text.localize('To authenticate your account, kindly email the following to [_1]').replace('[_1]', '<a href="mailto:support@binary.com">support@binary.com</a>') +
                                      '</p>' +
                                      '<p>' +
                                        text.localize('- A scanned copy of your passport, driving licence (provisional or full) or identity card, showing your name and date of birth.') +
                                      '</p>' +
                                      '<p>' +
                                        text.localize('and') +
                                      '</p>' +
                                      '<p>' +
                                        text.localize('- A scanned copy of a utility bill or bank statement (no more than 3 months old).') +
                                      '</p>';
                }
              } else if (error) {
                show_error(error.message);
              }
            }
          }
        });
        BinarySocket.send({'get_account_status': 1});
      }
    }
  };
});
;var account_transferws = (function(){
    "use strict";
    var $form ;
    var account_from , account_to ;
    var currType,account_bal;
    var availableCurr= [] ;
    var payoutCurr = [];
    
    var init = function(){
        if(page.client.redirect_if_is_virtual()) {
            return;
        }

        $form = $('#account_transfer');
        $("#success_form").hide();
        $("#client_message").hide();
        account_bal = 0;

        BinarySocket.send({ "transfer_between_accounts": "1","req_id" : 4 });

        $form.find("button").on("click", function(e){
            e.preventDefault();
            e.stopPropagation();

            if(validateForm() === false){
                return false;
            }

            var amt = $form.find("#acc_transfer_amount").val();
            BinarySocket.send({ 
                        "transfer_between_accounts": "1",
                        "account_from": account_from,
                        "account_to": account_to,
                        "currency": currType,
                        "amount": amt
            });

        });

        $form.find("#transfer_account_transfer").on("change",function(){

           $form.find("#invalid_amount").text("");
           set_account_from_to();

           BinarySocket.send({"payout_currencies": "1"});

        });
    };
    var set_account_from_to = function(){

        var accounts = $("#transfer_account_transfer option:selected").text();
        var matches = accounts
                        .split('(')
                        .filter(function(v){ 
                            return v.indexOf(')') > -1;})
                        .map( function(value) { 
                            return value.split(')')[0];
                    }); 

        account_from = matches[0];
        account_to = matches[1];
        
        $.each(availableCurr,function(index,value){
            if(value.account == account_from){
                currType = value.currency;
                account_bal = value.balance;
            }
        });

        $form.find("#currencyType").html(currType);
    };
    var validateForm =function(){

        var amt = $form.find("#acc_transfer_amount").val();
        var isValid = true;
       
        if(amt.length <=0 ){
            $form.find("#invalid_amount").text(text.localize("Invalid amount. Minimum transfer amount is 0.10, and up to 2 decimal places."));
            isValid = false;
        }

        return isValid;
    };

    var apiResponse = function(response){
        var type = response.msg_type;
        if (type === "authorize") {
            init();
        }
        else if (type === "transfer_between_accounts" || (type === "error" && "transfer_between_accounts" in response.echo_req)) {
           responseMessage(response);
        }
        else if(type === "payout_currencies" || (type === "error" && "payout_currencies" in response.echo_req)) {
            responseMessage(response);
        }
    };

    var responseMessage = function(response) {
        var resvalue ;
        if("error" in response) {
                if("message" in response.error) {

                    if($('#transfer_account_transfer option').length > 0 ){
                        $form.find("#invalid_amount").text(text.localize(response.error.message));
                    }
                    else{
                        $("#client_message").show();
                        $("#client_message p").html(text.localize(response.error.message));
                        $("#success_form").hide();
                        $form.hide();

                    }
                    return false;
                }

                return false;
        }
        else if("payout_currencies" in response){

            payoutCurr = response.payout_currencies;
        }
        else if ("transfer_between_accounts" in response){

            if(response.req_id === 5){
        
                $.each(response.accounts,function(key,value){
                    $form.hide();
                    $("#success_form").show();
                    $("#client_message").hide();

                    if(value.loginid == account_from){
                        $("#loginid_1").html(value.loginid);
                        $("#balance_1").html(value.balance);
                    }
                    else if(value.loginid == account_to){
                        $("#loginid_2").html(value.loginid);
                        $("#balance_2").html(value.balance);

                    }
                });
            }
            else if(response.req_id === 4){

                var secondacct, firstacct,str,optionValue;
                var selectedIndex = -1;

                $.each(response.accounts, function(index,value){
                    var currObj = {};

                    if($.isEmptyObject(firstacct))
                    {
                        firstacct = value.loginid;
                        currObj.account = value.loginid;
                        currObj.currency = value.currency;
                        currObj.balance = value.balance;

                        if(value.balance > 0 && selectedIndex < 0)
                        {
                            selectedIndex = index;
                        }

                        availableCurr.push(currObj);
                    }
                    else
                    {
                        secondacct = value.loginid;
                        str = text.localize("from account (" + firstacct + ") to account (" + secondacct + ")");
                        optionValue = firstacct + "_to_" + secondacct;
                        $form.find("#transfer_account_transfer")
                             .append($("<option></option>")
                             .attr("value",optionValue)
                             .text(str));
                        str = text.localize("from account (" + secondacct + ") to account (" + firstacct + ")");
                        optionValue = secondacct + "_to_" + firstacct;
                        $form.find("#transfer_account_transfer")
                             .append($("<option></option>")
                             .attr("value",optionValue)
                             .text(str));     

                        currObj.account = value.loginid;
                        currObj.currency = value.currency;
                        currObj.balance = value.balance;

                        availableCurr.push(currObj);     

                        firstacct = {};    

                        if(selectedIndex < 0 && value.balance){
                            selectedIndex =  index;
                        }  
                    }
                    
                    if(($.isEmptyObject(firstacct) === false) && ($.isEmptyObject(secondacct) === false))
                    {
                        str = text.localize("from account (" + secondacct + ") to account (" + firstacct + ")");
                        optionValue = secondacct + "_to_" + firstacct;
                        $form.find("#transfer_account_transfer")
                                 .append($("<option></option>")
                                 .attr("value",optionValue)
                                 .text(str));     
                    }
                    secondacct = {};

                    if(value.balance <= 0){
                        $form.find("#transfer_account_transfer option:last").remove();
                    }
                    else{
                        if(selectedIndex < 0 ){
                            selectedIndex =  index;
                        } 
                    }


                });
                
                for(var i = 0; i < selectedIndex; i++){
                    $form.find("#transfer_account_transfer option").eq(i).remove();
                }

                if(selectedIndex >=0){
                    $form.find("#transfer_account_transfer option").eq(selectedIndex).attr('selected', 'selected');
                }
        

                set_account_from_to();

                if((account_bal <=0) && (response.accounts.length > 1) ){
                    $("#client_message").show();
                    $("#success_form").hide();
                    $form.hide();
                    return false;
                }
                else if(account_to === undefined || account_from === undefined || $.isEmptyObject(account_to))
                {
                    $("#client_message").show();
                    $("#client_message p").html(text.localize("The account transfer is unavailable for your account."));
                    $("#success_form").hide();
                    $form.hide();
                    return false;
                }

                BinarySocket.send({"payout_currencies": "1"});
            }
            else{
                BinarySocket.send({ 
                    "transfer_between_accounts": "1",
                    "req_id" : 5
                });

            }
        }

    };

    return {
        init : init,
        apiResponse : apiResponse
    };

})();

pjax_config_page("cashier/account_transferws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

        	BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);
                    if (response) {
                        account_transferws.apiResponse(response);
                    }
                }
            });	

            if(TUser.get().hasOwnProperty('is_virtual')) {
                account_transferws.init();
            }
        }
    };
});;var MyAccountWS = (function() {
    "use strict";

    var loginid,
        isReal,
        get_account_status,
        is_authenticated_payment_agent,
        terms_conditions_version,
        client_tnc_status;
    var hiddenClass,
        welcomeTextID,
        virtualTopupID,
        authButtonID;

    var init = function() {
        hiddenClass    = 'invisible';
        welcomeTextID  = '#welcome_text';
        virtualTopupID = '#VRT_topup_link';
        authButtonID   = '#authenticate_button';

        loginid = page.client.loginid || $.cookie('loginid');

        BinarySocket.send({"get_settings"      : 1});
        BinarySocket.send({"website_status"    : 1});
        BinarySocket.send({"get_account_status": 1});

        //checkDisabledAccount();
    };

    var responseGetSettings = function(response) {
        var get_settings = response.get_settings;
        if (get_settings.country === null || $.cookie('residence') === '') {
          var documentDomain = document.domain.split('.').slice(-2).join('.');
          if ($.cookie('residence') !== '') {
            $.cookie('residence', '', {path: '/', domain: documentDomain});
          } else if (get_settings.country_code) {
            $.cookie('residence', get_settings.country_code, {path: '/', domain: documentDomain});
          }
          page.client.residence = get_settings.country_code;
          page.contents.topbar_message_visibility();
        }
        client_tnc_status = get_settings.client_tnc_status || '-';
        is_authenticated_payment_agent = get_settings.is_authenticated_payment_agent;

        checkAll();

        addGTMDataLayer(get_settings);
    };

    var responseAccountStatus = function(response) {
        get_account_status = response.get_account_status;
        checkAll();
    };

    var checkAll = function() {
        if(!terms_conditions_version || !client_tnc_status || !get_account_status) {
            return;
        }

        if(isReal && terms_conditions_version !== client_tnc_status) {
            window.location.href = page.url.url_for('user/tnc_approvalws');
            return;
        }

        showWelcomeMessage();
        if(!isReal) {
            showTopUpLink();
        }
        else {
            if(is_authenticated_payment_agent) {
                $('#payment_agent').removeClass(hiddenClass);
            }
        }

        if(get_account_status[0] === 'unwelcome'){
            $(authButtonID).removeClass(hiddenClass);
        }

        $('#cashier-portfolio, #profit-statement').removeClass(hiddenClass);
        $('#loading').remove();
    };

    var showWelcomeMessage = function() {
        var landing_company = page.client.get_storage_value('landing_company_name');
        $(welcomeTextID)
            .text(
                text.localize(
                    isReal ?
                        'You are currently logged in to your real money account with [_1] ([_2]).' :
                        'You are currently logged in to your virtual money account ([_2]).'
                )
                    .replace('[_1]', landing_company || '')
                    .replace('[_2]', loginid)
            )
            .removeClass(hiddenClass);
    };

    var showTopUpLink = function() {
        if(TUser.get().balance < 1000) {
            $(virtualTopupID + ' a')
                .text(
                    text.localize('Deposit [_1] [_2] virtual money into your account [_3]')
                        .replace('[_1]', TUser.get().currency)
                        .replace('[_2]', '10000')
                        .replace('[_3]', loginid)
                );
            $(virtualTopupID).removeClass(hiddenClass);
        }
    };

    var addGTMDataLayer = function(get_settings) {
        var is_login = page.url.param('login'),
            is_newaccount = localStorage.getItem('new_account') === '1';
        if(is_login || is_newaccount) {
            localStorage.removeItem('new_account');
            var oldUrl = window.location.href;
            var newUrl = oldUrl.replace(/(login=true&|newaccounttype=real&|newaccounttype=virtual&)/gi, '');

            var affiliateToken = $.cookie('affiliate_tracking');
            if (affiliateToken) {
                GTM.push_data_layer({'bom_affiliate_token': JSON.parse(affiliateToken).t});
            }

            var data = {
                'visitorID'   : page.client.loginid,
                'bom_country' : get_settings.country,
                'bom_email'   : get_settings.email,
                'url'         : oldUrl,
                'bom_today'   : Math.floor(Date.now() / 1000),
                'event'       : is_newaccount ? 'new_account' : 'log_in'
            };

            if(is_newaccount) {
                data['bom_date_joined'] = data['bom_today'];
            }

            if(isReal) {
                data['bom_age']       = parseInt((moment().unix() - get_settings.date_of_birth) / 31557600);
                data['bom_firstname'] = get_settings.first_name;
                data['bom_lastname']  = get_settings.last_name;
                data['bom_phone']     = get_settings.phone;
            }

            GTM.push_data_layer(data);

            window.history.replaceState('My Account', document.title, newUrl);
        }
    };

    var checkDisabledAccount = function() {
        var disabledAccount = [];
        page.user.loginid_array.map(function(loginObj) {
            if (loginObj.disabled && loginObj.real) {
                disabledAccount.push(loginObj.id);
            }
        });

        if(disabledAccount.length > 0) {
            var msgSingular = text.localize('Your [_1] account is unavailable. For any questions please contact [_2].'),
                msgPlural   = text.localize('Your [_1] accounts are unavailable. For any questions please contact [_2].');
            $('<p/>', {class: 'notice-msg'})
                .html(
                    (disabledAccount.length === 1 ? msgSingular : msgPlural)
                        .replace('[_1]', disabledAccount.join(', '))
                        .replace('[_2]', $('<a/>', {class: 'pjaxload', href: page.url.url_for('contact'), text: text.localize('Customer Support')}).prop('outerHTML'))
                )
                .insertAfter($(welcomeTextID));
        }
    };

    var apiResponse = function(response) {
        if('error' in response){
            if('message' in response.error) {
                console.warn(response.error.message);
            }
            return false;
        }

        isReal = !page.client.is_virtual();

        switch(response.msg_type) {
            case 'get_account_status':
                responseAccountStatus(response);
                break;
            case 'get_settings':
                responseGetSettings(response);
                break;
            case 'landing_company_details':
                showWelcomeMessage();
                break;
            case 'website_status':
                terms_conditions_version = response.website_status.terms_conditions_version;
                checkAll();
                break;
            default:
                break;
        }
    };

    return {
        init : init,
        apiResponse : apiResponse
    };
}());


pjax_config_page("user/my_accountws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

            showLoadingImage($('<div/>', {id: 'loading'}).insertAfter('#welcome'));

            if(page.url.param('login')) {
                page.client.clear_storage_values();
            }

            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        MyAccountWS.apiResponse(response);
                    }
                }
            });

            Content.populate();
            MyAccountWS.init();
        }
    };
});
;var PaymentAgentListWS = (function() {
    "use strict";

    var hiddenClass,
        ddlCountriesID,
        $paListContainer;

    var residence,
        agentTemplate;


    var init = function() {
        hiddenClass = 'hidden';
        ddlCountriesID = '#target_country';
        $paListContainer = $('#pa_list');
        agentTemplate = $paListContainer.find('#accordion').html();

        residence = $.cookie('residence');
        if(!residence || residence.length === 0) {
            residence = '00'; // just to get a list of payment agent Countries
        }

        sendRequest(residence, true);
    };

    var sendRequest = function(country, isList) {
        BinarySocket.send({
            "paymentagent_list": country ? country : $(ddlCountriesID).val(), 
            "passthrough": isList ? {"countries_list": "1"} : {}
        });
    };

    var responseHandler = function(response) {
        if(response.echo_req.passthrough && response.echo_req.passthrough.countries_list === '1') {
            populateCountriesList(response);
        }
        else {
            populateAgentsList(response.paymentagent_list.list);
        }
    };

    // --------------------------
    // ----- Countries List -----
    // --------------------------
    var populateCountriesList = function(response) {
        var $ddlCountries = $(ddlCountriesID);
        $ddlCountries.empty();

        var cList = response.paymentagent_list.available_countries;
        if(cList.length === 0) {
            $ddlCountries.parent().addClass(hiddenClass);
            showEmptyListMsg();
            return;
        }

        var requestedCountry = response.echo_req.paymentagent_list;
        var found = false;
        cList.map(function(country) {
            if(country === requestedCountry) {
                found = true;
            }
            insertListOption($ddlCountries, country[1], country[0]);
        });

        if(found) {
            $ddlCountries.val(requestedCountry);
            populateAgentsList(response.paymentagent_list.list);
        }
        else {
            sendRequest();
        }

        $ddlCountries.change(function() {
            sendRequest();
        });
    };

    var insertListOption = function($ddlObject, itemText, itemValue) {
        $ddlObject.append($('<option/>', {value: itemValue, text: itemText}));
    };

    // -----------------------
    // ----- Agents List -----
    // -----------------------
    var populateAgentsList = function(list) {
        if(!list || list.length === 0) {
            showEmptyListMsg();
            return;
        }

        showLoadingImage($paListContainer);

        var $accordion = $('<div/>', {id: 'accordion'});

        list.map(function(agent){
            var supported_banks = '';
            if(agent.supported_banks && agent.supported_banks.length > 0) {
                var banks = agent.supported_banks.split(',');
                banks.map(function(bank){
                    supported_banks += bank.length === 0 ? 
                        '' :
                        '<img src="' + page.url.url_for_static('images/pages/payment_agent/banks/' + bank.toLowerCase() + '.png') + '" alt="' + bank + '" title="' + bank + '" />';
                });
            }
        
            $accordion.append(
                agentTemplate
                    .replace(/%name/g                   , agent.name)
                    .replace(/%summary/g                , agent.summary)
                    .replace(/%deposit_commission/g     , agent.deposit_commission)
                    .replace(/%withdrawal_commission/g  , agent.withdrawal_commission)
                    .replace(/%url/g                    , agent.url)
                    .replace(/%email/g                  , agent.email)
                    .replace(/%telephone/g              , agent.telephone)
                    .replace(/%further_information/g    , agent.further_information)
                    .replace(/%supported_banks/g        , supported_banks)
            );
        });

        $paListContainer.empty().append($accordion);

        $('#accordion').accordion({
            heightStyle : 'content',
            collapsible : true,
            active      : false
        });
    };

    var showEmptyListMsg = function() {
        $('#no_paymentagent').removeClass(hiddenClass);
    };

    return {
        init: init,
        responseHandler: responseHandler
    };
}());



pjax_config_page("payment_agent_listws", function() {
    return {
        onLoad: function() {
            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "paymentagent_list") {
                            PaymentAgentListWS.responseHandler(response);
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });

            Content.populate();
            PaymentAgentListWS.init();
        }
    };
});
;var PaymentAgentWithdrawWS = (function() {
    "use strict";

    var containerID,
        viewIDs,
        fieldIDs,
        errorClass,
        $views;

    var formData,
        isValid;

    var withdrawCurrency,
        minAmount,
        maxAmount;

    var init = function() {
        containerID = '#paymentagent_withdrawal';
        $views      = $(containerID + ' .viewItem');
        errorClass  = 'errorfield';
        viewIDs = {
            error   : '#viewError',
            success : '#viewSuccess',
            confirm : '#viewConfirm',
            form    : '#viewForm'
        };
        fieldIDs = {
            verificationCode : '#verification-code',
            ddlAgents        : '#ddlAgents',
            txtAmount        : '#txtAmount',
            txtDesc          : '#txtDescription'
        };
        withdrawCurrency = 'USD';
        minAmount = 10;
        maxAmount = 2000;

        $views.addClass('hidden');

        if(page.client.is_virtual()) { // Virtual Account
            showPageError(text.localize('You are not authorized for withdrawal via payment agent.'));
            return false;
        }

        var residence = $.cookie('residence');
        BinarySocket.send({"paymentagent_list": residence});

        $(viewIDs.form + ' button').click(function(e){
            e.preventDefault();
            e.stopPropagation();
            formData = formValidate();
            if(!formData) {
                return false;
            }
            else {
                withdrawRequest(true);
            }
        });
    };

    // -----------------------
    // ----- Agents List -----
    // -----------------------
    var populateAgentsList = function(response) {
        var $ddlAgents = $(fieldIDs.ddlAgents);
        $ddlAgents.empty();
        var paList = response.paymentagent_list.list;
        if(paList.length > 0) {
            BinarySocket.send({verify_email:page.user.email, type:'paymentagent_withdraw'});
            insertListOption($ddlAgents, text.localize('Please select a payment agent'), '');
            for(var i = 0; i < paList.length; i++){
                insertListOption($ddlAgents, paList[i].name, paList[i].paymentagent_loginid);
            }
            setActiveView(viewIDs.form);
        }
        else {
            showPageError(text.localize('The Payment Agent facility is currently not available in your country.'));
        }
    };

    var insertListOption = function($ddlObject, itemText, itemValue) {
        $ddlObject.append($('<option/>', {value: itemValue, text: itemText}));
    };

    // ----------------------------
    // ----- Form Validations -----
    // ----------------------------
    var formValidate = function() {
        clearError();
        isValid = true;

        var agent  = $(fieldIDs.ddlAgents).val(),
            amount = $(fieldIDs.txtAmount).val().trim(),
            desc   = $(fieldIDs.txtDesc).val().trim(),
            token  = $(fieldIDs.verificationCode).val().trim();

        var letters = Content.localize().textLetters,
            numbers = Content.localize().textNumbers,
            space   = Content.localize().textSpace,
            period  = Content.localize().textPeriod,
            comma   = Content.localize().textComma;

        // Payment Agent
        isRequiredError(fieldIDs.ddlAgents);

        // verification token
        if(!isRequiredError(fieldIDs.verificationCode)){
          if (token.length !== 48) {
            showError(fieldIDs.verificationCode, Content.errorMessage('valid', text.localize('verification token')));
          }
        }

        // Amount
        if(!isRequiredError(fieldIDs.txtAmount)){
            if(!(/^\d+(\.\d+)?$/).test(amount) || !$.isNumeric(amount)) {
                showError(fieldIDs.txtAmount, Content.errorMessage('reg', [numbers]));
            }
            else if(!(/^\d+(\.\d{1,2})?$/).test(amount)) {
                showError(fieldIDs.txtAmount, text.localize('Only 2 decimal points are allowed.'));
            }
            else if(amount < minAmount) {
                showError(fieldIDs.txtAmount, text.localize('Invalid amount, minimum is') + ' ' + withdrawCurrency + ' ' + minAmount);
            }
            else if(amount > maxAmount) {
                showError(fieldIDs.txtAmount, text.localize('Invalid amount, maximum is') + ' ' + withdrawCurrency + ' ' + maxAmount);
            }
        }

        // Description
        if(!(/^[a-zA-Z0-9\s\.\,\-']*$/).test(desc)) {
            showError(fieldIDs.txtDesc, Content.errorMessage('reg', [letters, numbers, space, period, comma, '- \'']));
        }

        if(isValid) {
            return {
                agent             : agent,
                agentname         : $(fieldIDs.ddlAgents + ' option:selected').text(),
                currency          : withdrawCurrency,
                amount            : amount,
                desc              : desc,
                verificationCode : token
            };
        }
        else {
            return false;
        }
    };

    var isRequiredError = function(fieldID) {
        if(!$(fieldID).val() || !(/.+/).test($(fieldID).val().trim())){
            showError(fieldID, Content.errorMessage('req'));
            return true;
        } else {
            return false;
        }
    };

    var isCountError = function(fieldID, min, max) {
        var fieldValue = $(fieldID).val().trim();
        if((fieldValue.length > 0 && fieldValue.length < min) || fieldValue.length > max) {
            showError(fieldID, Content.errorMessage('range', '(' + min + '-' + max + ')'));
            return true;
        } else {
            return false;
        }
    };

    // ----------------------------
    // ----- Withdraw Process -----
    // ----------------------------
    var withdrawRequest = function(isDryRun) {
        var dry_run = isDryRun ? 1 : 0;
        BinarySocket.send({
            "paymentagent_withdraw" : 1,
            "paymentagent_loginid"  : formData.agent,
            "currency"              : formData.currency,
            "amount"                : formData.amount,
            "description"           : formData.desc,
            "dry_run"               : dry_run,
            "verification_code"     : formData.verificationCode
        });
    };

    var withdrawResponse = function(response) {
        var responseCode = response.paymentagent_withdraw;
        switch(responseCode){
            case 2: // dry_run success: showing the confirmation page
                setActiveView(viewIDs.confirm);

                $('#lblAgentName').text(formData.agentname);
                $('#lblCurrency').text(formData.currency);
                $('#lblAmount').text(formData.amount);

                $(viewIDs.confirm + ' #btnConfirm').click(function(){
                    withdrawRequest(false);
                });
                $(viewIDs.confirm + ' #btnBack').click(function(){
                    setActiveView(viewIDs.form);
                });
                break;

            case 1: // withdrawal success
                setActiveView(viewIDs.success);
                $('#successMessage').css('display', '')
                    .attr('class', 'success-msg')
                    .html(
                        '<ul class="checked"><li>' +
                        text.localize('Your request to withdraw [_1] [_2] from your account [_3] to Payment Agent [_4] account has been successfully processed.')
                            .replace('[_1]', formData.currency)
                            .replace('[_2]', formData.amount)
                            .replace('[_3]', $.cookie('loginid'))
                            .replace('[_4]', formData.agentname) +
                        '</li></ul>'
                    );
                break;

            default: // error
                if(response.echo_req.dry_run === 1) {
                    setActiveView(viewIDs.form);
                    $('#formMessage').css('display', '')
                        .attr('class', errorClass)
                        .html(response.error.message);
                } else if (response.error.code === 'InvalidToken') {
                    showPageError(Content.localize().textClickHereToRestart.replace('[_1]', page.url.url_for('paymentagent/withdrawws')));
                } else {
                    showPageError(response.error.message);
                }
                break;
        }
    };

    // -----------------------------
    // ----- Message Functions -----
    // -----------------------------
    var showPageError = function(errMsg, noticeMsg) {
        setActiveView(viewIDs.error);
        $(viewIDs.error + ' > p').html(errMsg);
        if (noticeMsg) {
          $(viewIDs.error).append($('<p/>', {html: noticeMsg}));
        }
    };

    var showError = function(fieldID, errMsg) {
        $(fieldID).parent().append($('<p/>', {class: errorClass, text: errMsg}));
        isValid = false;
    };

    var clearError = function(fieldID) {
        $(fieldID ? fieldID : viewIDs.form + ' .' + errorClass).remove();
    };

    // ----- View Control -----
    var setActiveView = function(viewID) {
        $views.addClass('hidden');
        $(viewID).removeClass('hidden');
    };


    return {
        init: init,
        populateAgentsList: populateAgentsList,
        withdrawResponse: withdrawResponse
    };
}());



pjax_config_page("paymentagent/withdrawws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }
            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        var type = response.msg_type;
                        switch(type){
                            case "authorize":
                                PaymentAgentWithdrawWS.init();
                                break;
                            case "paymentagent_list":
                                PaymentAgentWithdrawWS.populateAgentsList(response);
                                break;
                            case "paymentagent_withdraw":
                                PaymentAgentWithdrawWS.withdrawResponse(response);
                                break;
                            default:
                                break;
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });

            Content.populate();
            if(TUser.get().hasOwnProperty('is_virtual')) {
                PaymentAgentWithdrawWS.init();
            }
        }
    };
});
;var securityws = (function(){
    "use strict";
    var $form,
        init_done;

    var clearErrors = function(){
        $("#SecuritySuccessMsg").text('');
        $("#invalidinputfound").text('');
        $('#errorcashierlockpassword1').contents().filter(function () {
          return this.nodeType === 3;
        }).remove();
    };

    var init = function(){
        init_done = true;

        $form   = $("#changeCashierLock");

        clearErrors();

        if(page.client.is_virtual()) {
            $form.hide();
            $('#SecuritySuccessMsg').addClass('notice-msg center').text(Content.localize().textFeatureUnavailable);
            return;
        }

        $form   = $("#changeCashierLock");
        clearErrors();

        var loginToken = CommonData.getApiToken();
        $form.find("button").on("click", function(e){
            e.preventDefault();
            e.stopPropagation();
            if(validateForm() === false){
                return false;
            }
            BinarySocket.send({"authorize": loginToken, "passthrough": {"value": $(this).attr("value") === "Update" ? "lock_password" : "unlock_password"}});
        });
        BinarySocket.send({"authorize": loginToken, "passthrough": {"value": "is_locked"}});
    };

    var validateForm = function(){
        var isValid = true;
        clearErrors();

        var pwd1 = document.getElementById("cashierlockpassword1").value,
            pwd2 = document.getElementById("cashierlockpassword2").value,
            errorPassword = document.getElementById('errorcashierlockpassword1'),
            errorRPassword = document.getElementById('errorcashierlockpassword2'),
            isVisible = $("#repasswordrow").is(':visible');

        if(isVisible === true){
          if (!Validate.errorMessagePassword(pwd1, pwd2, errorPassword, errorRPassword)){
            isValid = false;
          }
        } else if (!/[ -~]{6,25}/.test(pwd1)) {
          errorPassword.textContent = Content.errorMessage('min', 6);
          isValid = false;
        }
        return isValid;
    };
    var isAuthorized =  function(response){
        if(response.echo_req.passthrough){
            var option = response.echo_req.passthrough.value;
            var pwd = $("#cashierlockpassword1").val();

            switch(option){
                case   "lock_password" :
                        BinarySocket.send({
                            "cashier_password": "1",
                            "lock_password": pwd
                        });
                        break;
                case   "unlock_password" :
                        BinarySocket.send({
                            "cashier_password": "1",
                            "unlock_password": pwd
                        });
                        break;
                case   "is_locked" :
                        BinarySocket.send({
                            "cashier_password": "1",
                            "passthrough" : {"value" : "lock_status"}
                        });
                        break ;
                default:
                        if(!init_done) {
                            init();
                        }
                        break;
            }
        }
    };
    var responseMessage = function(response){

       var resvalue;

       if(response.echo_req.passthrough && (response.echo_req.passthrough.value === "lock_status") ){
            var passthrough = response.echo_req.passthrough.value;
            resvalue = response.cashier_password;
            if(parseInt(resvalue) === 1){
                $("#repasswordrow").hide();
                $("legend").text(text.localize("Unlock Cashier"));
                $("#lockInfo").text(text.localize("Your cashier is locked as per your request - to unlock it, please enter the password."));
                $form.find("button").attr("value","Unlock Cashier");
                $form.find("button").html(text.localize("Unlock Cashier"));
                $('#changeCashierLock').show();
            }
            else if(parseInt(resvalue) === 0){
                $("#repasswordrow").show();
                $("legend").text(text.localize("Lock Cashier"));
                $("#lockInfo").text(text.localize("An additional password can be used to restrict access to the cashier."));
                $form.find("button").attr("value","Update");
                $form.find("button").html(text.localize("Update"));
                $('#password-meter-div').attr('style', 'display:block');
                if (isIE() === false) {
                  $('#cashierlockpassword1').on('input', function() {
                    $('#password-meter').attr('value', testPassword($('#cashierlockpassword1').val())[0]);
                  });
                } else {
                  $('#password-meter').remove();
                }
                $('#changeCashierLock').show();
            }
        }
        else{
            if("error" in response) {
                if("message" in response.error) {
                    $("#invalidinputfound").text(text.localize(response.error.message));
                }
                return false;
            }
            else{
                resvalue = response.echo_req.cashier_password;
                if(parseInt(resvalue) === 1){
                    $("#changeCashierLock").hide();
                    $("#invalidinputfound").text('');
                    $("#SecuritySuccessMsg").text(text.localize('Your settings have been updated successfully.'));
                }
                else{
                    $("#invalidinputfound").text(text.localize('Sorry, an error occurred while processing your account.'));
                    return false;
                }
            }
        }
        return;
    };
    var SecurityApiResponse = function(response){
        var type = response.msg_type;
        if (type === "cashier_password" || (type === "error" && "cashier_password" in response.echo_req)){
           responseMessage(response);

        }else if(type === "authorize" || (type === "error" && "authorize" in response.echo_req))
        {
            isAuthorized(response);
        }
    };

    return {
        init : init,
        SecurityApiResponse : SecurityApiResponse
    };
})();

pjax_config_page("user/settings/securityws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

            Content.populate();

            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);
                    if (response) {
                        securityws.SecurityApiResponse(response);
                    }
                }
            });

            if(page.client.get_storage_value('is_virtual').length > 0) {
                securityws.init();
            }
        }
    };
});
;var TopUpVirtualWS = (function() {
	"use strict";

    var containerID,
        viewIDs,
        hiddenClass,
        $views;

    var init = function() {
        containerID = '#topup_virtual';
        hiddenClass = 'hidden';
        $views      = $(containerID + ' .viewItem');
        viewIDs = {
            error   : '#viewError',
            success : '#viewSuccess'
        };

        $views.addClass('hidden');

        if(!page.client.is_virtual()) {
            showMessage(text.localize('Sorry, this feature is available to virtual accounts only.'), false);
        }
        else {
            BinarySocket.send({"topup_virtual": "1"});
        }
    };

    var responseHandler = function(response) {
    	var str, amt , currType;
	 	if('error' in response) {
            if('message' in response.error) {
                showMessage(text.localize(response.error.message), false);
            }
        }
        else{
            showMessage(
                text.localize('[_1] [_2] has been credited to your Virtual money account [_3]')
                    .replace('[_1]', response.topup_virtual.currency)
                    .replace('[_2]', response.topup_virtual.amount)
                    .replace('[_3]', page.client.loginid),
                true);
        }
    };

    var showMessage = function(message, isSuccess) {
        var viewID = isSuccess ? viewIDs.success : viewIDs.error;
        setActiveView(viewID);
        $(viewID + ' > p').html(message);
    };

    var setActiveView = function(viewID) {
        $views.addClass(hiddenClass);
        $(viewID).removeClass(hiddenClass);
    };


    return {
    	init: init,
    	responseHandler: responseHandler
    };
}());


pjax_config_page("top_up_virtualws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }

        	BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);
                    if (response) {
                        if (response.msg_type === "authorize") {
                            TopUpVirtualWS.init();
                        }
                        else if (response.msg_type === "topup_virtual") {
                            TopUpVirtualWS.responseHandler(response);
                        }
                    }
                    else {
                        console.log('some error occured');
                    }
                }
            });

            Content.populate();
            if(TUser.get().hasOwnProperty('is_virtual')) {
                TopUpVirtualWS.init();
            }
        }
    };
});
;var Button = (function(){
    "use strict";
    function createBinaryStyledButton(){
        var span = $("<span></span>", {class: "button"});
        var button = $("<button></button>", {class: "button"});
        span.append(button);

        return span;
    }

    return {
        createBinaryStyledButton: createBinaryStyledButton
    };
}());
;var CommonData = (function(){
    function getCookieItem(sKey) {
        if (!sKey) { return null; }
        return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
    }
    
    //because getCookieItem('login') is confusing and does not looks like we are getting API token
    function getApiToken(){
        return getCookieItem("login");
    }

    return {
        getCookieItem: getCookieItem,
        getApiToken: getApiToken
    };
}());;function onlyNumericOnKeypress(ev) {
    var key = ev.keyCode;
    var char = String.fromCharCode(ev.which);
    if(
        (char === '.' && ev.target.value.indexOf(char) >= 0) ||
        (!/[0-9\.]/.test(char) && [8, 37, 39, 46].indexOf(key) < 0) || // delete, backspace, arrow keys
        /['%]/.test(char)) { // similarity to arrows key code in some browsers

        ev.returnValue = false;
        ev.preventDefault();
    }
}
;var PasswordMeter = (function(){
    'use strict';

    /**
     * attach password meter to DOM
     * @param $container       container for password meter, can be a p or div
     * @param id               optional id for meter element
     */
    function attach($container) {
        if (isIE()) return;
        var $meter = $('<meter></meter>', {id: 'password-meter', min: 0, max: 50, high: 20, low: 10, optimum: 50});
        $container
            .append($meter);
    }

    /**
     * Update password meter
     * @param $container        container for password meter, can be a p or div
     * @param newPW
     */
    function updateMeter($container, newPW) {
        var pwStrength = testPassword(newPW);
        var pwStrengthScore = pwStrength[0];

        $container.children('meter').val(pwStrengthScore);
    }

    return {
        attach: attach,
        updateMeter: updateMeter
    };
}());
;
var StringUtil = (function(){
    function toTitleCase(str){
        return str.replace(/\w[^\s\/\\]*/g, function(txt){
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
    }

    function dateToStringWithoutTime(date){
        return [date.getDate(), date.getMonth()+1, date.getFullYear()].join("/");
    }

    //Time should be in SECOND !!!
    function timeStampToDateString(time){
        var dateObj = new Date(time * 1000);
        var momentObj = moment.utc(dateObj);
        return momentObj.format("YYYY-MM-DD");
    }

    //Time should be in SECOND !!!
    function timeStampToTimeString(time){
        var dateObj = new Date(time * 1000);
        var momentObj = moment.utc(dateObj);
        return momentObj.format("HH:mm:ss");
    }

    //Time should be in SECOND !!!
    function timeStampToDateTimeString(time){
        var dateObj = new Date(time * 1000);
        var momentObj = moment.utc(dateObj);
        return momentObj.toString();
    }

    return {
        toTitleCase: toTitleCase,
        dateToStringWithoutTime: dateToStringWithoutTime,
        unixTimeToDateString: timeStampToDateString,
        unixTimeToTimeString: timeStampToTimeString,
        unixTimeToDateTimeString: timeStampToDateTimeString
    };
}());

;
var Table = (function(){
    "use strict";
    /***
     *
     * @param {Array[]} data ordered data to pump into table body
     * @param {Object} metadata object containing metadata of table
     * @param {String[]} metadata.cols cols of table
     * @param {String} metadata.id table id
     * @param {String[]} [metadata.tableClass] class used in html
     * @param {String[]} [header] string to be used as Header in table, if not stated then table will not have Header
     * @param {String[]} [footer] string to be used as footer, to have empty footer, simply use an empty element in array
     * eg. ["", "halo", ""] will have 3 elements in footer, 2 of them being empty
     */
    function createFlexTable(body, metadata, header, footer){

        var tableClasses = (metadata.tableClass) ? metadata.tableClass + " flex-table" : "flex-table";

        var $tableContainer = $("<div></div>", {class: "flex-table-container"});
        var $table = $("<table></table>", {class: tableClasses, id: metadata.id});
        var $body = createFlexTableTopGroup(body, metadata.cols, "body");

        if (header) {
            var $header = createFlexTableTopGroup([header], metadata.cols, "header");
            $header.appendTo($table);
        }

        $body.appendTo($table);

        if (footer) {
            var $footer = createFlexTableTopGroup([footer], metadata.cols, "footer");
            $footer.appendTo($table);
        }

        $table.appendTo($tableContainer);

        return $tableContainer;
    }

    /***
     *
     * @param {object[][]} data header strings
     * @param {String[]} metadata cols name
     * @param {"header"\"footer"|"body"} opt optional arg to specify which type of element to create, default to header
     */
    function createFlexTableTopGroup(data, metadata, opt){

        var $outer = function(){
            switch (opt) {
                case "body":
                    return $("<tbody></tbody>");
                case "footer":
                    return $("<tfoot></tfoot>");
                default :
                    return $("<thead></thead>");
            }
        }();

        for (var i = 0 ; i < data.length ; i++){
            var innerType = (opt === "body") ? "data" : "header";
            var $tr = createFlexTableRow(data[i], metadata, innerType);
            $tr.appendTo($outer);
        }

        return $outer;
    }

    /***
     *
     * @param {object[]} data
     * @param {String[]} metadata cols name
     * @param {"header"|"data"} opt optional, default to "header"
     */
    function createFlexTableRow(data, metadata, opt){
        if (data.length !== metadata.length) {
            throw new Error("metadata and data does not match");
        }

        var isData = (opt === "data");

        var $tr = $("<tr></tr>", {class: "flex-tr"});
        for (var i = 0 ; i < data.length ; i++){
            var className = metadata[i].toLowerCase().replace(/\s/g, "-") + " flex-tr-child";
            var rowElement = (isData) ?
                $("<td></td>", {class: className, text: data[i]}) :
                $("<th></th>", {class: className, text: data[i]});
            rowElement.appendTo($tr);
        }

        return $tr;
    }

    function clearTableBody(id){
        var tbody = document.querySelector("#" + id +">tbody");
        while (tbody && tbody.firstElementChild){
            tbody.removeChild(tbody.firstElementChild);
        }
    }

    /***
     *
     * @param {String} id table id
     * @param {Object[]} data array of data to be transform to row
     * @param {Function} rowGenerator takes in one arg, and convert it into row to be append to table body
     */
    function appendTableBody(id, data, rowGenerator){
        var tbody = document.querySelector("#" + id +">tbody");
        var docFrag = document.createDocumentFragment();
        data.map(function(ele){
            var row = rowGenerator(ele);
            docFrag.appendChild(row);
        });

        tbody.appendChild(docFrag);
    }

    /***
     *
     * @param {String} id table id
     * @param {Object[]} data array of data to be transform to row
     * @param {Function} rowGenerator takes in one arg, and convert it into row to be append to table body
     */
    function overwriteTableBody(id, data, rowGenerator){
        clearTableBody(id);
        appendTableBody(id, data, rowGenerator);
    }

    return {
        createFlexTable: createFlexTable,
        createFlexTableRow: createFlexTableRow,
        overwriteTableBody: overwriteTableBody,
        clearTableBody: clearTableBody,
        appendTableBody: appendTableBody
    };
}());
;var ValidAccountOpening = (function(){
  var redirectCookie = function() {
    if (page.client.redirect_if_logout()) {
        return;
    }
    if (!page.client.is_virtual()) {
      window.location.href = page.url.url_for('user/my_accountws');
      return;
    }
    for (i = 0; i < page.user.loginid_array.length; i++){
      if (page.user.loginid_array[i].real === true){
        window.location.href = page.url.url_for('user/my_accountws');
        return;
      }
    }
  };
  var handler = function(response, message) {
    if (response.error) {
      var errorMessage = response.error.message;
      if (response.error.code === 'show risk disclaimer' && document.getElementById('financial-form')) {
        $('#financial-form').addClass('hidden');
        $('#financial-risk').removeClass('hidden');
        return;
      }
      if (document.getElementById('real-form')) {
        $('#real-form').remove();
      } else if (document.getElementById('japan-form')) {
        $('#japan-form').remove();
      } else if (document.getElementById('financial-form')) {
        $('#financial-form').remove();
        $('#financial-risk').remove();
      }
      var error = document.getElementsByClassName('notice-msg')[0];
      error.innerHTML = (response.msg_type === 'sanity_check') ? text.localize('There was some invalid character in an input field.') : errorMessage;
      error.parentNode.parentNode.parentNode.setAttribute('style', 'display:block');
      return;
    } else if (getCookieItem('residence') === 'jp') {
      window.location.href = page.url.url_for('new_account/knowledge_testws');
      $('#topbar-msg').children('a').addClass('invisible');
    } else {     // jp account require more steps to have real account
      var loginid = message.client_id;
      // set a flag to push to gtm in my_account
      localStorage.setItem('new_account', '1');
      //generate dropdown list and switch
      page.client.clear_storage_values();
      var option = new Option('Real Account (' + loginid + ')', loginid);
      document.getElementById('client_loginid').appendChild(option);
      $('#client_loginid option[value="' + page.client.loginid + '"]').removeAttr('selected');
      option.setAttribute('selected', 'selected');
      $('#loginid-switch-form').submit();
    }
  };
  var letters, numbers, space, hyphen, period, apost;

  var initializeValues = function() {
    letters = Content.localize().textLetters;
    numbers = Content.localize().textNumbers;
    space   = Content.localize().textSpace;
    hyphen  = Content.localize().textHyphen;
    period  = Content.localize().textPeriod;
    apost   = Content.localize().textApost;
  };

  var checkFname = function(fname, errorFname) {
    if (Trim(fname.value).length < 2) {
      errorFname.innerHTML = Content.errorMessage('min', '2');
      Validate.displayErrorMessage(errorFname);
      window.accountErrorCounter++;
    } else if (!/^[a-zA-Z\s-.']+$/.test(fname.value)){
      initializeValues();
      errorFname.innerHTML = Content.errorMessage('reg', [letters, space, hyphen, period, apost]);
      Validate.displayErrorMessage(errorFname);
      window.accountErrorCounter++;
    }
    return;
  };
  var checkLname = function(lname, errorLname) {
    if (Trim(lname.value).length < 2) {
      errorLname.innerHTML = Content.errorMessage('min', '2');
      Validate.displayErrorMessage(errorLname);
      window.accountErrorCounter++;
    } else if (!/^[a-zA-Z\s-.']+$/.test(lname.value)){
      initializeValues();
      errorLname.innerHTML = Content.errorMessage('reg', [letters, space, hyphen, period, apost]);
      Validate.displayErrorMessage(errorLname);
      window.accountErrorCounter++;
    }
    return;
  };
  var checkDate = function(dobdd, dobmm, dobyy, errorDob) {
    if (!isValidDate(dobdd.value, dobmm.value, dobyy.value) || dobdd.value === '' || dobmm.value === '' || dobyy.value === '') {
      errorDob.innerHTML = Content.localize().textErrorBirthdate;
      Validate.displayErrorMessage(errorDob);
      window.accountErrorCounter++;
    }
    return;
  };
  var checkPostcode = function(postcode, errorPostcode) {
    if (postcode.value !== '' && !/^[a-zA-Z\d-]+$/.test(postcode.value)){
      initializeValues();
      errorPostcode.innerHTML = Content.errorMessage('reg', [letters, numbers, hyphen]);
      Validate.displayErrorMessage(errorPostcode);
      window.accountErrorCounter++;
    }
    return;
  };
  var checkTel = function(tel, errorTel) {
    if (tel.value.replace(/\+| /g,'').length < 6) {
      errorTel.innerHTML = Content.errorMessage('min', 6);
      Validate.displayErrorMessage(errorTel);
      window.accountErrorCounter++;
    } else if (!/^\+?[0-9\s]{6,35}$/.test(tel.value)){
      initializeValues();
      errorTel.innerHTML = Content.errorMessage('reg', [numbers, space]);
      Validate.displayErrorMessage(errorTel);
      window.accountErrorCounter++;
    }
    return;
  };
  var checkAnswer = function(answer, errorAnswer) {
    if (answer.value.length < 4) {
      errorAnswer.innerHTML = Content.errorMessage('min', 4);
      Validate.displayErrorMessage(errorAnswer);
      window.accountErrorCounter++;
    }
    return;
  };
  return {
    redirectCookie: redirectCookie,
    handler: handler,
    checkFname: checkFname,
    checkLname: checkLname,
    checkDate: checkDate,
    checkPostcode: checkPostcode,
    checkTel: checkTel,
    checkAnswer: checkAnswer
  };
}());
;var Validate = (function(){
  var errorCounter = 0;

  //give DOM element of error to display
  function displayErrorMessage(error){
    error.setAttribute('style', 'display:block');
  }

  //give DOM element or error to hide
  function hideErrorMessage(error){
    error.setAttribute('style', 'display:none');
    var errorMessage = $('.error-message-password');
    if (errorMessage){
      errorMessage.remove();
    }
  }

  function handleError(error, text){
    var par = document.createElement('p'),
        re = new RegExp(text),
        allText = '';
    par.className = 'error-message-password';
    var parClass = $('.' + par.className);
    if (parClass.length > 1) {
      for (i = 0; i < parClass.length; i++){
        allText = allText + parClass[i].textContent;
      }
      if (!re.test(allText)){
        par.innerHTML = par.innerHTML + ' ' + text;
      }
    } else {
      par.innerHTML = text;
    }
    error.appendChild(par);
    displayErrorMessage(error);
  }

  //check validity of token
  function validateToken(token) {
    if (token.length == 48) {
      return true;
    }
    return false;
  }

  //give error message for invalid email, needs DOM element of error and value of email
  function errorMessageEmail(email, error) {
    if (email === "") {
      error.textContent = Content.errorMessage('req');
      displayErrorMessage(error);
      return true;
    } else if (!validateEmail(email)) {
      error.textContent = Content.errorMessage('valid', text.localize('email address'));
      displayErrorMessage(error);
      return true;
    }
    hideErrorMessage(error);
    return false;
  }

  //give error message for invalid verification token, needs DOM element of error and value of verification token
  function errorMessageToken(token, error) {
    if (token === "") {
      error.textContent = Content.errorMessage('req');
      displayErrorMessage(error);
      return true;
    } else if (!validateToken(token)) {
      error.textContent = Content.errorMessage('valid', text.localize('verification token'));
      displayErrorMessage(error);
      return true;
    }
    hideErrorMessage(error);
    return false;
  }

  function passwordNotEmpty(password, error){
    if (!/^.+$/.test(password)) {
      handleError(error, Content.errorMessage('req'));
      return errorCounter++;
    }
    return true;
  }

  function fieldNotEmpty(field, error){
    if (!/^.+$/.test(field)) {
      error.textContent = Content.errorMessage('req');
      displayErrorMessage(error);
      return errorCounter++;
    }
    return true;
  }

  function passwordMatching(password, rPassword, rError){
    if (password !== rPassword) {
      rError.textContent = Content.localize().textPasswordsNotMatching;
      displayErrorMessage(rError);
      return errorCounter++;
    }
    return true;
  }

  function passwordLength(password, error){
    if (password.length < 6 || password.length > 25) {
      handleError(error, Content.errorMessage('range', '6-25'));
      return errorCounter++;
    }
    return true;
  }

  function passwordChars(password, error){
    if (/[0-9]+/.test(password) && /[A-Z]+/.test(password) && /[a-z]+/.test(password)) {
      return true;
    }
    handleError(error, text.localize('Password should have lower and uppercase letters with numbers.'));
    return errorCounter++;
  }

  function passwordValid(password, error){
    if (!/^[!-~]+$/.test(password)) {
      handleError(error, Content.errorMessage('valid', Content.localize().textPassword));
      return errorCounter++;
    }
    return true;
  }

  function passwordStrong(password, error){
    var tooltipPassword = document.getElementById('tooltip-password');
    tooltipPassword.setAttribute('style', 'display:none');
    if (testPassword(password)[0] < 20) {
      displayErrorMessage(error);
      return errorCounter++;
    }
    return true;
  }

  //give error message for invalid password, needs value of password, repeat of password, and DOM element of error
  /**
   *
   * @param password      password
   * @param rPassword     confirm password
   * @param error         dom to show error for password (not jquery!)
   * @param rError        dom to show error for confirm password (not jquery!)
   * @returns {boolean}
     */
  function errorMessagePassword(password, rPassword, error, rError) {
    hideErrorMessage(error);
    hideErrorMessage(rError);
    errorCounter = 0;

    if (passwordNotEmpty(password, error) === true){
      passwordLength(password, error);
      passwordChars(password, error);
      passwordValid(password, error);
      if (fieldNotEmpty(rPassword, rError) === true){
        passwordMatching(password, rPassword, rError);
      }
    } else {
      fieldNotEmpty(rPassword, rError);
    }

    if (errorCounter === 0){
      return true;
    }
    return false;
  }

  function errorMessageResidence(residence, error) {
    hideErrorMessage(error);
    if (residence === ""){
      error.textContent = Content.errorMessage('req');
      displayErrorMessage(error);
      return true;
    }
    return false;
  }

  return {
    displayErrorMessage: displayErrorMessage,
    hideErrorMessage: hideErrorMessage,
    errorMessageEmail: errorMessageEmail,
    errorMessagePassword: errorMessagePassword,
    fieldNotEmpty: fieldNotEmpty,
    errorMessageResidence: errorMessageResidence,
    errorMessageToken: errorMessageToken
  };
}());

function validateEmail(mail) {
  if (/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$/.test(mail)){
    return true;
  }
  return false;
}

function passwordValid(password) {
  if (password.length > 25) {
    return false;
  }

  var r = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{6,25}$/;
  return r.test(password);
}

/**
 * Use this if you want to separate validation logic with UI
 * Use Validate.errorMessagePassword if you want to handle UI with validation together
 * @param password      password
 * @returns {Array}     array of error message, can be empty
 */
function showPasswordError(password) {
  var errMsgs = [];
  if (password.length < 6 || password.length > 25) {
    errMsgs.push(Content.errorMessage('range', '6-25'));
  }

  var hasUpperLowerDigitRegex = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z])/;
  if (!hasUpperLowerDigitRegex.test(password)) {
    errMsgs.push(text.localize('Password should have lower and uppercase letters with numbers.'));
  }

  return errMsgs;
}
;pjax_config_page("new_account/maltainvestws", function(){
  return {
    onLoad: function() {
      Content.populate();
      if (page.client.redirect_if_logout()) {
          return;
      }
      for (i = 0; i < page.user.loginid_array.length; i++){
        if (page.user.loginid_array[i].financial){
          window.location.href = page.url.url_for('user/my_accountws');
          return;
        } else if (page.user.loginid_array[i].non_financial){
          $('.security').hide();
        }
      }
      handle_residence_state_ws();
      BinarySocket.send({residence_list:1});
      BinarySocket.send({get_settings:1});
      $('#financial-form').submit(function(evt) {
        evt.preventDefault();
        if (FinancialAccOpeningUI.checkValidity()){
          BinarySocket.init({
            onmessage: function(msg){
              var response = JSON.parse(msg.data);
              if (response) {
                var error = response.error;
                if (response.msg_type === 'new_account_maltainvest'){
                  ValidAccountOpening.handler(response, response.new_account_maltainvest);
                }
              }
            }
          });
        }
      });
      $('#financial-risk').submit(function(evt) {
        evt.preventDefault();
        window.acceptRisk = true;
        if (FinancialAccOpeningUI.checkValidity()){
          BinarySocket.init({
            onmessage: function(msg){
              var response = JSON.parse(msg.data);
              if (response) {
                if (response.msg_type === 'new_account_maltainvest'){
                  ValidAccountOpening.handler(response, response.new_account_maltainvest);
                }
              }
            }
          });
        }
      });
    }
  };
});
;var FinancialAccOpeningData = (function(){
    function getRealAcc(elementObj){
        var req = {
            new_account_maltainvest: 1,
            salutation: elementObj['title'].value,
            first_name: elementObj['fname'].value,
            last_name: elementObj['lname'].value,
            date_of_birth: elementObj['dobyy'].value + '-' + elementObj['dobmm'].value + '-' + elementObj['dobdd'].value,
            residence: elementObj['residence'].value,
            address_line_1: elementObj['address1'].value,
            address_line_2: elementObj['address2'].value,
            address_city: elementObj['town'].value,
            address_state: elementObj['state'].value,
            address_postcode: elementObj['postcode'].value,
            phone: elementObj['tel'].value,
            forex_trading_experience: elementObj['forexExperience'].value,
            forex_trading_frequency: elementObj['forexFrequency'].value,
            indices_trading_experience: elementObj['indicesExperience'].value,
            indices_trading_frequency: elementObj['indicesFrequency'].value,
            commodities_trading_experience: elementObj['commoditiesExperience'].value,
            commodities_trading_frequency: elementObj['commoditiesFrequency'].value,
            stocks_trading_experience: elementObj['stocksExperience'].value,
            stocks_trading_frequency: elementObj['stocksFrequency'].value,
            other_derivatives_trading_experience: elementObj['binaryExperience'].value,
            other_derivatives_trading_frequency: elementObj['binaryFrequency'].value,
            other_instruments_trading_experience: elementObj['otherExperience'].value,
            other_instruments_trading_frequency: elementObj['otherFrequency'].value,
            employment_industry: elementObj['employment'].value,
            education_level: elementObj['education'].value,
            income_source: elementObj['incomeSource'].value,
            net_income: elementObj['income'].value,
            estimated_worth: elementObj['netWorth'].value
        };

        if ($.cookie('affiliate_tracking')) {
          req.affiliate_token = JSON.parse($.cookie('affiliate_tracking')).t;
        }

        if (elementObj['answer'].value !== '') {
          req.secret_question = elementObj['question'].value;
          req.secret_answer = elementObj['answer'].value;
        }

        if (window.acceptRisk) {
          req.accept_risk = 1;
        } else {
          req.accept_risk = 0;
        }

        BinarySocket.send(req);
    }

    return {
        getRealAcc: getRealAcc
    };
}());
;var FinancialAccOpeningUI = (function(){
  "use strict";

  function checkValidity(){
    window.accountErrorCounter = 0;

    var letters = Content.localize().textLetters,
        numbers = Content.localize().textNumbers,
        space   = Content.localize().textSpace,
        hyphen  = Content.localize().textHyphen,
        period  = Content.localize().textPeriod,
        apost   = Content.localize().textApost;

    var elementObj = {
        title                    : document.getElementById('title'),
        fname                    : document.getElementById('fname'),
        lname                    : document.getElementById('lname'),
        dobdd                    : document.getElementById('dobdd'),
        dobmm                    : document.getElementById('dobmm'),
        dobyy                    : document.getElementById('dobyy'),
        residence                : document.getElementById('residence-disabled'),
        address1                 : document.getElementById('address1'),
        address2                 : document.getElementById('address2'),
        town                     : document.getElementById('address-town'),
        state                    : document.getElementById('address-state'),
        postcode                 : document.getElementById('address-postcode'),
        tel                      : document.getElementById('tel'),
        question                 : document.getElementById('secret-question'),
        answer                   : document.getElementById('secret-answer'),
        tnc                      : document.getElementById('tnc'),
        forexExperience          : document.getElementById('forex-trading-experience'),
        forexFrequency           : document.getElementById('forex-trading-frequency'),
        indicesExperience        : document.getElementById('indices-trading-experience'),
        indicesFrequency         : document.getElementById('indices-trading-frequency'),
        commoditiesExperience    : document.getElementById('commodities-trading-experience'),
        commoditiesFrequency     : document.getElementById('commodities-trading-frequency'),
        stocksExperience         : document.getElementById('stocks-trading-experience'),
        stocksFrequency          : document.getElementById('stocks-trading-frequency'),
        binaryExperience         : document.getElementById('other-derivatives-trading-experience'),
        binaryFrequency          : document.getElementById('other-derivatives-trading-frequency'),
        otherExperience          : document.getElementById('other-instruments-trading-experience'),
        otherFrequency           : document.getElementById('other-instruments-trading-frequency'),
        employment               : document.getElementById('employment-industry'),
        education                : document.getElementById('education-level'),
        incomeSource             : document.getElementById('income-source'),
        income                   : document.getElementById('net-income'),
        netWorth                 : document.getElementById('estimated-worth')
    };

    var errorObj = {
        title                    : document.getElementById('error-title'),
        fname                    : document.getElementById('error-fname'),
        lname                    : document.getElementById('error-lname'),
        dobdd                    : document.getElementById('error-birthdate'),
        dobmm                    : document.getElementById('error-birthdate'),
        dobyy                    : document.getElementById('error-birthdate'),
        residence                : document.getElementById('error-residence'),
        address1                 : document.getElementById('error-address1'),
        address2                 : document.getElementById('error-address2'),
        town                     : document.getElementById('error-town'),
        state                    : document.getElementById('error-state'),
        postcode                 : document.getElementById('error-postcode'),
        tel                      : document.getElementById('error-tel'),
        question                 : document.getElementById('error-question'),
        answer                   : document.getElementById('error-answer'),
        tnc                      : document.getElementById('error-tnc'),
        forexExperience          : document.getElementById('error-forex-trading-experience'),
        forexFrequency           : document.getElementById('error-forex-trading-frequency'),
        indicesExperience        : document.getElementById('error-indices-trading-experience'),
        indicesFrequency         : document.getElementById('error-indices-trading-frequency'),
        commoditiesExperience    : document.getElementById('error-commodities-trading-experience'),
        commoditiesFrequency     : document.getElementById('error-commodities-trading-frequency'),
        stocksExperience         : document.getElementById('error-stocks-trading-experience'),
        stocksFrequency          : document.getElementById('error-stocks-trading-frequency'),
        binaryExperience         : document.getElementById('error-other-derivatives-trading-experience'),
        binaryFrequency          : document.getElementById('error-other-derivatives-trading-frequency'),
        otherExperience          : document.getElementById('error-other-instruments-trading-experience'),
        otherFrequency           : document.getElementById('error-other-instruments-trading-frequency'),
        employment               : document.getElementById('error-employment-industry'),
        education                : document.getElementById('error-education-level'),
        incomeSource             : document.getElementById('error-income-source'),
        income                   : document.getElementById('error-net-income'),
        netWorth                 : document.getElementById('error-estimated-worth')
    };

    var key;
    for (key in errorObj) {
      if (errorObj[key].offsetParent !== null) {
        errorObj[key].setAttribute('style', 'display:none');
      }
    }

    ValidAccountOpening.checkFname(elementObj['fname'], errorObj['fname']);
    ValidAccountOpening.checkLname(elementObj['lname'], errorObj['lname']);
    ValidAccountOpening.checkDate(elementObj['dobdd'], elementObj['dobmm'], elementObj['dobyy'], errorObj['dobdd']);
    ValidAccountOpening.checkPostcode(elementObj['postcode'], errorObj['postcode']);

    if (elementObj['residence'].value === 'gb' && /^$/.test(Trim(elementObj['postcode'].value))){
      errorPostcode.innerHTML = Content.errorMessage('req');
      Validate.displayErrorMessage(errorPostcode);
      window.accountErrorCounter++;
    }

    ValidAccountOpening.checkTel(elementObj['tel'], errorObj['tel']);
    if (elementObj['answer'].offsetParent !== null) {
      ValidAccountOpening.checkAnswer(elementObj['answer'], errorObj['answer']);
    }

    for (key in elementObj){
      if (elementObj[key].offsetParent !== null && key !== 'address2' && key !== 'postcode' && key !== 'state') {
        if (/^$/.test(Trim(elementObj[key].value)) && elementObj[key].type !== 'checkbox'){
          errorObj[key].innerHTML = Content.errorMessage('req');
          Validate.displayErrorMessage(errorObj[key]);
          window.accountErrorCounter++;
        }
        if (elementObj[key].type === 'checkbox' && !elementObj[key].checked){
          errorObj[key].innerHTML = Content.errorMessage('req');
          Validate.displayErrorMessage(errorObj[key]);
          window.accountErrorCounter++;
        }
      }
    }

    if (window.accountErrorCounter === 0) {
      FinancialAccOpeningData.getRealAcc(elementObj);
      for (key in errorObj) {
        if (errorObj[key].offsetParent !== null) {
          errorObj[key].setAttribute('style', 'display:none');
        }
      }
      return 1;
    }
    return 0;
  }

  return {
    checkValidity: checkValidity
  };
})();
;var FinancialAssessmentws = (function(){
   "use strict";
   
    var init = function(){
        LocalizeText();
        $("#assessment_form").on("submit",function(event) {
            event.preventDefault();
            submitForm();
            return false;
        });
        BinarySocket.send(JSON.parse("{\"get_financial_assessment\" : 1}"));
    };
   
    // For translating strings
    var LocalizeText = function(){
        $("#heading").text(text.localize($("#heading").text())); 
        $("legend").text(text.localize($("legend").text()));
        $("#assessment_form label").each(function(){
            var ele = $(this);
            ele.text(text.localize(ele.text()));
        });
        $("#assessment_form option").each(function(){
            var ele = $(this);
            ele.text(text.localize(ele.text()));
        });
        $("#warning").text(text.localize($("#warning").text()));
        $("#submit").text(text.localize($("#submit").text()));
    };
    
    var submitForm = function(){
        if(!validateForm()){
            return;
        }
        var data = {'set_financial_assessment' : 1};
        showLoadingImg();
        $('#assessment_form select').each(function(){
            data[$(this).attr("id")] = $(this).val();
        });
        $('html, body').animate({ scrollTop: 0 }, 'fast');
        BinarySocket.send(data);
        
    };
    
    var validateForm = function(){
        var isValid = true,
            errors = {};
        $('#assessment_form select').each(function(){
            if($(this).val() === ''){
                isValid = false;
                errors[$(this).attr("id")] = text.localize('Please select a value.');
            }
        });
        if(!isValid){
            displayErrors(errors);
        }
        
        return isValid;
    };
    
    var showLoadingImg = function(){
        showLoadingImage($('<div/>', {id: 'loading'}).insertAfter('#heading')); 
        $("#assessment_form").addClass('invisible');
    };
    
    var hideLoadingImg = function(show_form){
        $("#loading").remove();
        if(typeof show_form === 'undefined'){
            show_form = true;
        }
        if(show_form)
            $("#assessment_form").removeClass('invisible');
    };
    
    var responseGetAssessment = function(response){
        hideLoadingImg();
        for(var key in response.get_financial_assessment){
            if(key){
                var val = response.get_financial_assessment[key];
                $("#"+key).val(val);
            }
        }
    };
    
    var displayErrors = function(errors){
        var id;
        $(".errorfield").each(function(){$(this).text('');});
        for(var key in errors){
            if(key){
                var error = errors[key];
                $("#error"+key).text(text.localize(error));
                id = key;
            }
        }  
        hideLoadingImg();
        $('html, body').animate({
            scrollTop: $("#"+id).offset().top
        }, 'fast');
    };
    
    var responseOnSuccess = function(){
        $("#heading").hide();
        hideLoadingImg(false);
        $("#response_on_success").text(text.localize("Your details have been updated."))
            .removeClass("invisible");
    };
    
    var apiResponse = function(response){
        if(response.msg_type === 'get_financial_assessment'){
            responseGetAssessment(response);
        }
        else if(response.msg_type === 'set_financial_assessment' && 'error' in response){
            displayErrors(response.error.details);
        }
        else if(response.msg_type === 'set_financial_assessment'){
            responseOnSuccess();
        }
    };
    return {
        init : init,
        apiResponse : apiResponse
    };
}());


pjax_config_page("user/assessmentws", function() {
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout() || page.client.redirect_if_is_virtual('user/my_accountws')) {
                return;
            }

            BinarySocket.init({
                onmessage: function(msg) {
                    var response = JSON.parse(msg.data);
                    if (response) {
                        FinancialAssessmentws.apiResponse(response);
                    }
                }
            });
            showLoadingImage($('<div/>', {id: 'loading'}).insertAfter('#heading'));
            FinancialAssessmentws.init();
        }
    };
});
;pjax_config_page("user/iphistoryws", function(){
    return {
        onLoad: function() {
            if (!getCookieItem('login')) {
                window.location.href = page.url.url_for('login');
                return;
            }
            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);

                    if (response) {
                        var type = response.msg_type;
                        if (type === 'login_history'){
                            IPHistory.responseHandler(response);
                        }
                    }
                }
            });
            Content.populate();
            IPHistory.init();
        },
        onUnload: function(){
            IPHistory.clean();
        }
    };
});
;var IPHistoryData = (function(){
    "use strict";

    function getHistory(limit){
        var request = {login_history: 1};
        if(limit){
            $.extend(request,limit);
        }
        BinarySocket.send(request);
    }

    return{
      getHistory: getHistory,
    };
}());
;var IPHistory = (function(){
    "use strict";

    //Batch refer to number of data get from ws service per request
    //chunk refer to number of data populate to ui for each append
    //receive means receive from ws service
    //consume means consume by UI and displayed to page

    var batchSize = 50;
    var chunkSize = batchSize/5;

    var noMoreData = true;
    var pending = false;            //serve as a lock to prevent ws request is sequential
    var currentBatch = [];
    var historyReceived = 0;
    var historyConsumed = 0;

    var tableExist = function(){
        return document.getElementById("login-history-table");
    };
    var finishedConsumed = function(){
        return historyConsumed === historyReceived;
    };

    function responseHandler(response){
        if (response.hasOwnProperty('error') && response.error.message) {
          document.getElementById('err').textContent = response.error.message;
          return;
        } else {
          pending = false;

          var login_history = response.login_history;
          currentBatch = login_history;
          historyReceived += currentBatch.length;

          if (!tableExist()) {
              IPHistoryUI.createEmptyTable().appendTo("#login_history-ws-container");
              IPHistoryUI.updateTable(getNextChunk());

              // Show a message when the table is empty
              if ((historyReceived === 0) && (currentBatch.length === 0)) {
                  $('#login-history-table tbody')
                      .append($('<tr/>', {class: "flex-tr"})
                          .append($('<td/>', {colspan: 6})
                              .append($('<p/>', {class: "notice-msg center", text: text.localize("Your account has no Login/Logout activity.")})
                              )
                          )
                      );
              }

              var titleElement = document.getElementById("login_history-title").firstElementChild;
              titleElement.textContent = text.localize(titleElement.textContent);
          }
        }
    }

    function getNextBatch(){
        IPHistoryData.getHistory({limit: 50});
        pending = true;
    }

    function getNextChunk(){
        var chunk = currentBatch.splice(0, chunkSize);
        historyConsumed += chunk.length;
        return chunk;
    }


    function loadChunkWhenScroll(){
        $(document).scroll(function(){

            function hidableHeight(percentage){
                var totalHidable = $(document).height() - $(window).height();
                return Math.floor(totalHidable * percentage / 100);
            }

            var pFromTop = $(document).scrollTop();

            if (!tableExist()){
                return;
            }

            if (pFromTop < hidableHeight(70)) {
                return;
            }

            /*if (finishedConsumed() && !noMoreData && !pending) {
                getNextBatchStatement();
                return;
            }*/

            if (!finishedConsumed()){
                IPHistoryUI.updateTable(getNextChunk());
            }
        });
    }


    function initTable(){
        pending = false;
        noMoreData = false;

        currentBatch = [];

        historyReceived = 0;
        historyConsumed = 0;

        $("#login_history-ws-container .error-msg").text("");

        IPHistoryUI.clearTableContent();
    }

    function initPage(){
        getNextBatch();
        loadChunkWhenScroll();
    }

    function cleanPageState(){
        initTable();
    }

    return {
        init: initPage,
        responseHandler: responseHandler,
        clean: cleanPageState
    };
}());
;var IPHistoryUI = (function(){
    "use strict";

    var tableID = "login-history-table",
        columns = ["timestamp","action","browser","ip","status"];

    function createEmptyTable(){
        var header = [
            text.localize("Date and Time"),
            text.localize("Action"),
            text.localize("Browser"),
            text.localize("IP Address"),
            text.localize("Status"),
        ];
        var metadata = {
            id: tableID,
            cols: columns
        };
        var data = [];
        var $table = Table.createFlexTable(data,metadata,header);
        return $table;
    }

    function updateTable(history){
        Table.appendTableBody(tableID, history, createRow);
    }

    function createRow(data){
        var userAgent = data['environment'];
        var history = userAgent.split(' ');
        var timestamp = history[0];
        var ip = history[2].split('=')[1];
        var browser = "Unknown",
            ver = "Unknown",
            verOffset = 0;
        if (/(msie|trident)/i.test(userAgent)){
            browser = "Internet Explorer";
            verOffset = /(msie)/i.test(userAgent) ? userAgent.indexOf("MSIE") : verOffset;
            verOffset = /(trident)/i.test(userAgent) ? userAgent.indexOf("Trident") : verOffset;
            ver = userAgent.substring(verOffset+13).split(" ")[0].split(":")[1].split(")")[0];
        } else if ((verOffset = userAgent.indexOf("Edge")) != -1) {
            browser = "Edge";
            ver = userAgent.substring(verOffset).split("/")[1].split(" ")[0];
        } else if ((verOffset = userAgent.indexOf("OPR")) != -1){
            browser = "Opera";
            ver = userAgent.substring(verOffset+4).split(" ")[0];
        } else if ((verOffset = userAgent.indexOf("Chrome")) != -1){
            browser = "Chrome";
            ver = userAgent.substring(verOffset+7).split(" ")[0];
        } else if ((verOffset = userAgent.indexOf("Safari")) != -1){
            browser = "Safari";
            ver = userAgent.substring(verOffset+7).split(" ")[0];
        } else if ((verOffset = userAgent.indexOf("Firefox")) != -1){
            browser = "Firefox";
            ver = userAgent.substring(verOffset+8).split(" ")[0];
        }
        var status = data['status'] === 1 ? text.localize('Successful') : text.localize('Failed');
        var browserString = browser + " v" + ver;
        var $row = Table.createFlexTableRow([timestamp, data['action'], browserString, ip, status], columns, "data");
        $row.children(".timestamp").first().append('<br>' + history[1]);
        return $row[0];
    }

    function clearTableContent(){
        Table.clearTableBody(tableID);
        $("#" + tableID +">tfoot").hide();
    }

    return{
        createEmptyTable: createEmptyTable,
        updateTable: updateTable,
        clearTableContent: clearTableContent
    };
}());
;pjax_config_page("new_account/japanws", function(){
  return {
    onLoad: function() {
      Content.populate();
      ValidAccountOpening.redirectCookie();
      if (page.client.residence !== 'jp') {
        window.location.href = page.url.url_for('user/my_accountws');
        return;
      }
      handle_residence_state_ws();
      BinarySocket.send({get_settings:1});
      var purpose = $('#trading-purpose'),
          hedging = $('.hedging-assets');
      purpose.change(function(evt) {
        if (purpose.val() === 'Hedging') {
          hedging.show();
        }
        else if (hedging.is(":visible")) {
          hedging.hide();
        }
        return;
      });
      $('#japan-form').submit(function(evt) {
        evt.preventDefault();
        if (JapanAccOpeningUI.checkValidity()){
          BinarySocket.init({
            onmessage: function(msg){
              var response = JSON.parse(msg.data);
              if (response) {
                var type = response.msg_type;
                if (type === 'new_account_japan'){
                  ValidAccountOpening.handler(response, response.new_account_japan);
                } else if (type === 'sanity_check') {
                  ValidAccountOpening.handler(response);
                }
              }
            }
          });
          JapanAccOpeningUI.fireRequest();
        }
      });
    }
  };
});
;var JapanAccOpeningData = (function(){
    function getJapanAcc(elementObj){
        var req = {
          new_account_japan: 1,
          gender : elementObj['gender'].value,
          first_name: elementObj['fname'].value,
          last_name: elementObj['lname'].value,
          date_of_birth : elementObj['dobyy'].value + '-' + elementObj['dobmm'].value + '-' + elementObj['dobdd'].value,
          occupation: elementObj['occupation'].value,
          residence : page.client.residence,
          address_line_1: elementObj['address1'].value,
          address_line_2: elementObj['address2'].value,
          address_city: elementObj['town'].value,
          address_postcode: elementObj['postcode'].value,
          address_state : elementObj['state'].value,
          phone: elementObj['tel'].value,
          secret_question: elementObj['question'].value,
          secret_answer: elementObj['answer'].value,
          annual_income: elementObj['income'].value,
          financial_asset: elementObj['asset'].value,
          daily_loss_limit: elementObj['limit'].value,
          trading_experience_equities: elementObj['equities'].value,
          trading_experience_commodities: elementObj['commodities'].value,
          trading_experience_foreign_currency_deposit: elementObj['deposit'].value,
          trading_experience_margin_fx: elementObj['margin'].value,
          trading_experience_investment_trust: elementObj['trust'].value,
          trading_experience_public_bond: elementObj['bond'].value,
          trading_experience_option_trading: elementObj['otc'].value,
          trading_purpose : elementObj['purpose'].value,
          agree_use_electronic_doc                : 1,
          agree_warnings_and_policies             : 1,
          confirm_understand_own_judgment         : 1,
          confirm_understand_trading_mechanism    : 1,
          confirm_understand_judgment_time        : 1,
          confirm_understand_total_loss           : 1,
          confirm_understand_sellback_loss        : 1,
          confirm_understand_shortsell_loss       : 1,
          confirm_understand_company_profit       : 1,
          confirm_understand_expert_knowledge     : 1,
          declare_not_fatca                       : 1
        };

        if (elementObj['purpose'].value === 'Hedging') {
          req.hedge_asset = elementObj['hedge'].value;
          req.hedge_asset_amount = elementObj['amount'].value;
        }

        BinarySocket.send(req);
    }

    return {
        getJapanAcc: getJapanAcc
    };
}());
;var JapanAccOpeningUI = function () {
  "use strict";

    var elementObj;

  function checkValidity() {
    window.accountErrorCounter = 0;
    var letters = Content.localize().textLetters,
        numbers = Content.localize().textNumbers,
        space = Content.localize().textSpace,
        hyphen = Content.localize().textHyphen,
        period = Content.localize().textPeriod,
        apost = Content.localize().textApost;

    elementObj = {
        gender: document.getElementById('gender'),
        fname: document.getElementById('fname'),
        lname: document.getElementById('lname'),
        dobdd: document.getElementById('dobdd'),
        dobmm: document.getElementById('dobmm'),
        dobyy: document.getElementById('dobyy'),
        occupation: document.getElementById('occupation'),
        address1: document.getElementById('address1'),
        address2: document.getElementById('address2'),
        town: document.getElementById('address-town'),
        state: document.getElementById('address-state'),
        postcode: document.getElementById('address-postcode'),
        tel: document.getElementById('tel'),
        question: document.getElementById('secret-question'),
        answer: document.getElementById('secret-answer'),
        fatca: document.getElementById('fatca'),
        income: document.getElementById('annual-income'),
        asset: document.getElementById('financial-asset'),
        limit: document.getElementById('daily-loss-limit'),
        equities: document.getElementById('equities'),
        commodities: document.getElementById('commodities'),
        deposit: document.getElementById('foreign-currency-deposit'),
        margin: document.getElementById('margin-fx'),
        trust: document.getElementById('investment-trust'),
        bond: document.getElementById('public-and-corporation-bond'),
        otc: document.getElementById('otc-derivative-trading'),
        purpose: document.getElementById('trading-purpose'),
        hedge: document.getElementById('hedge-asset'),
        amount: document.getElementById('hedge-asset-amount'),
        electronic: document.getElementById('use-electronic-doc'),
        policies: document.getElementById('warnings-and-policies'),
        judgement: document.getElementById('own-judgment'),
        mechanism: document.getElementById('trading-mechanism'),
        time: document.getElementById('judgment-time'),
        total: document.getElementById('total-loss'),
        sellback: document.getElementById('sellback-loss'),
        shortsell: document.getElementById('shortsell-loss'),
        profit: document.getElementById('company-profit'),
        knowledge: document.getElementById('expert-knowledge')
    };

    var errorObj = {
        gender: document.getElementById('error-gender'),
        fname: document.getElementById('error-fname'),
        lname: document.getElementById('error-lname'),
        dobdd: document.getElementById('error-birthdate'),
        dobmm: document.getElementById('error-birthdate'),
        dobyy: document.getElementById('error-birthdate'),
        occupation: document.getElementById('error-occupation'),
        address1: document.getElementById('error-address1'),
        address2: document.getElementById('error-address2'),
        town: document.getElementById('error-town'),
        state: document.getElementById('error-state'),
        postcode: document.getElementById('error-postcode'),
        tel: document.getElementById('error-tel'),
        question: document.getElementById('error-question'),
        answer: document.getElementById('error-answer'),
        fatca: document.getElementById('error-fatca'),
        income: document.getElementById('error-annual-income'),
        asset: document.getElementById('error-financial-asset'),
        limit: document.getElementById('error-daily-loss-limit'),
        equities: document.getElementById('error-equities'),
        commodities: document.getElementById('error-commodities'),
        deposit: document.getElementById('error-foreign-currency-deposit'),
        margin: document.getElementById('error-margin-fx'),
        trust: document.getElementById('error-investment-trust'),
        bond: document.getElementById('error-public-and-corporation-bond'),
        otc: document.getElementById('error-otc-derivative-trading'),
        purpose: document.getElementById('error-trading-purpose'),
        hedge: document.getElementById('error-hedge-asset'),
        amount: document.getElementById('error-hedge-asset-amount'),
        electronic: document.getElementById('error-use-electronic-doc'),
        policies: document.getElementById('error-warnings-and-policies'),
        judgement: document.getElementById('error-own-judgment'),
        mechanism: document.getElementById('error-trading-mechanism'),
        time: document.getElementById('error-judgment-time'),
        total: document.getElementById('error-total-loss'),
        sellback: document.getElementById('error-sellback-loss'),
        shortsell: document.getElementById('error-shortsell-loss'),
        profit: document.getElementById('error-company-profit'),
        knowledge: document.getElementById('error-expert-knowledge')
    };
    var key;
    for (key in errorObj) {
      if (errorObj[key].offsetParent !== null) {
        errorObj[key].setAttribute('style', 'display:none');
      }
    }

    if (/[`~!@#$%^&*)(_=+\[}{\]\\\/";:\?><,|\d]+/.test(Trim(elementObj['fname'].value))) {
      errorObj['fname'].innerHTML = Content.errorMessage('reg', [letters, space, hyphen, period, apost]);
      Validate.displayErrorMessage(errorObj['fname']);
      window.accountErrorCounter++;
    }

    if (/[`~!@#$%^&*)(_=+\[}{\]\\\/";:\?><,|\d]+/.test(Trim(elementObj['lname'].value))) {
      errorObj['lname'].innerHTML = Content.errorMessage('reg', [letters, space, hyphen, period, apost]);
      Validate.displayErrorMessage(errorObj['lname']);
      window.accountErrorCounter++;
    }

    ValidAccountOpening.checkDate(elementObj['dobdd'], elementObj['dobmm'], elementObj['dobyy'], errorObj['dobdd']);

    if (!/^\d{3}-\d{4}$/.test(elementObj['postcode'].value)) {
      errorObj['postcode'].innerHTML = text.localize('Please follow the pattern 3 numbers, a dash, followed by 4 numbers.');
      Validate.displayErrorMessage(errorObj['postcode']);
      window.accountErrorCounter++;
    }

    if (elementObj['tel'].value.replace(/\+| /g,'').length < 6) {
      errorObj['tel'].innerHTML = Content.errorMessage('min', 6);
      Validate.displayErrorMessage(errorObj['tel']);
      window.accountErrorCounter++;
    } else if (!/^\+?[0-9\s-]{6,35}$/.test(elementObj['tel'].value)){
      errorObj['tel'].innerHTML = Content.errorMessage('reg', [numbers, space, hyphen]);
      Validate.displayErrorMessage(errorObj['tel']);
      window.accountErrorCounter++;
    }

    if (!/^\d+$/.test(elementObj['limit'].value)) {
      errorObj['limit'].innerHTML = Content.errorMessage('reg', [numbers]);
      Validate.displayErrorMessage(errorObj['limit']);
      window.accountErrorCounter++;
    }

    if (elementObj['amount'].offsetParent !== null && !/^\d+$/.test(elementObj['amount'].value)) {
      errorObj['amount'].innerHTML = Content.errorMessage('reg', [numbers]);
      Validate.displayErrorMessage(errorObj['amount']);
      window.accountErrorCounter++;
    }

    for (key in elementObj) {
      if (elementObj[key].offsetParent !== null && key !== 'address2') {
        if (/^$/.test(Trim(elementObj[key].value)) && elementObj[key].type !== 'checkbox') {
          errorObj[key].innerHTML = Content.errorMessage('req');
          Validate.displayErrorMessage(errorObj[key]);
          window.accountErrorCounter++;
        }
        if (elementObj[key].type === 'checkbox' && !elementObj[key].checked) {
          errorObj[key].innerHTML = Content.errorMessage('req');
          Validate.displayErrorMessage(errorObj[key]);
          window.accountErrorCounter++;
        }
      }
    }

    if (window.accountErrorCounter === 0) {
      for (key in errorObj) {
        if (errorObj[key].offsetParent !== null) {
          errorObj[key].setAttribute('style', 'display:none');
        }
      }
      return 1;
    }
    return 0;
  }

    function fireRequest() {
        JapanAccOpeningData.getJapanAcc(elementObj);
    }

  return {
    checkValidity: checkValidity,
      fireRequest: fireRequest,
  };
}();
;pjax_config_page("limitsws", function(){
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }
            Content.populate();
            Content.limitsTranslation();
            if (TUser.get().is_virtual) {
                LimitsWS.limitsError();
                return;
            }
            document.getElementById('client_message').setAttribute('style', 'display:none');

            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);
                    if (response) {
                        var type = response.msg_type;
                        var error = response.error;

                        if (type === 'authorize' && TUser.get().is_virtual){
                            LimitsWS.limitsError();
                        } else if (type === 'get_limits' && !error){
                            LimitsWS.limitsHandler(response);
                        } else if (error) {
                            LimitsWS.limitsError();
                        }
                    }
                }
            });

            BinarySocket.send({get_limits: 1});
        },
        onUnload: function(){
            LimitsWS.clean();
        }
    };
});
;var LimitsWS = (function(){
    "use strict";

    function limitsHandler(response){
        var limits = response.get_limits;
        LimitsUI.fillLimitsTable(limits);

        var elem_withdrawal_limit = document.getElementById("withdrawal-limit");
        var elem_already_withdraw = document.getElementById("already-withdraw");
        var elem_withdrawal_limit_aggregate = document.getElementById("withdrawal-limit-aggregate");

        if(limits['lifetime_limit'] === 99999999 && limits['num_of_days_limit'] === 99999999) {
            elem_withdrawal_limit.textContent = Content.localize().textAuthenticatedWithdrawal;
        } else {
            var text_WithdrawalLimits     = Content.localize().textWithdrawalLimitsEquivalant;
            var text_WithrawalAmount      = Content.localize().textWithrawalAmountEquivalant;
            var text_CurrentMaxWithdrawal = Content.localize().textCurrentMaxWithdrawalEquivalant;
            var client_currency           = 'EUR';
            var num_of_days_limit         = addComma(limits['num_of_days_limit']);
            var already_withdraw          = limits["withdrawal_since_inception_monetary"]; // no need for addComma since it is already string like "1,000"
            var remainder                 = addComma(limits['remainder']);

            if((/^(iom)$/i).test(TUser.get().landing_company_name)) { // MX
                text_WithdrawalLimits = Content.localize().textWithdrawalLimitsEquivalantDay;
                text_WithrawalAmount  = Content.localize().textWithrawalAmountEquivalantDay;
                elem_withdrawal_limit.textContent = text_WithdrawalLimits.replace('[_1]', limits['num_of_days']).replace('[_2]', client_currency).replace('[_3]', num_of_days_limit);
                elem_already_withdraw.textContent = text_WithrawalAmount.replace('[_1]', client_currency).replace('[_2]', already_withdraw).replace('[_3]', limits['num_of_days']);
            }
            else {
                if((/^(costarica|japan)$/i).test(TUser.get().landing_company_name)) { // CR , JP
                    text_WithdrawalLimits     = Content.localize().textWithdrawalLimits;
                    text_WithrawalAmount      = Content.localize().textWithrawalAmount;
                    text_CurrentMaxWithdrawal = Content.localize().textCurrentMaxWithdrawal;
                    client_currency           = TUser.get().currency || page.client.get_storage_value('currencies');
                }
                elem_withdrawal_limit.textContent = text_WithdrawalLimits.replace('[_1]', client_currency).replace('[_2]', num_of_days_limit);
                elem_already_withdraw.textContent =  text_WithrawalAmount.replace('[_1]', client_currency).replace('[_2]', already_withdraw);
            }
            elem_withdrawal_limit_aggregate.textContent = text_CurrentMaxWithdrawal.replace('[_1]', client_currency).replace('[_2]', remainder);
        }
    }

    function limitsError(){
        document.getElementById('limits-title').setAttribute('style', 'display:none');
        document.getElementsByClassName('notice-msg')[0].innerHTML = Content.localize().textFeatureUnavailable;
        document.getElementById('client_message').setAttribute('style', 'display:block');
    }

    function initTable(){
        document.getElementById('client_message').setAttribute('style', 'display:none');
        LimitsUI.clearTableContent();
    }

    return {
        limitsHandler: limitsHandler,
        limitsError: limitsError,
        clean: initTable
    };
}());
;var LimitsUI = (function(){
    "use strict";

    function fillLimitsTable(limits){
        var open_positions = addComma(limits['open_positions']);
        var account_balance = addComma(limits['account_balance']);
        var daily_turnover = addComma(limits['daily_turnover']);
        var payout = addComma(limits['payout']);

        document.getElementById('item').textContent = Content.localize().textItem;
        
        var currency = TUser.get().currency;
        var limit = document.getElementById('limit');
        if (currency === "") {
            limit.textContent = Content.localize().textLimit;
        } else {
            limit.textContent = Content.localize().textLimit + " (" + currency + ")";
        }
        $('#max-open-position').prepend(Content.localize().textMaxOpenPosition);
        document.getElementById('max-open-position-tooltip').setAttribute('title', Content.localize().textMaxOpenPositionTooltip);
        document.getElementById('open-positions').textContent = open_positions;
        
        $('#max-acc-balance').prepend(Content.localize().textMaxAccBalance);
        document.getElementById('max-acc-balance-tooltip').setAttribute('title', Content.localize().textMaxAccBalanceTooltip);
        document.getElementById('account-balance').textContent = account_balance;
        
        $('#max-daily-turnover').prepend(Content.localize().textMaxDailyTurnover);
        document.getElementById('max-daily-turnover-tooltip').setAttribute('title', Content.localize().textMaxDailyTurnoverTooltip);
        document.getElementById('daily-turnover').textContent = daily_turnover;
        
        $('#max-aggregate').prepend(Content.localize().textMaxAggregate);
        document.getElementById('max-aggregate-tooltip').setAttribute('title', Content.localize().textMaxAggregateTooltip);
        document.getElementById('payout').textContent = payout;
    }

    function clearTableContent(){
        Table.clearTableBody('client-limits');
        $("#limits-title>tfoot").hide();
    }

    
    
    return {
        clearTableContent: clearTableContent,
        fillLimitsTable: fillLimitsTable
    };
}());
;pjax_config_page('user/lost_passwordws', function() {
    return {
        onLoad: function() {
            BinarySocket.init({
                onmessage: LostPassword.lostPasswordWSHandler
            });
            LostPassword.init();
        }
    };
});
;var LostPassword = (function() {
    'use strict';

    var hiddenClass = 'invisible';

    function submitEmail() {
        var emailInput = $('#lp_email').val();

        if (emailInput === '') {
            $("#email_error").removeClass(hiddenClass).text(text.localize('This field is required.'));
        } else if (!validateEmail(emailInput)){
            $("#email_error").removeClass(hiddenClass).text(text.localize('Invalid email format'));
        }
        else {
            BinarySocket.send({verify_email: emailInput, type: 'reset_password'});
            $('#submit').prop('disabled', true);
        }
    }

    function onEmailInput(input) {
        if (input) {
            $("#email_error").addClass(hiddenClass);
        }
    }
    
    function lostPasswordWSHandler(msg) {
        var response = JSON.parse(msg.data);
        var type = response.msg_type;

        if (type === 'verify_email') {
            if (response.verify_email === 1) {
                load_with_pjax('reset_passwordws');
            } else if (response.error) {
                $("#email_error").removeClass(hiddenClass).text(text.localize('Invalid email format'));
                $('#submit').prop('disabled', false);
            }
        }
    }

    function init() {
        $('#submit:enabled').click(function() {
            submitEmail();
        });

        $('#lp_email').keypress(function(ev) {
            if (ev.which === 13) {
                submitEmail();
            }
            onEmailInput(ev.target.value);
        });
    }

    return {
        lostPasswordWSHandler: lostPasswordWSHandler,
        init: init
    };
}());
;var PaymentAgentTransferData = (function () {
    "use strict";
    function transfer(transferTo, currency, amount, toDryRun) {
        var dryRun = toDryRun ? 1 : 0;
        BinarySocket.send({
            paymentagent_transfer: 1,
            transfer_to: transferTo,
            currency: currency,
            amount: amount,
            dry_run: dryRun
        });
    }

    return {
        transfer: transfer
    };
}());
;var PaymentAgentTransfer = (function () {
    var hiddenClass = 'invisible';
    function paymentAgentTransferHandler(response) {
        var req = response.echo_req;

        if (response.error) {
            if (req.dry_run === 1) {
                $('#transfer_error_client_id').removeClass(hiddenClass);
                $('#transfer_error_client_id').text(response.error.message);
                return;    
            } else {
                PaymentAgentTransferUI.showTransferError(response.error.message);
            }
        }
        
        if (response.paymentagent_transfer === 2) {
            PaymentAgentTransferUI.hideForm();
            PaymentAgentTransferUI.hideDone();
            PaymentAgentTransferUI.hideNotes();

            PaymentAgentTransferUI.showConfirmation();

            PaymentAgentTransferUI
                .updateConfirmView(response.client_to_full_name, req.transfer_to, req.amount, req.currency);
        }

        if (response.paymentagent_transfer === 1) {
            PaymentAgentTransferUI.hideForm();
            PaymentAgentTransferUI.hideConfirmation();
            PaymentAgentTransferUI.hideNotes();

            PaymentAgentTransferUI.showDone();

            PaymentAgentTransferUI.updateDoneView(TUser.get().loginid, req.transfer_to, req.amount, req.currency);
        }
    }

    function init(auth) {
        var $pa_form = $('#paymentagent_transfer');

        var currency = TUser.get().currency;

        if (auth && !currency) {
            $('#no_balance_error').removeClass(hiddenClass);
            $pa_form.addClass(hiddenClass);

            return;
        } else {
            $('#no_balance_error').addClass(hiddenClass);
            $pa_form.removeClass(hiddenClass);
        }

        PaymentAgentTransferUI.updateFormView(currency);

        var $submitFormButton = $pa_form.find('button#submit');
        var $clientIDInput = $pa_form.find('input#client_id');
        var $amountInput = $pa_form.find('input[name="amount"]');

        var $clientIDError = $('#transfer_error_client_id');
        var $amountError = $('#transfer_error_amount');
        var $insufficientBalError = $('#insufficient-balance-error');

        var $paConfirmTransferButton = $('#pa_confirm_transfer #confirm_transfer');
        var $paConfirmBackButton = $('#back_transfer');

        $submitFormButton.click(function() {
            var clientID = $clientIDInput.val();
            var amount = $amountInput.val();

            if (!clientID) {
                $clientIDError.removeClass(hiddenClass);
                $clientIDError.text('Please enter the Login ID to transfer funds.');
                return;
            }

            if (!(/^\w+\d+$/.test(clientID))) {
                $clientIDError.removeClass(hiddenClass);
                $clientIDError.text('Please enter a valid Login ID.');
                return;
            }

            if (!amount) {
                $amountError.removeClass(hiddenClass);
                return;
            }

            if (amount > 2000 || amount < 10) {
                $amountError.removeClass(hiddenClass);
                return;
            }

            var bal = +(TUser.get().balance);
            if (amount > bal) {
                $insufficientBalError.removeClass(hiddenClass);
                return;
            }

            PaymentAgentTransferData.transfer(clientID, currency, amount, true);
        });

        $paConfirmTransferButton.click(function() {
            var clientID = $clientIDInput.val();
            var amount = $amountInput.val();
            PaymentAgentTransferData.transfer(clientID, currency, amount, false);
        });

        $paConfirmBackButton.click(function() {
            PaymentAgentTransferUI.showForm();
            PaymentAgentTransferUI.showNotes();
            PaymentAgentTransferUI.hideConfirmation();
            PaymentAgentTransferUI.hideDone();
        });

        $clientIDInput.keyup(function(ev) {
            $clientIDError.addClass(hiddenClass);

            if (ev.which === 13) {
                $submitFormButton.click();
            }
        });

        $amountInput.keypress(onlyNumericOnKeypress);

        $amountInput.keyup(function(ev){
            $amountError.addClass(hiddenClass);
            $insufficientBalError.addClass(hiddenClass);

            if (ev.which === 13) {
                $submitFormButton.click();
            }
        });
    }

    return {
        init: init,
        paymentAgentTransferHandler: paymentAgentTransferHandler
    };
}());
;var PaymentAgentTransferUI = (function () {
    "use strict";
    var hiddenClass = 'invisible';
    
    function hideForm() {
        $('#paymentagent_transfer').addClass(hiddenClass);
    }
    function showForm() {
        $('#paymentagent_transfer').removeClass(hiddenClass);
    }

    function hideConfirmation() {
        $('#pa_confirm_transfer').addClass(hiddenClass);
    }
    function showConfirmation() {
        $('#pa_confirm_transfer').removeClass(hiddenClass);
        $('#pa_confirm_transfer .errorfield').addClass(hiddenClass);
    }

    function hideDone() {
        $('#pa_transfer_done').addClass(hiddenClass);
    }
    function showDone() {
        $('#pa_transfer_done').removeClass(hiddenClass);
    }

    function hideNotes() {
        $('#paymentagent_transfer_notes').addClass(hiddenClass);
    }
    function showNotes() {
        $('#paymentagent_transfer_notes').removeClass(hiddenClass);
    }
    function updateFormView(currency) {
        $('#paymentagent_transfer label[for="amount"]').text(text.localize('Amount') + ' ' + currency);
    }

    function updateConfirmView(username, loginid, amount, currency) {
        $('#pa_confirm_transfer td#user-name').html(username);
        $('#pa_confirm_transfer td#login-id').html(loginid);
        $('#pa_confirm_transfer td#amount').html(currency + ' ' + amount);
    }

    function showTransferError(err) {
        $('#pa_confirm_transfer .errorfield')
            .removeClass(hiddenClass)
            .text(text.localize(err));
    }

    function updateDoneView(fromID, toID, amount, currency) {
        var templateString = "Your request to transfer [_1] [_2] from [_3] to [_4] has been successfully processed.";
        var translated = text.localize(templateString);
        var confirmMsg = translated
            .replace('[_1]', amount)
            .replace('[_2]', currency)
            .replace('[_3]', fromID)
            .replace('[_4]', toID);

        $('#pa_transfer_done > #confirm-msg').text(confirmMsg);
        $('#pa_transfer_done > #confirm-msg').removeClass(hiddenClass);
    }

    return {
        hideForm: hideForm,
        showForm: showForm,
        hideConfirmation: hideConfirmation,
        showConfirmation: showConfirmation,
        hideDone: hideDone,
        showDone: showDone,
        hideNotes: hideNotes,
        showNotes: showNotes,
        showTransferError: showTransferError,
        updateFormView: updateFormView,
        updateConfirmView: updateConfirmView,
        updateDoneView: updateDoneView
    };
}());
;pjax_config_page("paymentagent/transferws", function(){
    return {
        onLoad: function() {
            if (!getCookieItem('login')) {
                window.location.href = page.url.url_for('login');
                return;
            }
            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);

                    if (response) {
                        var type = response.msg_type;
                        if (type === 'authorize') {
                            PaymentAgentTransfer.init(true);
                        }

                        if (type === 'paymentagent_transfer'){
                            PaymentAgentTransfer.paymentAgentTransferHandler(response);
                        }
                    }
                }
            });
            Content.populate();

            if (TUser.get().email) {
                PaymentAgentTransfer.init();
            }
        }
    };
});;

pjax_config_page("user/profit_table", function(){
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }
            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);

                    if (response) {
                        var type = response.msg_type;
                        if (type === 'profit_table'){
                            ProfitTableWS.profitTableHandler(response);
                        }
                    }
                }
            });
            Content.populate();
            ProfitTableWS.init();
        },
        onUnload: function(){
            ProfitTableWS.clean();
        }
    };
});
;
var ProfitTableData = (function(){
    function getProfitTable(opts){
        var req = {profit_table: 1, description: 1};
        if(opts){
            $.extend(true, req, opts);
        }

        BinarySocket.send(req);
    }

    return {
        getProfitTable: getProfitTable
    };
}());;
var ProfitTableWS = (function () {
    var batchSize = 100;
    var chunkSize = batchSize/2;

    var transactionsReceived = 0;
    var transactionsConsumed = 0;
    var noMoreData = false;
    var pending = false;

    var currentBatch = [];

    var tableExist = function(){
        return document.getElementById("profit-table");
    };

    var finishedConsumed = function(){
        return transactionsConsumed === transactionsReceived;
    };

    function initTable(){
        currentBatch = [];
        transactionsConsumed = 0;
        transactionsReceived = 0;
        pending = false;

        $(".error-msg").text("");

        if (tableExist()) {
            ProfitTableUI.cleanTableContent();
        }
    }

    function profitTableHandler(response){

        pending = false;
        var profitTable = response.profit_table;
        currentBatch = profitTable.transactions;
        transactionsReceived += currentBatch.length;

        if (currentBatch.length < batchSize) {
            noMoreData = true;
        }

        if (!tableExist()) {
            ProfitTableUI.createEmptyTable().appendTo("#profit-table-ws-container");
            ProfitTableUI.updateProfitTable(getNextChunk());

            // Show a message when the table is empty
            if((transactionsReceived === 0) && (currentBatch.length === 0)) {
                $('#profit-table tbody')
                    .append($('<tr/>', {class: "flex-tr"})
                        .append($('<td/>', {colspan: 8})
                            .append($('<p/>', {class: "notice-msg center", text: text.localize("Your account has no trading activity.")})
                            )
                        )
                    );
            }

            Content.profitTableTranslation();
        }
    }

    function getNextBatchTransactions(){
        ProfitTableData.getProfitTable({offset: transactionsReceived, limit: batchSize});
        pending = true;
    }

    function getNextChunk(){
        var chunk = currentBatch.splice(0, chunkSize);
        transactionsConsumed += chunk.length;
        return chunk;
    }

    function onScrollLoad(){
        $(document).scroll(function(){
            function hidableHeight(percentage){
                var totalHidable = $(document).height() - $(window).height();
                return Math.floor(totalHidable * percentage / 100);
            }

            var pFromTop = $(document).scrollTop();

            if (!tableExist()){
                return;
            }

            if (pFromTop < hidableHeight(50)) {
                return;
            }

            if (finishedConsumed() && !noMoreData && !pending) {
                getNextBatchTransactions();
                return;
            }

            if (!finishedConsumed()) {
                ProfitTableUI.updateProfitTable(getNextChunk());
            }
        });
    }



    function init(){
        getNextBatchTransactions();
        onScrollLoad();
    }

    return {
        profitTableHandler: profitTableHandler,
        init: init,
        clean: initTable
    };
}());
;
var ProfitTableUI = (function(){
    "use strict";

    var profitTableID = "profit-table";
    var cols = ["buy-date", "ref", "contract", "buy-price", "sell-date", "sell-price", "pl", "details"];

    function createEmptyTable(){
        var header = [
            Content.localize().textPurchaseDate,
            Content.localize().textRef,
            Content.localize().textContract,
            Content.localize().textPurchasePrice,
            Content.localize().textSaleDate,
            Content.localize().textSalePrice,
            Content.localize().textProfitLoss,
            Content.localize().textDetails
        ];

        header[6] = header[6] + (TUser.get().currency ? " (" + TUser.get().currency + ")" : "");

        var footer = [Content.localize().textTotalProfitLoss, "", "", "", "", "", "", ""];

        var data = [];
        var metadata = {
            cols: cols,
            id: profitTableID
        };
        var $tableContainer = Table.createFlexTable(data, metadata, header, footer);

        var $pltotal = $tableContainer.
            children("table").
            children("tfoot").
            children("tr").
            attr("id", "pl-day-total");

        return $tableContainer;
    }

    function updateProfitTable(transactions){
        Table.appendTableBody(profitTableID, transactions, createProfitTableRow);
        updateFooter(transactions);
    }

    function updateFooter(transactions){
        var accTotal = document.querySelector("#pl-day-total > .pl").textContent;
        accTotal = parseFloat(accTotal.replace(/,/g, ''));
        if (isNaN(accTotal)) {
            accTotal = 0;
        }

        var currentTotal = transactions.reduce(function(previous, current){
            var buyPrice = Number(parseFloat(current["buy_price"]));
            var sellPrice = Number(parseFloat(current["sell_price"]));
            var pl = sellPrice - buyPrice;
            return previous + pl;
        }, 0);

        var total = accTotal + currentTotal;

        $("#pl-day-total > .pl").text(addComma(Number(total).toFixed(2)));

        var subTotalType = (total >= 0 ) ? "profit" : "loss";
        $("#pl-day-total > .pl").removeClass("profit").removeClass("loss");
        $("#pl-day-total > .pl").addClass(subTotalType);
    }

    function createProfitTableRow(transaction){
        var buyMoment = moment.utc(transaction["purchase_time"] * 1000);
        var sellMoment = moment.utc(transaction["sell_time"] * 1000);

        var buyDate = buyMoment.format("YYYY-MM-DD") + "\n" + buyMoment.format("HH:mm:ss");
        var sellDate = sellMoment.format("YYYY-MM-DD") + "\n" + sellMoment.format("HH:mm:ss");

        var ref = transaction["transaction_id"];
        var buyPrice = Number(parseFloat(transaction["buy_price"])).toFixed(2);
        var sellPrice = Number(parseFloat(transaction["sell_price"])).toFixed(2);

        var pl = Number(sellPrice - buyPrice).toFixed(2);

        var plType = (pl >= 0) ? "profit" : "loss";

        var data = [buyDate, ref, '', buyPrice, sellDate, sellPrice, pl, ''];
        var $row = Table.createFlexTableRow(data, cols, "data");

        $row.children(".buy-date").addClass("pre");
        $row.children(".pl").addClass(plType);
        $row.children(".sell-date").addClass("pre");
        $row.children(".contract").html(transaction["longcode"] + "<br>");

        //create view button and append
        var $viewButtonSpan = Button.createBinaryStyledButton();
        var $viewButton = $viewButtonSpan.children(".button").first();
        $viewButton.text(text.localize("View"));
        $viewButton.addClass("open_contract_detailsws");
        $viewButton.attr("contract_id", transaction["contract_id"]);

        $row.children(".contract,.details").append($viewButtonSpan);

        return $row[0];
    }

    function initDatepicker(){
        DatepickerUtil.initDatepicker("profit-table-date", moment.utc(), null, 0);
    }

    function clearTableContent(){
        Table.clearTableBody(profitTableID);
        $("#" + profitTableID + ">tfoot").hide();
    }

    return {
        createEmptyTable: createEmptyTable,
        updateProfitTable: updateProfitTable,
        initDatepicker: initDatepicker,
        cleanTableContent: clearTableContent
    };
}());
;// temporary script to show message about Random renamed to Volatile on trading page

function showRandomRenamedMsg(msg) {
    if (JSON.parse(msg.data).msg_type !== 'active_symbols') {
        return;
    }
    var hasRandom = false;
    Object.keys(Symbols.markets())
        .forEach(function(s) {
            if (s === 'volidx') {
                hasRandom = true;
            }
        });

    if(page.language().toLowerCase() === 'id') {
        $('#temp_notice_msg a').attr('href', 'https://blog.binary.com/indeks-random-berganti-nama-menjadi-indeks-volatilitas/');
    }

    var tempMsgKey = 'hide_temp_msg';
    if (SessionStore.get(tempMsgKey) || !hasRandom) {
        $('#temp_notice_msg').addClass('invisible');
    }

    $('#close_temp_msg').click(function() {
        SessionStore.set(tempMsgKey, '1');
        $('#temp_notice_msg').addClass('invisible');
    });
}
;pjax_config_page("new_account/realws", function(){
  return {
    onLoad: function() {
      Content.populate();
      ValidAccountOpening.redirectCookie();
      handle_residence_state_ws();
      if (page.client.residence) {
        BinarySocket.send({landing_company: page.client.residence});
      }
      BinarySocket.send({get_settings:1});
      BinarySocket.send({residence_list:1});
      $('#real-form').submit(function(evt) {
        evt.preventDefault();
        if (RealAccOpeningUI.checkValidity()){
          BinarySocket.init({
            onmessage: function(msg){
              var response = JSON.parse(msg.data);
              if (response) {
                if(response.msg_type === 'authorize' && !page.client.is_virtual()) {
                    window.location.href = page.url.url_for('user/my_accountws');
                    return;
                }
                else if (response.msg_type === 'new_account_real'){
                  ValidAccountOpening.handler(response, response.new_account_real);
                }
              }
            }
          });
        }
      });
    }
  };
});
;var RealAccOpeningData = (function(){
    function getRealAcc(elementObj){
        var req = {
            new_account_real: 1,
            salutation: elementObj['title'].value,
            first_name: elementObj['fname'].value,
            last_name: elementObj['lname'].value,
            date_of_birth: elementObj['dobyy'].value + '-' + elementObj['dobmm'].value + '-' + elementObj['dobdd'].value,
            residence: elementObj['residence'].value,
            address_line_1: elementObj['address1'].value,
            address_line_2: elementObj['address2'].value,
            address_city: elementObj['town'].value,
            address_state: elementObj['state'].value,
            address_postcode: elementObj['postcode'].value,
            phone: elementObj['tel'].value,
            secret_question: elementObj['question'].value,
            secret_answer: elementObj['answer'].value
        };

        if ($.cookie('affiliate_tracking')) {
          req.affiliate_token = JSON.parse($.cookie('affiliate_tracking')).t;
        }

        BinarySocket.send(req);
    }

    return {
        getRealAcc: getRealAcc
    };
}());
;var RealAccOpeningUI = (function(){
  "use strict";

  function checkValidity(){
    window.accountErrorCounter = 0;

    var letters = Content.localize().textLetters,
        numbers = Content.localize().textNumbers,
        space   = Content.localize().textSpace,
        hyphen  = Content.localize().textHyphen,
        period  = Content.localize().textPeriod,
        apost   = Content.localize().textApost;

    var elementObj = {
        title     : document.getElementById('title'),
        fname     : document.getElementById('fname'),
        lname     : document.getElementById('lname'),
        dobdd     : document.getElementById('dobdd'),
        dobmm     : document.getElementById('dobmm'),
        dobyy     : document.getElementById('dobyy'),
        residence : document.getElementById('residence-disabled'),
        address1  : document.getElementById('address1'),
        address2  : document.getElementById('address2'),
        town      : document.getElementById('address-town'),
        state     : document.getElementById('address-state'),
        postcode  : document.getElementById('address-postcode'),
        tel       : document.getElementById('tel'),
        question  : document.getElementById('secret-question'),
        answer    : document.getElementById('secret-answer'),
        tnc       : document.getElementById('tnc')
    };

    var errorObj = {
        title     : document.getElementById('error-title'),
        fname     : document.getElementById('error-fname'),
        lname     : document.getElementById('error-lname'),
        dobdd     : document.getElementById('error-birthdate'),
        dobmm     : document.getElementById('error-birthdate'),
        dobyy     : document.getElementById('error-birthdate'),
        residence : document.getElementById('error-residence'),
        address1  : document.getElementById('error-address1'),
        address2  : document.getElementById('error-address2'),
        town      : document.getElementById('error-town'),
        state     : document.getElementById('error-state'),
        postcode  : document.getElementById('error-postcode'),
        tel       : document.getElementById('error-tel'),
        question  : document.getElementById('error-question'),
        answer    : document.getElementById('error-answer'),
        tnc       : document.getElementById('error-tnc')
    };

    var key;
    for (key in errorObj) {
      if (errorObj[key].offsetParent !== null) {
        errorObj[key].setAttribute('style', 'display:none');
      }
    }

    ValidAccountOpening.checkFname(elementObj['fname'], errorObj['fname']);
    ValidAccountOpening.checkLname(elementObj['lname'], errorObj['lname']);
    ValidAccountOpening.checkDate(elementObj['dobdd'], elementObj['dobmm'], elementObj['dobyy'], errorObj['dobdd']);
    ValidAccountOpening.checkPostcode(elementObj['postcode'], errorObj['postcode']);

    if (elementObj['residence'].value === 'gb' && /^$/.test(Trim(elementObj['postcode'].value))){
      errorPostcode.innerHTML = Content.errorMessage('req');
      Validate.displayErrorMessage(errorPostcode);
      window.accountErrorCounter++;
    }

    ValidAccountOpening.checkTel(elementObj['tel'], errorObj['tel']);
    ValidAccountOpening.checkAnswer(elementObj['answer'], errorObj['answer']);

    for (key in elementObj){
      if (elementObj[key].offsetParent !== null && key !== 'address2' && key !== 'postcode' && key !== 'state') {
        if (/^$/.test(Trim(elementObj[key].value)) && elementObj[key].type !== 'checkbox'){
          errorObj[key].innerHTML = Content.errorMessage('req');
          Validate.displayErrorMessage(errorObj[key]);
          window.accountErrorCounter++;
        }
        if (elementObj[key].type === 'checkbox' && !elementObj[key].checked){
          errorObj[key].innerHTML = Content.errorMessage('req');
          Validate.displayErrorMessage(errorObj[key]);
          window.accountErrorCounter++;
        }
      }
    }

    if (window.accountErrorCounter === 0) {
      $('#btn_submit').attr('disabled','disabled');
      RealAccOpeningData.getRealAcc(elementObj);
      for (key in errorObj) {
        if (errorObj[key].offsetParent !== null) {
          errorObj[key].setAttribute('style', 'display:none');
        }
      }
      return 1;
    }
    return 0;
  }

  return {
    checkValidity: checkValidity
  };
})();
;var RealityCheckData = (function () {
    'use strict';

    var defaultInterval = 600000;
    var durationTemplateString = '[_1] days [_2] hours [_3] minutes';
    var tradingTimeTemplate = 'Your trading statistics since [_1].';

    function getSummaryAsync() {
        BinarySocket.send({reality_check: 1});
    }

    function getAck() {
        return LocalStore.get('reality_check.ack');
    }

    function setOpenSummaryFlag() {
        LocalStore.set('reality_check.keep_open', 1);
    }

    function getOpenSummaryFlag() {
        return LocalStore.get('reality_check.keep_open');
    }

    function triggerCloseEvent() {
        LocalStore.set('reality_check.keep_open', 0);
    }
    
    function updateAck() {
        LocalStore.set('reality_check.ack', 1);
    }

    function getInterval() {
        return LocalStore.get('reality_check.interval');
    }

    function getPreviousLoadLoginId() {
        return LocalStore.get('reality_check.loginid');
    }

    function setPreviousLoadLoginId() {
        var id = TUser.get().loginid;
        LocalStore.set('reality_check.loginid', id);
    }

    function updateInterval(ms) {
        LocalStore.set('reality_check.interval', ms);
    }

    function clear() {
        LocalStore.remove('reality_check.ack');
        LocalStore.remove('reality_check.interval');
        LocalStore.remove('reality_check.keep_open');
        LocalStore.remove('reality_check.close');
        LocalStore.remove('reality_check.svrtime');
        LocalStore.remove('reality_check.basetime');
    }

    function resetInvalid() {
        var ack = LocalStore.get('reality_check.ack');
        var interval = +(LocalStore.get('reality_check.interval'));
        if (ack !== '0' && ack !== '1') {
            LocalStore.set('reality_check.ack', 0);
        }

        if (!interval) {
            LocalStore.set('reality_check.interval', defaultInterval);
        }
    }

    function summaryData(wsData) {
        var startTime = moment.utc(new Date(wsData.start_time * 1000));
        var currentTime = moment.utc();

        var sessionDuration = moment.duration(currentTime.diff(startTime));
        var durationD = sessionDuration.get('days');
        var durationH = sessionDuration.get('hours');
        var durationM = sessionDuration.get('minutes');

        var durationString = durationTemplateString
            .replace('[_1]', durationD)
            .replace('[_2]', durationH)
            .replace('[_3]', durationM);

        var turnover = +(wsData.buy_amount) + (+(wsData.sell_amount));
        var profitLoss = +(wsData.sell_amount) - (+(wsData.buy_amount));

        var startTimeString = tradingTimeTemplate.replace('[_1]', startTime.format('YYYY-MM-DD HH:mm:ss') + ' GMT');
        return {
            startTimeString: startTimeString,
            loginTime: startTime.format('YYYY-MM-DD HH:mm:ss') + ' GMT',
            currentTime: currentTime.format('YYYY-MM-DD HH:mm:ss') + ' GMT',
            sessionDuration: durationString,
            loginId: wsData.loginid,
            currency: wsData.currency,
            turnover: (+turnover).toFixed(2),
            profitLoss: (+profitLoss).toFixed(2),
            contractsBought: wsData.buy_count,
            contractsSold: wsData.sell_count,
            openContracts: wsData.open_contract_count,
            potentialProfit: (+(wsData.potential_profit)).toFixed(2)
        };
    }

    return {
        getSummaryAsync: getSummaryAsync,
        getAck: getAck,
        setOpenSummaryFlag: setOpenSummaryFlag,
        getOpenSummaryFlag: getOpenSummaryFlag,
        getPreviousLoadLoginId: getPreviousLoadLoginId,
        setPreviousLoadLoginId: setPreviousLoadLoginId,
        updateAck: updateAck,
        getInterval: getInterval,
        updateInterval: updateInterval,
        clear: clear,
        resetInvalid: resetInvalid,
        summaryData: summaryData,
        triggerCloseEvent: triggerCloseEvent
    };
}());
;var RealityCheck = (function () {
    'use strict';
    var hiddenClass = 'invisible';
    var loginTime;

    function realityCheckWSHandler(response) {
        if ($.isEmptyObject(response.reality_check)) {
            // not required for reality check
            return;
        }
        var summary = RealityCheckData.summaryData(response.reality_check);
        RealityCheckUI.renderSummaryPopUp(summary);
    }

    function computeIntervalForNextPopup(loginTime, interval) {
        var currentTime = Date.now();
        var timeLeft = interval - ((currentTime - loginTime) % interval);
        return timeLeft;
    }

    function startSummaryTimer() {
        var interval = RealityCheckData.getInterval();
        var toWait = computeIntervalForNextPopup(loginTime, interval);
        
        window.setTimeout(function () {
            RealityCheckData.setOpenSummaryFlag();
            RealityCheckData.getSummaryAsync();
        }, toWait);
    }

    function realityStorageEventHandler(ev) {
        if (ev.key === 'reality_check.ack' && ev.newValue === '1') {
            RealityCheckUI.closePopUp();
            startSummaryTimer();
        } else if (ev.key === 'reality_check.keep_open' && ev.newValue === '0') {
            RealityCheckUI.closePopUp();
            startSummaryTimer();
        }
    }

    function onContinueClick() {
        var intervalMinute = +($('#realityDuration').val());

        if (!(Math.floor(intervalMinute) == intervalMinute && $.isNumeric(intervalMinute))) {
            var shouldBeInteger = text.localize('Interval should be integer.');
            $('p.error-msg').text(shouldBeInteger);
            $('p.error-msg').removeClass(hiddenClass);
            return;
        }

        if (intervalMinute < 10 || intervalMinute > 120) {
            var minimumValueMsg = Content.errorMessage('number_should_between', '10 to 120');
            $('p.error-msg').text(minimumValueMsg);
            $('p.error-msg').removeClass(hiddenClass);
            return;
        }
        
        var intervalMs = intervalMinute * 60 * 1000;
        RealityCheckData.updateInterval(intervalMs);
        RealityCheckData.triggerCloseEvent();
        RealityCheckData.updateAck();
        RealityCheckUI.closePopUp();
        startSummaryTimer();
    }

    function onLogoutClick() {
        logout();
    }

    function logout() {
        BinarySocket.send({"logout": "1"});
    }

    function init() {
        if (!page.client.require_reality_check()) {
            RealityCheckData.setPreviousLoadLoginId();
            return;
        }

        var rcCookie = getCookieItem('reality_check');
        loginTime = rcCookie && rcCookie.split(',')[1] * 1000;

        window.addEventListener('storage', realityStorageEventHandler, false);

        if (TUser.get().loginid !== RealityCheckData.getPreviousLoadLoginId()) {
            RealityCheckData.clear();
        }

        RealityCheckData.resetInvalid();            // need to reset after clear

        if (RealityCheckData.getAck() !== '1') {
            RealityCheckUI.renderFrequencyPopUp();
        } else if (RealityCheckData.getOpenSummaryFlag() === '1') {
            RealityCheckData.getSummaryAsync();
        } else {
            startSummaryTimer();
        }

        RealityCheckData.setPreviousLoadLoginId();
    }
    
    return {
        init: init,
        onContinueClick: onContinueClick,
        onLogoutClick: onLogoutClick,
        realityCheckWSHandler: realityCheckWSHandler
    };
}());
;var RealityCheckUI = (function () {
    'use strict';

    var frequency_url = page.url.url_for('user/reality_check_frequencyws');
    var summary_url  = page.url.url_for('user/reality_check_summaryws');

    function showPopUp(content) {
        if ($('#reality-check').length > 0) {
            return;
        }

        var lightboxDiv = $("<div id='reality-check' class='lightbox'></div>");

        var wrapper = $('<div></div>');
        wrapper = wrapper.append(content);
        wrapper = $('<div></div>').append(wrapper);
        wrapper.appendTo(lightboxDiv);
        lightboxDiv.appendTo('body');

        $('#realityDuration').val(RealityCheckData.getInterval());
        $('#realityDuration').keypress(onlyNumericOnKeypress);
    }

    function showIntervalOnPopUp() {
        var intervalMinutes = Math.floor(RealityCheckData.getInterval() / 60 / 1000);
        $('#realityDuration').val(intervalMinutes);
    }

    function renderFrequencyPopUp() {
        $.ajax({
            url: frequency_url,
            dataType: 'html',
            method: 'GET',
            success: function(realityCheckText) {
                if (realityCheckText.includes('reality-check-content')) {
                    var payload = $(realityCheckText);
                    showPopUp(payload.find('#reality-check-content'));
                    showIntervalOnPopUp();
                    $('#continue').click(RealityCheck.onContinueClick);
                }
            },
            error: function(xhr) {
                return;
            }
        });
        $('#continue').click(RealityCheck.onContinueClick);
    }

    function updateSummary(summary) {
        $('#start-time').text(summary.startTimeString);
        $('#login-time').text(summary.loginTime);
        $('#current-time').text(summary.currentTime);
        $('#session-duration').text(summary.sessionDuration);
        
        $('#login-id').text(summary.loginId);
        $('#rc_currency').text(summary.currency);
        $('#turnover').text(summary.turnover);
        $('#profitloss').text(summary.profitLoss);
        $('#bought').text(summary.contractsBought);
        $('#sold').text(summary.contractsSold);
        $('#open').text(summary.openContracts);
        $('#potential').text(summary.potentialProfit);
    }

    function renderSummaryPopUp(summary) {
        $.ajax({
            url: summary_url,
            dataType: 'html',
            method: 'GET',
            success: function(realityCheckText) {
                if (realityCheckText.includes('reality-check-content')) {
                    var payload = $(realityCheckText);
                    showPopUp(payload.find('#reality-check-content'));
                    updateSummary(summary);
                    showIntervalOnPopUp();
                    $('#continue').click(RealityCheck.onContinueClick);
                    $('button#btn_logout').click(RealityCheck.onLogoutClick);
                }
            },
            error: function(xhr) {
                return;
            }
        });
    }

    function frequencyEventHandler() {
        $('button#continue').click(function() {
            RealityCheckData.updateAck();
        });
    }
    
    function summaryEventHandler() {
        $('button#continue').click(function() {
            RealityCheckData.updateAck();
        });
        
        $('button#btn_logout').click(function() {
            BinarySocket.send({logout: 1});
        });
    }

    function closePopUp() {
        $('#reality-check').remove();
    }

    return {
        frequencyEventHandler: frequencyEventHandler,
        summaryEventHandler: summaryEventHandler,
        renderFrequencyPopUp: renderFrequencyPopUp,
        renderSummaryPopUp: renderSummaryPopUp,
        closePopUp: closePopUp
    };
}());
;pjax_config_page('user/reset_passwordws', function() {
    return {
        onLoad: function() {
            BinarySocket.init({
                onmessage: ResetPassword.resetPasswordWSHandler
            });
            ResetPassword.init();
        }
    };
});
;var ResetPassword = (function () {
    'use strict';

    var hiddenClass = 'invisible';
    var resetErrorTemplate = '[_1]' +
        ' Please click the link below to restart the password recovery process. ' +
        'If you require further assistance, please contact our Customer Support.';
    var dobdd, dobmm, dobyy;

    function submitResetPassword() {
        var token = $('#verification-code').val();
        var pw1 = $('#reset-password1').val();
        var pw2 = $('#reset-password2').val();

        if (token.length < 48) {
            $('#verification-error').removeClass(hiddenClass).text(text.localize('Verification code format incorrect.'));
            return;
        }

        if (!pw1) {                                         // password not entered
            $('#password-error1').empty();
            $('#password-error1').append('<p></p>', {class: 'errorfield'}).text(Content.localize().textMessageRequired);
            $('#password-error1').removeClass(hiddenClass);
            return;
        } else if (!passwordValid(pw1)) {                   // password failed validation
            var errMsgs = showPasswordError(pw1);
            $('#password-error1').empty();
            errMsgs.forEach(function(msg){
                var $errP = $('<p></p>', {class: 'errorfield'}).text(msg);
                $('#password-error1').append($errP);
            });

            $('#password-error1').removeClass(hiddenClass);
            return;
        }

        if (pw1 !== pw2) {
            if (!pw2) {
                $('#password-error2')
                    .removeClass(hiddenClass)
                    .text(Content.localize().textMessageRequired);
            } else {
                $('#password-error2')
                    .removeClass(hiddenClass)
                    .text(Content.localize().textPasswordsNotMatching);
            }

            return;
        }

        var dobEntered = dobdd && dobmm && dobyy;
        if (dobEntered) {
            var dob;
            if (!isValidDate(dobdd, dobmm, dobyy)) {
                $('#dob-error').removeClass(hiddenClass).text(text.localize('Invalid format for date of birth.'));
                return;
            }

            dob = dobyy + '-' + dobmm + '-' + dobdd;
            BinarySocket.send({
                reset_password: 1,
                verification_code: token,
                new_password: pw1,
                date_of_birth: dob
            });
            $('#reset').prop('disabled', true);
        } else {
            BinarySocket.send({
                reset_password: 1,
                verification_code: token,
                new_password: pw1
            });
            $('#reset').prop('disabled', true);
        }
    }

    function hideError() {
        $('.errorfield').addClass(hiddenClass);
    }

    function resetPasswordWSHandler(msg) {
        var response = JSON.parse(msg.data);
        var type = response.msg_type;

        if (type === 'reset_password') {
            $('#reset').prop('disabled', true);
            $('#reset-form').addClass(hiddenClass);

            if (response.error) {
                $('p.notice-msg').addClass(hiddenClass);
                $('#reset-error').removeClass(hiddenClass);

                // special handling as backend return inconsistent format
                var errMsg;
                if (response.error.code === 'InputValidationFailed') {
                    errMsg = text.localize(resetErrorTemplate).replace('[_1]', text.localize('Token has expired.'));
                } else {
                    errMsg = text.localize(resetErrorTemplate).replace('[_1]', text.localize(response.error.message));
                }

                $('#reset-error-msg').text(errMsg);
            } else {
                $('p.notice-msg')
                    .text(text.localize('Your password has been successfully reset. ' +
                        'Please log into your account using your new password.'));
                window.setTimeout(function () {
                    window.location.href = page.url.url_for('login');
                }, 5000);
            }
        }
    }

    function haveRealAccountHandler() {
        var isChecked = $('#have-real-account').is(':checked');

        dobdd = undefined;
        dobmm = undefined;
        dobyy = undefined;

        $('#dobdd').val('');
        $('#dobmm').val('');
        $('#dobyy').val('');

        if (isChecked) {
            $('#dob-field').removeClass(hiddenClass);
        } else {
            $('#dob-field').addClass(hiddenClass);
        }
    }

    function onDOBChange() {
        dobdd = $('#dobdd').val();
        dobmm = $('#dobmm').val();
        dobyy = $('#dobyy').val();
    }

    function onEnterKey(e) {
        if (e.which === 13) {
            submitResetPassword();
        }
    }

    function init() {
        Content.populate();
        generateBirthDate();
        var $pmContainer = $('#password-meter-container');

        $('input').keypress(function (e) {
            hideError();
            onEnterKey(e);
        });

        $('#reset-password1').keyup(function (ev) {
            PasswordMeter.updateMeter($pmContainer, ev.target.value);
        });

        $('#reset:enabled').click(function () {
            submitResetPassword();
        });

        $('#have-real-account').click(function () {
            haveRealAccountHandler();
        });

        $('select').change(function () {
            hideError();
            onDOBChange();
        });

        PasswordMeter.attach($pmContainer);
    }

    return {
        resetPasswordWSHandler: resetPasswordWSHandler,
        init: init
    };
}());
;pjax_config_page("user/statement", function(){
    return {
        onLoad: function() {
            if (page.client.redirect_if_logout()) {
                return;
            }
            BinarySocket.init({
                onmessage: function(msg){
                    var response = JSON.parse(msg.data);

                    if (response) {
                        var type = response.msg_type;
                        if (type === 'statement'){
                            StatementWS.statementHandler(response);
                        }
                    }
                }
            });
            Content.populate();
            StatementWS.init();
        },
        onUnload: function(){
            StatementWS.clean();
        }
    };
});
;var StatementData = (function(){
    "use strict";
    var hasOlder = true;

    function getStatement(opts){
        var req = {statement: 1, description: 1};
        if(opts){ 
            $.extend(true, req, opts);    
        }

        BinarySocket.send(req);
    }

    return {
        getStatement: getStatement,
        hasOlder: hasOlder
    };
}());
;var StatementWS = (function(){
    "use strict";

    //Batch refer to number of data get from ws service per request
    //chunk refer to number of data populate to ui for each append
    //receive means receive from ws service
    //consume means consume by UI and displayed to page

    var batchSize = 100;
    var chunkSize = batchSize/2;

    var noMoreData = false;
    var pending = false;            //serve as a lock to prevent ws request is sequential
    var currentBatch = [];
    var transactionsReceived = 0;
    var transactionsConsumed = 0;

    var tableExist = function(){
        return document.getElementById("statement-table");
    };
    var finishedConsumed = function(){
        return transactionsConsumed === transactionsReceived;
    };

    function statementHandler(response){
        pending = false;

        var statement = response.statement;
        currentBatch = statement.transactions;
        transactionsReceived += currentBatch.length;

        if (currentBatch.length < batchSize){
            noMoreData = true;
        }

        if (!tableExist()) {
            StatementUI.createEmptyStatementTable().appendTo("#statement-ws-container");
            StatementUI.updateStatementTable(getNextChunkStatement());

            // Show a message when the table is empty
            if ((transactionsReceived === 0) && (currentBatch.length === 0)) {
                $('#statement-table tbody')
                    .append($('<tr/>', {class: "flex-tr"})
                        .append($('<td/>', {colspan: 7})
                            .append($('<p/>', {class: "notice-msg center", text: text.localize("Your account has no trading activity.")})
                            )
                        )
                    );
            }

            Content.statementTranslation();
        }
    }

    function getNextBatchStatement(){
        StatementData.getStatement({offset: transactionsReceived, limit: batchSize});
        pending = true;
    }

    function getNextChunkStatement(){
        var chunk = currentBatch.splice(0, chunkSize);
        transactionsConsumed += chunk.length;
        return chunk;
    }


    function loadStatementChunkWhenScroll(){
        $(document).scroll(function(){

            function hidableHeight(percentage){
                var totalHidable = $(document).height() - $(window).height();
                return Math.floor(totalHidable * percentage / 100);
            }

            var pFromTop = $(document).scrollTop();

            if (!tableExist()){
                return;
            }

            if (pFromTop < hidableHeight(70)) {
                return;
            }

            if (finishedConsumed() && !noMoreData && !pending) {
                getNextBatchStatement();
                return;
            }

            if (!finishedConsumed()){
                StatementUI.updateStatementTable(getNextChunkStatement());
            }
        });
    }


    function initTable(){
        pending = false;
        noMoreData = false;

        currentBatch = [];

        transactionsReceived = 0;
        transactionsConsumed = 0;

        $(".error-msg").text("");

        StatementUI.clearTableContent();
    }

    function initPage(){
        getNextBatchStatement();
        loadStatementChunkWhenScroll();
    }

    function cleanStatementPageState(){
        initTable();
    }

    return {
        init: initPage,
        statementHandler: statementHandler,
        clean: cleanStatementPageState
    };
}());
;var StatementUI = (function(){
    "use strict";
    var tableID = "statement-table";
    var columns = ["date", "ref", "act", "desc", "credit", "bal", "details"];

    function createEmptyStatementTable(){
        var header = [
            Content.localize().textPurchaseDate,
            Content.localize().textRef,
            Content.localize().textAction,
            Content.localize().textDescription,
            Content.localize().textCreditDebit,
            Content.localize().textBalance,
            Content.localize().textDetails
        ];

        header[5] = header[5] + (TUser.get().currency ? " (" + TUser.get().currency + ")" : "");

        var metadata = {
            id: tableID,
            cols: columns
        };
        var data = [];
        var $tableContainer = Table.createFlexTable(data, metadata, header);
        return $tableContainer;
    }

    function updateStatementTable(transactions){
        Table.appendTableBody(tableID, transactions, createStatementRow);
    }

    function clearTableContent(){
        Table.clearTableBody(tableID);
        $("#" + tableID +">tfoot").hide();
    }

    function createStatementRow(transaction){
        var action = transaction["action_type"];
        var dateObj = new Date(transaction["transaction_time"] * 1000);
        if (action === 'sell') {
            dateObj = new Date(transaction["purchase_time"] * 1000);
        }
        action = StringUtil.toTitleCase(action);

        var momentObj = moment.utc(dateObj);
        var dateStr = momentObj.format("YYYY-MM-DD");
        var timeStr = momentObj.format("HH:mm:ss");

        var date = dateStr + "\n" + timeStr;
        var ref = transaction["transaction_id"];
        var desc = transaction["longcode"].replace(/\n/g, '<br />');
        var amount = addComma(Number(parseFloat(transaction["amount"])));
        var balance = addComma(Number(parseFloat(transaction["balance_after"])));

        var creditDebitType = (parseFloat(amount) >= 0) ? "profit" : "loss";

        var $statementRow = Table.createFlexTableRow([date, ref, action, '', amount, balance, ''], columns, "data");
        $statementRow.children(".credit").addClass(creditDebitType);
        $statementRow.children(".date").addClass("pre");
        $statementRow.children(".desc").html(desc + "<br>");

        //create view button and append
        if (action === "Sell" || action === "Buy") {
            var $viewButtonSpan = Button.createBinaryStyledButton();
            var $viewButton = $viewButtonSpan.children(".button").first();
            $viewButton.text(text.localize("View"));
            $viewButton.addClass("open_contract_detailsws");
            $viewButton.attr("contract_id", transaction["contract_id"]);

            $statementRow.children(".desc,.details").append($viewButtonSpan);
        }

        return $statementRow[0];        //return DOM instead of jquery object
    }

    return {
        clearTableContent: clearTableContent,
        createEmptyStatementTable: createEmptyStatementTable,
        updateStatementTable: updateStatementTable
    };
}());
;function submit_email() {
  var error = document.getElementById('signup_error');
  $('#verify-email-form').submit( function(evt){
    evt.preventDefault();
    var email = document.getElementById('email').value;
    Content.populate();

    if(!Validate.errorMessageEmail(email, error)) {
      BinarySocket.init({
          onmessage: function(msg){
              var response = JSON.parse(msg.data);

              if (response) {
                  var type = response.msg_type;
                  var wsError = response.error;
                  if (type === 'verify_email' && !wsError){
                    window.location.href = page.url.url_for('new_account/virtualws');
                  } else if (wsError && wsError.message) {
                    error.innerHTML = wsError.message;
                    error.style.display = 'inline-block';
                  }
              }
          }
      });
      BinarySocket.send({verify_email: email, type: 'account_opening'});
    }
  });
}
;var ViewPopupUI = (function() {
    var _container = null;
    return {
        _init: function () {
            _container = null;
        },
        container: function (refresh) {
            if (refresh) {
                if (this._container) {
                    this._container.remove();
                }
                this._container = null;
            }
            if (!this._container) {
                var that = this;
                var con = $('<div class="inpage_popup_container inpage_popup_container_ws" id="sell_popup_container"><a class="close">x</a><div class="inpage_popup_content"></div></div>');
                con.hide();
                var _on_close = function () {
                    that.cleanup(true);
                    window.updateChart = 'false';
                    if(TradePage.is_trading_page()) {
                        // Re-subscribe the trading page's tick stream which was unsubscribed by popup's chart
                        BinarySocket.send({'ticks_history':$('#underlying').val(),'style':'ticks','end':'latest','count':20,'subscribe':1});
                    }
                };
                con.find('a.close').on('click', function () { _on_close(); } );
                $(document).on('keydown', function(e) {
                     if (e.which === 27) _on_close();
                });
                this._container = con;
            }
            return this._container;
        },
        cleanup: function () {
            this.forget_streams();
            this.clear_timer();
            this.close_container();
            this._init();
            Highchart.clear_values();
        },
        forget_streams: function() {
            while(window.stream_ids && window.stream_ids.length > 0) {
                var id = window.stream_ids.pop();
                if(id && id.length > 0) {
                    BinarySocket.send({"forget": id});
                }
            }
        },
        clear_timer: function() {
            if(window.ViewPopupTimerInterval) {
                clearInterval(window.ViewPopupTimerInterval);
                window.ViewPopupTimerInterval = undefined;
            }
        },
        close_container: function () {
            if (this._container) {
                this._container.hide().remove();
                $('.popup_page_overlay').hide().remove();
                this._container = null;
            }
        },
        disable_button: function (button) {
            button.attr('disabled', 'disabled');
            button.fadeTo(0, 0.5);
        },
        enable_button: function (button) {
            button.removeAttr('disabled');
            button.fadeTo(0, 1);
        },
        show_inpage_popup: function (data, containerClass, dragHandle) {
            var that = this;
            var con = this.container(true);
            if(containerClass) {
                con.addClass(containerClass);
            }
            if (data) {
                $('.inpage_popup_content', con).html(data);
            }
            var body = $(document.body);
            con.css('position', 'fixed').css('z-index', get_highest_zindex() + 100);
            body.append(con);
            con.show();
            $(document.body).append($('<div/>', {class: 'popup_page_overlay'}));
            $('.popup_page_overlay').click(function(){con.find('a.close').click();});
            con.draggable({
                stop: function() {
                    that.reposition_confirmation_ondrag();
                },
                handle: dragHandle,
                scroll: false,
            });
            $(dragHandle).disableSelection();
            this.reposition_confirmation();
            return con;
        },
        reposition_confirmation_ondrag: function () {
            var con    = this.container();
            var offset = con.offset();
            var win_   = $(window);
            // top
            if(offset.top < win_.scrollTop()) {con.offset({top: win_.scrollTop()});}
            // left
            if(offset.left < 0) {con.offset({left: 0});}
            // right
            if(offset.left > win_.width() - con.width()) {con.offset({left: win_.width() - con.width()});}
        },
        reposition_confirmation: function (x, y) {
            var con = this.container();
            var win_ = $(window);
            var x_min = 50;
            var y_min = 500;
            if(win_.width() < 767) { //To be responsive, on mobiles and phablets we show popup as full screen.
                x_min = 0;
                y_min = 0;
            }
            if (x === undefined) {
                x = Math.max(Math.floor((win_.width() - win_.scrollLeft() - con.width()) / 2), x_min) + win_.scrollLeft();
            }
            if (y === undefined) {
                y = Math.min(Math.floor((win_.height() - con.height()) / 2), y_min) + win_.scrollTop();
                if(y < win_.scrollTop()) {y = win_.scrollTop();}
            }
            con.offset({left: x, top: y});
        },
    };
}());
;var ViewPopupWS = (function() {
    "use strict";

    var contractID,
        contractType,
        contract,
        history,
        proposal,
        isSold,
        isSellClicked,
        chartStarted,
        tickForgotten;
    var $Container,
        $loading,
        btnView,
        popupboxID,
        wrapperID,
        winStatusID,
        hiddenClass;

    var init = function(button) {
        btnView       = button;
        contractID    = $(btnView).attr('contract_id');
        contractType  = '';
        contract      = {};
        history       = {};
        proposal      = {};
        isSold        = false;
        isSellClicked = false;
        chartStarted  = false;
        tickForgotten = false;
        $Container    = '';
        popupboxID    = 'inpage_popup_content_box';
        wrapperID     = 'sell_content_wrapper';
        winStatusID   = 'contract_win_status';
        hiddenClass   = 'hidden';

        if (btnView) {
            ViewPopupUI.disable_button($(btnView));
            ViewPopupUI.cleanup(true);
        }

        getContract();

        setLoadingState(true);
    };

    var responseContract = function(response) {
        if(!response.proposal_open_contract || Object.keys(response.proposal_open_contract).length === 0) {
            showErrorPopup(response);
            return;
        }
        // In case of error such as legacy shortcode, this call is returning the error message
        // but no error field. To specify those cases, we check for other fields existence
        if(!response.proposal_open_contract.hasOwnProperty('shortcode')) {
            showErrorPopup(response, response.proposal_open_contract.validation_error);
            return;
        }

        $.extend(contract, response.proposal_open_contract);

        if(contract && contractType) {
            if (!document.getElementById(wrapperID)) return;
            ViewPopupWS[contractType + 'Update']();
            return;
        }

        // ----- Tick -----
        if(contract.hasOwnProperty('tick_count')) {
            contractType = 'tick';
            getTickHistory(contract.underlying, contract.date_start - 60, contract.date_start - 1, 1);
        }
        // ----- Spread -----
        else if(contract.shortcode.toUpperCase().indexOf('SPREAD') === 0) {
            contractType = 'spread';
            getTickHistory(contract.underlying, contract.date_start + 1, contract.date_start + 60, 0);

            var shortcode = contract.shortcode.toUpperCase();
            var details   = shortcode.replace(contract.underlying.toUpperCase() + '_', '').split('_');
            contract.per_point   = details[1];
            contract.stop_loss   = details[3];
            contract.stop_profit = details[4];
            contract.is_point    = details[5] === 'POINT';

            socketSend({
                "proposal"        : 1,
                "symbol"          : contract.underlying,
                "currency"        : contract.currency,
                "contract_type"   : details[0],
                "amount_per_point": contract.per_point,
                "stop_loss"       : contract.stop_loss,
                "stop_profit"     : contract.stop_profit,
                "stop_type"       : details[5].toLowerCase()
            });
        }
        // ----- Normal -----
        else {
            contractType = 'normal';
            normalShowContract();
        }
    };

    // ===== Contract: Tick =====
    var tickShowContract = function() {
        setLoadingState(false);

        ViewPopupUI.show_inpage_popup(
            $('<div/>', {id: wrapperID, class: popupboxID})
                .append($('<div/>', {class: 'popup_bet_desc drag-handle', text: contract.longcode}))
                .append($('<div/>', {id: 'tick_chart'}))
                .append($('<div/>', {id: winStatusID, class: hiddenClass})),
            'tick_popup'
        );

        TickDisplay.initialize({
             "symbol"              : contract.underlying,
             "number_of_ticks"     : contract.tick_count,
             "previous_tick_epoch" : history.times[0],
             "contract_category"   : ((/asian/i).test(contract.shortcode) ? 'asian' : (/digit/i).test(contract.shortcode) ? 'digits' : 'callput'),
             "longcode"            : contract.longcode,
             "display_decimals"    : history.prices[0].split('.')[1].length || 2,
             "display_symbol"      : contract.display_name,
             "contract_start"      : contract.date_start,
             "show_contract_result": 0
         });

        tickUpdate();
    };

    var tickUpdate = function() {
        if(contract.is_expired) {
            showWinLossStatus((contract.sell_price || contract.bid_price) > 0);
        }
    };

    // ===== Contract: Spread =====
    var spreadShowContract = function() {
        if(Object.keys(history).length === 0 || Object.keys(proposal).length === 0) {
            return;
        }

        setLoadingState(false);

        contract.is_up        = contract.shortcode['spread'.length] === 'U';
        contract.direction    = contract.is_up ? 1 : -1;
        contract.spread       = proposal.spread;
        contract.decPlaces    = ((/^\d+(\.\d+)?$/).exec(history.prices[0])[1] || '-').length - 1;
        contract.entry_level  = parseFloat(history.prices[0] * 1 + contract.direction * contract.spread / 2);

        spreadSetValues();

        if(!$Container) {
            $Container = spreadMakeTemplate();
        }

        $Container.find('#entry_level').text(contract.entry_level.toFixed(contract.decPlaces));
        $Container.find('#per_point').text((contract.is_up ? '+' : '-') + contract.per_point);

        spreadUpdate();
    };

    var spreadSetValues = function() {
        contract.is_ended          = contract.is_expired || contract.is_sold;
        contract.status            = text.localize(contract.is_ended ? 'Closed' : 'Open');
        contract.profit            = contract.sell_price ? parseFloat(contract.sell_price) - parseFloat(contract.buy_price) : parseFloat(contract.bid_price) - parseFloat(contract.ask_price);
        contract.profit_point      = contract.profit / contract.per_point;
        contract.stop_loss_level   = contract.entry_level + contract.stop_loss   / (contract.is_point ? 1 : contract.per_point) * (- contract.direction);
        contract.stop_profit_level = contract.entry_level + contract.stop_profit / (contract.is_point ? 1 : contract.per_point) * contract.direction;
    };

    var spreadUpdate = function() {
        spreadSetValues();

        containerSetText('status'           , contract.status, {'class': contract.is_ended ? 'loss' : 'profit'});
        containerSetText('stop_loss_level'  , contract.stop_loss_level.toFixed(contract.decPlaces));
        containerSetText('stop_profit_level', contract.stop_profit_level.toFixed(contract.decPlaces));
        containerSetText('pl_value'         , contract.profit.toFixed(2), {'class': contract.profit >= 0 ? 'profit' : 'loss'});
        containerSetText('pl_point'         , contract.profit_point.toFixed(2));

        if(!contract.is_ended) {
            contract.sell_level = contract.entry_level + contract.profit_point * contract.direction;
            containerSetText('sell_level', contract.sell_level.toFixed(contract.decPlaces));
        }
        else {
            spreadContractEnded(contract.profit >= 0);
        }

        sellSetVisibility(!isSellClicked && !contract.is_ended);
    };

    var spreadContractEnded = function(is_win) {
        contract.exit_level = contract.entry_level + contract.profit_point * contract.direction;
        $Container.find('#sell_level').parent('tr').addClass(hiddenClass);
        $Container.find('#exit_level').text(contract.exit_level.toFixed(contract.decPlaces)).parent('tr').removeClass(hiddenClass);
        sellSetVisibility(false);
        // showWinLossStatus(is_win);
    };

    var spreadMakeTemplate = function() {
        $Container = $('<div/>');
        $Container.prepend($('<div/>', {id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: text.localize('Contract Information')}));

        var $table = $('<table><tbody></tbody></table>');
        var tbody = spreadRow('Status'              , 'status', (contract.is_ended ? 'loss' : 'profit')) +
                    spreadRow('Entry Level'         , 'entry_level') +
                    spreadRow('Exit Level'          , 'exit_level', '', '', !contract.is_ended) +
                    spreadRow('Stop Loss Level'     , 'stop_loss_level') +
                    spreadRow('Stop Profit Level'   , 'stop_profit_level') +
                    spreadRow('Current Level'       , 'sell_level', '', '', contract.is_ended) +
                    spreadRow('Amount Per Point'    , 'per_point') +
                    spreadRow('Profit/Loss'         , 'pl_value', (contract.profit >= 0 ? 'profit' : 'loss'), ' (' + contract.currency + ')') +
                    spreadRow('Profit/Loss (points)', 'pl_point');

        $table.find('tbody').append(tbody);
        $Container.append(
            $('<div/>', {id: wrapperID})
                .append($('<div/>', {id: 'spread_table'}).append($table))
                .append($('<div/>', {id: 'errMsg', class: 'notice-msg ' + hiddenClass}))
                .append($('<div/>', {id: winStatusID, class: hiddenClass}))
                .append($('<div/>', {id: 'contract_sell_wrapper', class: hiddenClass}))
        );

        ViewPopupUI.show_inpage_popup('<div class="' + popupboxID + '">' + $Container.html() + '</div>', 'spread_popup', '#sell_bet_desc, #sell_content_wrapper');

        return $('#' + wrapperID);
    };

    var spreadRow = function(label, id, classname, label_no_localize, isHidden) {
        return '<tr' + (isHidden ? ' class="' + hiddenClass + '"' : '') + '><td>' + text.localize(label) + (label_no_localize || '') + '</td><td' + (id ? ' id="' + id + '"' : '') + (classname ? ' class="' + classname + '"' : '') + '></td></tr>';
    };

    // ===== Contract: Normal =====
    var normalShowContract = function() {
        setLoadingState(false);

        if(!$Container) {
            $Container = normalMakeTemplate();
        }

        containerSetText('trade_details_contract_id'   , contract.contract_id);
        containerSetText('trade_details_start_date'    , epochToDateTime(contract.date_start));
        containerSetText('trade_details_end_date'      , epochToDateTime(contract.date_expiry));
        containerSetText('trade_details_purchase_price', contract.currency + ' ' + parseFloat(contract.buy_price).toFixed(2));

        normalUpdateTimers();
        normalUpdate();
    };

    var normalUpdate = function() {
        var finalPrice = contract.sell_price || contract.bid_price,
            is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start,
            user_sold  = contract.sell_spot_time && contract.sell_spot_time < contract.date_expiry,
            is_ended   = contract.is_expired || contract.is_sold || user_sold;

        if(contract.high_barrier) {
            containerSetText('trade_details_barrier'    , contract.high_barrier , '', true);
            containerSetText('trade_details_barrier_low', contract.low_barrier  , '', true);
        } else if(contract.barrier) {
            containerSetText('trade_details_barrier'    , contract.barrier || '', '', true);
        }

        var currentSpot = user_sold ? contract.sell_spot : (is_ended ? contract.exit_tick : contract.current_spot);

        containerSetText('trade_details_ref_id'          , contract.transaction_ids.buy + (contract.transaction_ids.sell ? ' - ' + contract.transaction_ids.sell : ''));
        containerSetText('trade_details_current_date'    , epochToDateTime(!is_ended ? contract.current_spot_time : (user_sold ? contract.sell_spot_time : contract.exit_tick_time)));
        containerSetText('trade_details_current_spot'    , currentSpot || text.localize('not available'));
        containerSetText('trade_details_indicative_price', contract.currency + ' ' + parseFloat(is_ended ? (contract.sell_price || contract.bid_price) : contract.bid_price).toFixed(2));

        var profit_loss = finalPrice - contract.buy_price;
        var percentage  = (profit_loss * 100 / contract.buy_price).toFixed(2);
        containerSetText('trade_details_profit_loss', contract.currency + ' ' + parseFloat(profit_loss).toFixed(2) + '<span>(' + (percentage > 0 ? '+' : '') + percentage + '%' + ')</span>', {'class': (profit_loss >= 0 ? 'profit' : 'loss')});

        if(!is_started) {
            containerSetText('trade_details_entry_spot', '-');
            containerSetText('trade_details_message'   , text.localize('Contract is not started yet'));
        }
        else{
            if(contract.entry_spot > 0) {
                containerSetText('trade_details_entry_spot', contract.entry_spot);
            }
            containerSetText('trade_details_message', contract.validation_error || '&nbsp;');
        }

        if(!chartStarted) {
            if (TradePage.is_trading_page() && !tickForgotten) {
              socketSend({"forget_all":"ticks"});
              tickForgotten = true;
            } else if (!TradePage.is_trading_page()) {
                Highchart.show_chart(contract);
                if (contract.entry_tick_time) {
                  chartStarted = true;
                }
                tickForgotten = true;
            } else if (tickForgotten) {
              Highchart.show_chart(contract, 'update');
              if (contract.entry_tick_time) {
                chartStarted = true;
              }
            }
        }

        if(!isSold && user_sold) {
            isSold = true;
            Highchart.show_chart(contract, 'update');
        }
        if(is_ended) {
            normalContractEnded(parseFloat(profit_loss) >= 0);
            if(contract.is_valid_to_sell && contract.is_expired && !contract.is_sold && !isSellClicked) {
                ViewPopupUI.forget_streams();
                sellExpired();
            }
            Highchart.show_chart(contract, 'update');
        }

        sellSetVisibility(!isSellClicked && !isSold && !is_ended && +contract.is_valid_to_sell === 1);
        contract.chart_validation_error = contract.validation_error;
        contract.validation_error = '';
    };

    var normalUpdateTimers = function() {
        var update_time = function() {
            var now = Math.max(Math.ceil((window.time || 0) / 1000), contract.current_spot_time || 0);
            containerSetText('trade_details_live_date' , epochToDateTime(now));

            var is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start,
                is_ended   = contract.is_expired || contract.is_sold;
            if(!is_started || is_ended || now >= contract.date_expiry) {
                containerSetText('trade_details_live_remaining', '-');
            } else {
                var remained = contract.date_expiry - now,
                    day_seconds = 24 * 60 * 60,
                    days = 0;
                if(remained > day_seconds) {
                    days = Math.floor(remained / day_seconds);
                    remained = remained % day_seconds;
                }
                containerSetText('trade_details_live_remaining',
                    (days > 0 ? days + ' ' + text.localize(days > 1 ? 'days' : 'day') + ', ' : '') +
                    moment((remained) * 1000).utc().format('HH:mm:ss'));
            }
        };
        update_time();

        clearInterval(window.ViewPopupTimerInterval);
        window.ViewPopupTimerInterval = setInterval(update_time, 500);
    };

    var normalContractEnded = function(is_win) {
        containerSetText('trade_details_current_title'   , text.localize(contract.sell_spot_time < contract.date_expiry ? 'Contract Sold' : 'Contract Expiry'));
        containerSetText('trade_details_spot_label'      , text.localize('Exit Spot'));
        containerSetText('trade_details_spottime_label'  , text.localize('Exit Spot Time'));
        containerSetText('trade_details_indicative_label', text.localize('Price'));
        containerSetText('trade_details_message'         , '&nbsp;', {'epoch_time': ''});
        sellSetVisibility(false);
        // showWinLossStatus(is_win);
    };

    var normalMakeTemplate = function() {
        $Container = $('<div/>').append($('<div/>', {id: wrapperID}));
        $Container.prepend($('<div/>', {id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: contract.longcode}));
        var $sections = $('<div/>').append($('<div id="sell_details_chart_wrapper" class="grd-grid-8 grd-grid-mobile-12"></div><div id="sell_details_table" class="grd-grid-4 grd-grid-mobile-12 drag-handle"></div>'));

        $sections.find('#sell_details_table').append($(
            '<table>' +
                '<tr><th colspan="2">' + text.localize('Contract Information') + '</th></tr>' +
                    normalRow('Contract ID',    '', 'trade_details_contract_id') +
                    normalRow('Reference ID',   '', 'trade_details_ref_id') +
                    normalRow('Start Time',     '', 'trade_details_start_date') +
                    normalRow('End Time',       '', 'trade_details_end_date') +
                    normalRow('Remaining Time', '', 'trade_details_live_remaining') +
                    normalRow('Entry Spot',     '', 'trade_details_entry_spot') +
                    normalRow(contract.high_barrier ? 'High Barrier' : 'Barrier', '', 'trade_details_barrier'    , true) +
                    (contract.low_barrier ? normalRow('Low Barrier',              '', 'trade_details_barrier_low', true) : '') +
                    normalRow('Purchase Price', '', 'trade_details_purchase_price') +
                '<tr><th colspan="2" id="trade_details_current_title">' + text.localize('Current') + '</th></tr>' +
                    normalRow('Spot',           'trade_details_spot_label'    , 'trade_details_current_spot') +
                    normalRow('Spot Time',      'trade_details_spottime_label', 'trade_details_current_date') +
                    normalRow('Current Time',   '', 'trade_details_live_date') +
                    normalRow('Indicative',     'trade_details_indicative_label', 'trade_details_indicative_price') +
                    normalRow('Profit/Loss',    '', 'trade_details_profit_loss') +
                '<tr><td colspan="2" class="last_cell" id="trade_details_message">&nbsp;</td></tr>' +
            '</table>' +
            '<div id="errMsg" class="notice-msg hidden"></div>' +
            '<div id="trade_details_bottom"><div id="contract_sell_wrapper" class="' + hiddenClass + '"></div><div id="contract_sell_message"></div><div id="contract_win_status" class="' + hiddenClass + '"></div></div>'
        ));

        $sections.find('#sell_details_chart_wrapper').html('<div id="live_chart_form_wrapper" class="grd-grid-12"></div>' +
            '<div class="chart-notice"><div class="notice" id="delayed_feed_notice" style="display: none;">Charting for this underlying is delayed</div><div class="notice" id="not_available_notice" style="display: none;">Charting is not available for this underlying</div></div>' +
            '<div id="analysis_live_chart" class="live_chart_wrapper grd-grid-12"><div>');

        $Container.find('#' + wrapperID)
            .append($sections.html())
            .append($('<div/>', {id: 'errMsg', class: 'notice-msg ' + hiddenClass}));

        ViewPopupUI.show_inpage_popup('<div class="' + popupboxID + '">' + $Container.html() + '</div>', '', '#sell_bet_desc, #sell_details_table');

        return $('#' + wrapperID);
    };

    var normalRow = function(label, label_id, value_id, isHidden) {
        return '<tr' + (isHidden ? ' class="' + hiddenClass + '"' : '') + '><td' + (label_id ? ' id="' + label_id + '"' : '') + '>' + text.localize(label) + '</td><td' + (value_id ? ' id="' + value_id + '"' : '') + '></td></tr>';
    };

    var normalSetVisibleRow = function(child_id, isVisible) {
        var $row = $('#' + child_id).parent('tr');
        if(isVisible) $row.removeClass(hiddenClass);
        else $row.addClass(hiddenClass);
    };

    var epochToDateTime = function(epoch) {
        return moment.utc(epoch * 1000).format('YYYY-MM-DD HH:mm:ss');
    };

    // ===== Tools =====
    var containerSetText = function(id, text, attributes, isVisible) {
        if(!$Container || $Container.length === 0) {
            $Container = $('#' + wrapperID);
        }

        var $target = $Container.find('#' + id);
        if($target && $target.length > 0) {
            $target.html(text);
            if(attributes && Object.keys(attributes).length > 0) {
                $target.attr(attributes);
            }
            if(isVisible) $target.parent('tr').removeClass(hiddenClass);
        }
    };

    var showWinLossStatus = function(isWin) {
        containerSetText(
            winStatusID,
            text.localize('This contract has ' + (isWin ? 'WON' : 'LOST')),
            {class: isWin ? 'won' : 'lost'}
        );
    };

    var setLoadingState = function(showLoading) {
        if(showLoading) {
            $loading = $('#trading_init_progress');
            if($loading.length) {
                $loading.show();
            }
        }
        else {
            if($loading.length) {
                $loading.hide();
            }
            if (btnView) {
                ViewPopupUI.enable_button($(btnView));
            }
        }
    };

    var showMessagePopup = function(message, title, msgClass) {
        setLoadingState(false);
        var $con = $('<div/>');
        $con.prepend($('<div/>', {id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: text.localize(title)}));
        $con.append(
            $('<div/>', {id: wrapperID})
                .append($('<div/>', {class: msgClass, html: text.localize(message)}))
        );
        ViewPopupUI.show_inpage_popup('<div class="' + popupboxID + '">' + $con.html() + '</div>', 'message_popup', '#sell_bet_desc, #sell_content_wrapper');
    };

    var showErrorPopup = function(response, message) {
        if(!message || message.length === 0) {
            message = 'Sorry, an error occurred while processing your request.';
        }
        showMessagePopup(text.localize(message), 'There was an error', 'notice-msg');
        console.log(response);
    };

    var sellSetVisibility = function(show) {
        var sellWrapperID = 'sell_at_market_wrapper',
            sellButtonID  = 'sell_at_market';
        var isExist = $Container.find('#' + sellWrapperID).length > 0;
        if(show === true) {
            if(!isExist) {
                if(contractType === 'spread') {
                    $Container.find('#contract_sell_wrapper').removeClass(hiddenClass).append(
                        $('<p/>', {id: sellWrapperID, class: 'button'})
                            .append($('<button/>', {id: sellButtonID, class: 'button', text: text.localize('Sell')}))
                    );
                }
                else {
                    $Container.find('#contract_sell_wrapper').removeClass(hiddenClass).append($('<div id="' + sellWrapperID + '"><span class="button"><button id="' + sellButtonID + '" class="button">' + text.localize('Sell at market') + '</button></span>' +
                        '<div class="note"><strong>' + text.localize('Note') + ':</strong> ' + text.localize('Contract will be sold at the prevailing market price when the request is received by our servers. This price may differ from the indicated price.') + '</div>'));
                }
                $Container.find('#' + sellButtonID).unbind('click').click(function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    ViewPopupUI.forget_streams();
                    isSellClicked = true;
                    sellSetVisibility(false);
                    sellContract();
                });
            }
        }
        else {
            if(isExist) {
                $Container.find('#' + sellButtonID).unbind('click');
                $Container.find('#' + sellWrapperID).remove();
            }
        }
    };

    // ===== Requests & Responses =====
    // ----- Get Contract -----
    var getContract = function() {
        if(contractID) {
            ViewPopupUI.forget_streams();
            socketSend({"proposal_open_contract": 1, "contract_id": contractID, "subscribe": 1});
        }
    };

    // ----- Sell Expired -----
    var sellExpired = function(passthrough) {
        var req = {"sell_expired": 1, passthrough: {}};
        if(passthrough && Object.keys(passthrough).length > 0) {
            req.passthrough = passthrough;
        }
        socketSend(req);
    };

    var responseSellExpired = function(response) {
        getContract();
    };

    // ----- Sell Contract -----
    var sellContract = function(price, passthrough) {
        if(!price) {
            price = 0;
        }
        var req = {"sell": contractID, "price": price, passthrough: {}};
        if(passthrough && Object.keys(passthrough).length > 0) {
            req.passthrough = passthrough;
        }
        socketSend(req);
    };

    var responseSell = function(response) {
        if(response.hasOwnProperty('error')) {
            if(response.error.code === 'NoOpenPosition') {
                getContract();
            }
            else {
                $Container.find('#errMsg').text(response.error.message).removeClass(hiddenClass);
            }
            return;
        }
        if(contractType === 'spread') {
            sellSetVisibility(false);
            getContract();
        }
        else if(contractType === 'normal') {
            sellSetVisibility(false);
            if(isSellClicked) {
                containerSetText('contract_sell_message',
                    text.localize('You have sold this contract at [_1] [_2]').replace('[_1]', contract.currency).replace('[_2]', response.sell.sold_for) +
                    '<br />' +
                    text.localize('Your transaction reference number is [_1]').replace('[_1]', response.sell.transaction_id)
                );
            }
            getContract();
        }
    };

    // ----- Tick History -----
    var getTickHistory = function(symbol, start, end, count, passthrough, granularity) {
        var req = {"ticks_history": symbol, "start": start, "end": end, "count": count, passthrough: {}};
        if(!start) {
            delete(req['start']);
        }
        if(!count || count === 0) {
            delete(req['count']);
        }
        if(passthrough && Object.keys(passthrough).length > 0) {
            req.passthrough = passthrough;
        }
        req.passthrough.contract_id = contractID;
        if(granularity > 0) {
            req.style = 'candles';
            req.granularity = granularity;
        }
        socketSend(req);
    };

    var responseHistory = function(response) {
        if(response.hasOwnProperty('error')) {
            // Sometimes when tick data or feed is not ready, the tick_history response returns with unclear error
            showErrorPopup(response);
            return;
        }
        if(response.echo_req.passthrough && response.echo_req.passthrough.contract_id != contractID) {
            return;
        }

        switch(contractType) {
            case 'tick':
                 history = response.history;
                 tickShowContract();
                 break;
            case 'spread':
                history = response.history;
                spreadShowContract();
                break;
        }
    };

    // ----- Proposal -----
    var responseProposal = function(response) {
        if(response.hasOwnProperty('error')) {
            showErrorPopup(response);
            return;
        }
        if(response.proposal.hasOwnProperty('id')) {
            BinarySocket.send({"forget": response.proposal.id});
        }
        if(contractType === 'spread' && Object.keys(proposal).length === 0) {
            proposal = response.proposal;
            spreadShowContract();
        }
    };

    // ===== Dispatch =====
    var storeSubscriptionID = function(id) {
        if(!window.stream_ids) {
            window.stream_ids = [];
        }
        if(id && id.length > 0 && $.inArray(id, window.stream_ids) < 0) {
            window.stream_ids.push(id);
        }
    };

    var socketSend = function(req) {
        if(!req.hasOwnProperty('passthrough')) {
            req.passthrough = {};
        }
        req.passthrough['dispatch_to'] = 'ViewPopupWS';
        BinarySocket.send(req);
    };

    var dispatch = function(response) {
        if(response.echo_req.hasOwnProperty('passthrough') && response.echo_req.passthrough.dispatch_to === 'ViewPopupWS') {
            switch(response.msg_type) {
                case 'proposal_open_contract':
                    if(response.proposal_open_contract && response.proposal_open_contract.contract_id == contractID) {
                        storeSubscriptionID(response.proposal_open_contract.id);
                        responseContract(response);
                    }
                    break;
                case 'history':
                case 'candles':
                case 'ticks_history':
                    responseHistory(response);
                    break;
                case 'proposal':
                    responseProposal(response);
                    break;
                case 'sell':
                    responseSell(response);
                    break;
                case 'sell_expired':
                    responseSellExpired(response);
                    break;
                case 'forget_all':
                    Highchart.show_chart(contract);
                    if (contract.entry_tick_time) {
                      chartStarted = true;
                    }
                    break;
                default:
                    break;
            }
        }
    };

    return {
        init                : init,
        dispatch            : dispatch,
        tickUpdate          : tickUpdate,
        spreadUpdate        : spreadUpdate,
        normalUpdate        : normalUpdate,
        storeSubscriptionID : storeSubscriptionID
    };
}());


pjax_config_page("profit_tablews|statementws|openpositionsws|trading", function() {
    return {
        onLoad: function() {
            $('#profit-table-ws-container, #statement-ws-container, #portfolio-table, #contract_confirmation_container')
                .on('click', '.open_contract_detailsws', function (e) {
                    e.preventDefault();
                    ViewPopupWS.init(this);
                });
        }
    };
});
;
var ViewBalance = (function () {
    function init(){
        BinarySocket.init(1);
    }

    return {
        init: init
    };
}());;
var ViewBalanceUI = (function(){

    function updateBalances(response){
        if(response.hasOwnProperty('error')) {
            console.log(response.error.message);
            return;
        }
        var balance = response.balance;
        var bal = addComma(Number(parseFloat(balance.balance)));
        var currency = balance.currency;
        var view = currency.toString() + " " + bal.toString();

        if(!currency){
            return;
        }

        TUser.get().balance = balance.balance;
        $("#balance").text(view);
    }

    return {
        updateBalances: updateBalances
    };
}());
;pjax_config_page("new_account/virtualws", function(){
  return {
    onLoad: function() {
      if (getCookieItem('login')) {
          window.location.href = page.url.url_for('user/my_accountws');
          return;
      }
      Content.populate();
      var virtualForm = $('#virtual-form');

      handle_residence_state_ws();
      BinarySocket.send({residence_list:1});
      var form = document.getElementById('virtual-form');
      var errorPassword = document.getElementById('error-password'),
          errorRPassword = document.getElementById('error-r-password'),
          errorResidence = document.getElementById('error-residence'),
          errorAccount = document.getElementById('error-account-opening'),
          errorVerificationCode = document.getElementById('error-verification-code');

      if (isIE() === false) {
        $('#password').on('input', function() {
          $('#password-meter').attr('value', testPassword($('#password').val())[0]);
        });
      } else {
        $('#password-meter').remove();
      }

      if (form) {
        virtualForm.submit( function(evt) {
          evt.preventDefault();

          var verificationCode = document.getElementById('verification-code').value,
              residence        = document.getElementById('residence').value,
              password         = document.getElementById('password').value,
              rPassword        = document.getElementById('r-password').value;

          Validate.errorMessageResidence(residence, errorResidence);
          Validate.errorMessageToken(verificationCode, errorVerificationCode);
          Validate.hideErrorMessage(errorAccount);

          if (Validate.errorMessagePassword(password, rPassword, errorPassword, errorRPassword) && !Validate.errorMessageResidence(residence, errorResidence) && !Validate.errorMessageToken(verificationCode, errorVerificationCode)){
            BinarySocket.init({
              onmessage: function(msg){
                var response = JSON.parse(msg.data);
                if (response) {
                  var type = response.msg_type;
                  var error = response.error;

                  if (type === 'new_account_virtual' && !error){
                    // set a flag to push to gtm in my_account
                    localStorage.setItem('new_account', '1');

                    document.getElementById('email').value = response.new_account_virtual.email;
                    form.setAttribute('action', '/login');
                    form.setAttribute('method', 'POST');
                    virtualForm.unbind('submit');
                    form.submit();
                  } else if (type === 'error' || error) {
                    if (error.code === 'InvalidToken') {
                      virtualForm.empty();
                      $('.notice-message').remove();
                      var noticeText = '<p>' + Content.localize().textClickHereToRestart.replace('[_1]', page.url.url_for('')) + '</p>';
                      virtualForm.html(noticeText);
                      return;
                    } else if (error.code === 'PasswordError') {
                      errorAccount.textContent = text.localize('Password is not strong enough.');
                    } else if (error.message) {
                      errorAccount.textContent = error.message;
                    }
                    Validate.displayErrorMessage(errorAccount);
                  }
                }
              }
            });
            VirtualAccOpeningData.getDetails(password, residence, verificationCode);
          }
        });
      }
    }
  };
});
;var VirtualAccOpeningData = (function(){
    "use strict";

    function getDetails(password, residence, verificationCode){
        var req = {
                    new_account_virtual: 1,
                    client_password: password,
                    residence: residence,
                    verification_code: verificationCode
                };

        if ($.cookie('affiliate_tracking')) {
            req.affiliate_token = JSON.parse($.cookie('affiliate_tracking')).t;
        }

        BinarySocket.send(req);
    }

    return {
        getDetails: getDetails
    };
}());
;//////////////////////////////////////////////////////////////////
// Purpose: Write loading image to a container for ajax request
// Parameters:
// 1) container - a jQuery object
//////////////////////////////////////////////////////////////////
function showLoadingImage(container)
{
    var image_link = page.settings.get('image_link');

    container.empty().append('<div id="std_loading_img"><p>'+text.localize('loading...')+'</p><img src="'+image_link['hourglass']+'" /></div>');
}

/////////////////////////////////////////////////////////////////
// Purpose   : Generate form's parameters in the format that is
//             required by XMLHttpRequest.send
// Return    : Parameters string e.g. var1=val1&var2=var2
// Parameters: Targeted form object
/////////////////////////////////////////////////////////////////
function getFormParams(form_obj)
{
    var params_arr = [];
    if (! form_obj) return '';
    var elem = form_obj.elements;

    var j=0;
    for (var i = 0; i < elem.length; i++)
    {
        if(elem[i].name)
        {
            if(elem[i].nodeName == 'INPUT' && elem[i].type.match(/radio|checkbox/) && !elem[i].checked)
            {
                continue; // skip if it is not checked
            }

            params_arr[j] = elem[i].name+'='+encodeURIComponent(elem[i].value);
            j++;
        }
    }

    var params_str = params_arr.join('&');
    return params_str;
}

/**
 * Adds thousand separators for numbers.
 *
 * @param Number num: any number (int or float)
 * @param string separator [optional] string to use for the separator (default is , as the name suggests)
 * @return string
 */
function virgule(given_num)
{
    if (isNaN(given_num)) {
        return given_num;
    }
    var maybe_minus = '';
    var num = given_num;
    if (given_num < 0) {
        num = num * -1;
        maybe_minus = '-';
    }

    if (num < 1000) {
        return maybe_minus + num;
    }

    var separator = ',';
    if (arguments.length > 1) {
        separator = arguments[1];
    }

    var int_part = num;
    var float_part = '';
    var float_match = /(\d{3,})\.(\d+)/.exec(num);
    if (float_match) {
        int_part = float_match[1];
        float_part = '.' + float_match[2];
    }
    var match = /(\d+)(\d\d\d)$/.exec(int_part);

    return maybe_minus + virgule(match[1], separator) + separator + match[2] + float_part;
}

function getImageLink() {
    var image_link = page.settings.get('image_link');
    return '<img src="' + image_link['hourglass'] + '" class="bet_bottom_loading_image" />';
}

/**
 * updates a container node for when a price value inside is updated.
 * Like when the bet price is changed, updates the bet buy price container
 * with arrows to display the change.
 *
 * @param item Object: the node object
 * @param old_val: what it used to be
 * @param new_val: what it is now
 */
function price_moved (item, old_val, new_val) {
    if (new_val < old_val) {
       item.removeClass("price_moved_up");
       item.addClass("price_moved_down");
    } else if (new_val > old_val) {
       item.removeClass("price_moved_down");
       item.addClass("price_moved_up");
    } else {
       item.removeClass("price_moved_down");
       item.removeClass("price_moved_up");
    }
}


/**
 * Returns the highest z-index in the page.
 * Accepts a jquery style selector to only check those elements,
 * uses all container tags by default
 * If no element found, returns null.
 *
 * @param selector: a jquery style selector for target elements
 * @return int|null
 */
function get_highest_zindex(selector) {
    if (!selector) {
        selector = 'div,p,area,nav,section,header,canvas,aside,span';
    }
    var all = [];
    var _store_zindex = function () {
        if ($(this).is(':visible')) {
            var z = $(this).css("z-index");
            if ( !isNaN(z) ) {
                all.push(z);
            }
        }
    };
    $(selector).each(_store_zindex);

    return all.length ? Math.max.apply(Math, all) : null;
}

/**
 * Returns a stylized price for a value as units and cents.
 * this could be used anywhere we need to show a float value
 * like in bet_sell.js to display the current sell price.
*/
function stylized_price(val) {
    var units = '0';
    var cents = '00';
    if (val) {
        val = Math.round(val * 100) / 100;
        var val_str = val.toString();
        var parts = val_str.split('.');
        units = virgule(parts[0]);
        cents = parts[1] || '00';
        if (cents.length < 2) {
            cents += '0';
        }
    }
    return {
        units: units,
        cents: '.' + cents
   };
}

/**
 * Add login param which contains the login cookie.
 * Required as our most of our ajax requests are now Cross domain and it will no longer send the login cookie.
 * Replaces the old header X-AJAX-COOKIE as this way it works for both IE9 and other newer browsers.
 * Not adding the header also avoid extra options request saving a whole 700ms on pricing.
 */
var ajax_loggedin = function(params) {
    var login_cookie = $.cookie('login');
    if(login_cookie) {
        var extra_params = 'login=' + encodeURIComponent(login_cookie);
        var staff_cookie = $.cookie('staff');
        if(staff_cookie) {
            extra_params += '&staff=' + encodeURIComponent(staff_cookie);
        }

        if(params.data) {
            params.data += '&' + extra_params;
        } else {
            params.data = extra_params;
        }
    }

    //A magical limit to param length imposed by IE.
    if(params.data && params.data.length > 2000) {
        params.type = "POST";
    }

    return params;
};

/**
 * Gets a DOM or jQuery element and reads its data attributes
 * and return an object of data stored in element attributes.
 * This is used where we store some data as element attributes.
 * Excludes commont HTML attributes from the element.
 *
 * @param element: DOM|jQuery element
 * @return object
 */
function element_data_attrs(element) {
    if (element && element instanceof jQuery) {
        element = element.get().pop();
    }
    if (!element || !element.attributes) {
        console.log(element);
        throw new Error("Can not get data attributes from none element parameter");
    }
    var data = {};
    var attrs = element.attributes;
    if (attrs.length) {
        var attr_blacklist = ['id', 'class', 'name', 'style', 'href', 'src', 'title', 'onclick'];
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            if (attr_blacklist.indexOf(attr.name.toLowerCase()) > -1) continue;
            data[attr.name] = attr.value;
        }
    }
    return data;
}

/**
 * Gets a DOM or jQuery element and reads its data attributes
 * and returns a URL encoded string (like a form data)
 * This is used where we store some data as element attributes.
 *
 * @param element: DOM or jQuery element
 * @return string
 */
function element_data_attrs_as_form_params(element) {
    var data =  element_data_attrs(element);
    var params = [];
    var key;
    for (key in data) if (data.hasOwnProperty(key)) {
        var val = data[key];
        if (val === undefined) continue;
        params.push( key + '=' + encodeURIComponent(val) );
    }
    return params.join('&');
}

/**
 * Converts a snake_cased string to a camelCased string.
 * The first character case not changed unless requested.
 *
 * @param snake: snake_cased string
 * @param lower_case_first_char: boolean to force the first char to be lower cased
 * @param chars: string of chars to be considered a separator (default is _ and -)
 */
function snake_case_to_camel_case(snake, lower_case_first_char, chars) {
    chars = chars || '_-';
    var _upper2ndchar = function (m) { return m[1].toUpperCase(); };
    var regex = new RegExp('[' + chars + ']([a-zA-Z])', 'g');
    var camel = snake.replace(regex, _upper2ndchar);
    camel.replace('_', '');
    if (lower_case_first_char) {
        camel = camel[0].toLowerCase() + camel.substr(1);
    }
    return camel;
}

/**
 * attaches a datepicker to the specified element
 * This is a thin wrapper for datepicker, helps to keep a unique site-wide
 * default configurations for the datepicker.
 *
 * @param element any jquery selector or DOM/jQuery object to attach the datepicker to
 * @param config custom configurations for the datepicker
 */
function attach_date_picker(element, conf) {
    var k,
        target = $(element);
    if (!target || !target.length) return false;
    var today = new Date();
    var next_year = new Date();
    next_year.setDate(today.getDate() + 365);
    var options = {
        dateFormat: 'yy-mm-dd',
        maxDate: next_year,
    };
    for (k in conf) if (conf.hasOwnProperty(k)) {
        options[k] = conf[k];
    }
    return target.datepicker(options);
}

/**
 * attaches a timepicker to the specified element.
 * This is a thin wrapper for timepicker, helps to keep a unique site-wide
 * default configurations for the timepicker.
 *
 * @param element any jquery selector or DOM/jQuery object to attach the timepicker to
 * @param config custom configurations for the timepicker
 */
function attach_time_picker(element, conf) {
    var attr, k, target = $(element);
    if (!target || !target.length) return false;
    var opts = {
        timeSeparator: ':',
        showLeadingZero: true,
        howMinutesLeadingZero: true,
        hourText: text.localize("Hour"),
        minuteText: text.localize("Minute"),
        minTime: {},
        maxTime: {},
    };
    var data_attrs = element_data_attrs(target);
    var regex = /^time\:(.+)/;
    for (attr in data_attrs) if (data_attrs.hasOwnProperty(attr)) {
        var matched = attr.match(regex);
        if (matched) {
            var data = data_attrs[attr];
            var opt_name = matched[1].trim();
            if (data == 'true') {
                data = true;
            } else if (data == 'false') {
                data = false;
            }
            opt_name = snake_case_to_camel_case(opt_name, true).toLowerCase();
            switch (opt_name) {
                case 'mintimehour':
                    opts.minTime.hour = data;
                    break;
                case 'mintimeminute':
                    opts.minTime.minute = data;
                    break;
                case 'maxtimehour':
                    opts.maxTime.hour = data;
                    break;
                case 'maxtimeminute':
                    opts.maxTime.minute = data;
                    break;
            }
        }
    }
    for (k in conf) if (conf.hasOwnProperty(k)) {
        opts[k] = conf[k];
    }
    return target.timepicker(opts);
}

/**
 * attaches an inpage popup to the specified element.
 *
 * @param element any jquery selector or DOM/jQuery object to attach the inpage popups to
 */
function attach_inpage_popup(element) {
    var targets = $(element);
    var popups = [];
    var regx = /^popup-(.+)/;
    targets.each(function () {
        var attr,
            matched,
            attrs = element_data_attrs(this),
            conf = {};
        for (attr in attrs) if (attrs.hasOwnProperty(attr)) {
            matched = attr.match(regx);
            if (matched) {
                conf[matched[1]] = attrs[attr];
            }
        }
        var popup = new InPagePopup(conf);
        popup.attach(this);
        popups.push(popup);
    });
    return popups;
}

/** 
 * Calculate container width for chart as of now but can
 * be used to get current container width
 */

function get_container_width() {
    var width = 960;
    if ($('.chart_holder').length > 0) {
        width = $('.chart_holder').width();
    } else {
        width = $('.grd-container').width();
    }
    return width;
}

/**
 * in a jquery UI tabs object, finds out whitch tab is marked to be the
 * active tab by default.
 *
 * The default active tab is selected based on CSS classes of tab list items.
 *
 * @param element any jquery selector or DOM/jquery object that contains a jquery UI tab UL
 * @return int the index of active list item or 0 if none of the items were
 * marked as active.
 */
function find_active_jqtab(el) {
    var jqel = $(el);
    var ul = jqel.children('ul');
    if (!ul) throw new Error("Invalid parameter. element is not a jquery UI tab container");
    ul = ul.filter(":first");
    var items = ul.children('li');
    for (var i = 0; i < items.length; i++) {
        if ($(items[i]).hasClass('active')) {
            return i;
        }
    }
    return 0;
}

/**
 * attaches tabs to the specified element selector
 *
 * @param element any jquery selector or DOM/jQuery object
 */
function attach_tabs(element) {
    var targets = $(element);
    targets.each(function () {
        var jqel = $(this);
        var conf = {};
        var active = 0;
        try {
            active = find_active_jqtab(jqel);
        } catch (e) {
            console.log(e);
            console.log(jqel);
        }
        if (active) {
            conf['active'] = active;
            $('li.active', jqel).removeClass('active');
        }
        jqel.tabs(conf);
    });
    return targets;
}
;if (isJapanTrading()) {
    var Contract = (function() {
        'use strict';

        var contractDetails = {},
            contractType = {},
            periods = {},
            open, close, form, barrier;

        var populate_periods = function(currentContract) {
            var currentCategory = currentContract['contract_category'];
            if (!periods[currentCategory]) {
                periods[currentCategory] = {};
            }

            if (!periods[currentCategory][currentContract.underlying_symbol]) {
                periods[currentCategory][currentContract.underlying_symbol] = {};
            }

            var period = currentContract['trading_period']['date_start']['epoch'] + '_' + currentContract['trading_period']['date_expiry']['epoch'];

            periods[currentCategory][currentContract['underlying_symbol']][period] = {
                available_barriers: currentContract['available_barriers'],
                barrier: currentContract['barrier'],
                high_barrier: currentContract['high_barrier'],
                low_barrier: currentContract['low_barrier'],
                barriers: currentContract['barriers'],
                date_start: currentContract['trading_period']['date_start'],
                date_expiry: currentContract['trading_period']['date_expiry'],
                duration: currentContract['trading_period']['duration']
            };
        };

        var details = function(formName) {
            var contracts = Contract.contracts()['contracts_for'],
                contractCategories = {},
                barrierCategory;

            open = contracts['open'];
            close = contracts['close'];

            var formBarrier = getFormNameBarrierCategory(formName);
            form = formName = formBarrier['formName'];
            barrier = barrierCategory = formBarrier['barrierCategory'];

            contracts.available.forEach(function(currentObj) {
                var contractCategory = currentObj['contract_category'];

                if (formName && formName === contractCategory) {

                    populate_periods(currentObj);

                    if (!contractType[contractCategory]) {
                        contractType[contractCategory] = {};
                    }

                    if (!contractType[contractCategory].hasOwnProperty(currentObj['contract_type'])) {
                        contractType[contractCategory][currentObj['contract_type']] = currentObj['contract_display'];
                    }
                }
            });
        };

        var getContracts = function(underlying) {
            BinarySocket.send({ contracts_for: underlying, region: 'japan' });
        };

        var getContractForms = function() {
            var contracts = Contract.contracts()['contracts_for'],
                tradeContractForms = {};

            contracts.available.forEach(function(currentObj) {
                var contractCategory = currentObj['contract_category'];
                if (contractCategory && !tradeContractForms.hasOwnProperty(contractCategory)) {
                    if (contractCategory === 'callput') {
                        if (currentObj['barrier_category'] === 'euro_atm') {
                            tradeContractForms['risefall'] = Content.localize().textFormRiseFall;
                        } else {
                            tradeContractForms['higherlower'] = Content.localize().textFormHigherLower;
                        }
                    } else {
                        tradeContractForms[contractCategory] = text.localize(currentObj['contract_category_display']);
                    }
                }
            });

            if (tradeContractForms.risefall || tradeContractForms.higherlower) {
                tradeContractForms['updown'] = Content.localize().textFormUpDown;
            }

            if (tradeContractForms.endsinout || tradeContractForms.staysinout) {
                tradeContractForms['inout'] = Content.localize().textFormInOut;
            }

            return tradeContractForms;
        };

        return {
            details: details,
            getContracts: getContracts,
            contractForms: getContractForms,
            open: function() {
                return open; },
            close: function() {
                return close; },
            contracts: function() {
                return contractDetails; },
            durations: function() {
                return false; },
            startDates: function() {
                return false; },
            barriers: function() {
                return false; },
            periods: function() {
                return periods; },
            contractType: function() {
                return contractType; },
            form: function() {
                return form; },
            barrier: function() {
                return barrier; },
            setContracts: function(data) {
                contractDetails = data;
            }
        };

    })();
}
;pjax_config_page_require_auth("new_account/knowledge_testws", function(){
    return {
        onLoad: function() {
            KnowledgeTest.init();
        }
    };
});
;var KnowledgeTestData = (function() {
    "use strict";
    var questions = {
        section1:[
            {
                question: "{JAPAN ONLY}An option holder must buy ( or sell ) the underlying asset at a predetermined price within a specified period ( or at a specific time ).",
                answer: false,
                id: 1,
            },
            {
                question: "{JAPAN ONLY}A Currency Option confers the right to sell one currency in exchange for another currency as the underlying asset. For example, the right to sell Yen and buy Dollars is known as a Yen Put / Dollar Call Option, or just Yen Put for short; and the opposite right to buy Yen and sell Dollar is called a Yen Call / Dollar Put Option, or just Yen Call for short.",
                answer: true,
                id: 2
            },
            {
                question: "{JAPAN ONLY}There are two types of option delivery: One requires exchanging the underlying asset, and the other requires a payment which depends on the difference between the fair market price and the exercise price. A Binary Option is the second type where if the fair market price meets certain conditions with respect to the exercise price, then an agreed fixed amount will be paid to the option buyer.",
                answer: true,
                id: 3
            },
            {
                question: "{JAPAN ONLY}A  Net Settlement type of option is one where the underlying asset does not include yen, but the option fee and settlement are paid in yen; it therefore requires some definition of how the settlement amounts will be calculated and converted to yen.",
                answer: true,
                id: 4
            },
            {
                question: "{JAPAN ONLY}A Binary Option contains the right for the buyer to receive a certain fixed amount if the market price reaches the exercise price by the exercise time, but it does not contain any rights to sell or buy the underlying asset.",
                answer: true,
                id: 5
            },
            {
                question: "{JAPAN ONLY}There are some types of Binary Option, such as Range Binary Options, Touch or No-Touch Binary Options, that are exceptions to the general rule where payment is made at a known exercise time. For these types of option a payment is made automatically at Exit Time when certain conditions have been met.",
                answer: true,
                id: 6
            },
            {
                question: "{JAPAN ONLY}There are many types of Binary Option, including some such as Range Binary Options and Touch or No-Touch Binary Options which do not always require automatic payment at Exercise Time and which will be settled earlier if certain conditions have been met. However, in all cases, for a payment to be required, the option must end In The Money.",
                answer: true,
                id: 7
            },
            {
                question: "{JAPAN ONLY}A Currency Binary Option is one where there is a target for a particular currency pair, so a strike price for the exchange rate is agreed, and a payout will be due if the judgment price meets the conditions of being over or under the target strike price, depending on the option type, by the exercise time.",
                answer: true,
                id: 8
            },
            {
                question: "{JAPAN ONLY}For a currency binary option which has the underlying exchange rate of dollars against yen, the right to receive a payout if the yen becomes weaker is known as a dollar-put binary option.",
                answer: false,
                id: 9
            },
            {
                question: "{JAPAN ONLY}For a currency binary option with the underlying exchange rate of dollars against yen, the right to receive a payout if the yen becomes stronger is known as a dollar-put binary option.",
                answer: true,
                id: 10
            },
            {
                question: "{JAPAN ONLY}If you sell a currency binary call option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will need to payout 1,000 yen to the buyer of the option.",
                answer: false,
                id: 11
            },
            {
                question: "{JAPAN ONLY}If you sell a currency binary put option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will need to payout 1,000 yen to the buyer of the option.",
                answer: true,
                id: 12
            },
            {
                question: "{JAPAN ONLY}If you buy a currency binary call option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will receive a payout 1,000 yen from the seller of the option.",
                answer: false,
                id: 13
            },
            {
                question: "{JAPAN ONLY}If you buy a currency binary put option at a price of 500 yen, with an underlying of dollar against yen, the payout is 1,000 yen, and the strike price is 100, then if the judgment price at exercise time is 99, you will receive a payout 1,000 yen from the seller of the option.",
                answer: true,
                id: 14
            },
            {
                question: "{JAPAN ONLY}If you buy a currency binary option at a price of 500 yen, and the judgment price meets the conditions so you receive a payout of 1,000 yen, then your profit can be calculated 500 yen after subtracting the 500 yen that was paid as a fee to the option seller.",
                answer: true,
                id: 15
            },
            {
                question: "{JAPAN ONLY}If you sell a currency binary option at a price of 500 yen, and the judgment price meets the conditions so you need to payout 1,000 yen, then your profit will be minus 500 yen after subtracting the 500 yen that was received as a fee from the option buyer.",
                answer: true,
                id: 16
            }
        ],
        section2:[
            {
                question: "{JAPAN ONLY}To avoid or hedge the future price of an underlying asset which you hold, you should buy a call option.",
                answer: false,
                id: 17
            },
            {
                question: "{JAPAN ONLY}To compensate for any rise in the price of an underlying asset that you intend to buy in future, you should buy a call option.",
                answer: true, id: 18
            },
            {
                question: "{JAPAN ONLY}If you believe the underlying asset price will move by a large amount in either direction, you can benefit by buying both a call and a put option, with the exercise prices set above and below the current underlying price.",
                answer: true, id: 19
            },
            {
                question: "{JAPAN ONLY}If you believe the underlying asset price will be only moderately volatile, you could still benefit by buying both a call and put option with exercise prices that are above and below the exercise price.",
                answer: true, id: 20
            },
            {
                question: "{JAPAN ONLY}A Covered option position is where you hold an offsetting position in the underlying asset.",
                answer: true,
                id: 21,
            },
            {
                question: "{JAPAN ONLY}A binary call option buyer will benefit from a correct prediction that the asset price will decline to below the strike price by the judgment time.",
                answer: false,
                id: 22
            },
            {
                question: "{JAPAN ONLY}A binary put option buyer will benefit from a correct prediction that the asset price will decline to below the strike price by the judgment time.",
                answer: false,
                id: 23
            },
            {
                question: "{JAPAN ONLY}A binary put options buyer will benefit from a correct prediction that the asset price will rise above the strike price by the judgment time.",
                answer: false,
                id: 24
            },
            {
                question: "{JAPAN ONLY}A binary call options buyer will benefit from a correct prediction that the asset price will rise above the strike price by the judgment time.",
                answer: true,
                id: 25
            },
            {
                question: "{JAPAN ONLY}When buying a vanilla call option, the break-even price at the exercise point is the strike price plus the option price paid in units of the underlying.",
                answer: true,
                id: 26
            },
            {
                question: "{JAPAN ONLY}When buying a vanilla put option, the break-even price at the exercise point is the strike price minus the option price paid in units of the underlying.",
                answer: true,
                id: 27
            },
            {
                question: "{JAPAN ONLY}Using binary options for hedging a position in the underlying asset means that only part of the loss or gain can be hedged, because the payout amount is fixed.",
                answer: true,
                id: 28
            },
            {
                question: "{JAPAN ONLY}It is possible to use two binary options to make a profit if the asset price settles inbetween the two strikes. It is also possible to buy a single range option that will achieve the same result.",
                answer: true,
                id: 29
            },
            {
                question: "{JAPAN ONLY}It is possible to use two binary options to make a profit if the asset price settles outside the two strikes. It is also possible to buy a single range option that will achieve the same result.",
                answer: true,
                id: 30
            },

        ],
        section3:[
            {
                question: "{JAPAN ONLY}In Japan there are defined trading periods for binary options must be 2 hours or longer, and all trades must be conducted at the start of each trading period.",
                answer: false,
                id: 31
            },
            {
                question: "{JAPAN ONLY}A bought or sold binary option may be closed-out before exercise time by selling or buying-back the option, or alternatively by cancelling.",
                answer: true,
                id: 32
            },
            {
                question: "{JAPAN ONLY}In contrast to other types of FX options, short positions in FX Binary Options cannot be closed-out as they are not subject to loss-cut regulations.",
                answer: false,
                id: 33
            },
            {
                question: "{JAPAN ONLY}Short positions in FX Binary Options must be covered by initial margin and any further losses must be covered by further margin deposits.",
                answer: true,
                id: 34
            },
            {
                question: "{JAPAN ONLY}Although customers and brokers will set limits on customers trading losses, even if those losses are exceeded, it is the customer's responsibility to close the position and so mandatory loss-cuts will not be executed by the broker company.",
                answer: false,
                id: 35
            },
            {
                question: "{JAPAN ONLY}Options may be European or American style of exercise, and those which can be exercised at only one expiry time are the European style options.",
                answer: true,
                id: 36
            },
            {
                question: "{JAPAN ONLY}For a call option, if the price of the underlying asset is higher than the option exercise price, it is know as an in-the-money option.",
                answer: true,
                id: 37
            },
            {
                question: "{JAPAN ONLY}For a call option, if the price of the underlying asset is higher than the option exercise price, it is know as an out-of-the-money option.",
                answer: false,
                id: 38
            },
            {
                question: "{JAPAN ONLY}For both call and put options, if the underlying asset price is the same as the exercise price, it is known as an at-the-money option.",
                answer: true,
                id: 39
            },
            {
                question: "{JAPAN ONLY}For a put option, if the underlying asset price is lower than the option exercise price, it is known as an out-of-the-money option.",
                answer: false,
                id: 40
            },
            {
                question: "{JAPAN ONLY}For a put option, if the underlying asset price is higher than the option exercise price, it is known as an in-the-money option.",
                answer: false,
                id: 41,
            },
            {
                question: "{JAPAN ONLY}The Exercise Price is the level at which the option buyer has the right to trade the underlying, and is also used for binary options to determine whether the buyer should receive a payout.",
                answer: true,
                id: 42
            },
            {
                question: "{JAPAN ONLY}The Exit Price is the price that is observed at the judgment time, and is used to determine whether a payout should be made.",
                answer: true,
                id: 43
            },
            {
                question: "{JAPAN ONLY}The payout is the amount that the option seller must pay to the buyer if the buyer exercises his right when the conditions for a payout have been satisfied.",
                answer: true,
                id: 44
            },
            {
                question: "{JAPAN ONLY}In OTC currency binary options trading, if the exchange rate during the trading period moves by more than expected in one direction, and there are no longer any exercise prices which can continue to trade, it is possible under certain conditions to add further exercise prices. However, even when further exercise price have been added, the prices of the original options will not be affected.",
                answer: true,
                id: 45
            },
            {
                question: "{JAPAN ONLY}The exit price is important in binary options. In case of handling the OTC currency-related binary options trading for private individuals, the broker company must perform inspections of the exit prices which have been used for determining option payout, and must check whether there is an error in the data in cases where that the company has used rated data provided by third company.",
                answer: true,
                id: 46
            },
            {
                question: "{JAPAN ONLY}About OTC currency for binary options trading, summarizes the profit and loss result of all transactions that have been made between the customer, to publish the information in the company's home page, at any time while the customer is doing the transaction before the start, or the transaction, the information Make sure, for that you're willing to trade under the calm judgment, we are committed to a variety of environmental improvement.",
                answer: true,
                id: 47
            },
            {
                question: "{JAPAN ONLY}For an individual investor, all profits from OTC currency options trading are tax-free.",
                answer: false,
                id: 48
            },
            {
                question: "{JAPAN ONLY}For an individual investor, profits and losses from OTC currency options traing cannot be combined with profits and losses from margin FX and securities-related OTC options.",
                answer: false,
                id: 49
            },
            {
                question: "{JAPAN ONLY}Unless special arrangements are made, cooling-off will not be available after OTC binary options trading contract has been made.",
                answer: true,
                id: 50
            }
        ],
        section4:[
            {
                question: "{JAPAN ONLY}If the buyer of an option does not exercise the option rights, there will be no fee payable to the option seller.",
                answer: false,
                id: 51
            },
            {
                question: "{JAPAN ONLY}If the buyer of an option waives his right to exercise, a transaction in the underlying asset will not be dealt between the seller and the buyer.",
                answer: true, id: 52
            },
            {
                question: "{JAPAN ONLY}The seller of an option should receive the option premium from the buyer, even if the buyer waives the right to exercise the option.",
                answer: true, id: 53
            },
            {
                question: "{JAPAN ONLY}If an option buyer wishes to exercise the option rights, the seller may still reject the deal.",
                answer: false, id: 54
            },
            {
                question: "{JAPAN ONLY}Options are said to be leveraged products because in the case of large moves in the underlying asset price, the values of the options can increase by large amounts compared to the price paid for the option.",
                answer: true, id: 55
            },
            {
                question: "{JAPAN ONLY}The buyer of a vanilla option can choose whether to exercise the option or not. His loss is limited to the price paid for the option, whereas his potential profit is unlimited.",
                answer: true, id: 56
            },
            {
                question: "{JAPAN ONLY}The seller of a vanilla option can not choose whether to exercise the option or not. His profit is limited to the price received for the option, whereas his potential loss is unlimited and could be substantial.",
                answer: true, id: 57
            },
            {
                question: "{JAPAN ONLY}If the exercise period passes without the option being exercised by the buyer, the option premium received by the seller will be the profit made on the trade.",
                answer: true, id: 58
            },
            {
                question: "{JAPAN ONLY}Even if the option is exercise or not exercised, the original option premium remains with the option seller.",
                answer: true, id: 59
            },
            {
                question: "{JAPAN ONLY}The maximum loss for the buyer of an option is the price paid, and the maximium loss for the option seller will be the payout amount minus the opion price he received.",
                answer: true, id: 60
            },
            {
                question: "{JAPAN ONLY}Because option prices are determined by the probability of being exercised, it cannot be said that cheaper options have any natural advantage over expensive options.",
                answer: true,
                id: 61,
            },
            {
                question: "{JAPAN ONLY}Binary options have lower risk than vanilla options for option sellers, because with binary options the maximum loss is fixed.",
                answer: false,
                id: 62
            },
            {
                question: "{JAPAN ONLY}Even though losses in binary options are limited, it is still necessary to take care not to engage in excessive speculative trading and to moderate your transactions volume.",
                answer: true,
                id: 63
            },
            {
                question: "{JAPAN ONLY}If the probablility of a payout is 50% then when the potential payout is less than 100% of the price paid for the option, the expected return on the investment will be less than 100%.",
                answer: true,
                id: 64
            },
            {
                question: "{JAPAN ONLY}It cannot be said that binary options trading is unconditionally advanteous over regular spot fx trading, because investors may lose all of their investment whereas in spot fx trading there will still be some value in the trading position.",
                answer: true,
                id: 65
            },
            {
                question: "{JAPAN ONLY}The particular details of binary options are all the same, no matter which broking company you trade with.",
                answer: false,
                id: 66
            },
            {
                question: "{JAPAN ONLY}Even if all details of the binary options match perfectly, there may still be differences in the prices shown by different broking companies.",
                answer: true,
                id: 67
            },
            {
                question: "{JAPAN ONLY}Prices for currency options are calculated relative the value of theunderlying spot price, and are dependant on multiple factors which may vary.",
                answer: true,
                id: 68
            },
            {
                question: "{JAPAN ONLY}Where broking companies show bid and offer prices for purchasing and sell-back of positions, these prices may become further apart the nearer you are to the exercise time.",
                answer: true,
                id: 69
            },
            {
                question: "{JAPAN ONLY}Option prices depend on the spot price, the time to expiry, the volatility of the spot rate and interest rates.",
                answer: true, id: 70
            },

        ],
        section5:[
            {
                question: "{JAPAN ONLY}The price of an option can be affected by the underlying asset price, by the volatility rate of the underlying asset, or by the time remaining to the exercise time.",
                answer: true, id: 71
            },
            {
                question: "{JAPAN ONLY}The price of a vanilla call option will be lower when price of the underlying asset is low, but the price of the put option will be higher when the price of the underlying asset is low.",
                answer: true, id: 72
            },
            {
                question: "{JAPAN ONLY}If the exercise prices and exercise times are the same for an American style and European style option, then the American style option will have a higher price.",
                answer: true, id: 73
            },
            {
                question: "{JAPAN ONLY}In case of the right to buy the underlying asset (call option), when the underlying asset price falls, the option price will increase.",
                answer: false, id: 74
            },
            {
                question: "{JAPAN ONLY}In case of the right to sell the underlying asset (put option), when the underlying asset price rises, the option price will increase.",
                answer: false, id: 75
            },
            {
                question: "{JAPAN ONLY}For an out-of-the-money option, the further away from the underlying asset price that the option exercise price is, the lower the price of the option will be.",
                answer: true, id: 76
            },
            {
                question: "{JAPAN ONLY}For an in-the-money option, the further away from the underlying asset price that the option exercise price is, the lower the price of the option will be.",
                answer: false, id: 77
            },
            {
                question: "{JAPAN ONLY}If implied volatility increases then the prices of both call and put types of plain vanilla options will increase.",
                answer: true, id: 78
            },
            {
                question: "{JAPAN ONLY}As the expected volatility of the underlying asset increases, a plain vanilla option price will move higher.",
                answer: true, id: 79
            },
            {
                question: "{JAPAN ONLY}For a plain vanilla option, as the time to the exercise point shortens, the price of the option will decrease.",
                answer: true, id: 80
            },
            {
                question: "{JAPAN ONLY}An option price is the sum of the intrinsic-value and the time-value.",
                answer: true,
                id: 81,
            },
            {
                question: "{JAPAN ONLY}If the underlying asset price is 100 yen, the exercise price is 80 yen, and the call option price is 45 yen, then it can be said that the option's intrinsic-value is 20 yen, and its time-value is 25 yen.",
                answer: true,
                id: 82
            },
            {
                question: "{JAPAN ONLY}The time-value of an option represents the expected value of the option at the exercise point, and may be positive, even when the intrinsic-value is zero.",
                answer: true,
                id: 83
            },
            {
                question: "{JAPAN ONLY}As the time to the exercise point shortens, the time-value of a plain vanilla option decreases.",
                answer: true,
                id: 84
            },
            {
                question: "{JAPAN ONLY}A binary option price cannot exceed the payout amount.",
                answer: true,
                id: 85
            },
            {
                question: "{JAPAN ONLY}In general a binary option price will not exceed the payout amount.",
                answer: true,
                id: 86
            },
            {
                question: "{JAPAN ONLY}Unlike a plain vanilla option, an in-the-money binary option will have a lower price, the further away it is from the exercise point.",
                answer: true,
                id: 87
            },
            {
                question: "{JAPAN ONLY}In general the price of a binary option will be lower than the price of a plain vanilla option because the payout amount is fixed.",
                answer: false,
                id: 88
            },
            {
                question: "{JAPAN ONLY}A binary option which is out-of-the-money will have a lower price than an option which is in-the-money because the probability of receiving the payout amount is lower.",
                answer: true,
                id: 89
            },
            {
                question: "{JAPAN ONLY}A binary option which is in-the-money will have a higher value than an option that is out-of-the-money because there will be a higher probability of receiving the payout amount.",
                answer: true, id: 90
            },
            {
                question: "{JAPAN ONLY}As the exercise deadline approaches, the price of an in-the-money binary option will move towards the payout amount.",
                answer: true, id: 91
            },
            {
                question: "{JAPAN ONLY}As the exercise deadline approaches, the price of an out-of-the-money binary option will move towards zero.",
                answer: true, id: 92
            },
            {
                question: "{JAPAN ONLY}The price of a binary option is affected by not only the change in the underlying asset price, but also the change in remaining time to the exercise point.",
                answer: true, id: 93
            },
            {
                question: "{JAPAN ONLY}Implied volatility is a prediction of the future rate of change in the underlying asset.",
                answer: true, id: 94
            },
            {
                question: "{JAPAN ONLY}Historical volatility is a prediction of the future rate of change in the underlying asset.",
                answer: false, id: 95
            },
            {
                question: "{JAPAN ONLY}Delta refers to  a percentage change of the option price with respect to the change in the underlying asset price.",
                answer: true, id: 96
            },
            {
                question: "{JAPAN ONLY}Option prices are normally dependant on elements such as the underlying asset price, the exercise price, the length of time until the exercise point, volatility, and interest rates. Apart from the fixed exercise price, all other elements are changing constantly, so an understanding of the relationships between each element and changes in the options price is necessary for the management of options trading risk.",
                answer: true, id: 97
            },
            {
                question: "{JAPAN ONLY}Option prices are normally dependant on elements such as the underlying asset price, the exercise price, the length of time until the exercise point, volatility, and interest rates. However, when the remaining time to the exercise point is very short, there is no need to consider these when managing option trading risk, as all these elements are constant.",
                answer: false, id: 98
            },
            {
                question: "{JAPAN ONLY}The Black-Scholes model is widely used to calculate theoretical option prices.",
                answer: true, id: 99
            },
            {
                question: "{JAPAN ONLY}A modified version of the Black-Scholes model is widely used to calculate the theoretical prices of binary options.",
                answer: true, id: 100
            },
        ],
    };

    function randomPick4(questions) {
        var availables = Object.keys(questions);

        var randomPicks = [];
        for (var i = 0 ; i < 4 ; i ++) {
            var randomIndex = Math.floor(Math.random() * 100) % availables.length;
            var randomQid = availables[randomIndex];
            var randomPick = questions[randomQid];
            randomPicks.push(randomPick);
            availables.splice(randomIndex, 1);
        }

        return randomPicks;
    }

    function randomPick20() {
        var qFromSection1 = randomPick4(questions.section1);
        var qFromSection2 = randomPick4(questions.section2);
        var qFromSection3 = randomPick4(questions.section3);
        var qFromSection4 = randomPick4(questions.section4);
        var qFromSection5 = randomPick4(questions.section5);

        return [
            qFromSection1,
            qFromSection2,
            qFromSection3,
            qFromSection4,
            qFromSection5
        ];
    }

    function sendResult(results) {
        var status = results >= 14 ? 'pass' : 'fail';
        BinarySocket.send({jp_knowledge_test: 1, score: results, status: status});
    }

    return {
        questions: questions,
        randomPick20: randomPick20,
        sendResult: sendResult
    };
}());
;var KnowledgeTest = (function() {
    "use strict";

    var hiddenClass = 'invisible';

    var submitted = {};
    var randomPicks = [];
    var randomPicksAnswer = {};
    var resultScore = 0;

    var passMsg = '{JAPAN ONLY}Congratulations, you have pass the test, our Customer Support will contact you shortly';
    var failMsg = '{JAPAN ONLY}Sorry, you have failed the test, please try again after 24 hours.';

    function questionAnswerHandler(ev) {
        var selected = ev.target.value;
        var qid = ev.target.name;
        submitted[qid] = selected === '1';
    }

    function submitHandler() {
        var answeredQid = Object.keys(submitted).map(function(k) {return +k;});
        if (answeredQid.length !== 20) {
            $('#knowledge-test-msg')
                .addClass('notice-msg')
                .text(text.localize('You need to finish all 20 questions.'));

            // $("html, body").animate({ scrollTop: 0 }, "slow");

            var allQid = [].concat.apply([], randomPicks).map(function(q) {
                return q.id;
            });
            var unAnswered = allQid.find(function(q){
                return answeredQid.indexOf(q) === -1;
            });
            window.location.href = '#' + unAnswered;
            return;
        }

        // compute score
        for (var k in submitted) {
            if (submitted.hasOwnProperty(k)) {
                resultScore += submitted[k] === randomPicksAnswer[k] ? 1 : 0;
            }
        }
        KnowledgeTestData.sendResult(resultScore);
    }

    function showQuestionsTable() {
        for (var j = 0 ; j < randomPicks.length ; j ++) {
            var table = KnowledgeTestUI.createQuestionTable(randomPicks[j]);
            $('#section' + (j + 1) + '-question').append(table);
        }

        $('#knowledge-test-questions input[type=radio]').click(questionAnswerHandler);
        $('#knowledge-test-submit').click(submitHandler);
        $('#knowledge-test-questions').removeClass(hiddenClass);
        $('#knowledge-test-msg').text(text.localize('{JAPAN ONLY}Please complete the following questions.'));
    }

    function showResult(score, time) {
        $('#knowledge-test-header').text(text.localize('{JAPAN ONLY}Knowledge Test Result'));
        if (score >= 14) {
            $('#knowledge-test-msg').text(text.localize(passMsg));
        } else {
            $('#knowledge-test-msg').text(text.localize(failMsg));
        }

        var $resultTable = KnowledgeTestUI.createResultUI(score, time);

        $('#knowledge-test-container').append($resultTable);
        $('#knowledge-test-questions').addClass(hiddenClass);
    }

    function showMsgOnly(msg) {
        $('#knowledge-test-questions').addClass(hiddenClass);
        $('#knowledge-test-msg').text(text.localize(msg));
    }

    function showDisallowedMsg(jpStatus) {
        var nextTestEpoch = jpStatus.next_test_epoch;
        var lastTestEpoch = jpStatus.last_test_epoch;

        var nextTestDate = new Date(nextTestEpoch * 1000);
        var lastTestDate = new Date(lastTestEpoch * 1000);

        var msgTemplate =
            '{JAPAN ONLY}Dear customer, you are not allowed to take knowledge test until [_1].\nLast test taken at [_2].';

        var msg = text.localize(msgTemplate)
            .replace('[_1]', nextTestDate.toUTCString())
            .replace('[_2]', lastTestDate.toUTCString());

        showMsgOnly(msg);
    }

    function showCompletedMsg() {
        var msg = "{JAPAN ONLY}Dear customer, you've already completed the knowledge test, please proceed to next step.";
        showMsgOnly(msg);
    }

    function populateQuestions() {
        randomPicks = KnowledgeTestData.randomPick20();
        for (var i = 0 ; i < 5 ; i ++) {
            for ( var k = 0 ; k < 4 ; k++) {
                var qid = randomPicks[i][k].id;
                var ans = randomPicks[i][k].answer;

                randomPicksAnswer[qid] = ans;
            }
        }

        showQuestionsTable();
    }

    function init() {
        BinarySocket.init({
            onmessage: function(msg) {
                var response = JSON.parse(msg.data);
                var type = response.msg_type;

                var passthrough = response.echo_req.passthrough && response.echo_req.passthrough.key;

                if (type === 'get_settings' && passthrough === 'knowledgetest') {
                    var jpStatus = response.get_settings.jp_account_status;

                    if (!jpStatus) {
                        window.location.href = page.url.url_for('/');
                        return;
                    }

                    switch(jpStatus.status) {
                        case 'jp_knowledge_test_pending': populateQuestions();
                            break;
                        case 'jp_knowledge_test_fail': if (Date.now() >= (jpStatus.next_test_epoch * 1000)) {
                            // show Knowledge Test cannot be taken
                            populateQuestions();
                        } else {
                            showDisallowedMsg(jpStatus);
                        }
                            break;
                        case 'jp_activation_pending': showCompletedMsg();
                            break;
                        default: {
                            console.warn('Unexpected jp status');
                            window.location.href = page.url.url_for('/');
                        }
                    }
                } else if (type === 'jp_knowledge_test') {
                    if (!response.error) {
                        showResult(resultScore, response.jp_knowledge_test.test_taken_epoch * 1000);
                        $("html, body").animate({ scrollTop: 0 }, "slow");

                        $('#knowledgetest-link').addClass(hiddenClass);     // hide it anyway
                        localStorage.setItem('jp_test_allowed', 0);
                    } else if (response.error.code === 'TestUnavailableNow') {
                        showMsgOnly('{JAPAN ONLY}The test is unavailable now, test can only be taken again on next business day with respect of most recent test.');
                    }
                }
            }
        });

        BinarySocket.send({get_settings: 1, passthrough: {key: 'knowledgetest'}});
    }

    function showKnowledgeTestTopBarIfValid(jpStatus) {
        if (!jpStatus) {
            return;
        }
        switch (jpStatus.status) {
            case 'jp_knowledge_test_pending': KnowledgeTestUI.createKnowledgeTestLink();
                break;
            case 'jp_knowledge_test_fail': if (Date.now() >= (jpStatus.next_test_epoch * 1000)) {
                KnowledgeTestUI.createKnowledgeTestLink();
            }
                break;
            case 'jp_activation_pending': $('#topbar-msg').children('a').addClass(hiddenClass);
                break;
            default: return;
        }
    }

    return {
        init: init,
        showKnowledgeTestTopBarIfValid: showKnowledgeTestTopBarIfValid
    };
}());
;var KnowledgeTestUI = (function () {
    "use strict";

    function createTrueFalseBox(question, showAnswer) {
        var qid = question.id;
        var trueId = qid + 'true';
        var falseId = qid + 'false';

        var $trueButton = $('<input />', {
            type: 'radio',
            name: qid,
            id: trueId,
            value: '1'
        });
        var $trueLabel = $('<label></label>', {class: 'img-holder true', for: trueId, value: '1'});
        var $trueTd = $('<td></td>').append($trueButton);

        var $falseButton = $('<input />', {
            type: 'radio',
            name: qid,
            id: falseId,
            value: '0'
        });
        var $falseLabel = $('<label></label>', {class: 'img-holder false', for: falseId, value: '0'});
        var $falseTd = $('<td></td>').append($falseButton);

        if (showAnswer) {
            if (question.answer) {
                $trueButton.prop('checked', true);
            } else {
                $falseButton.prop('checked', true);
            }
            $trueButton.attr('disabled', true);
            $falseButton.attr('disabled', true);
        }

        return [$trueTd, $falseTd];
    }

    function createQuestionRow(questionNo, question, showAnswer) {
        var $questionRow = $('<tr></tr>', {id: questionNo, class: 'question'});
        var $questionData = $('<td></td>').text(text.localize(question.question));
        var $questionLink = $('<a></a>', {name: question.id});
        $questionData.append($questionLink);

        var trueFalse = createTrueFalseBox(question, showAnswer);

        return $questionRow
            .append($questionData)
            .append(trueFalse[0])
            .append(trueFalse[1]);
    }

    function createQuestionTable(questions, showAnswer) {
        var $header = $('<tr></tr>');
        var $questionColHeader = $('<th></th>', {id: 'question-header', class: 'question-col'})
            .text(text.localize('Questions'));

        var $trueColHeader = $('<th></th>', {id: 'true-header', class: 'true-col'})
            .text(text.localize('True'));

        var $falseColHeader = $('<th></th>', {id: 'fasle-header', class: 'false-col'})
            .text(text.localize('False'));

        $header
            .append($questionColHeader)
            .append($trueColHeader)
            .append($falseColHeader);

        var $tableContainer = $('<table></table>', {id: 'knowledge-test'});

        $tableContainer.append($header);
        questions.forEach(function(question, questionNo) {
            var qr = createQuestionRow(questionNo, question, showAnswer);
            $tableContainer.append(qr);
        });

        return $tableContainer;
    }

    function createResultUI(score, time) {

        var $resultTable = $('<table></table>', { class: 'kv-pairs'});
        var $scoreRow = $('<tr></tr>').append($('<td>' + text.localize('Score') + '</td>')).append($('<td>'+ score + '</td>'));

        var submitDate = (new Date(time)).toUTCString();

        var $dateRow = $('<tr></tr>').append($('<td>' + text.localize('Date') + '</td>')).append($('<td>'+ submitDate + '</td>'));

        $resultTable.append($scoreRow).append($dateRow);

        return $resultTable;
    }

    function createAlreadyCompleteDiv() {
        var msg = "{JAPAN ONLY}Dear customer, you've already completed the knowledge test, please proceed to next step.";
        var $completeDiv = $('<div></div>').text(text.localize(msg));
        return $completeDiv;
    }

    function createKnowledgeTestLink() {
        // change topbar to knowledge test link
        var $topbarmsg = $('#topbar-msg');
        if ($topbarmsg.length <= 0) {
            return;         // topbar not exist, do nothing
        }

        var $knowledgeTestLink = $('<a></a>', {
            class: 'pjaxload',
            id: 'knowledgetest-link',
            href: '/new_account/knowledge_testws'
        }).text(text.localize('{JAPAN ONLY}Take knowledge test'));

        $topbarmsg.children('a').addClass('invisible');
        $topbarmsg.append($knowledgeTestLink);
    }

    return {
        createTrueFalseBox: createTrueFalseBox,
        createQuestionRow: createQuestionRow,
        createQuestionTable: createQuestionTable,
        createResultUI: createResultUI,
        createAlreadyCompleteDiv: createAlreadyCompleteDiv,
        createKnowledgeTestLink: createKnowledgeTestLink,
    };
}());

;if(isJapanTrading()){
	var Periods = (function(){
		var barrier = 0,
			barrier2 = 0,
			barriers1 = [],
			barriers2 = [];

		var displayPeriods = function(){

			var periods = Contract.periods();
			if(!periods){
				return false;
			}
			var wrapper = document.getElementById('period_row'),
				target= document.getElementById('period'),
			    formName = Contract.form(),
			    underlying = document.getElementById('underlying').value,
			    fragment =  document.createDocumentFragment();

			while (target && target.firstChild) {
			    target.removeChild(target.firstChild);
			}

			if(!periods[formName] || !periods[formName][underlying]){
				return false;
			}

			wrapper.style.display = 'flex';

			periods = periods[formName][underlying];
			list = Object.keys(periods);

			list.sort(function(a,b){
				if(periods[a].date_expiry.epoch - periods[a].date_start.epoch > periods[b].date_expiry.epoch - periods[b].date_start.epoch){
					return 1;
				}
				else if(periods[a].date_expiry.epoch - periods[a].date_start.epoch < periods[b].date_expiry.epoch - periods[b].date_start.epoch){
					return -1;
				}
				else{
					if(periods[a].date_start.epoch > periods[b].date_start.epoch){
						return 1;
					}
					else {
						return -1;
					}
				}
			});

			list.forEach(function(p){
				var period = periods[p];
				var option, content, text;
				if(period.duration.match(/^\d+h$/)){
					var match1 = period.date_start.date.match(/^\d{4}-\d{2}-\d{2}\s+(\d{2}):(\d{2}):\d{2}$/);
					var s_hours = match1[1];
					var s_min = match1[2];

					var match2 = period.date_expiry.date.match(/^\d{4}-\d{2}-\d{2}\s+(\d{2}):(\d{2}):\d{2}$/);
					var e_hours = match2[1];
					var e_min = match2[2];

					text = s_hours+":"+s_min+' - '+e_hours+":"+e_min+' ('+period.duration+')';
				}
				else{
					text = period.date_expiry.date + ' ('+period.duration+')';
				}
				option = document.createElement('option');
				content = document.createTextNode(text);
				option.setAttribute('value', p);
				option.appendChild(content);
				fragment.appendChild(option);
			});

			target.appendChild(fragment);
			displayBarriers();
		};

		var displayBarriers = function(){

			var periods = Contract.periods();
			if(!periods){
				return false;
			}

			var target1= document.getElementById('jbarrier'),
				target2= document.getElementById('jbarrier_high'),
				target3= document.getElementById('jbarrier_low'),
			    formName = Contract.form(),
			    underlying = document.getElementById('underlying').value,
			    period = document.getElementById('period').value,
			    fragment = document.createDocumentFragment();

			while (target1 && target1.firstChild) {
			    target1.removeChild(target1.firstChild);
			}

			while (target2 && target2.firstChild) {
			    target2.removeChild(target2.firstChild);
			}

			while (target3 && target3.firstChild) {
			    target3.removeChild(target3.firstChild);
			}


			if(!periods[formName] || !periods[formName][underlying] || !periods[formName][underlying][period]){
				return false;
			}

			document.getElementById('barrier_row').style.display = 'none';
			document.getElementById('high_barrier_row').style.display = 'none';
			document.getElementById('low_barrier_row').style.display = 'none';
		};

		return {
			barrier: function(){return barrier;},
			barrier2: function(){return barrier2;},
			barriers1: function(){return barriers1;},
			barriers2: function(){return barriers2;},
			displayPeriods: displayPeriods,
			displayBarriers: displayBarriers
		};
	})();
}
;if(isJapanTrading()){
	var Price = Object.create(Price);
	Object.defineProperties(Price,{
		proposal:{
			value:function(typeOfContract){
				var parent = Object.getPrototypeOf(this);
				var proposal = parent.proposal(typeOfContract);

				var period = document.getElementById('period'),
					barrier = document.getElementById('jbarrier'),
					highBarrier = document.getElementById('jbarrier_high'),
					lowBarrier = document.getElementById('jbarrier_low');

				if (barrier && isVisible(barrier) && barrier.value) {
				    proposal['barrier'] = barrier.value;

				}

				if (highBarrier && isVisible(highBarrier) && highBarrier.value) {
				    proposal['barrier'] = highBarrier.value;

				}

				if (lowBarrier && isVisible(lowBarrier) && lowBarrier.value) {
				    proposal['barrier2'] = lowBarrier.value;
				}

				if (period && isVisible(period) && period.value) {
					var p = period.value.match(/^\d+_(\d+)$/);
					if(p){
						proposal['date_expiry'] = p[1];
					}				
				}
				return proposal;
			}
		}
	});
};var PricingTable = (function() {

  var state = {
    prev_prices: {},
    prices: {},
  };

  var ContractDescription = React.createClass({
    displayName: 'ContractDescription',

    render: function render() {

      var values = this.props.longCode.values;
      var longCode = this.props.longCode.mask;

      Object.keys(values).forEach(function(key) {
        longCode = longCode.replace('{' + key + '}', values[key]);
      });

      longCode = longCode.replace(/\[_1\]/, values.currency)
        .replace(/\[_2\]/, values.sum)
        .replace(/\[_3\]/, values.symbol)
        .replace(/\[_4\]/, values.close);


      return React.createElement(
        'div', { className: 'contract_description' },
        React.createElement(
          'h4', { 'className': 'contract_heading ' + this.props.type },
          this.props.contractName
        ),
        React.createElement(
          'div', { 'className': 'contract_longcode' },
          longCode
        )
      );
    }
  });

  var PricingTableCell = React.createClass({
    displayName: "PricingTableCell",

    render: function render() {
      var price = parseInt(this.props.price);
      var inactive = this.props.is_active && price !== 1000 && price !== 0 ? '' : 'inactive';
      var barrierArr = this.props.barrier ? this.props.barrier.split(/ \- /).reverse() : [];
      var props = this.props;

      return React.createElement(
        "div", {
          key: 'inactive',
          "className": "pricing_table_cell col row " +
            this.props.type + "_cell" +
            (this.props.dyn > 0 ? " price_rise" : (this.props.dyn < 0 ? " price_fall" : ''))
        },
        (this.props.empty ? undefined : [
          React.createElement(
            "div", { "className": inactive, key: 'inactive' }
          ),
          React.createElement(
            "div", { "className": "price", "key": "price" },
            '¥' + price
          ),
          (this.props.type === 'buy' ? React.createElement(
            "div", {
              "className": "col button",
              "key": "button",
              onClick: function() {
                buyContract({
                  price: price,
                  units: props.units,
                  contractType: props.contractType,
                  symbol: props.symbol,
                  dateExpiry: props.dateExpiry,
                  barrier: barrierArr[0],
                  barrier2: barrierArr[1],
                });
              }
            },
            Content.localize()['textBuy']
          ) : undefined)
        ])
      );
    }

  });

  var PricingTableHeader = React.createClass({
    displayName: "PricingTableHeader",
    render: function render() {
      var barrierLabel = Content.localize().textBarrier;
      var buyPriceUnitLabel = Content.localize().textBuyPriceUnit;
      var sellPriceUnitLabel = Content.localize().textSellPriceUnit;

      return React.createElement(
        'div', { 'className': 'pricing_table_row row heading' },
        React.createElement(
          'div', { 'className': 'col exercise_price_h' },
          barrierLabel
        ),
        React.createElement(
          'div', { 'className': 'col prices_h' },
          buyPriceUnitLabel
        ),
        React.createElement(
          'div', { 'className': 'col prices_h' },
          sellPriceUnitLabel
        ),
        React.createElement(
          'div', { 'className': 'col prices_h' },
          buyPriceUnitLabel
        ),
        React.createElement(
          'div', { 'className': 'col prices_h' },
          sellPriceUnitLabel
        )
      );
    }
  });

  var PricingTableRow = React.createClass({
    displayName: "PricingTableRow",

    render: function render() {
      var types = Object.keys(this.props.values);
      var buy1 = React.createElement(PricingTableCell, { type: 'buy', is_active: 0, price: 1000 });
      var sell1 = React.createElement(PricingTableCell, { type: 'sell', is_active: 0, price: 0 });
      var buy2 = React.createElement(PricingTableCell, { type: 'buy', is_active: 0, price: 1000 });
      var sell2 = React.createElement(PricingTableCell, { type: 'sell', is_active: 0, price: 0 });

      var barrier = this.props.barrier.replace(/_/, ' - ');

      for (var i = 0; i < types.length; i++) {
        var type = types[i];
        var position = contractTypeDisplayMapping(type);
        var dyn = 0;
        if (this.props.prev_values !== undefined && this.props.prev_values[type] !== undefined) {
          if (this.props.values[type] > this.props.prev_values[type]) {
            dyn = 1;
          } else if (this.props.values[type] < this.props.prev_values[type]) {
            dyn = -1;
          }
        }

        if (position === 'top') {
          buy1 = React.createElement(PricingTableCell, {
            type: 'buy',
            is_active: 1,
            price: this.props.values[type],
            dyn: dyn,
            barrier: barrier,
            contractType: type,
            units: this.props.units,
            symbol: this.props.symbol,
            dateExpiry: this.props.dateExpiry,
          });
          sell2 = React.createElement(PricingTableCell, {
            type: 'sell',
            is_active: 1,
            price: 1000 - this.props.values[type],
            dyn: dyn,
            barrier: barrier,
            contractType: type,
            units: this.props.units,
            symbol: this.props.symbol,
            dateExpiry: this.props.dateExpiry,
          });
        } else {
          buy2 = React.createElement(PricingTableCell, {
            type: 'buy',
            is_active: 1,
            price: this.props.values[type],
            dyn: dyn,
            barrier: barrier,
            contractType: type,
            units: this.props.units,
            symbol: this.props.symbol,
            dateExpiry: this.props.dateExpiry,
          });
          sell1 = React.createElement(PricingTableCell, {
            type: 'sell',
            is_active: 1,
            price: 1000 - this.props.values[type],
            dyn: dyn,
            barrier: barrier,
            contractType: type,
            units: this.props.units,
            symbol: this.props.symbol,
            dateExpiry: this.props.dateExpiry,
          });
        }
      }

      return React.createElement(
        "div", { "className": "pricing_table_row row" },
        React.createElement(
          "div", { "className": "col barrier" },
          barrier
        ),
        buy1,
        sell1,
        buy2,
        sell2
      );
    }
  });


  var PricingTable = React.createClass({
    displayName: "PricingTable",

    render: function render() {
      var barriers = Object.keys(this.props.prices).sort(function(a, b) {
        return b - a;
      });

      var i = 1;
      var props = this.props;
      var rows = barriers.map(function(barrier) {
        return React.createElement(PricingTableRow, {
          key: i++,
          barrier: barrier,
          values: props.prices[barrier],
          prev_values: (props.prev_prices !== undefined ? props.prev_prices[barrier] : undefined),
          units: props.units,
          dateExpiry: props.dateExpiry,
          symbol: props.symbol,
        });
      });
      rows.unshift(React.createElement(PricingTableHeader, { key: 0 }));

      return React.createElement(
        "div", { "className": "pricing_table" },
        rows
      );
    }
  });

  function sendRequest(form) {
    if (form.contract_category && form.date_expiry && form.symbol) {
      $('#pricing_table').hide();
      $('#contract_description1').hide();
      state.prev_prices = {};
      state.prices = {};
      state.category = form.contract_category;
      state.dateExpiry = form.date_expiry;
      state.symbol = form.symbol;
      state.units = form.units;
      BinarySocket.send({
        pricing_table: 1,
        contract_category: form.contract_category,
        date_expiry: form.date_expiry,
        symbol: form.symbol,
        type: 'japan',
      });
    }
  }

  function buyContract(params) {
    var buyContractParams = {
      buy: 1,
      price: params.price * params.units,
      parameters: {
        amount: params.units * 1000,
        basis: 'payout',
        contract_type: params.contractType,
        currency: 'JPY',
        symbol: params.symbol,
        date_expiry: params.dateExpiry,
        barrier: params.barrier,
      }
    };

    if (params.barrier2) {
      buyContractParams.parameters.barrier2 = params.barrier2;
    }

    $('#trading_init_progress').show();

    BinarySocket.send(buyContractParams);
  }

  function handleResponse(res) {
    var echo_req = res.echo_req;

    if (!document.getElementById('pricing_table')) {
      processForgetTables();
    } else if (state.category === echo_req.contract_category &&
      state.dateExpiry === echo_req.date_expiry &&
      state.symbol === echo_req.symbol) {

      state.prev_prices = state.prices;
      state.prices = res.pricing_table.prices;

      var contractTypes = Contract.contractType()[state.category];
      var close = $("#period option:selected").text();
      close = close.replace(/\s+\(.+$/, '');

      if (contractTypes) {

        Object.keys(contractTypes).forEach(function(type) {
          var contractName = contractTypes[type];
          var mask = Content.localize()['text' + type];
          if (mask) {
            var longCode = {
              mask: mask,
              values: {
                currency: '¥',
                sum: 1000,
                symbol: state.symbol,
                close: close,
              },
            };

            var position = contractTypeDisplayMapping(type);
            var positionIndex = position === 'top' ? 1 : 2;

            ReactDOM.render(
              React.createElement(ContractDescription, {
                longCode: longCode,
                type: type,
                contractName: contractName,
              }),
              document.getElementById('contract_description' + positionIndex)
            );
            $('#contract_description' + positionIndex).css('display', 'flex');
          }
        });
      }

      ReactDOM.render(
        React.createElement(PricingTable, state),
        document.getElementById('pricing_table')
      );

      $('#pricing_table').show();
    }
  }

  function processBuy(res) {
    $('#trading_init_progress').hide();

    if (res.error) {
      alert(res.error.message);
    } else {
      var button = $('<div />', { contract_id: res.buy.contract_id }).get(0);
      ViewPopupWS.init(button);
    }
  }

  return {
    sendRequest: sendRequest,
    handleResponse: handleResponse,
    getState: function() {
      return state;
    },
    processBuy: processBuy
  };
})();

;if (isJapanTrading()) {

  var processForgetTables = function() {
    BinarySocket.send({
      forget_all: 'pricing_table',
    });
  };

  var processPricingTableRequest = function() {
    processForgetTables();
    var symbol = $('#underlying').val();
    var period = $('#period').val();
    var res = period.split('_');
    var date_expiry = res[1];
    var formName = sessionStorage.getItem('formname');
    var units = Math.abs(parseInt($('#japan_unit').val(), 10)) || 1;
    var category = formName === 'higherlower' ? 'callput' : formName;

    PricingTable.sendRequest({
      symbol: symbol,
      date_expiry: date_expiry,
      contract_category: category,
      units: units,
    });
  };

  var processContractForm = function() {

    Contract.details(sessionStorage.getItem('formname'));

    StartDates.display();

    if (Periods) {
      Periods.displayPeriods();
    }

    displayPrediction();

    displaySpreads();

    if (sessionStorage.getItem('japan_unit')) $('#japan_unit').val(sessionStorage.getItem('japan_unit'));
    if (sessionStorage.getItem('currency')) selectOption(sessionStorage.getItem('currency'), document.getElementById('currency'));

    Durations.display();

    processPricingTableRequest();

  };
}
